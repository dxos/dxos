//
// Copyright 2022 DXOS.org
//

import chalk from 'chalk';
import { execSync } from 'child_process';
import { Table } from 'console-table-printer';
import deepEqual from 'deep-equal';
import fs from 'fs';
import globrex from 'globrex';
import defaultsDeep from 'lodash.defaultsdeep';
import pick from 'lodash.pick';
import { existsSync } from 'node:fs';
import { inspect } from 'node:util';
import { dirname, join, relative } from 'path';
import sortPackageJson from 'sort-package-json';

import { loadJson, saveJson, sortJson } from './util';
import { type PackageJson, type Project, ProjectGraph } from './util/project-graph';

const raise = (err: Error) => {
  throw err;
};

const JS_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs', '.mts', '.cts'];

export type ToolboxConfig = {
  project?: {
    ignored?: string[];
    fixedKeys?: string[];
  };
  package?: {
    commonKeys: string[];
    withCustomExports: string[];
  };
  tsconfig?: {
    fixedKeys?: string[];
    pathMapping?: {
      /**
       * Root packages that will use tsconfig paths.
       * Used to verify dep graph integrity.
       * Ensures there are no "holes" in the dependency graph where a package
       * in the middle of the graph is not included while its dependencies are.
       */
      roots?: string[];

      /**
       * Array of globs for package names.
       */
      include: string[];
    };
    noProjectReferences?: boolean;
    noDirectOutDir?: boolean;
  };
};

type ProjectJson = {
  tags?: string[];
  sourceRoot: string;
  projectType: string;
  targets: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type NxJson = {
  targetDefaults: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type TsConfigJson = {
  extends: string | string[];
  references: {
    path: string;
  }[];
  compilerOptions: any;
};

type ToolboxOptions = {
  verbose?: boolean;
};

const defaultOptions = {
  verbose: false,
};

type Diagnostic = {
  code: string;
  message: string;
  path: string;
};

export class Toolbox {
  private readonly options: ToolboxOptions;
  private readonly rootDir: string;

  private config!: ToolboxConfig;
  private rootPackage!: PackageJson;
  private graph!: ProjectGraph;

  // TODO(burdon): Merge options.
  constructor(options: ToolboxOptions = {}) {
    this.options = defaultsDeep({}, options, defaultOptions);
    this.rootDir = process.env.DX_BUILD_ROOT_DIR ?? execSync('git rev-parse --show-toplevel').toString().trim();
  }

  /**
   * Initialize.
   * - Read config.
   * - Create package list.
   */
  async init(): Promise<void> {
    const configPath = join(this.rootDir, 'toolbox.json');
    this.config = await loadJson<ToolboxConfig>(configPath);
    console.log(`Config: ${configPath}`);

    // Get workspace package.
    this.rootPackage = await loadJson(join(this.rootDir, 'package.json'));

    // Load and sort projects.
    this.graph = new ProjectGraph(this.rootDir, this.config.project?.ignored ?? []);
    await this.graph.init();
  }

  info(): void {
    const table = new Table({
      columns: [
        { name: 'package', alignment: 'left' },
        { name: 'path', alignment: 'left' },
      ],
    });

    // TODO(burdon): Sort by tools, packages.
    for (const project of this.graph.projects) {
      table.addRow({
        package: chalk.green(project.name),
        path: chalk.blue(project.path),
      });
    }

    console.log(table.render());
  }

  /**
   * Resolves NX substitutions in the project.json file (e.g {projectRoot}).
   */
  resolveProjectOption(project: Project, option: string | undefined): string | undefined {
    if (!option) {
      return option;
    }

    if (typeof option !== 'string') {
      throw new TypeError(`Expected string, got ${typeof option}`);
    }

    return option.replace(/\{projectRoot\}/g, project.path);
  }

  /**
   * Update root workspace file.
   * - Sort
   *
   * @deprecated Nx deprecated this file
   */
  async updateWorkspace(): Promise<void> {
    console.log('Updating workspace.json');
    const workspace = {
      '//': 'This file is generated by tools/executors/toolbox.',
      version: 2,
      projects: Object.fromEntries(
        this.graph.projects.map((project) => [
          project.name.slice('@dxos/'.length),
          relative(this.rootDir, project.path),
        ]),
      ),
    };

    await saveJson(join(this.rootDir, 'workspace.json'), workspace, this.options.verbose);
  }

  async updateReleasePlease(): Promise<void> {
    console.log('Updating release-please-config.json');
    const config = {
      '//': 'This file is generated by tools/executors/toolbox.',
      $schema: 'https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json',
      packages: {
        '.': {
          component: 'dxos',
          'bump-minor-pre-major': true,
          'bump-patch-for-minor-pre-major': true,
          'include-component-in-tag': false,
          'include-v-in-tag': true,
          // eslint-disable-next-line no-template-curly-in-string
          'pull-request-title-pattern': 'chore: release v${version}',
          'extra-files': [
            // TODO(wittjosiah): Move extra files to toolbox config.
            'packages/sdk/client/src/version.ts',
            'packages/sdk/client-services/src/version.ts',
            ...this.graph.projects
              .sort((projectA, projectB) => projectA.path.localeCompare(projectB.path))
              .map((project) => ({
                type: 'json',
                path: `${project.path.substring(this.rootDir.length + 1)}/package.json`,
                jsonpath: '$.version',
              })),
          ],
        },
      },
    };

    await saveJson(join(this.rootDir, 'release-please-config.json'), config, this.options.verbose);
  }

  /**
   * Update root package file.
   * - Sort
   */
  async updateRootPackage(): Promise<void> {
    console.log('Updating package.json');
    const packagePath = join(this.rootDir, 'package.json');
    const packageJson = await loadJson<PackageJson>(packagePath);
    const updated = sortPackageJson(packageJson);
    await saveJson(packagePath, updated, this.options.verbose);
  }

  /**
   * Update project files.
   * - Sort keys.
   */
  async updateProjects(): Promise<void> {
    const nxJson = await loadJson<NxJson>(join(this.rootDir, 'nx.json'));

    console.log('Updating all project.json');
    for (const project of this.graph.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);
      if (projectJson?.targets) {
        for (const target of Object.keys(projectJson.targets)) {
          if (projectJson.targets[target].executor === nxJson.targetDefaults[target]?.executor) {
            delete projectJson.targets[target].executor;
          }

          if (
            projectJson.targets[target].outputs &&
            deepEqual(projectJson.targets[target].outputs, nxJson.targetDefaults[target]?.outputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].inputs &&
            deepEqual(projectJson.targets[target].inputs, nxJson.targetDefaults[target]?.inputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].dependsOn &&
            deepEqual(projectJson.targets[target].dependsOn, nxJson.targetDefaults[target]?.dependsOn)
          ) {
            delete projectJson.targets[target].outputs;
          }

          if (projectJson.targets[target].options && Object.keys(projectJson.targets[target].options).length === 0) {
            delete projectJson.targets[target].options;
          }
        }

        if (projectJson.targets.build != null) {
          projectJson.targets.pack ??= {};
        }

        const updated = sortJson(projectJson, {
          depth: -1,
          map: {
            '.': this.config.project?.fixedKeys ?? [],
          },
        });

        await saveJson(projectPath, updated, this.options.verbose);
      }
    }
  }

  /**
   * Update package files.
   * - Sort keys.
   */
  async updatePackages(): Promise<void> {
    console.log('Updating all package.json');
    for (const project of this.graph.projects) {
      const packagePath = join(project.path, 'package.json');
      const packageJson = await loadJson<PackageJson>(packagePath);

      // if (project.path.includes('dxos/packages')) {
      //   packageJson.type = 'module';
      // }

      const commonKeys = pick(this.rootPackage, this.config.package?.commonKeys ?? []);
      // TODO(burdon): Investigate util: https://github.com/JamieMason/syncpack
      const updated = sortPackageJson(defaultsDeep(packageJson, commonKeys));
      await saveJson(packagePath, updated, this.options.verbose);
    }
  }

  /**
   * Update tsconfig files.
   * - Sort keys.
   * - Update references.
   */
  async updateTsConfig(): Promise<void> {
    console.log('Updating all tsconfig.json');
    for (const project of this.graph.projects) {
      const projectPath = join(project.path, 'package.json');
      const projectPackage = await loadJson<PackageJson>(projectPath);
      const tsConfigPath = join(project.path, 'tsconfig.json');
      if (fs.existsSync(tsConfigPath)) {
        const tsConfigJson = await loadJson<TsConfigJson>(tsConfigPath);

        // Get refs.
        const { dependencies = {}, devDependencies = {}, peerDependencies = {} } = projectPackage!;
        const depsMap = new Map(
          [
            ...Object.entries(dependencies),
            ...Object.entries(devDependencies),
            ...Object.entries(peerDependencies),
          ].filter(([_, value]) => value === 'workspace:*'),
        );

        const deps = Array.from(depsMap.entries());
        if (!this.config.tsconfig?.noProjectReferences) {
          tsConfigJson.references = deps.map(([dependencyName]) => {
            const dependency = this._getProjectByPackageName(dependencyName)!;
            const path = relative(project.path, dependency.path);
            return { path };
          });
        } else {
          tsConfigJson.references = [];
        }

        // if (!this.config.tsconfig?.noDirectOutDir && `${tsConfigJson?.extends}`.endsWith('tsconfig.base.json')) {
        //   tsConfigJson.compilerOptions ??= {};
        //   tsConfigJson.compilerOptions.outDir ??= './dist/types';
        // }

        const updated = sortJson(tsConfigJson, {
          depth: 3,
          map: {
            '.': this.config.tsconfig?.fixedKeys ?? [],
            '.references': (value: any) => value.path,
          },
        });

        // Preserve root dir order.
        if (tsConfigJson.compilerOptions?.rootDirs) {
          updated.compilerOptions.rootDirs = tsConfigJson.compilerOptions.rootDirs;
        }

        await saveJson(tsConfigPath, updated, this.options.verbose);
      }
    }
  }

  async updateTsConfigPaths(): Promise<void> {
    const regexes = Array.from(this.config.tsconfig?.pathMapping?.include ?? []).map((pattern) =>
      globrex(pattern, { extended: true, globstar: true }),
    );

    const includedPackages = this.graph.projects.filter((project) =>
      regexes.some((re) => {
        return relative(this.rootDir!, project.path).match(re.regex);
      }),
    );

    if (this.config.tsconfig?.pathMapping?.roots) {
      const roots = this.config.tsconfig.pathMapping.roots;
      if (!roots.every((root) => this.graph.hasPackage(root))) {
        throw new Error('Missing packages');
      }

      const allDepsFromRoot = this.graph.getTransitiveWorkspaceDeps(roots);
      const missingPackages = this.graph.projects.filter(
        (project) =>
          !roots.includes(project.name) &&
          allDepsFromRoot.includes(project.name) &&
          !includedPackages.includes(project) &&
          this.graph
            .getWorkspaceDependencies(project.name, { devDeps: false })
            .some((dep) => includedPackages.find((p) => p.name === dep) != null),
      );
      if (missingPackages.length > 0) {
        console.error(
          `These packages must be included in the path mapping config file because their dependencies are included:\n${missingPackages
            .map(
              (p) =>
                `${relative(this.rootDir, p.path)} because it depends on ${this.graph
                  .getWorkspaceDependencies(p.name)
                  .filter((dep) => includedPackages.find((p) => p.name === dep) != null)
                  .join(', ')}`,
            )
            .join('\n')}`,
        );
        // TODO(thure): Lit packages which use decorators need to be “missing” by this definition in order to work.
        // throw new Error('Missing packages');
      }
    }

    const tsconfigPaths = await loadJson<TsConfigJson>(join(this.rootDir, 'tsconfig.paths.json'));
    tsconfigPaths.compilerOptions.paths = Object.fromEntries(
      (
        await Promise.all(
          includedPackages.map(async (project) => {
            const projectJson = await loadJson<ProjectJson>(join(project.path, 'project.json'));
            const entryPoints = projectJson?.targets?.compile?.options?.entryPoints;
            if (!Array.isArray(entryPoints)) {
              return [];
            }
            const entries = entryPoints.map((entryPoint) => {
              entryPoint = this.resolveProjectOption(project, entryPoint);
              let entryId = relative(join(project.path, 'src'), entryPoint);
              if (entryPoint.endsWith('index.ts')) {
                entryId = dirname(entryId);
              } else if (JS_EXTENSIONS.some((ext) => entryPoint.endsWith(ext))) {
                entryId = entryId.slice(0, -JS_EXTENSIONS.find((ext) => entryPoint.endsWith(ext))!.length);
              }

              return { path: relative(project.path, entryPoint), entryId };
            });
            return entries.map(({ path, entryId }) => [
              join(project.name, entryId),
              [relative(this.rootDir, join(project.path, path))],
            ]);
          }),
        )
      ).flat(), // TODO(dmaretskyi): Entrypoints.
    );

    await saveJson(join(this.rootDir, 'tsconfig.paths.json'), tsconfigPaths, this.options.verbose);
  }

  async updateTsConfigAll(): Promise<void> {
    const tsconfigAll = await loadJson<TsConfigJson>(join(this.rootDir, 'tsconfig.all.json'));
    tsconfigAll.references = this.graph.projects
      // TODO(dmaretskyi): Blade runner doesn't build.
      .filter(
        (project) =>
          !project.name.includes('blade-runner') &&
          !project.name.includes('docs') &&
          !project.name.includes('kube-publishing'),
      )
      .filter((project) => existsSync(join(project.path, 'tsconfig.json')))
      .map((project) => {
        return { path: relative(this.rootDir, join(project.path, 'tsconfig.json')) };
      });

    await saveJson(join(this.rootDir, 'tsconfig.all.json'), tsconfigAll, this.options.verbose);
  }

  async printStats(): Promise<void> {
    const stats: Record<
      string,
      {
        executors: Set<string>;
        count: number;
      }
    > = {};

    for (const project of this.graph.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      for (const target of Object.keys(projectJson.targets ?? {})) {
        stats[target] ??= {
          executors: new Set(),
          count: 0,
        };

        stats[target].count++;
        stats[target].executors.add(projectJson.targets[target].executor ?? 'undefined');
      }
    }

    console.log(inspect(stats, { depth: null }));
  }

  async updateTags(): Promise<void> {
    for (const project of this.graph.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      // Skip uncategorized projects.
      const relativePath = relative(this.rootDir, project.path);
      if (!relativePath.startsWith('packages') || relativePath.split('/').length < 3) {
        continue;
      }

      const scope = project.path.split('/').at(-2);
      if (!scope) {
        continue;
      }

      const scopeTag = `scope:${scope}`;
      const tags = (projectJson.tags ??= []);
      if (!tags.includes(scopeTag)) {
        tags.push(scopeTag);

        await saveJson(projectPath, projectJson, this.options.verbose);
      }
    }
  }

  async getModuleStats() {
    const diagnostics: Diagnostic[] = [];
    const fieldsForStats = ['exports', 'main', 'types', 'typesVersions', 'browser'] as const;
    const byField = fieldsForStats.reduce(
      (acc, field) => {
        acc[field] = [];
        return acc;
      },
      {} as Record<(typeof fieldsForStats)[number], string[]>,
    );
    const byModuleType = {
      commonjs: [] as string[],
      module: [] as string[],
      unspecified: [] as string[],
    };
    const byExportCondition: Record<string, string[]> = {};

    for (const project of this.graph.projects) {
      const packageJson = await loadJson<PackageJson>(join(project.path, 'package.json'));

      for (const field of fieldsForStats) {
        if ((packageJson as any)[field]) {
          byField[field].push(project.name);
        }
      }

      switch (packageJson.type) {
        case 'commonjs':
          byModuleType.commonjs.push(project.name);
          break;
        case 'module':
          byModuleType.module.push(project.name);
          break;
        default:
          byModuleType.unspecified.push(project.name);
      }

      if (typeof packageJson.exports === 'object') {
        for (const [_key, value] of Object.entries(packageJson.exports)) {
          if (typeof value === 'object') {
            for (const key of Object.keys(value)) {
              byExportCondition[key] ??= [];
              if (!byExportCondition[key].includes(project.name)) {
                byExportCondition[key].push(project.name);
              }
            }
          }
        }
      }
    }

    return { byField, byModuleType, byExportCondition, diagnostics };
  }

  async lintPackageExports(): Promise<void> {
    for (const project of this.graph.projects) {
      if (this.config.package?.withCustomExports.includes(project.name)) {
        continue;
      }

      const packageJson = await loadJson<PackageJson>(join(project.path, 'package.json'));
      const projectJson = await loadJson<ProjectJson>(join(project.path, 'project.json'));

      const entrypoints = projectJson.targets?.compile?.options?.entryPoints;
      if (!Array.isArray(entrypoints)) {
        console.log(`skip ${project.name}`);
        continue;
      }

      const isNode =
        !projectJson.targets?.compile?.options?.platforms ||
        projectJson.targets?.compile?.options?.platforms.includes('node');
      const isBrowser =
        !projectJson.targets?.compile?.options?.platforms ||
        projectJson.targets?.compile?.options?.platforms.includes('browser');

      packageJson.exports = {};
      // exports.types are only used with modern module resolution strategies so we keep this for compatibility.
      packageJson.types = 'dist/types/src/index.d.ts';
      packageJson.typesVersions = {
        '*': {},
      };
      delete packageJson.main;

      for (const entrypoint of entrypoints) {
        const substituted = entrypoint.replace(/{projectRoot}/, project.path);
        const relativePath = relative(project.path, substituted);

        const exportName = relativePath
          .replace(/^src\//, './')
          .replace(/\/index\.tsx?$/, '')
          .replace(/\.tsx?$/, '');
        const distSlug = relativePath.replace(/^src\//, '').replace(/\.tsx?$/, '');

        // console.log({ relativePath, exportName, distSlug });
        packageJson.exports[exportName] = {};
        (packageJson.exports[exportName] as any).types = `./dist/types/src/${distSlug}.d.ts`;
        if (isBrowser) {
          (packageJson.exports[exportName] as any).browser = `./dist/lib/browser/${distSlug}.mjs`;
        }
        if (isNode) {
          (packageJson.exports[exportName] as any).node = `./dist/lib/node-esm/${distSlug}.mjs`;
        }

        // exports.types are only used with modern module resolution strategies so we keep this for compatibility.
        if (exportName !== '.') {
          packageJson.typesVersions['*'][exportName.replace(/^\.\//, '')] = [`dist/types/src/${distSlug}.d.ts`];
        }
      }

      packageJson.exports = sortJson(packageJson.exports, { depth: 1 });
      packageJson.typesVersions['*'] = sortJson(packageJson.typesVersions['*'], { depth: -1 });

      if (typeof packageJson.browser === 'object' && packageJson.browser !== null) {
        for (const key in packageJson.browser) {
          if (key.startsWith('./dist/lib')) {
            delete packageJson.browser[key];
          }
        }
        if (Object.keys(packageJson.browser).length === 0) {
          delete packageJson.browser;
        }
      }

      // {
      //   const { name, exports, types, typesVersions } = packageJson;
      //   console.log(inspect({ name, exports, types, typesVersions }, { depth: null, colors: true }));
      // }
      await saveJson(join(project.path, 'package.json'), packageJson, this.options.verbose);
    }
  }

  _getProjectByPackageName(name: string): Project {
    return this.graph.getProject(name) ?? raise(new Error(`Package not found: ${name}`));
  }
}
