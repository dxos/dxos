//
// Copyright 2022 DXOS.org
//

import chalk from 'chalk';
import { execSync } from 'child_process';
import { Table } from 'console-table-printer';
import deepEqual from 'deep-equal';
import fs from 'fs';
import globrex from 'globrex';
import defaultsDeep from 'lodash.defaultsdeep';
import pick from 'lodash.pick';
import { inspect } from 'node:util';
import { dirname, join, relative } from 'path';
import sortPackageJson from 'sort-package-json';

import { loadJson, saveJson, sortJson } from './util';

const raise = (err: Error) => {
  throw err;
};

const JS_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs', '.mts', '.cts'];

export type ToolboxConfig = {
  project?: {
    ignored?: string[];
    fixedKeys?: string[];
  };
  package?: {
    commonKeys: string[];
    withCustomExports: string[];
  };
  tsconfig?: {
    fixedKeys?: string[];
    pathMapping?: {
      /**
       * Array of globs for package names.
       */
      include: string[];
    };
  };
};

type Project = {
  name: string;
  version: string;
  private: boolean;
  path: string;
};

type ProjectJson = {
  tags?: string[];
  sourceRoot: string;
  projectType: string;
  targets: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type NxJson = {
  targetDefaults: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type PackageJson = {
  name: string;
  version: string;
  type?: string;
  private: boolean;
  exports?: string | Record<string, string | Record<string, string | Record<string, string>>>;
  main?: string;
  browser?: Record<string, string>;
  types?: string;
  typesVersions?: Record<string, Record<string, string[]>>;
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
  peerDependencies: Record<string, string>;
};

type TsConfigJson = {
  extends: string | string[];
  references: {
    path: string;
  }[];
  compilerOptions: any;
};

type ToolboxOptions = {
  verbose?: boolean;
};

const defaultOptions = {
  verbose: false,
};

type Diagnostic = {
  code: string;
  message: string;
  path: string;
};

export class Toolbox {
  private readonly options: ToolboxOptions;
  private readonly rootDir: string;

  private config!: ToolboxConfig;
  private rootPackage!: PackageJson;
  private projects!: Project[];

  // TODO(burdon): Merge options.
  constructor(options: ToolboxOptions = {}) {
    this.options = defaultsDeep({}, options, defaultOptions);
    this.rootDir = process.env.DX_BUILD_ROOT_DIR ?? execSync('git rev-parse --show-toplevel').toString().trim();
  }

  /**
   * Initialize.
   * - Read config.
   * - Create package list.
   */
  async init() {
    const configPath = join(this.rootDir, 'toolbox.json');
    this.config = await loadJson<ToolboxConfig>(configPath);
    console.log(`Config: ${configPath}`);

    // Get workspace package.
    this.rootPackage = await loadJson(join(this.rootDir, 'package.json'));

    // Load and sort projects.
    const projects: Project[] = JSON.parse(execSync('pnpm ls -r --depth -1 --json').toString());
    this.projects = projects.filter(
      (project: Project) =>
        (project.name?.startsWith('@dxos') || project.name?.startsWith('@braneframe')) &&
        (!this.config.project?.ignored || this.config.project?.ignored.indexOf(project.name) === -1),
    );

    this.projects.sort((a: Project, b: Project) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));
    // console.log('==', this.projects.length);
  }

  info() {
    const table = new Table({
      columns: [
        { name: 'package', alignment: 'left' },
        { name: 'path', alignment: 'left' },
      ],
    });

    // TODO(burdon): Sort by tools, packages.
    for (const project of this.projects) {
      table.addRow({
        package: chalk.green(project.name),
        path: chalk.blue(project.path),
      });
    }

    console.log(table.render());
  }

  /**
   * Resolves NX substitutions in the project.json file (e.g {projectRoot}).
   */
  resolveProjectOption(project: Project, option: string | undefined): string | undefined {
    if (!option) {
      return option;
    }

    if (typeof option !== 'string') {
      throw new TypeError(`Expected string, got ${typeof option}`);
    }

    return option.replace(/\{projectRoot\}/g, project.path);
  }

  /**
   * Update root workspace file.
   * - Sort
   *
   * @deprecated Nx deprecated this file
   */
  async updateWorkspace() {
    console.log('Updating workspace.json');
    const workspace = {
      '//': 'This file is generated by tools/executors/toolbox.',
      version: 2,
      projects: Object.fromEntries(
        this.projects.map((project) => [project.name.slice('@dxos/'.length), relative(this.rootDir, project.path)]),
      ),
    };

    await saveJson(join(this.rootDir, 'workspace.json'), workspace, this.options.verbose);
  }

  async updateReleasePlease() {
    console.log('Updating release-please-config.json');
    const config = {
      '//': 'This file is generated by tools/executors/toolbox.',
      $schema: 'https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json',
      packages: {
        '.': {
          component: 'dxos',
          'bump-minor-pre-major': true,
          'bump-patch-for-minor-pre-major': true,
          'include-component-in-tag': false,
          'include-v-in-tag': true,
          // eslint-disable-next-line no-template-curly-in-string
          'pull-request-title-pattern': 'chore: release v${version}',
          'extra-files': [
            // TODO(wittjosiah): Move extra files to toolbox config.
            'packages/sdk/client/src/version.ts',
            'packages/sdk/client-services/src/version.ts',
            ...this.projects
              .sort((projectA, projectB) => projectA.path.localeCompare(projectB.path))
              .map((project) => ({
                type: 'json',
                path: `${project.path.substring(this.rootDir.length + 1)}/package.json`,
                jsonpath: '$.version',
              })),
          ],
        },
      },
    };

    await saveJson(join(this.rootDir, 'release-please-config.json'), config, this.options.verbose);
  }

  /**
   * Update root package file.
   * - Sort
   */
  async updateRootPackage() {
    console.log('Updating package.json');
    const packagePath = join(this.rootDir, 'package.json');
    const packageJson = await loadJson<PackageJson>(packagePath);
    const updated = sortPackageJson(packageJson);
    await saveJson(packagePath, updated, this.options.verbose);
  }

  /**
   * Update project files.
   * - Sort keys.
   */
  async updateProjects() {
    const nxJson = await loadJson<NxJson>(join(this.rootDir, 'nx.json'));

    console.log('Updating all project.json');
    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);
      if (projectJson?.targets) {
        for (const target of Object.keys(projectJson.targets)) {
          if (projectJson.targets[target].executor === nxJson.targetDefaults[target]?.executor) {
            delete projectJson.targets[target].executor;
          }

          if (
            projectJson.targets[target].outputs &&
            deepEqual(projectJson.targets[target].outputs, nxJson.targetDefaults[target]?.outputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].inputs &&
            deepEqual(projectJson.targets[target].inputs, nxJson.targetDefaults[target]?.inputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].dependsOn &&
            deepEqual(projectJson.targets[target].dependsOn, nxJson.targetDefaults[target]?.dependsOn)
          ) {
            delete projectJson.targets[target].outputs;
          }

          if (projectJson.targets[target].options && Object.keys(projectJson.targets[target].options).length === 0) {
            delete projectJson.targets[target].options;
          }
        }

        const updated = sortJson(projectJson, {
          depth: -1,
          map: {
            '.': this.config.project?.fixedKeys ?? [],
          },
        });

        await saveJson(projectPath, updated, this.options.verbose);
      }
    }
  }

  /**
   * Update package files.
   * - Sort keys.
   */
  async updatePackages() {
    console.log('Updating all package.json');
    for (const project of this.projects) {
      const packagePath = join(project.path, 'package.json');
      const packageJson = await loadJson<PackageJson>(packagePath);
      const commonKeys = pick(this.rootPackage, this.config.package?.commonKeys ?? []);
      // TODO(burdon): Investigate util: https://github.com/JamieMason/syncpack
      const updated = sortPackageJson(defaultsDeep(packageJson, commonKeys));
      await saveJson(packagePath, updated, this.options.verbose);
    }
  }

  /**
   * Update tsconfig files.
   * - Sort keys.
   * - Update references.
   */
  async updateTsConfig() {
    console.log('Updating all tsconfig.json');
    for (const project of this.projects) {
      const projectPath = join(project.path, 'package.json');
      const projectPackage = await loadJson<PackageJson>(projectPath);
      const tsConfigPath = join(project.path, 'tsconfig.json');
      if (fs.existsSync(tsConfigPath)) {
        const tsConfigJson = await loadJson<TsConfigJson>(tsConfigPath);

        // Get refs.
        const { dependencies = {}, devDependencies = {}, peerDependencies = {} } = projectPackage!;
        const depsMap = new Map(
          [
            ...Object.entries(dependencies),
            ...Object.entries(devDependencies),
            ...Object.entries(peerDependencies),
          ].filter(([_, value]) => value === 'workspace:*'),
        );

        const deps = Array.from(depsMap.entries());
        tsConfigJson.references = deps.map(([dependencyName]) => {
          const dependency = this._getProjectByPackageName(dependencyName)!;
          const path = relative(project.path, dependency.path);
          return { path };
        });

        const updated = sortJson(tsConfigJson, {
          depth: 3,
          map: {
            '.': this.config.tsconfig?.fixedKeys ?? [],
            '.references': (value: any) => value.path,
          },
        });

        // Preserve root dir order.
        if (tsConfigJson.compilerOptions?.rootDirs) {
          updated.compilerOptions.rootDirs = tsConfigJson.compilerOptions.rootDirs;
        }

        await saveJson(tsConfigPath, updated, this.options.verbose);
      }
    }
  }

  async updateTsConfigPaths() {
    const regexes = Array.from(this.config.tsconfig?.pathMapping?.include ?? []).map((pattern) =>
      globrex(pattern, { extended: true, globstar: true }),
    );

    const includedPackages = this.projects.filter((project) =>
      regexes.some((re) => {
        return relative(this.rootDir!, project.path).match(re.regex);
      }),
    );

    const tsconfigPaths = await loadJson<TsConfigJson>(join(this.rootDir, 'tsconfig.paths.json'));
    tsconfigPaths.compilerOptions.paths = Object.fromEntries(
      (
        await Promise.all(
          includedPackages.map(async (project) => {
            const projectJson = await loadJson<ProjectJson>(join(project.path, 'project.json'));
            const entryPoints = projectJson?.targets?.compile?.options?.entryPoints;
            if (!Array.isArray(entryPoints)) {
              return [];
            }
            const entries = entryPoints.map((entryPoint) => {
              entryPoint = this.resolveProjectOption(project, entryPoint);
              let entryId = relative(join(project.path, 'src'), entryPoint);
              if (entryPoint.endsWith('index.ts')) {
                entryId = dirname(entryId);
              } else if (JS_EXTENSIONS.some((ext) => entryPoint.endsWith(ext))) {
                entryId = entryId.slice(0, -JS_EXTENSIONS.find((ext) => entryPoint.endsWith(ext))!.length);
              }

              return { path: relative(project.path, entryPoint), entryId };
            });
            return entries.map(({ path, entryId }) => [
              join(project.name, entryId),
              [relative(this.rootDir, join(project.path, path))],
            ]);
          }),
        )
      ).flat(), // TODO(dmaretskyi): Entrypoints.
    );

    await saveJson(join(this.rootDir, 'tsconfig.paths.json'), tsconfigPaths, this.options.verbose);
  }

  async printStats() {
    const stats: Record<
      string,
      {
        executors: Set<string>;
        count: number;
      }
    > = {};

    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      for (const target of Object.keys(projectJson.targets ?? {})) {
        stats[target] ??= {
          executors: new Set(),
          count: 0,
        };

        stats[target].count++;
        stats[target].executors.add(projectJson.targets[target].executor ?? 'undefined');
      }
    }

    console.log(inspect(stats, { depth: null }));
  }

  async updateTags() {
    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      // Skip uncatagorized projects.
      const relativePath = relative(this.rootDir, project.path);
      if (!relativePath.startsWith('packages') || relativePath.split('/').length < 3) {
        continue;
      }

      const scope = project.path.split('/').at(-2);
      if (!scope) {
        continue;
      }

      const scopeTag = `scope:${scope}`;
      const tags = (projectJson.tags ??= []);
      if (!tags.includes(scopeTag)) {
        tags.push(scopeTag);

        await saveJson(projectPath, projectJson, this.options.verbose);
      }
    }
  }

  async getModuleStats() {
    const diagnostics: Diagnostic[] = [];
    const fieldsForStats = ['exports', 'main', 'types', 'typesVersions', 'browser'] as const;
    const byField = fieldsForStats.reduce(
      (acc, field) => {
        acc[field] = [];
        return acc;
      },
      {} as Record<(typeof fieldsForStats)[number], string[]>,
    );
    const byModuleType = {
      commonjs: [] as string[],
      module: [] as string[],
      unspecified: [] as string[],
    };
    const byExportCondition: Record<string, string[]> = {};

    for (const project of this.projects) {
      const packageJson = await loadJson<PackageJson>(join(project.path, 'package.json'));

      for (const field of fieldsForStats) {
        if ((packageJson as any)[field]) {
          byField[field].push(project.name);
        }
      }

      switch (packageJson.type) {
        case 'commonjs':
          byModuleType.commonjs.push(project.name);
          break;
        case 'module':
          byModuleType.module.push(project.name);
          break;
        default:
          byModuleType.unspecified.push(project.name);
      }

      if (typeof packageJson.exports === 'object') {
        for (const [_key, value] of Object.entries(packageJson.exports)) {
          if (typeof value === 'object') {
            for (const key of Object.keys(value)) {
              byExportCondition[key] ??= [];
              if (!byExportCondition[key].includes(project.name)) {
                byExportCondition[key].push(project.name);
              }
            }
          }
        }
      }
    }

    return { byField, byModuleType, byExportCondition, diagnostics };
  }

  async lintPackageExports() {
    for (const project of this.projects) {
      if (this.config.package?.withCustomExports.includes(project.name)) {
        continue;
      }

      const packageJson = await loadJson<PackageJson>(join(project.path, 'package.json'));
      const projectJson = await loadJson<ProjectJson>(join(project.path, 'project.json'));

      const entrypoints = projectJson.targets?.compile?.options?.entryPoints;
      if (!Array.isArray(entrypoints)) {
        console.log(`skip ${project.name}`);
        continue;
      }

      const isNode =
        !projectJson.targets?.compile?.options?.platforms ||
        projectJson.targets?.compile?.options?.platforms.includes('node');
      const isBrowser =
        !projectJson.targets?.compile?.options?.platforms ||
        projectJson.targets?.compile?.options?.platforms.includes('browser');

      packageJson.exports = {};
      // exports.types are only used with modern module resolution strategies so we keep this for compatibility.
      packageJson.types = 'dist/types/src/index.d.ts';
      packageJson.typesVersions = {
        '*': {},
      };
      delete packageJson.main;

      for (const entrypoint of entrypoints) {
        const substituted = entrypoint.replace(/{projectRoot}/, project.path);
        const relativePath = relative(project.path, substituted);

        const exportName = relativePath
          .replace(/^src\//, './')
          .replace(/\/index\.tsx?$/, '')
          .replace(/\.tsx?$/, '');
        const distSlug = relativePath.replace(/^src\//, '').replace(/\.tsx?$/, '');

        // console.log({ relativePath, exportName, distSlug });
        packageJson.exports[exportName] = {};
        if (isBrowser) {
          (packageJson.exports[exportName] as any).browser = `./dist/lib/browser/${distSlug}.mjs`;
        }
        if (isNode) {
          (packageJson.exports[exportName] as any).node = {
            default: `./dist/lib/node/${distSlug}.cjs`,
          };
        }
        (packageJson.exports[exportName] as any).types = `./dist/types/src/${distSlug}.d.ts`;

        // exports.types are only used with modern module resolution strategies so we keep this for compatibility.
        if (exportName !== '.') {
          packageJson.typesVersions['*'][exportName.replace(/^\.\//, '')] = [`dist/types/src/${distSlug}.d.ts`];
        }
      }

      packageJson.exports = sortJson(packageJson.exports, { depth: -1 });
      packageJson.typesVersions['*'] = sortJson(packageJson.typesVersions['*'], { depth: -1 });

      if (typeof packageJson.browser === 'object' && packageJson.browser !== null) {
        for (const key in packageJson.browser) {
          if (key.startsWith('./dist/lib')) {
            delete packageJson.browser[key];
          }
        }
        if (Object.keys(packageJson.browser).length === 0) {
          delete packageJson.browser;
        }
      }

      // {
      //   const { name, exports, types, typesVersions } = packageJson;
      //   console.log(inspect({ name, exports, types, typesVersions }, { depth: null, colors: true }));
      // }
      await saveJson(join(project.path, 'package.json'), packageJson, this.options.verbose);
    }
  }

  _getProjectByPackageName(name: string): Project {
    return this.projects.find((project) => project.name === name) ?? raise(new Error(`Package not found: ${name}`));
  }
}
