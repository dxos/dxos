//
// Copyright 2022 DXOS.org
//

import chalk from 'chalk';
import { execSync } from 'child_process';
import { Table } from 'console-table-printer';
import deepEqual from 'deep-equal';
import fs from 'fs';
import globrex from 'globrex';
import defaultsDeep from 'lodash.defaultsdeep';
import pick from 'lodash.pick';
import { inspect } from 'node:util';
import { dirname, join, relative } from 'path';
import sortPackageJson from 'sort-package-json';

import { loadJson, saveJson, sortJson } from './util';

const raise = (err: Error) => {
  throw err;
};

const JS_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs', '.mts', '.cts'];

export type ToolboxConfig = {
  project?: {
    ignored?: string[];
    fixedKeys?: string[];
  };
  package?: {
    commonKeys: string[];
  };
  tsconfig?: {
    fixedKeys?: string[];
    pathMapping?: {
      /**
       * Array of globs for package names.
       */
      include: string[];
    };
  };
};

type Project = {
  name: string;
  version: string;
  private: boolean;
  path: string;
};

type ProjectJson = {
  tags?: string[];
  sourceRoot: string;
  projectType: string;
  targets: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type NxJson = {
  targetDefaults: {
    [target: string]: {
      executor?: string;
      options?: any;
      outputs?: string[];
      inputs?: string[];
      dependsOn?: string[];
    };
  };
};

type PackageJson = {
  name: string;
  version: string;
  private: boolean;
  dependencies: Record<string, string>[];
  devDependencies: Record<string, string>[];
  peerDependencies: Record<string, string>[];
};

type TsConfigJson = {
  extends: string | string[];
  references: {
    path: string;
  }[];
  compilerOptions: any;
};

type ToolboxOptions = {
  verbose?: boolean;
};

const defaultOptions = {
  verbose: false,
};

class Toolbox {
  private readonly options: ToolboxOptions;
  private readonly rootDir: string;

  private config!: ToolboxConfig;
  private rootPackage!: PackageJson;
  private projects!: Project[];

  // TODO(burdon): Merge options.
  constructor(options: ToolboxOptions = {}) {
    this.options = defaultsDeep({}, options, defaultOptions);
    this.rootDir = process.env.DX_BUILD_ROOT_DIR ?? execSync('git rev-parse --show-toplevel').toString().trim();
  }

  /**
   * Initialize.
   * - Read config.
   * - Create package list.
   */
  async init() {
    const configPath = join(this.rootDir, 'toolbox.json');
    this.config = await loadJson<ToolboxConfig>(configPath);
    console.log(`Config: ${configPath}`);

    // Get workspace package.
    this.rootPackage = await loadJson(join(this.rootDir, 'package.json'));

    // Load and sort projects.
    const projects: Project[] = JSON.parse(execSync('pnpm ls -r --depth -1 --json').toString());
    this.projects = projects.filter(
      (project: Project) =>
        (project.name?.startsWith('@dxos') || project.name?.startsWith('@braneframe')) &&
        (!this.config.project?.ignored || this.config.project?.ignored.indexOf(project.name) === -1),
    );

    this.projects.sort((a: Project, b: Project) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));
    // console.log('==', this.projects.length);
  }

  info() {
    const table = new Table({
      columns: [
        { name: 'package', alignment: 'left' },
        { name: 'path', alignment: 'left' },
      ],
    });

    // TODO(burdon): Sort by tools, packages.
    for (const project of this.projects) {
      table.addRow({
        package: chalk.green(project.name),
        path: chalk.blue(project.path),
      });
    }

    console.log(table.render());
  }

  /**
   * Update root workspace file.
   * - Sort
   *
   * @deprecated Nx deprecated this file
   */
  async updateWorkspace() {
    console.log('Updating workspace.json');
    const workspace = {
      '//': 'This file is generated by tools/executors/toolbox.',
      version: 2,
      projects: Object.fromEntries(
        this.projects.map((project) => [project.name.slice('@dxos/'.length), relative(this.rootDir, project.path)]),
      ),
    };

    await saveJson(join(this.rootDir, 'workspace.json'), workspace, this.options.verbose);
  }

  async updateReleasePlease() {
    console.log('Updating release-please-config.json');
    const config = {
      '//': 'This file is generated by tools/executors/toolbox.',
      $schema: 'https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json',
      packages: {
        '.': {
          component: 'dxos',
          'bump-minor-pre-major': true,
          'bump-patch-for-minor-pre-major': true,
          'include-component-in-tag': false,
          'include-v-in-tag': true,
          // eslint-disable-next-line no-template-curly-in-string
          'pull-request-title-pattern': 'chore: release v${version}',
          'extra-files': [
            // TODO(wittjosiah): Move extra files to toolbox config.
            'packages/sdk/client/src/version.ts',
            'packages/sdk/client-services/src/version.ts',
            ...this.projects
              .sort((projectA, projectB) => projectA.path.localeCompare(projectB.path))
              .map((project) => ({
                type: 'json',
                path: `${project.path.substring(this.rootDir.length + 1)}/package.json`,
                jsonpath: '$.version',
              })),
          ],
        },
      },
    };

    await saveJson(join(this.rootDir, 'release-please-config.json'), config, this.options.verbose);
  }

  /**
   * Update root package file.
   * - Sort
   */
  async updateRootPackage() {
    console.log('Updating package.json');
    const packagePath = join(this.rootDir, 'package.json');
    const packageJson = await loadJson<PackageJson>(packagePath);
    const updated = sortPackageJson(packageJson);
    await saveJson(packagePath, updated, this.options.verbose);
  }

  /**
   * Update project files.
   * - Sort keys.
   */
  async updateProjects() {
    const nxJson = await loadJson<NxJson>(join(this.rootDir, 'nx.json'));

    console.log('Updating all project.json');
    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);
      if (projectJson?.targets) {
        for (const target of Object.keys(projectJson.targets)) {
          if (projectJson.targets[target].executor === nxJson.targetDefaults[target]?.executor) {
            delete projectJson.targets[target].executor;
          }

          if (
            projectJson.targets[target].outputs &&
            deepEqual(projectJson.targets[target].outputs, nxJson.targetDefaults[target]?.outputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].inputs &&
            deepEqual(projectJson.targets[target].inputs, nxJson.targetDefaults[target]?.inputs)
          ) {
            delete projectJson.targets[target].outputs;
          }
          if (
            projectJson.targets[target].dependsOn &&
            deepEqual(projectJson.targets[target].dependsOn, nxJson.targetDefaults[target]?.dependsOn)
          ) {
            delete projectJson.targets[target].outputs;
          }

          if (projectJson.targets[target].options && Object.keys(projectJson.targets[target].options).length === 0) {
            delete projectJson.targets[target].options;
          }
        }

        const updated = sortJson(projectJson, {
          depth: -1,
          map: {
            '.': this.config.project?.fixedKeys ?? [],
          },
        });

        await saveJson(projectPath, updated, this.options.verbose);
      }
    }
  }

  /**
   * Update package files.
   * - Sort keys.
   */
  async updatePackages() {
    console.log('Updating all package.json');
    for (const project of this.projects) {
      const packagePath = join(project.path, 'package.json');
      const packageJson = await loadJson<PackageJson>(packagePath);
      const commonKeys = pick(this.rootPackage, this.config.package?.commonKeys ?? []);
      // TODO(burdon): Investigate util: https://github.com/JamieMason/syncpack
      const updated = sortPackageJson(defaultsDeep(packageJson, commonKeys));
      await saveJson(packagePath, updated, this.options.verbose);
    }
  }

  /**
   * Update tsconfig files.
   * - Sort keys.
   * - Update references.
   */
  async updateTsConfig() {
    console.log('Updating all tsconfig.json');
    for (const project of this.projects) {
      const projectPath = join(project.path, 'package.json');
      const projectPackage = await loadJson<PackageJson>(projectPath);
      const tsConfigPath = join(project.path, 'tsconfig.json');
      if (fs.existsSync(tsConfigPath)) {
        const tsConfigJson = await loadJson<TsConfigJson>(tsConfigPath);

        // Get refs.
        const { dependencies = {}, devDependencies = {}, peerDependencies = {} } = projectPackage!;
        const depsMap = new Map(
          [
            ...Object.entries(dependencies),
            ...Object.entries(devDependencies),
            ...Object.entries(peerDependencies),
          ].filter(([_, value]) => value === 'workspace:*'),
        );

        const deps = Array.from(depsMap.entries());
        tsConfigJson.references = deps.map(([dependencyName]) => {
          const dependency = this._getProjectByPackageName(dependencyName)!;
          const path = relative(project.path, dependency.path);
          return { path };
        });

        const updated = sortJson(tsConfigJson, {
          depth: 3,
          map: {
            '.': this.config.tsconfig?.fixedKeys ?? [],
            '.references': (value: any) => value.path,
          },
        });

        // Preserve root dir order.
        if (tsConfigJson.compilerOptions?.rootDirs) {
          updated.compilerOptions.rootDirs = tsConfigJson.compilerOptions.rootDirs;
        }

        await saveJson(tsConfigPath, updated, this.options.verbose);
      }
    }
  }

  async updateTsConfigPaths() {
    const regexes = Array.from(this.config.tsconfig?.pathMapping?.include ?? []).map((pattern) =>
      globrex(pattern, { extended: true, globstar: true }),
    );

    const includedPackages = this.projects.filter((project) =>
      regexes.some((re) => {
        console.log(project.path);
        return relative(this.rootDir!, project.path).match(re.regex);
      }),
    );

    const tsconfigPaths = await loadJson<TsConfigJson>(join(this.rootDir, 'tsconfig.paths.json'));
    tsconfigPaths.compilerOptions.paths = Object.fromEntries(
      (
        await Promise.all(
          includedPackages.map(async (project) => {
            const projectJson = await loadJson<ProjectJson>(join(project.path, 'project.json'));
            const entryPoints = projectJson?.targets?.compile?.options?.entryPoints;
            if (!Array.isArray(entryPoints)) {
              return [];
            }
            const entries = entryPoints.map((entryPoint) => {
              let entryId = relative(join(project.path, 'src'), entryPoint);
              if (entryPoint.endsWith('index.ts')) {
                entryId = dirname(entryId);
              } else if (JS_EXTENSIONS.some((ext) => entryPoint.endsWith(ext))) {
                entryId = entryId.slice(0, -JS_EXTENSIONS.find((ext) => entryPoint.endsWith(ext))!.length);
              }

              return { path: relative(project.path, entryPoint), entryId };
            });
            return entries.map(({ path, entryId }) => [
              join(project.name, entryId),
              [relative(this.rootDir, join(project.path, path))],
            ]);
          }),
        )
      ).flat(), // TODO(dmaretskyi): Entrypoints.
    );

    await saveJson(join(this.rootDir, 'tsconfig.paths.json'), tsconfigPaths, this.options.verbose);
  }

  async printStats() {
    const stats: Record<
      string,
      {
        executors: Set<string>;
        count: number;
      }
    > = {};

    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      for (const target of Object.keys(projectJson.targets ?? {})) {
        stats[target] ??= {
          executors: new Set(),
          count: 0,
        };

        stats[target].count++;
        stats[target].executors.add(projectJson.targets[target].executor ?? 'undefined');
      }
    }

    console.log(inspect(stats, { depth: null }));
  }

  async updateTags() {
    for (const project of this.projects) {
      const projectPath = join(project.path, 'project.json');
      const projectJson = await loadJson<ProjectJson>(projectPath);

      const scope = project.path.split('/').at(-2);
      if (!scope) {
        continue;
      }

      const scopeTag = `scope:${scope}`;
      const tags = (projectJson.tags ??= []);
      if (!tags.includes(scopeTag)) {
        tags.push(scopeTag);

        await saveJson(projectPath, projectJson, this.options.verbose);
      }
    }
  }

  _getProjectByPackageName(name: string): Project {
    return this.projects.find((project) => project.name === name) ?? raise(new Error(`Package not found: ${name}`));
  }
}

/**
 * Hook runs on `pnpm i` (see root `package.json` script `postinstall`).
 */
const run = async () => {
  // TODO(burdon): Parse options using yargs.
  const toolbox = new Toolbox({ verbose: false });
  await toolbox.init();
  await toolbox.updateReleasePlease();
  await toolbox.updateRootPackage();
  await toolbox.updateProjects();
  await toolbox.updatePackages();
  await toolbox.updateTsConfig();
  await toolbox.updateTsConfigPaths();
  await toolbox.updateTags();

  // await toolbox.printStats();
};

void run();
