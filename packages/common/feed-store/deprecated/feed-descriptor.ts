//
// Copyright 2019 DXOS.org
//

import hypercore, { Range } from 'hypercore';
import type { Hypercore, HypercoreConstructor, ReplicationOptions, ValueEncoding } from 'hypercore';
import type { ProtocolStream } from 'hypercore-protocol';
import assert from 'node:assert';
import type { RandomAccessStorageConstructor } from 'random-access-storage';

import { Lock, py } from '@dxos/async';
import { sha256, Signer } from '@dxos/crypto';
import { createCrypto } from '@dxos/hypercore';
import { PublicKey } from '@dxos/keys';
import { Directory } from '@dxos/random-access-storage';

// TODO(burdon): Use hypercore.HypercoreOptions directly.
type FeedDescriptorOptions = {
  directory: Directory
  key: PublicKey
  hypercore?: HypercoreConstructor
  secretKey?: Buffer
  valueEncoding?: ValueEncoding
  disableSigning?: boolean
  signer: Signer
}

/**
 * Abstract handler for an Hypercore feed.
 */
// TODO(burdon): Replace with simpler wrapper that has well formed (opened) cores.
//  Only expose append and replicate (different interfaces).
export class FeedDescriptor {
  private readonly _directory: Directory;
  private readonly _key: PublicKey;
  private readonly _secretKey?: Buffer;
  private readonly _valueEncoding?: ValueEncoding;
  private readonly _hypercore: HypercoreConstructor;
  private readonly _disableSigning: boolean;
  private readonly _signer: Signer;

  // Semaphore to protect open/close.
  private readonly _lock = new Lock();

  private _feed?: Hypercore;

  constructor ({
    directory,
    key,
    secretKey, // TODO(burdon): Remove: https://github.com/dxos/dxos/pull/1611#discussion_r989888001
    valueEncoding, // TODO(burdon): Default or required?
    hypercore: hypercoreConstructor = hypercore,
    disableSigning = false,
    signer
  }: FeedDescriptorOptions) {
    assert(!signer || !secretKey, 'Cannot use signer and secretKey at the same time.');
    assert(!signer || !disableSigning, 'Signing cannot be disabled when signer is provided.');

    this._directory = directory;
    this._valueEncoding = valueEncoding;
    this._hypercore = hypercoreConstructor ?? hypercore;
    this._key = key;
    this._secretKey = secretKey;
    this._disableSigning = !!disableSigning;
    this._signer = signer;
    this._feed = undefined;
  }

  get key () {
    return this._key;
  }

  /**
   * @deprecated
   */
  // TODO(burdon): Remove.
  get secretKey () {
    return this._secretKey;
  }

  get discoveryKey () {
    return this._feed?.discoveryKey;
  }

  /**
   * @deprecated
   */
  // TODO(burdon): Remove.
  // get feed (): {} {
  //   assert(this._feed, 'Feed not initialized.');
  //   return this._feed;
  // }

  /**
   * @deprecated
   */
  // TODO(burdon): Remove.
  get initialized () {
    return !!this._feed;
  }

  get opened () {
    // TODO(burdon): TS requires explicit type here.
    return !!(this._feed && this._feed.opened && !this._feed.closed);
  }

  get length (): number {
    return this._feed?.length ?? 0;
  }

  get readable () {
    return !!this._feed?.readable;
  }

  get writable () {
    return !!this._signer; // TODO(burdon): ???
  }

  get valueEncoding () {
    return this._valueEncoding;
  }

  /**
   * Atomically open feed.
   */
  // TODO(burdon): Replace with factory.
  async open (): Promise<FeedDescriptor> {
    if (!this.opened) {
      await this._lock.executeSynchronized(async () => {
        return await this._open();
      });
    }

    return this;
  }

  async close () {
    if (!this.opened) {
      return;
    }

    await this._lock.executeSynchronized(async () => {
      assert(this._feed);
      console.log('closing...', this.opened, this._feed.opened, this._feed.closing);
      await this._feed.close();
      console.log('done');
    });
  }

  append (message: any): Promise<number> {
    assert(this._feed);
    return py(this._feed, this._feed.append)(message);
  }

  get (start: number): Promise<any> {
    assert(this._feed);
    return py(this._feed, this._feed.get)(start);
  }

  download (range?: Range): Promise<number> {
    assert(this._feed);
    return py(this._feed, this._feed.download)(range);
  }

  replicate (initiator: boolean, options?: ReplicationOptions): ProtocolStream {
    assert(this._feed);
    return this._feed?.replicate(initiator, options);
  }

  /**
   * Defines the real path where the Hypercore is going to work with the RandomAccessStorage specified.
   */
  private _createStorage (path = ''): RandomAccessStorageConstructor {
    return (filename) => {
      // TODO(burdon): Create Subdirectory for path?
      const { type, native } = this._directory.getOrCreateFile(`${path}/${filename}`);
      console.log(`File[${type}]: ${path}/${filename}`);
      return native;
    };
  }

  private async _open (): Promise<void> {
    // Keys generated by keyring are 65 bytes long, but hypercore expects 32 bytes.
    // We hash the signing key to get a 32 bytes key.
    // NOTE: This might cause a bug where descriptor.key !== descriptor.feed.key.
    // TODO(dmaretskyi): Replace sha256 from hypercore-crypto with a web-crypto equivalent.
    const key = sha256(this._key.toHex());
    const storage: RandomAccessStorageConstructor = this._createStorage(key);
    const hypercore = this._hypercore(storage, key, {
      // TODO(dmaretskyi): Can we just pass undefined. We might need this for hypercore to consider this feed as writable.
      secretKey: this._signer ? Buffer.from('secret') : undefined,
      valueEncoding: this._valueEncoding,
      crypto: createCrypto(this._signer, this._key)
    });

    // Wrap feed.
    this._feed = hypercore;

    // TODO(burdon): This isn't required unless sparse is set with options?
    // Request the feed to eagerly download everything.
    void hypercore.download();

    // Wait until ready.
    await py(hypercore, hypercore.open)();
  }
}
