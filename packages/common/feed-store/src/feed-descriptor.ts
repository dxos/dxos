//
// Copyright 2019 DXOS.org
//

import defaultHypercore from 'hypercore';
import type { HypercoreConstructor, ReplicationOptions, ValueEncoding } from 'hypercore';
import assert from 'node:assert';
import { callbackify } from 'node:util';
import type { RandomAccessStorageConstructor } from 'random-access-storage';

import { Lock } from '@dxos/async';
import { sha256, verifySignature, Signer } from '@dxos/crypto';
import { failUndefined } from '@dxos/debug';
import { HypercoreFeed, wrapFeed } from '@dxos/hypercore';
import { PublicKey } from '@dxos/keys';
import { Directory } from '@dxos/random-access-storage';

// TODO(burdon): Use hypercore.HypercoreOptions directly.
type FeedDescriptorOptions = {
  directory: Directory
  key: PublicKey
  hypercore?: HypercoreConstructor
  secretKey?: Buffer
  valueEncoding?: ValueEncoding
  disableSigning?: boolean
  signer?: Signer
}

/**
 * Abstract handler for an Hypercore feed.
 */
// TODO(burdon): Rename FeedWrapper (and hide hypercore).
export class FeedDescriptor {
  private readonly _directory: Directory;
  private readonly _key: PublicKey;
  private readonly _secretKey?: Buffer;
  private readonly _valueEncoding?: ValueEncoding;
  private readonly _hypercore: HypercoreConstructor;
  private readonly _disableSigning: boolean;
  private readonly _signer?: Signer;

  // Semaphore to protect open/close.
  private readonly _lock = new Lock();

  private _feed: HypercoreFeed | null;

  constructor ({
    directory,
    key,
    secretKey, // TODO(burdon): Remove: https://github.com/dxos/dxos/pull/1611#discussion_r989888001
    valueEncoding, // TODO(burdon): Default or required?
    hypercore = defaultHypercore, // TODO(burdon): Remove.
    disableSigning = false,
    signer
  }: FeedDescriptorOptions) {
    assert(!signer || !secretKey, 'Cannot use signer and secretKey at the same time.');
    assert(!signer || !disableSigning, 'Signing cannot be disabled when signer is provided.');

    this._directory = directory;
    this._valueEncoding = valueEncoding;
    this._hypercore = hypercore;
    this._key = key;
    this._secretKey = secretKey;
    this._disableSigning = !!disableSigning;
    this._signer = signer;
    this._feed = null;
  }

  get key () {
    return this._key;
  }

  // TODO(burdon): Remove.
  get secretKey () {
    return this._secretKey;
  }

  get discoveryKey () {
    return this._feed?.discoveryKey;
  }

  /**
   * @deprecated
   */
  // TODO(burdon): Remove (debug only); and remove from open().
  get feed (): HypercoreFeed {
    assert(this._feed, 'Feed not initialized.');
    return this._feed;
  }

  get initialized () {
    return !!this._feed;
  }

  get opened () {
    // TODO(burdon): TS requires explicit type here.
    return !!(this._feed && this._feed.opened && !this._feed.closed);
  }

  get length (): number {
    return this._feed?.length ?? 0;
  }

  get writable () {
    return !!this._signer;
  }

  get valueEncoding () {
    return this._valueEncoding;
  }

  /**
   * Open an Hypercore feed based on the related feed options.
   * This is an atomic operation, FeedDescriptor makes sure that the feed is not going to open again.
   */
  async open (): Promise<HypercoreFeed> {
    if (this.opened) {
      return this._feed ?? failUndefined();
    }

    await this._lock.executeSynchronized(async () => {
      return await this._open();
    });

    return this._feed ?? failUndefined();
  }

  /**
   * Close the Hypercore referenced by the descriptor.
   */
  async close () {
    if (!this.opened) {
      return;
    }

    assert(this._feed);
    await this._feed.close();
    // await this._lock.executeSynchronized(async () => {
    //   await pify(this._feed?.close.bind(this._feed))();
    // });
  }

  /**
   * Append the message block returning the sequence number.
   */
  append (message: any): Promise<number> {
    assert(this._feed);
    return this._feed.append(message);
  }

  /**
   * Return replication stream.
   */
  replicate (initiator: boolean, options?: ReplicationOptions) {
    assert(this._feed);
    return this._feed?.replicate(initiator, options);
  }

  /**
   * Defines the real path where the Hypercore is going to work with the RandomAccessStorage specified.
   */
  private _createStorage (path = ''): RandomAccessStorageConstructor {
    return (filename) => {
      // TODO(burdon): Create Subdirectory for path?
      const { type, native } = this._directory.getOrCreateFile(`${path}/${filename}`);
      console.log(`File[${type}]: ${path}/${filename}`);
      return native;
    };
  }

  private async _open (): Promise<void> {
    // Keys generated by keyring are 65 bytes long, but hypercore expects 32 bytes.
    // We hash the signing key to get a 32 bytes key.
    // NOTE: This might cause a bug where descriptor.key !== descriptor.feed.key.
    // TODO(dmaretskyi): Replace sha256 from hypercore-crypto with a web-crypto equivalent.
    const key = sha256(this._key.toHex());

    const storage: RandomAccessStorageConstructor = this._createStorage(key);

    const hypercore = this._hypercore(storage, key, {
      // TODO(dmaretskyi): Can we just pass undefined. We might need this for hypercore to consider this feed as writable.
      secretKey: this._signer ? Buffer.from('secret') : undefined,
      valueEncoding: this._valueEncoding,
      crypto: {
        sign: (data: any, secretKey: any, cb: any) => {
          assert(this._signer, 'Signer was not provided to the writable feed (writable feeds without an injected signer are deprecated).');
          callbackify(this._signer!.sign.bind(this._signer!))(this._key, data, (err, res) => {
            if (err) {
              cb(err);
              return;
            }

            cb(null, Buffer.from(res));
          });
        },

        verify: async (data: any, signature: any, key: any, cb: any) => {
          callbackify(verifySignature)(this._key, data, signature, cb);
        }
      }
    });

    // Wrap feed.
    const feed = wrapFeed(hypercore);
    this._feed = feed;

    // TODO(burdon): This isn't required unless sparse is set with options?
    // Request the feed to eagerly download everything.
    void feed.download();

    // Wait until ready.
    await feed.open();
  }
}
