//
// Copyright 2024 DXOS.org
//

import base32Decode from 'base32-decode';
import base32Encode from 'base32-encode';
import * as Schema from 'effect/Schema';

import { invariant } from '@dxos/invariant';

import { randomBytes } from './random-bytes';

/**
 * Denotes RFC4648 base-32 format.
 */
const MULTIBASE_PREFIX = 'B';

const ENCODED_LENGTH = 33;

const isValid = (value: string): value is SpaceId => {
  return typeof value === 'string' && value.startsWith(MULTIBASE_PREFIX) && value.length === ENCODED_LENGTH;
};

/**
 * A unique identifier for a space.
 * Space keys are generated by creating a keypair, and then taking the first 20 bytes of the SHA-256 hash of the public key and encoding them to multibase RFC4648 base-32 format (prefixed with B, see Multibase Table).
 * @example BA25QRC2FEWCSAMRP4RZL65LWJ7352CKE
 */
// TODO(burdon): Use effect branded type?
export type SpaceId = string & { __SpaceId: true };

export const SpaceId: Schema.Schema<SpaceId, string> & {
  byteLength: number;
  encode: (value: Uint8Array) => SpaceId;
  decode: (value: SpaceId) => Uint8Array;
  isValid: (value: string) => value is SpaceId;
  make: (value: string) => SpaceId;
  random: () => SpaceId;
} = class extends Schema.String.pipe(Schema.filter(isValid)) {
  static byteLength = 20;

  static encode = (value: Uint8Array): SpaceId => {
    invariant(value instanceof Uint8Array, 'Invalid type');
    invariant(value.length === SpaceId.byteLength, 'Invalid length');
    return (MULTIBASE_PREFIX + base32Encode(value, 'RFC4648')) as SpaceId;
  };

  static decode = (value: SpaceId): Uint8Array => {
    invariant(value.startsWith(MULTIBASE_PREFIX), 'Invalid multibase32 encoding');
    return new Uint8Array(base32Decode(value.slice(1), 'RFC4648'));
  };

  static isValid = isValid;

  static random = (): SpaceId => {
    return SpaceId.encode(randomBytes(SpaceId.byteLength));
  };
};
