//
// Copyright 2022 DXOS.org
//

syntax = "proto3";

package dxos.halo.credentials;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

import "dxos/halo/keys.proto";

//
// TODO(burdon): Move these notes to the design doc commentary.
// Peers maintain Feeds that are admitted to HALO and ECHO Parties.
// Peers act as Verifiers for Credentials that may be Presented from other Peers.
// Since Feeds implement a signed hash-linked data structure, they constitute a chain-of-authority for chained Credentials.
// Credentials written to HALO Feeds may be Presented to Peers Verifying ECHO Parties.
//

//
// **PartyGenesis** -
//  First message written to initial Feed in a new Party.
//

message PartyGenesis {
  dxos.halo.keys.PubKey partyKey = 1; // Feeds belong to Parties.
}

//
// **Claim** -
//  Statement about a subject.
//  Claims can be written directly to a feed or used within Credentials.
//

// Agent is authorized to access Party.
message PartyMember {
  // TODO(burdon): Consider permissions (e.g., for Bots).
  enum Role {
    INVALID = 0;
    /// Manage members.
    ADMIN = 1;
    /// Read and write.
    MEMBER = 2;
    /// Read-only.
    READER = 3;
  }

  dxos.halo.keys.PubKey partyKey = 1;
  Role role = 2;
}

// Device is authorized to sign messages for a given Agent (Identity).
// NOTE: Devices are Admitted to Identities.
message AuthorizedDevice {
  dxos.halo.keys.PubKey identityKey = 1;
  dxos.halo.keys.PubKey deviceKey = 2; // Existing authorized device.
}

// Feed is admitted to the Party for replication.
// NOTE: Feeds are Admitted to Parties.
message AdmittedFeed {
  enum Designation {
    /// Classic general purpose feeds for both HALO and ECHO messages together. To be deprecated.
    GENERAL = 0;
    /// Contain system-level messages messages, such as credentials and epochs.
    CONTROL = 1;
    /// Database mutations.
    DATA = 2;
  }

  dxos.halo.keys.PubKey partyKey = 1;

  /// Owning identity.
  dxos.halo.keys.PubKey identityKey = 2; // Could be derived.
  /// Owning device.
  dxos.halo.keys.PubKey deviceKey = 3;

  /// Controls sets the feed designation. Feeds with different designations are consumed by separate pipelines.
  Designation designation = 4;
}

/// Associtaes a space that will implement Agent's HALO with an Identity.
message HaloSpace {
  dxos.halo.keys.PubKey identityKey = 1;
  /// Space key.
  dxos.halo.keys.PubKey haloKey = 2;
}

/// Grants recovery permissions to a recovery key.
message IdentityRecovery {
  dxos.halo.keys.PubKey identityKey = 1;
  /// Public key derrived from the recovery seedphrase.
  dxos.halo.keys.PubKey recoveryKey = 2;
}

/// Sets profile information.
message IdentityProfile {
  message ProfileDocument {
    optional string displayName = 1;
    optional string avatarCID = 2;
  }

  // TODO(dmaretskyi): This could also be a DXNS link or stored in user's public HALO (we could also index the public HALO in the DMG).
  ProfileDocument profile = 1;
}

/// Metadata associated with a key.
/// Subject must be a key being referenced.
message KeyInfo {
  optional string name = 1;
}

//
// **Claim** -
//  Statement about a subject.
//  Claims can be written directly to a feed or used within Credentials.
//

message Claim {
  dxos.halo.keys.PubKey id = 1;                   // Subject of claim (e.g., Agent, Device, Feed).
  google.protobuf.Any assertion = 2;
}

//
// **Proof** -
//  Signature that makes Credential tamper-evident.
//  The proof is signed by the issuer of the Credential.
//  Ref: https://www.w3.org/TR/vc-data-model/#proofs-signatures
//

message Proof {
  string type = 1;                                // Type of proof (e.g., "Ed25519Signature2020").
  google.protobuf.Timestamp creationDate = 2;
  dxos.halo.keys.PubKey signer = 3;               // Entity that created the proof (e.g., Agent, Device, Party).
  optional bytes nonce = 4;                       // Used in Presentations to protect against replay attacks.

  /// Signature (excluded from signed data).
  bytes value = 5;

  /**
   * Must be present if signer is not credential issuer.
   * Establishes the authority of the signer. Proves that the signer can issue such credentials.
   * Excluded from signed data.
   */
  optional Chain chain = 6;
}

/**
 * A chain of credentials that establishes the delegated authority to issue new credentials.
 * Each key in the chain has an assotiated credential that establishes the authrity of that specific key.
 *
 * Example:
 *   Alice/Device-2 => Alice/Device-1 => Alice
 *
 * This chain would include 2 credentials:
 *   1. Giving Alice/Device-2 the authority to issue credentials on behalf of Alice, signed by Alice/Device-1.
 *   2. Giving Alice/Device-1 the authority to issue credentials on behalf of Alice, signed by Alice.
 */
message Chain {
  /// Credential that authorizes the subject to issue new credentials (can be recursive).
  Credential credential = 1;
}

//
// **Credential** -
//  Set of claims containing a proof signed by the issuer.
//  Credentials may be stored in a Credential Repository (e.g., digital wallet.)
//  Credentials may also be store within feeds (e.g., an agent's HALO).
//

message Credential {
  optional dxos.halo.keys.PubKey id = 1;        // Credential identifier (e.g., for storage indexing).
  dxos.halo.keys.PubKey issuer = 2;             // key = { Party (genesis) | Identity (genesis) | (authorized) Device }
  google.protobuf.Timestamp issuanceDate = 3;
  optional google.protobuf.Timestamp expirationDate = 4;
  optional bytes expirationRef = 5;             // Could reference blockchain or epoch number.
  Claim subject = 10;
  Proof proof = 11;
}

//
// **Presentation** -
//  Signed Credential(s) sent to a Verifier.
//  Presentations are typically NOT stored any may include a challenge (e.g., nonce).
//  Presentations may contain multiple Credentials (and require multiple proofs).
//

message Presentation {
  repeated Credential credentials = 1;
  repeated Proof proofs = 2;
}

//
// **Metadata** -
//   Persistant metadata stored outside of used to bootsrapt the stack.
//

/// Information needed to bootstrap a Space.
message SpaceRecord {
  dxos.halo.keys.PubKey spaceKey = 1;

  /// All feeds in the space must form a DAG (or a tree?). This is the root feed of that structure.
  dxos.halo.keys.PubKey genesisFeedKey = 2;
}

/// Information needed to bootstrap an Identity.
message IdentityRecord {
  dxos.halo.keys.PubKey identityKey = 1;

  SpaceRecord haloSpace = 2;

  /// Public profile information.
  /// Not yet implemented. Must be null.
  optional SpaceRecord profileSpace = 3;

  /// Cached profile.
  optional IdentityProfile.ProfileDocument profile = 4;
}
