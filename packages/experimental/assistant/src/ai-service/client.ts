//
// Copyright 2024 DXOS.org
//

/* eslint-disable no-console */

import { Schema as S } from '@effect/schema';

import { Trigger } from '@dxos/async';
import { invariant } from '@dxos/invariant';
import type { SpaceId } from '@dxos/keys';

import {
  Message,
  type GenerateRequest,
  type ObjectId,
  type ResultStreamEvent,
  type Space,
  type Thread,
} from './schema';
import { iterSSEMessages } from './sse';

export type AIServiceClientParams = {
  endpoint: string;
};

export interface AIServiceClient {
  getSpace(spaceId: SpaceId): Promise<Space>;
  getThread(spaceId: SpaceId, threadId: string): Promise<Thread>;
  getMessagesInThread(spaceId: SpaceId, threadId: string): Promise<Message[]>;
  insertMessages(messages: Message[]): Promise<void>;
  updateMessage(spaceId: SpaceId, threadId: string, messageId: string, message: Message): Promise<void>;
  generate(request: GenerateRequest): Promise<GenerationStream>;
}

export class AIServiceClientImpl implements AIServiceClient {
  private readonly _endpoint: string;
  constructor({ endpoint }: AIServiceClientParams) {
    this._endpoint = endpoint;
  }

  async getSpace(spaceId: SpaceId): Promise<Space> {
    throw new Error('Not implemented');
  }

  async getThread(spaceId: SpaceId, threadId: string): Promise<Thread> {
    throw new Error('Not implemented');
  }

  async getMessagesInThread(spaceId: SpaceId, threadId: string): Promise<Message[]> {
    const res = await fetch(`${this._endpoint}/space/${spaceId}/thread/${threadId}/message`);
    return S.decodePromise(S.Array(Message).pipe(S.mutable))((await res.json()).data.results);
  }

  async insertMessages(messages: Message[]): Promise<void> {
    const res = await fetch(`${this._endpoint}/message`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        messages: await S.encodePromise(S.Array(Message))(messages),
      }),
    });

    if (!res.ok) {
      throw new Error(await res.text());
    }
  }

  // TODO(dmaretskyi): Accept partial message schema.
  async updateMessage(spaceId: SpaceId, threadId: string, messageId: string, message: Message): Promise<void> {
    throw new Error('Not implemented');
  }

  async generate(request: GenerateRequest): Promise<GenerationStream> {
    const response = await fetch(`${this._endpoint}/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
    });
    invariant(response.body instanceof ReadableStream);

    return GenerationStream.fromSSEResponse(
      {
        spaceId: request.spaceId,
        threadId: request.threadId,
      },
      response,
    );
  }
}

type GenerationParams = {
  spaceId: SpaceId;
  threadId: ObjectId;
};

export class GenerationStream implements AsyncIterable<ResultStreamEvent> {
  static fromSSEResponse(params: GenerationParams, response: Response) {
    const controller = new AbortController();
    const iterator = async function* () {
      for await (const sse of iterSSEMessages(response, controller)) {
        if (sse.event === 'completion') {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error('Could not parse message into JSON:', sse.data);
            console.error('From chunk:', sse.raw);
            throw e;
          }
        }

        if (
          sse.event === 'message_start' ||
          sse.event === 'message_delta' ||
          sse.event === 'message_stop' ||
          sse.event === 'content_block_start' ||
          sse.event === 'content_block_delta' ||
          sse.event === 'content_block_stop'
        ) {
          try {
            yield JSON.parse(sse.data);
          } catch (e) {
            console.error('Could not parse message into JSON:', sse.data);
            console.error('From chunk:', sse.raw);
            throw e;
          }
        }

        if (sse.event === 'ping') {
          continue;
        }

        if (sse.event === 'error') {
          throw new Error(`Message generation error: ${sse.data}`);
        }
      }
    };
    return new GenerationStream(params, iterator);
  }

  private _accumulatedMessage?: Message = undefined;
  private _messageComplete = new Trigger();
  private _iterator?: AsyncIterator<ResultStreamEvent> = undefined;

  constructor(
    private readonly _params: GenerationParams,
    private readonly _getIterator: () => AsyncIterableIterator<ResultStreamEvent>,
  ) {}

  [Symbol.asyncIterator](): AsyncIterator<ResultStreamEvent> {
    return this._createIterator();
  }

  cancel() {
    throw new Error('Not implemented');
  }

  get accumulatedMessages(): Message[] {
    // TODO(dmaretskyi): Support multiple accumulated messages.
    return this._accumulatedMessage ? [this._accumulatedMessage] : [];
  }

  /**
   * Returns the complete message list generated by the AI service.
   */
  async complete(): Promise<Message[]> {
    await this._messageComplete.wait();
    invariant(this._accumulatedMessage !== undefined);
    return [this._accumulatedMessage];
  }

  private _createIterator(): AsyncIterator<ResultStreamEvent> {
    const self = this;
    return (this._iterator ??= (async function* () {
      for await (const event of self._getIterator()) {
        self._processEvent(event);
        yield event;
      }
    })());
  }

  private _processEvent(event: ResultStreamEvent) {
    // TODO(dmaretskyi): Support multiple message, e.g. for service-defined tools.
    switch (event.type) {
      case 'message_start': {
        if (this._accumulatedMessage) {
          throw new Error('Cannot process more than one message in a single generation stream');
        }
        this._accumulatedMessage = {
          ...event.message,
          threadId: this._params.threadId,
          spaceId: this._params.spaceId,
        };
        break;
      }
      case 'message_delta': {
        if (this._accumulatedMessage === undefined) {
          throw new Error('Received message delta without a message start');
        }
        break;
      }
      case 'message_stop': {
        if (this._accumulatedMessage === undefined) {
          throw new Error('Received message stop without a message start');
        }
        this._messageComplete.wake();
        break;
      }
      case 'content_block_start': {
        invariant(this._accumulatedMessage);
        this._accumulatedMessage.content.push(event.content);
        break;
      }
      case 'content_block_delta': {
        invariant(this._accumulatedMessage);
        const snapshotContent = this._accumulatedMessage.content.at(event.index);
        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {
          snapshotContent.text += event.delta.text;
        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {
          snapshotContent.inputJson ??= '';
          snapshotContent.inputJson += event.delta.partial_json;

          // TODO(dmaretskyi): Partial parsing.
          // if (jsonBuf) {
          //   snapshotContent.input = partialParse(jsonBuf);
          // }
        }
        break;
      }
      case 'content_block_stop': {
        invariant(this._accumulatedMessage);
        const lastBlock = this._accumulatedMessage.content.at(-1);
        if (lastBlock?.type === 'tool_use') {
          lastBlock.input = JSON.parse(lastBlock.inputJson ?? '');
        }
        break;
      }
    }
  }
}
