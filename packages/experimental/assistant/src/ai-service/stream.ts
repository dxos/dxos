//
// Copyright 2024 DXOS.org
//

import { type Message } from '@dxos/artifact';
import { Trigger } from '@dxos/async';
import { type ObjectId } from '@dxos/echo-schema';
import { invariant } from '@dxos/invariant';
import { type SpaceId } from '@dxos/keys';
import { log } from '@dxos/log';

import { type ResultStreamEvent } from './defs';
import { iterSSEMessages } from './util';

export type GenerationParams = {
  spaceId?: SpaceId;
  threadId?: ObjectId;
};

export class GenerationStream implements AsyncIterable<ResultStreamEvent> {
  /**
   * Creates a stream from an SSE response.
   */
  static fromSSEResponse(params: GenerationParams, response: Response, controller = new AbortController()) {
    const iterator = async function* () {
      for await (const sse of iterSSEMessages(response, controller)) {
        if (sse.event === 'completion') {
          try {
            yield JSON.parse(sse.data);
          } catch (err) {
            log.error('could not parse message into JSON:', { data: sse.data, raw: sse.raw });
            throw err;
          }
        }

        if (
          sse.event === 'message_start' ||
          sse.event === 'message_delta' ||
          sse.event === 'message_stop' ||
          sse.event === 'content_block_start' ||
          sse.event === 'content_block_delta' ||
          sse.event === 'content_block_stop'
        ) {
          try {
            yield JSON.parse(sse.data);
          } catch (err) {
            log.error('could not parse message into JSON:', { data: sse.data, raw: sse.raw });
            throw err;
          }
        }

        if (sse.event === 'ping') {
          continue;
        }

        if (sse.event === 'error') {
          throw new Error(`Message generation error: ${sse.data}`);
        }
      }
    };

    return new GenerationStream(controller, iterator, params);
  }

  private readonly _done = new Trigger();
  private _previousMessages: Message[] = [];
  private _accumulatedMessage?: Message = undefined;
  private _iterator?: AsyncIterator<ResultStreamEvent> = undefined;

  constructor(
    private readonly _controller: AbortController,
    private readonly _getIterator: () => AsyncIterableIterator<ResultStreamEvent>,
    private readonly _params: GenerationParams,
  ) {}

  [Symbol.asyncIterator](): AsyncIterator<ResultStreamEvent> {
    return this._createIterator();
  }

  get accumulatedMessages(): Message[] {
    // TODO(dmaretskyi): Support multiple accumulated messages.
    return [...this._previousMessages, ...(this._accumulatedMessage == null ? [] : [this._accumulatedMessage])];
  }

  /**
   * Aborts the stream.
   */
  abort() {
    this._controller.abort();
  }

  /**
   * Returns the complete message list generated by the AI service.
   */
  async complete(): Promise<Message[]> {
    await this._done.wait();
    return this.accumulatedMessages;
  }

  private _createIterator(): AsyncIterator<ResultStreamEvent> {
    const self = this;
    return (this._iterator ??= (() => {
      const generator = async function* (this: GenerationStream) {
        try {
          for await (const event of self._getIterator()) {
            self._processEvent(event);
            yield event;
          }
          this._done.wake();
        } catch (err: any) {
          this._done.throw(err);
        }
      };
      return generator.call(this);
    })());
  }

  private _processEvent(event: ResultStreamEvent) {
    // TODO(dmaretskyi): Support multiple message, e.g., for service-defined tools.
    switch (event.type) {
      case 'message_start': {
        if (this._accumulatedMessage) {
          this._previousMessages.push(this._accumulatedMessage);
          this._accumulatedMessage = undefined;
        }
        this._accumulatedMessage = {
          ...event.message,
          threadId: this._params.threadId,
          spaceId: this._params.spaceId,
        };
        break;
      }

      case 'message_delta': {
        if (this._accumulatedMessage === undefined) {
          throw new Error('Received message delta without a message start');
        }
        break;
      }

      case 'message_stop': {
        if (this._accumulatedMessage === undefined) {
          throw new Error('Received message stop without a message start');
        }
        break;
      }

      case 'content_block_start': {
        invariant(this._accumulatedMessage);
        this._accumulatedMessage.content.push(event.content);
        break;
      }

      case 'content_block_delta': {
        invariant(this._accumulatedMessage);
        const snapshotContent = this._accumulatedMessage.content.at(event.index);
        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {
          snapshotContent.text += event.delta.text;
        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {
          snapshotContent.inputJson ??= '';
          snapshotContent.inputJson += event.delta.partial_json;

          // TODO(dmaretskyi): Partial parsing.
          // if (jsonBuf) {
          //   snapshotContent.input = partialParse(jsonBuf);
          // }
        }
        break;
      }

      case 'content_block_stop': {
        invariant(this._accumulatedMessage);
        const lastBlock = this._accumulatedMessage.content.at(-1);
        if (lastBlock?.type === 'tool_use') {
          lastBlock.input =
            lastBlock.inputJson == null || lastBlock.inputJson === '' ? {} : JSON.parse(lastBlock.inputJson ?? '');
        }
        break;
      }
    }
  }
}
