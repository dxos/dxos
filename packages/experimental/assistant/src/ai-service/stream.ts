//
// Copyright 2024 DXOS.org
//

import { type Message } from '@dxos/artifact';
import { Trigger } from '@dxos/async';
import { invariant } from '@dxos/invariant';
import { log } from '@dxos/log';

import { type GenerateRequest, type ResultStreamEvent } from './defs';
import { iterSSEMessages } from './util';

export type GenerationParams = Pick<GenerateRequest, 'spaceId' | 'threadId'>;

/**
 * Server-Sent Events (SSE) stream from the AI service.
 * https://docs.anthropic.com/en/api/streaming
 * https://platform.openai.com/docs/api-reference/streaming
 * https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events
 */
export class GenerationStream implements AsyncIterable<ResultStreamEvent> {
  /**
   * Creates a stream from an SSE response.
   */
  static fromSSEResponse(response: Response, params: GenerationParams = {}, controller = new AbortController()) {
    const iterator = async function* () {
      for await (const sse of iterSSEMessages(response, controller)) {
        if (sse.event === 'completion') {
          try {
            yield JSON.parse(sse.data);
          } catch (err) {
            log.error('could not parse message into JSON:', { data: sse.data, raw: sse.raw });
            throw err;
          }
        }

        if (
          sse.event === 'message_start' ||
          sse.event === 'message_delta' ||
          sse.event === 'message_stop' ||
          sse.event === 'content_block_start' ||
          sse.event === 'content_block_delta' ||
          sse.event === 'content_block_stop'
        ) {
          try {
            yield JSON.parse(sse.data);
          } catch (err) {
            log.error('could not parse message into JSON:', { data: sse.data, raw: sse.raw });
            throw err;
          }
        }

        if (sse.event === 'ping') {
          continue;
        }

        if (sse.event === 'error') {
          throw new Error(`Message generation error: ${sse.data}`);
        }
      }
    };

    return new GenerationStream(controller, iterator, params);
  }

  /**
   * Accumulated messages.
   */
  private _messages: Message[] = [];

  /**
   * The current message being assembled.
   */
  private _current?: Message = undefined;

  /**
   * Iterator over the stream.
   */
  private _iterator?: AsyncIterator<ResultStreamEvent> = undefined;

  /**
   * Trigger event when the stream is done.
   */
  private readonly _done = new Trigger();

  constructor(
    private readonly _controller: AbortController,
    private readonly _getIterator: () => AsyncIterableIterator<ResultStreamEvent>,
    private readonly _params: GenerationParams,
  ) {}

  /**
   * Returns an iterator over the stream.
   */
  [Symbol.asyncIterator](): AsyncIterator<ResultStreamEvent> {
    return this._createIterator();
  }

  /**
   * Accumulated messasges.
   */
  get messages(): Message[] {
    return [...this._messages, ...(this._current == null ? [] : [this._current])];
  }

  /**
   * Aborts the stream.
   */
  abort() {
    this._controller.abort();
  }

  /**
   * Returns the complete message list generated by the AI service.
   */
  async complete(): Promise<Message[]> {
    await this._done.wait();
    return this.messages;
  }

  /**
   * Creates an iterator over the stream.
   */
  private _createIterator(): AsyncIterator<ResultStreamEvent> {
    const self = this;
    return (this._iterator ??= (() => {
      const generator = async function* (this: GenerationStream) {
        try {
          for await (const event of self._getIterator()) {
            self._processEvent(event);
            yield event;
          }
          this._done.wake();
        } catch (err: any) {
          this._done.throw(err);
        }
      };

      return generator.call(this);
    })());
  }

  private _processEvent(event: ResultStreamEvent) {
    log('processing', { event: event.type });

    // TODO(dmaretskyi): Support multiple message, e.g., for service-defined tools.
    switch (event.type) {
      //
      // Message events
      //

      case 'message_start': {
        if (this._current) {
          this._messages.push(this._current);
          this._current = undefined;
        }

        this._current = {
          ...event.message,
          spaceId: this._params.spaceId,
          threadId: this._params.threadId,
        };
        break;
      }

      case 'message_delta': {
        if (this._current === undefined) {
          throw new Error('Received message delta without a message start');
        }
        break;
      }

      case 'message_stop': {
        if (this._current === undefined) {
          throw new Error('Received message stop without a message start');
        }
        break;
      }

      //
      // Content block events
      //

      case 'content_block_start': {
        invariant(this._current);
        this._current.content.push(event.content);
        break;
      }

      case 'content_block_delta': {
        invariant(this._current);
        const snapshotContent = this._current.content.at(event.index);
        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {
          snapshotContent.text += event.delta.text;
        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {
          snapshotContent.inputJson ??= '';
          snapshotContent.inputJson += event.delta.partial_json;
          // TODO(dmaretskyi): Partial parsing.
          // if (jsonBuf) {
          //   snapshotContent.input = partialParse(jsonBuf);
          // }
        }
        break;
      }

      case 'content_block_stop': {
        invariant(this._current);
        const lastBlock = this._current.content.at(-1);
        if (lastBlock?.type === 'tool_use') {
          lastBlock.input =
            lastBlock.inputJson == null || lastBlock.inputJson === '' ? {} : JSON.parse(lastBlock.inputJson ?? '');
        }
        break;
      }
    }
  }
}
