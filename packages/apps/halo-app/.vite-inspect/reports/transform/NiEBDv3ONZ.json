{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/nanomessage.js","transforms":[{"name":"vite:load-fallback","result":"const { NanoresourcePromise } = require('nanoresource-promise/emitter')\nconst fastq = require('fastq')\n\nconst Request = require('./request')\nconst createCodec = require('./codec')\nconst { NMSG_ERR_CLOSE, NMSG_ERR_NOT_OPEN, NMSG_ERR_RESPONSE } = require('./errors')\nconst IdGenerator = require('./id-generator')\n\nconst kRequests = Symbol('nanomessage.requests')\nconst kInQueue = Symbol('nanomessage.inqueue')\nconst kOutQueue = Symbol('nanomessage.outqueue')\nconst kUnsubscribe = Symbol('nanomessage.unsubscribe')\nconst kOpen = Symbol('nanomessage.open')\nconst kClose = Symbol('nanomessage.close')\nconst kFastCheckOpen = Symbol('nanomessage.fastcheckopen')\nconst kTimeout = Symbol('nanomessage.timeout')\nconst kIdGenerator = Symbol('nanomessage.idgenerator')\nconst kCodec = Symbol('nanomessage.codec')\n\nfunction inWorker (info, done) {\n  this[kFastCheckOpen]()\n    .then(() => this._onMessage(info.data, info))\n    .then(data => {\n      if (this.closed || this.closing) return done()\n\n      info.responseData = data\n\n      return this._send(this[kCodec].encode({\n        id: info.id,\n        response: info.response,\n        data\n      }), info)\n    })\n    .then(() => done())\n    .catch(err => done(err))\n}\n\nfunction outWorker (request, done) {\n  const info = request.info()\n  this[kFastCheckOpen]()\n    .then(() => {\n      if (request.finished) return\n      request.start()\n      return this._send(this[kCodec].encode(info), info)\n    })\n    .then(() => {\n      if (request.finished) return\n      return request.promise\n    })\n    .then(data => done(null, data))\n    .catch(err => done(err))\n}\n\nclass Nanomessage extends NanoresourcePromise {\n  /**\n   * Creates an instance of Nanomessage.\n   * @param {Object} [opts={}]\n   * @param {(buf: Buffer, info: Object) => Promise|undefined} [opts.send]\n   * @param {function} [opts.subscribe]\n   * @param {(data: Object, info: Object) => Promise<*>} [opts.onMessage]\n   * @param {function} [opts.open]\n   * @param {function} [opts.close]\n   * @param {number} [opts.timeout]\n   * @param {Object} [opts.valueEncoding]\n   * @param {({ incoming: number, outgoing: number }|number)} [opts.concurrency]\n   * @memberof Nanomessage\n   */\n  constructor (opts = {}) {\n    super()\n\n    const { send, subscribe, onMessage, open, close, timeout, valueEncoding, concurrency = 256 } = opts\n\n    if (send) this._send = send\n    if (subscribe) this._subscribe = subscribe\n    if (onMessage) this.setMessageHandler(onMessage)\n    if (open) this[kOpen] = open\n    if (close) this[kClose] = close\n    this.setRequestTimeout(timeout)\n\n    this[kCodec] = createCodec(valueEncoding)\n\n    this[kInQueue] = fastq(this, inWorker, 1)\n    this[kOutQueue] = fastq(this, outWorker, 1)\n    this.setConcurrency(concurrency)\n\n    this[kRequests] = new Map()\n    this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1)\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get codec () {\n    return this[kCodec]\n  }\n\n  /**\n   * @readonly\n   * @type {Array<Request>}\n   */\n  get requests () {\n    return Array.from(this[kRequests].values())\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get inflightRequests () {\n    return this[kOutQueue].running()\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get requestTimeout () {\n    return this[kTimeout]\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get concurrency () {\n    return {\n      incoming: this[kInQueue].concurrency,\n      outgoing: this[kOutQueue].concurrency\n    }\n  }\n\n  /**\n   * @param {number} timeout\n   * @returns {Nanomessage}\n   */\n  setRequestTimeout (timeout) {\n    this[kTimeout] = timeout\n    return this\n  }\n\n  /**\n   * @param {({ incoming: number, outgoing: number }|number)} value\n   * @returns {Nanomessage}\n   */\n  setConcurrency (value) {\n    if (typeof value === 'number') {\n      this[kInQueue].concurrency = value\n      this[kOutQueue].concurrency = value\n    } else {\n      this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency\n      this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency\n    }\n    return this\n  }\n\n  /**\n   * Send a request and wait for the response.\n   *\n   * @param {*} data\n   * @param {Object} [opts]\n   * @param {number} [opts.timeout]\n   * @param {AbortSignal} [opts.signal]\n   * @returns {Promise<*>}\n   */\n  request (data, opts = {}) {\n    const request = new Request({ id: this[kIdGenerator].get(), data, timeout: opts.timeout || this[kTimeout], signal: opts.signal })\n    const info = request.info()\n\n    this[kRequests].set(request.id, request)\n    request.onFinish(() => {\n      this[kRequests].delete(request.id)\n      this[kIdGenerator].release(request.id)\n    })\n\n    this.emit('request-created', info)\n\n    this[kOutQueue].push(request, (err, data) => {\n      info.response = true\n      info.responseData = data\n      this.emit('request-ended', err, info)\n    })\n\n    return request.promise\n  }\n\n  /**\n   * Send a ephemeral message.\n   *\n   * @param {*} data\n   * @returns {Promise}\n   */\n  send (data) {\n    return this[kFastCheckOpen]()\n      .then(() => {\n        const info = Request.info({ id: 0, data })\n        return this._send(this[kCodec].encode(info), info)\n      })\n  }\n\n  /**\n   * @param {(data: Object, info: Object) => Promise<*>} onMessage\n   * @returns {Nanomessage}\n   */\n  setMessageHandler (onMessage) {\n    this._onMessage = onMessage\n    return this\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {undefined}\n   */\n  processIncomingMessage (buf) {\n    if (this.closed || this.closing) return\n\n    const info = Request.info(this[kCodec].decode(buf))\n\n    // resolve response\n    if (info.response) {\n      const request = this[kRequests].get(info.id)\n      if (request) request.resolve(info.data)\n      return\n    }\n\n    if (info.ephemeral) {\n      this.emit('request-received', info)\n      this[kFastCheckOpen]()\n        .then(() => this._onMessage(info.data, info))\n        .catch(err => {\n          const rErr = new NMSG_ERR_RESPONSE(err.message)\n          rErr.stack = err.stack || rErr.stack\n          this.emit('response-error', rErr, info)\n        })\n      return\n    }\n\n    info.response = true\n    this.emit('request-received', info)\n\n    this[kInQueue].push(info, err => {\n      if (err) {\n        const rErr = new NMSG_ERR_RESPONSE(err.message)\n        rErr.stack = err.stack || rErr.stack\n        this.emit('response-error', rErr, info)\n      }\n    })\n  }\n\n  /**\n   * @abstract\n   * @param {Buffer} buf\n   * @param {Object} info\n   * @returns {Promise|undefined}\n   */\n  async _send (buf, info) {\n    throw new Error('_send not implemented')\n  }\n\n  /**\n   * @abstract\n   * @param {Object} data\n   * @param {Object} info\n   * @returns {Promise<*>}\n   */\n  async _onMessage (data, info) {\n    throw new Error('_onMessage not implemented')\n  }\n\n  async _open () {\n    await (this[kOpen] && this[kOpen]())\n    this[kUnsubscribe] = this._subscribe && this._subscribe(this.processIncomingMessage.bind(this))\n  }\n\n  async _close () {\n    if (this[kUnsubscribe]) this[kUnsubscribe]()\n\n    const requestsToClose = []\n    this[kRequests].forEach(request => request.reject(new NMSG_ERR_CLOSE()))\n    this[kRequests].clear()\n\n    this[kInQueue] && this[kInQueue].kill()\n    this[kOutQueue] && this[kOutQueue].kill()\n\n    await (this[kClose] && this[kClose]())\n    await Promise.all(requestsToClose)\n  }\n\n  async [kFastCheckOpen] () {\n    if (this.closed || this.closing) throw new NMSG_ERR_CLOSE()\n    if (this.opening) return this.open()\n    if (!this.opened) throw new NMSG_ERR_NOT_OPEN()\n  }\n}\n\nmodule.exports = Nanomessage\n","start":1670465469288,"end":1670465469531},{"name":"vite:react-babel","result":"const { NanoresourcePromise } = require('nanoresource-promise/emitter')\nconst fastq = require('fastq')\n\nconst Request = require('./request')\nconst createCodec = require('./codec')\nconst { NMSG_ERR_CLOSE, NMSG_ERR_NOT_OPEN, NMSG_ERR_RESPONSE } = require('./errors')\nconst IdGenerator = require('./id-generator')\n\nconst kRequests = Symbol('nanomessage.requests')\nconst kInQueue = Symbol('nanomessage.inqueue')\nconst kOutQueue = Symbol('nanomessage.outqueue')\nconst kUnsubscribe = Symbol('nanomessage.unsubscribe')\nconst kOpen = Symbol('nanomessage.open')\nconst kClose = Symbol('nanomessage.close')\nconst kFastCheckOpen = Symbol('nanomessage.fastcheckopen')\nconst kTimeout = Symbol('nanomessage.timeout')\nconst kIdGenerator = Symbol('nanomessage.idgenerator')\nconst kCodec = Symbol('nanomessage.codec')\n\nfunction inWorker (info, done) {\n  this[kFastCheckOpen]()\n    .then(() => this._onMessage(info.data, info))\n    .then(data => {\n      if (this.closed || this.closing) return done()\n\n      info.responseData = data\n\n      return this._send(this[kCodec].encode({\n        id: info.id,\n        response: info.response,\n        data\n      }), info)\n    })\n    .then(() => done())\n    .catch(err => done(err))\n}\n\nfunction outWorker (request, done) {\n  const info = request.info()\n  this[kFastCheckOpen]()\n    .then(() => {\n      if (request.finished) return\n      request.start()\n      return this._send(this[kCodec].encode(info), info)\n    })\n    .then(() => {\n      if (request.finished) return\n      return request.promise\n    })\n    .then(data => done(null, data))\n    .catch(err => done(err))\n}\n\nclass Nanomessage extends NanoresourcePromise {\n  /**\n   * Creates an instance of Nanomessage.\n   * @param {Object} [opts={}]\n   * @param {(buf: Buffer, info: Object) => Promise|undefined} [opts.send]\n   * @param {function} [opts.subscribe]\n   * @param {(data: Object, info: Object) => Promise<*>} [opts.onMessage]\n   * @param {function} [opts.open]\n   * @param {function} [opts.close]\n   * @param {number} [opts.timeout]\n   * @param {Object} [opts.valueEncoding]\n   * @param {({ incoming: number, outgoing: number }|number)} [opts.concurrency]\n   * @memberof Nanomessage\n   */\n  constructor (opts = {}) {\n    super()\n\n    const { send, subscribe, onMessage, open, close, timeout, valueEncoding, concurrency = 256 } = opts\n\n    if (send) this._send = send\n    if (subscribe) this._subscribe = subscribe\n    if (onMessage) this.setMessageHandler(onMessage)\n    if (open) this[kOpen] = open\n    if (close) this[kClose] = close\n    this.setRequestTimeout(timeout)\n\n    this[kCodec] = createCodec(valueEncoding)\n\n    this[kInQueue] = fastq(this, inWorker, 1)\n    this[kOutQueue] = fastq(this, outWorker, 1)\n    this.setConcurrency(concurrency)\n\n    this[kRequests] = new Map()\n    this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1)\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get codec () {\n    return this[kCodec]\n  }\n\n  /**\n   * @readonly\n   * @type {Array<Request>}\n   */\n  get requests () {\n    return Array.from(this[kRequests].values())\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get inflightRequests () {\n    return this[kOutQueue].running()\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get requestTimeout () {\n    return this[kTimeout]\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get concurrency () {\n    return {\n      incoming: this[kInQueue].concurrency,\n      outgoing: this[kOutQueue].concurrency\n    }\n  }\n\n  /**\n   * @param {number} timeout\n   * @returns {Nanomessage}\n   */\n  setRequestTimeout (timeout) {\n    this[kTimeout] = timeout\n    return this\n  }\n\n  /**\n   * @param {({ incoming: number, outgoing: number }|number)} value\n   * @returns {Nanomessage}\n   */\n  setConcurrency (value) {\n    if (typeof value === 'number') {\n      this[kInQueue].concurrency = value\n      this[kOutQueue].concurrency = value\n    } else {\n      this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency\n      this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency\n    }\n    return this\n  }\n\n  /**\n   * Send a request and wait for the response.\n   *\n   * @param {*} data\n   * @param {Object} [opts]\n   * @param {number} [opts.timeout]\n   * @param {AbortSignal} [opts.signal]\n   * @returns {Promise<*>}\n   */\n  request (data, opts = {}) {\n    const request = new Request({ id: this[kIdGenerator].get(), data, timeout: opts.timeout || this[kTimeout], signal: opts.signal })\n    const info = request.info()\n\n    this[kRequests].set(request.id, request)\n    request.onFinish(() => {\n      this[kRequests].delete(request.id)\n      this[kIdGenerator].release(request.id)\n    })\n\n    this.emit('request-created', info)\n\n    this[kOutQueue].push(request, (err, data) => {\n      info.response = true\n      info.responseData = data\n      this.emit('request-ended', err, info)\n    })\n\n    return request.promise\n  }\n\n  /**\n   * Send a ephemeral message.\n   *\n   * @param {*} data\n   * @returns {Promise}\n   */\n  send (data) {\n    return this[kFastCheckOpen]()\n      .then(() => {\n        const info = Request.info({ id: 0, data })\n        return this._send(this[kCodec].encode(info), info)\n      })\n  }\n\n  /**\n   * @param {(data: Object, info: Object) => Promise<*>} onMessage\n   * @returns {Nanomessage}\n   */\n  setMessageHandler (onMessage) {\n    this._onMessage = onMessage\n    return this\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {undefined}\n   */\n  processIncomingMessage (buf) {\n    if (this.closed || this.closing) return\n\n    const info = Request.info(this[kCodec].decode(buf))\n\n    // resolve response\n    if (info.response) {\n      const request = this[kRequests].get(info.id)\n      if (request) request.resolve(info.data)\n      return\n    }\n\n    if (info.ephemeral) {\n      this.emit('request-received', info)\n      this[kFastCheckOpen]()\n        .then(() => this._onMessage(info.data, info))\n        .catch(err => {\n          const rErr = new NMSG_ERR_RESPONSE(err.message)\n          rErr.stack = err.stack || rErr.stack\n          this.emit('response-error', rErr, info)\n        })\n      return\n    }\n\n    info.response = true\n    this.emit('request-received', info)\n\n    this[kInQueue].push(info, err => {\n      if (err) {\n        const rErr = new NMSG_ERR_RESPONSE(err.message)\n        rErr.stack = err.stack || rErr.stack\n        this.emit('response-error', rErr, info)\n      }\n    })\n  }\n\n  /**\n   * @abstract\n   * @param {Buffer} buf\n   * @param {Object} info\n   * @returns {Promise|undefined}\n   */\n  async _send (buf, info) {\n    throw new Error('_send not implemented')\n  }\n\n  /**\n   * @abstract\n   * @param {Object} data\n   * @param {Object} info\n   * @returns {Promise<*>}\n   */\n  async _onMessage (data, info) {\n    throw new Error('_onMessage not implemented')\n  }\n\n  async _open () {\n    await (this[kOpen] && this[kOpen]())\n    this[kUnsubscribe] = this._subscribe && this._subscribe(this.processIncomingMessage.bind(this))\n  }\n\n  async _close () {\n    if (this[kUnsubscribe]) this[kUnsubscribe]()\n\n    const requestsToClose = []\n    this[kRequests].forEach(request => request.reject(new NMSG_ERR_CLOSE()))\n    this[kRequests].clear()\n\n    this[kInQueue] && this[kInQueue].kill()\n    this[kOutQueue] && this[kOutQueue].kill()\n\n    await (this[kClose] && this[kClose]())\n    await Promise.all(requestsToClose)\n  }\n\n  async [kFastCheckOpen] () {\n    if (this.closed || this.closing) throw new NMSG_ERR_CLOSE()\n    if (this.opening) return this.open()\n    if (!this.opened) throw new NMSG_ERR_NOT_OPEN()\n  }\n}\n\nmodule.exports = Nanomessage\n","start":1670465469531,"end":1670465469532,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoresource-promise@2.0.0/node_modules/nanoresource-promise/emitter.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/fastq@1.13.0/node_modules/fastq/queue.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/request.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/codec.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/errors.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/id-generator.js?commonjs-proxy\";\n\nconst { NanoresourcePromise } = require$$0\nconst fastq = require$$1\n\nconst Request = require$$2\nconst createCodec = require$$3\nconst { NMSG_ERR_CLOSE, NMSG_ERR_NOT_OPEN, NMSG_ERR_RESPONSE } = require$$4\nconst IdGenerator = require$$5\n\nconst kRequests = Symbol('nanomessage.requests')\nconst kInQueue = Symbol('nanomessage.inqueue')\nconst kOutQueue = Symbol('nanomessage.outqueue')\nconst kUnsubscribe = Symbol('nanomessage.unsubscribe')\nconst kOpen = Symbol('nanomessage.open')\nconst kClose = Symbol('nanomessage.close')\nconst kFastCheckOpen = Symbol('nanomessage.fastcheckopen')\nconst kTimeout = Symbol('nanomessage.timeout')\nconst kIdGenerator = Symbol('nanomessage.idgenerator')\nconst kCodec = Symbol('nanomessage.codec')\n\nfunction inWorker (info, done) {\n  this[kFastCheckOpen]()\n    .then(() => this._onMessage(info.data, info))\n    .then(data => {\n      if (this.closed || this.closing) return done()\n\n      info.responseData = data\n\n      return this._send(this[kCodec].encode({\n        id: info.id,\n        response: info.response,\n        data\n      }), info)\n    })\n    .then(() => done())\n    .catch(err => done(err))\n}\n\nfunction outWorker (request, done) {\n  const info = request.info()\n  this[kFastCheckOpen]()\n    .then(() => {\n      if (request.finished) return\n      request.start()\n      return this._send(this[kCodec].encode(info), info)\n    })\n    .then(() => {\n      if (request.finished) return\n      return request.promise\n    })\n    .then(data => done(null, data))\n    .catch(err => done(err))\n}\n\nclass Nanomessage extends NanoresourcePromise {\n  /**\n   * Creates an instance of Nanomessage.\n   * @param {Object} [opts={}]\n   * @param {(buf: Buffer, info: Object) => Promise|undefined} [opts.send]\n   * @param {function} [opts.subscribe]\n   * @param {(data: Object, info: Object) => Promise<*>} [opts.onMessage]\n   * @param {function} [opts.open]\n   * @param {function} [opts.close]\n   * @param {number} [opts.timeout]\n   * @param {Object} [opts.valueEncoding]\n   * @param {({ incoming: number, outgoing: number }|number)} [opts.concurrency]\n   * @memberof Nanomessage\n   */\n  constructor (opts = {}) {\n    super()\n\n    const { send, subscribe, onMessage, open, close, timeout, valueEncoding, concurrency = 256 } = opts\n\n    if (send) this._send = send\n    if (subscribe) this._subscribe = subscribe\n    if (onMessage) this.setMessageHandler(onMessage)\n    if (open) this[kOpen] = open\n    if (close) this[kClose] = close\n    this.setRequestTimeout(timeout)\n\n    this[kCodec] = createCodec(valueEncoding)\n\n    this[kInQueue] = fastq(this, inWorker, 1)\n    this[kOutQueue] = fastq(this, outWorker, 1)\n    this.setConcurrency(concurrency)\n\n    this[kRequests] = new Map()\n    this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1)\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get codec () {\n    return this[kCodec]\n  }\n\n  /**\n   * @readonly\n   * @type {Array<Request>}\n   */\n  get requests () {\n    return Array.from(this[kRequests].values())\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get inflightRequests () {\n    return this[kOutQueue].running()\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get requestTimeout () {\n    return this[kTimeout]\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get concurrency () {\n    return {\n      incoming: this[kInQueue].concurrency,\n      outgoing: this[kOutQueue].concurrency\n    }\n  }\n\n  /**\n   * @param {number} timeout\n   * @returns {Nanomessage}\n   */\n  setRequestTimeout (timeout) {\n    this[kTimeout] = timeout\n    return this\n  }\n\n  /**\n   * @param {({ incoming: number, outgoing: number }|number)} value\n   * @returns {Nanomessage}\n   */\n  setConcurrency (value) {\n    if (typeof value === 'number') {\n      this[kInQueue].concurrency = value\n      this[kOutQueue].concurrency = value\n    } else {\n      this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency\n      this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency\n    }\n    return this\n  }\n\n  /**\n   * Send a request and wait for the response.\n   *\n   * @param {*} data\n   * @param {Object} [opts]\n   * @param {number} [opts.timeout]\n   * @param {AbortSignal} [opts.signal]\n   * @returns {Promise<*>}\n   */\n  request (data, opts = {}) {\n    const request = new Request({ id: this[kIdGenerator].get(), data, timeout: opts.timeout || this[kTimeout], signal: opts.signal })\n    const info = request.info()\n\n    this[kRequests].set(request.id, request)\n    request.onFinish(() => {\n      this[kRequests].delete(request.id)\n      this[kIdGenerator].release(request.id)\n    })\n\n    this.emit('request-created', info)\n\n    this[kOutQueue].push(request, (err, data) => {\n      info.response = true\n      info.responseData = data\n      this.emit('request-ended', err, info)\n    })\n\n    return request.promise\n  }\n\n  /**\n   * Send a ephemeral message.\n   *\n   * @param {*} data\n   * @returns {Promise}\n   */\n  send (data) {\n    return this[kFastCheckOpen]()\n      .then(() => {\n        const info = Request.info({ id: 0, data })\n        return this._send(this[kCodec].encode(info), info)\n      })\n  }\n\n  /**\n   * @param {(data: Object, info: Object) => Promise<*>} onMessage\n   * @returns {Nanomessage}\n   */\n  setMessageHandler (onMessage) {\n    this._onMessage = onMessage\n    return this\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {undefined}\n   */\n  processIncomingMessage (buf) {\n    if (this.closed || this.closing) return\n\n    const info = Request.info(this[kCodec].decode(buf))\n\n    // resolve response\n    if (info.response) {\n      const request = this[kRequests].get(info.id)\n      if (request) request.resolve(info.data)\n      return\n    }\n\n    if (info.ephemeral) {\n      this.emit('request-received', info)\n      this[kFastCheckOpen]()\n        .then(() => this._onMessage(info.data, info))\n        .catch(err => {\n          const rErr = new NMSG_ERR_RESPONSE(err.message)\n          rErr.stack = err.stack || rErr.stack\n          this.emit('response-error', rErr, info)\n        })\n      return\n    }\n\n    info.response = true\n    this.emit('request-received', info)\n\n    this[kInQueue].push(info, err => {\n      if (err) {\n        const rErr = new NMSG_ERR_RESPONSE(err.message)\n        rErr.stack = err.stack || rErr.stack\n        this.emit('response-error', rErr, info)\n      }\n    })\n  }\n\n  /**\n   * @abstract\n   * @param {Buffer} buf\n   * @param {Object} info\n   * @returns {Promise|undefined}\n   */\n  async _send (buf, info) {\n    throw new Error('_send not implemented')\n  }\n\n  /**\n   * @abstract\n   * @param {Object} data\n   * @param {Object} info\n   * @returns {Promise<*>}\n   */\n  async _onMessage (data, info) {\n    throw new Error('_onMessage not implemented')\n  }\n\n  async _open () {\n    await (this[kOpen] && this[kOpen]())\n    this[kUnsubscribe] = this._subscribe && this._subscribe(this.processIncomingMessage.bind(this))\n  }\n\n  async _close () {\n    if (this[kUnsubscribe]) this[kUnsubscribe]()\n\n    const requestsToClose = []\n    this[kRequests].forEach(request => request.reject(new NMSG_ERR_CLOSE()))\n    this[kRequests].clear()\n\n    this[kInQueue] && this[kInQueue].kill()\n    this[kOutQueue] && this[kOutQueue].kill()\n\n    await (this[kClose] && this[kClose]())\n    await Promise.all(requestsToClose)\n  }\n\n  async [kFastCheckOpen] () {\n    if (this.closed || this.closing) throw new NMSG_ERR_CLOSE()\n    if (this.opening) return this.open()\n    if (!this.opened) throw new NMSG_ERR_NOT_OPEN()\n  }\n}\n\nvar nanomessage = Nanomessage\n\nexport default nanomessage;\nexport { nanomessage as __moduleExports };","start":1670465469532,"end":1670465471224,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoresource-promise@2.0.0/node_modules/nanoresource-promise/emitter.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/fastq@1.13.0/node_modules/fastq/queue.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/request.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/codec.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/errors.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/id-generator.js?commonjs-proxy\";\n\nconst { NanoresourcePromise } = require$$0\nconst fastq = require$$1\n\nconst Request = require$$2\nconst createCodec = require$$3\nconst { NMSG_ERR_CLOSE, NMSG_ERR_NOT_OPEN, NMSG_ERR_RESPONSE } = require$$4\nconst IdGenerator = require$$5\n\nconst kRequests = Symbol('nanomessage.requests')\nconst kInQueue = Symbol('nanomessage.inqueue')\nconst kOutQueue = Symbol('nanomessage.outqueue')\nconst kUnsubscribe = Symbol('nanomessage.unsubscribe')\nconst kOpen = Symbol('nanomessage.open')\nconst kClose = Symbol('nanomessage.close')\nconst kFastCheckOpen = Symbol('nanomessage.fastcheckopen')\nconst kTimeout = Symbol('nanomessage.timeout')\nconst kIdGenerator = Symbol('nanomessage.idgenerator')\nconst kCodec = Symbol('nanomessage.codec')\n\nfunction inWorker (info, done) {\n  this[kFastCheckOpen]()\n    .then(() => this._onMessage(info.data, info))\n    .then(data => {\n      if (this.closed || this.closing) return done()\n\n      info.responseData = data\n\n      return this._send(this[kCodec].encode({\n        id: info.id,\n        response: info.response,\n        data\n      }), info)\n    })\n    .then(() => done())\n    .catch(err => done(err))\n}\n\nfunction outWorker (request, done) {\n  const info = request.info()\n  this[kFastCheckOpen]()\n    .then(() => {\n      if (request.finished) return\n      request.start()\n      return this._send(this[kCodec].encode(info), info)\n    })\n    .then(() => {\n      if (request.finished) return\n      return request.promise\n    })\n    .then(data => done(null, data))\n    .catch(err => done(err))\n}\n\nclass Nanomessage extends NanoresourcePromise {\n  /**\n   * Creates an instance of Nanomessage.\n   * @param {Object} [opts={}]\n   * @param {(buf: Buffer, info: Object) => Promise|undefined} [opts.send]\n   * @param {function} [opts.subscribe]\n   * @param {(data: Object, info: Object) => Promise<*>} [opts.onMessage]\n   * @param {function} [opts.open]\n   * @param {function} [opts.close]\n   * @param {number} [opts.timeout]\n   * @param {Object} [opts.valueEncoding]\n   * @param {({ incoming: number, outgoing: number }|number)} [opts.concurrency]\n   * @memberof Nanomessage\n   */\n  constructor (opts = {}) {\n    super()\n\n    const { send, subscribe, onMessage, open, close, timeout, valueEncoding, concurrency = 256 } = opts\n\n    if (send) this._send = send\n    if (subscribe) this._subscribe = subscribe\n    if (onMessage) this.setMessageHandler(onMessage)\n    if (open) this[kOpen] = open\n    if (close) this[kClose] = close\n    this.setRequestTimeout(timeout)\n\n    this[kCodec] = createCodec(valueEncoding)\n\n    this[kInQueue] = fastq(this, inWorker, 1)\n    this[kOutQueue] = fastq(this, outWorker, 1)\n    this.setConcurrency(concurrency)\n\n    this[kRequests] = new Map()\n    this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1)\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get codec () {\n    return this[kCodec]\n  }\n\n  /**\n   * @readonly\n   * @type {Array<Request>}\n   */\n  get requests () {\n    return Array.from(this[kRequests].values())\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get inflightRequests () {\n    return this[kOutQueue].running()\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get requestTimeout () {\n    return this[kTimeout]\n  }\n\n  /**\n   * @readonly\n   * @type {Object}\n   */\n  get concurrency () {\n    return {\n      incoming: this[kInQueue].concurrency,\n      outgoing: this[kOutQueue].concurrency\n    }\n  }\n\n  /**\n   * @param {number} timeout\n   * @returns {Nanomessage}\n   */\n  setRequestTimeout (timeout) {\n    this[kTimeout] = timeout\n    return this\n  }\n\n  /**\n   * @param {({ incoming: number, outgoing: number }|number)} value\n   * @returns {Nanomessage}\n   */\n  setConcurrency (value) {\n    if (typeof value === 'number') {\n      this[kInQueue].concurrency = value\n      this[kOutQueue].concurrency = value\n    } else {\n      this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency\n      this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency\n    }\n    return this\n  }\n\n  /**\n   * Send a request and wait for the response.\n   *\n   * @param {*} data\n   * @param {Object} [opts]\n   * @param {number} [opts.timeout]\n   * @param {AbortSignal} [opts.signal]\n   * @returns {Promise<*>}\n   */\n  request (data, opts = {}) {\n    const request = new Request({ id: this[kIdGenerator].get(), data, timeout: opts.timeout || this[kTimeout], signal: opts.signal })\n    const info = request.info()\n\n    this[kRequests].set(request.id, request)\n    request.onFinish(() => {\n      this[kRequests].delete(request.id)\n      this[kIdGenerator].release(request.id)\n    })\n\n    this.emit('request-created', info)\n\n    this[kOutQueue].push(request, (err, data) => {\n      info.response = true\n      info.responseData = data\n      this.emit('request-ended', err, info)\n    })\n\n    return request.promise\n  }\n\n  /**\n   * Send a ephemeral message.\n   *\n   * @param {*} data\n   * @returns {Promise}\n   */\n  send (data) {\n    return this[kFastCheckOpen]()\n      .then(() => {\n        const info = Request.info({ id: 0, data })\n        return this._send(this[kCodec].encode(info), info)\n      })\n  }\n\n  /**\n   * @param {(data: Object, info: Object) => Promise<*>} onMessage\n   * @returns {Nanomessage}\n   */\n  setMessageHandler (onMessage) {\n    this._onMessage = onMessage\n    return this\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {undefined}\n   */\n  processIncomingMessage (buf) {\n    if (this.closed || this.closing) return\n\n    const info = Request.info(this[kCodec].decode(buf))\n\n    // resolve response\n    if (info.response) {\n      const request = this[kRequests].get(info.id)\n      if (request) request.resolve(info.data)\n      return\n    }\n\n    if (info.ephemeral) {\n      this.emit('request-received', info)\n      this[kFastCheckOpen]()\n        .then(() => this._onMessage(info.data, info))\n        .catch(err => {\n          const rErr = new NMSG_ERR_RESPONSE(err.message)\n          rErr.stack = err.stack || rErr.stack\n          this.emit('response-error', rErr, info)\n        })\n      return\n    }\n\n    info.response = true\n    this.emit('request-received', info)\n\n    this[kInQueue].push(info, err => {\n      if (err) {\n        const rErr = new NMSG_ERR_RESPONSE(err.message)\n        rErr.stack = err.stack || rErr.stack\n        this.emit('response-error', rErr, info)\n      }\n    })\n  }\n\n  /**\n   * @abstract\n   * @param {Buffer} buf\n   * @param {Object} info\n   * @returns {Promise|undefined}\n   */\n  async _send (buf, info) {\n    throw new Error('_send not implemented')\n  }\n\n  /**\n   * @abstract\n   * @param {Object} data\n   * @param {Object} info\n   * @returns {Promise<*>}\n   */\n  async _onMessage (data, info) {\n    throw new Error('_onMessage not implemented')\n  }\n\n  async _open () {\n    await (this[kOpen] && this[kOpen]())\n    this[kUnsubscribe] = this._subscribe && this._subscribe(this.processIncomingMessage.bind(this))\n  }\n\n  async _close () {\n    if (this[kUnsubscribe]) this[kUnsubscribe]()\n\n    const requestsToClose = []\n    this[kRequests].forEach(request => request.reject(new NMSG_ERR_CLOSE()))\n    this[kRequests].clear()\n\n    this[kInQueue] && this[kInQueue].kill()\n    this[kOutQueue] && this[kOutQueue].kill()\n\n    await (this[kClose] && this[kClose]())\n    await Promise.all(requestsToClose)\n  }\n\n  async [kFastCheckOpen] () {\n    if (this.closed || this.closing) throw new NMSG_ERR_CLOSE()\n    if (this.opening) return this.open()\n    if (!this.opened) throw new NMSG_ERR_NOT_OPEN()\n  }\n}\n\nvar nanomessage = Nanomessage\n\nexport default nanomessage;\nexport { nanomessage as __moduleExports };","start":1670465471224,"end":1670465471228,"order":"normal"}]}
