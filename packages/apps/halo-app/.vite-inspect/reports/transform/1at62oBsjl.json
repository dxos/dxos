{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sha512-wasm@2.3.4/node_modules/sha512-wasm/index.js","transforms":[{"name":"vite:load-fallback","result":"const assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst wasm = typeof WebAssembly !== 'undefined' && require('./sha512.js')({\n  imports: {\n    debug: {\n      log (...args) {\n        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')))\n      },\n      log_tee (arg) {\n        console.log((arg >>> 0).toString(16).padStart(8, '0'))\n        return arg\n      }\n    }\n  }\n})\n\nlet head = 0\n// assetrt head % 8 === 0 to guarantee alignment\nconst freeList = []\n\nmodule.exports = Sha512\nconst SHA512_BYTES = module.exports.SHA512_BYTES = 64\nconst INPUT_OFFSET = 80\nconst STATEBYTES = 216\nconst BLOCKSIZE = 128\n\nfunction Sha512 () {\n  if (!(this instanceof Sha512)) return new Sha512()\n  if (!(wasm)) throw new Error('WASM not loaded. Wait for Sha512.ready(cb)')\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += STATEBYTES\n  }\n\n  this.finalized = false\n  this.digestLength = SHA512_BYTES\n  this.pointer = freeList.pop()\n  this.pos = 0\n  this.wasm = wasm\n\n  this._memory = new Uint8Array(wasm.memory.buffer)\n  this._memory.fill(0, this.pointer, this.pointer + STATEBYTES)\n\n  if (this.pointer + this.digestLength > this._memory.length) this._realloc(this.pointer + STATEBYTES)\n}\n\nSha512.prototype._realloc = function (size) {\n  wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)))\n  this._memory = new Uint8Array(wasm.memory.buffer)\n}\n\nSha512.prototype.update = function (input, enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  if (head % 8 !== 0) head += 8 - head % 8\n  assert(head % 8 === 0, 'input should be aligned for int64')\n\n  const [inputBuf, length] = formatInput(input, enc)\n\n  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer')\n\n  if (head + input.length > this._memory.length) this._realloc(head + input.length)\n\n  this._memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE)\n  this._memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos)\n  this._memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head)\n\n  this.pos = (this.pos + length) & 0x7f\n  wasm.sha512(this.pointer, head, length, 0)\n\n  return this\n}\n\nSha512.prototype.digest = function (enc, offset = 0) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  this.finalized = true\n  freeList.push(this.pointer)\n\n  const paddingStart = this.pointer + INPUT_OFFSET + this.pos\n  this._memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE)\n  wasm.sha512(this.pointer, head, 0, 1)\n\n  const resultBuf = this._memory.subarray(this.pointer, this.pointer + this.digestLength)\n\n  if (!enc) {\n    return resultBuf\n  }\n\n  if (typeof enc === 'string') {\n    return b4a.toString(resultBuf, enc)\n  }\n\n  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer')\n  assert(enc.byteLength >= this.digestLength + offset,\n    \"output must have at least 'SHA512_BYTES' bytes remaining\")\n\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i + offset] = resultBuf[i]\n  }\n\n  return enc\n}\n\nSha512.WASM = wasm\nSha512.WASM_SUPPORTED = typeof WebAssembly !== 'undefined'\n\nSha512.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n  cb()\n  return Promise.resolve()\n}\n\nSha512.prototype.ready = Sha512.ready\n\nfunction HMAC (key) {\n  if (!(this instanceof HMAC)) return new HMAC(key)\n\n  this.pad = b4a.alloc(128)\n  this.inner = Sha512()\n  this.outer = Sha512()\n\n  const keyhash = b4a.alloc(64)\n  if (key.byteLength > 128) {\n    Sha512().update(key).digest(keyhash)\n    key = keyhash\n  }\n\n  this.pad.fill(0x36)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.inner.update(this.pad)\n\n  this.pad.fill(0x5c)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.outer.update(this.pad)\n\n  this.pad.fill(0)\n  keyhash.fill(0)\n}\n\nHMAC.prototype.update = function (input, enc) {\n  this.inner.update(input, enc)\n  return this\n}\n\nHMAC.prototype.digest = function (enc, offset = 0) {\n  this.outer.update(this.inner.digest())\n  return this.outer.digest(enc, offset)\n}\n\nSha512.HMAC = HMAC\n\nfunction noop () {}\n\nfunction formatInput (input, enc) {\n  var result = b4a.from(input, enc)\n\n  return [result, result.byteLength]\n}\n\n// only works for base that is power of 2\nfunction roundUp (n, base) {\n  return (n + base - 1) & -base\n}\n","start":1670465471238,"end":1670465471567},{"name":"vite:react-babel","result":"const assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst wasm = typeof WebAssembly !== 'undefined' && require('./sha512.js')({\n  imports: {\n    debug: {\n      log (...args) {\n        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')))\n      },\n      log_tee (arg) {\n        console.log((arg >>> 0).toString(16).padStart(8, '0'))\n        return arg\n      }\n    }\n  }\n})\n\nlet head = 0\n// assetrt head % 8 === 0 to guarantee alignment\nconst freeList = []\n\nmodule.exports = Sha512\nconst SHA512_BYTES = module.exports.SHA512_BYTES = 64\nconst INPUT_OFFSET = 80\nconst STATEBYTES = 216\nconst BLOCKSIZE = 128\n\nfunction Sha512 () {\n  if (!(this instanceof Sha512)) return new Sha512()\n  if (!(wasm)) throw new Error('WASM not loaded. Wait for Sha512.ready(cb)')\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += STATEBYTES\n  }\n\n  this.finalized = false\n  this.digestLength = SHA512_BYTES\n  this.pointer = freeList.pop()\n  this.pos = 0\n  this.wasm = wasm\n\n  this._memory = new Uint8Array(wasm.memory.buffer)\n  this._memory.fill(0, this.pointer, this.pointer + STATEBYTES)\n\n  if (this.pointer + this.digestLength > this._memory.length) this._realloc(this.pointer + STATEBYTES)\n}\n\nSha512.prototype._realloc = function (size) {\n  wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)))\n  this._memory = new Uint8Array(wasm.memory.buffer)\n}\n\nSha512.prototype.update = function (input, enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  if (head % 8 !== 0) head += 8 - head % 8\n  assert(head % 8 === 0, 'input should be aligned for int64')\n\n  const [inputBuf, length] = formatInput(input, enc)\n\n  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer')\n\n  if (head + input.length > this._memory.length) this._realloc(head + input.length)\n\n  this._memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE)\n  this._memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos)\n  this._memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head)\n\n  this.pos = (this.pos + length) & 0x7f\n  wasm.sha512(this.pointer, head, length, 0)\n\n  return this\n}\n\nSha512.prototype.digest = function (enc, offset = 0) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  this.finalized = true\n  freeList.push(this.pointer)\n\n  const paddingStart = this.pointer + INPUT_OFFSET + this.pos\n  this._memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE)\n  wasm.sha512(this.pointer, head, 0, 1)\n\n  const resultBuf = this._memory.subarray(this.pointer, this.pointer + this.digestLength)\n\n  if (!enc) {\n    return resultBuf\n  }\n\n  if (typeof enc === 'string') {\n    return b4a.toString(resultBuf, enc)\n  }\n\n  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer')\n  assert(enc.byteLength >= this.digestLength + offset,\n    \"output must have at least 'SHA512_BYTES' bytes remaining\")\n\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i + offset] = resultBuf[i]\n  }\n\n  return enc\n}\n\nSha512.WASM = wasm\nSha512.WASM_SUPPORTED = typeof WebAssembly !== 'undefined'\n\nSha512.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n  cb()\n  return Promise.resolve()\n}\n\nSha512.prototype.ready = Sha512.ready\n\nfunction HMAC (key) {\n  if (!(this instanceof HMAC)) return new HMAC(key)\n\n  this.pad = b4a.alloc(128)\n  this.inner = Sha512()\n  this.outer = Sha512()\n\n  const keyhash = b4a.alloc(64)\n  if (key.byteLength > 128) {\n    Sha512().update(key).digest(keyhash)\n    key = keyhash\n  }\n\n  this.pad.fill(0x36)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.inner.update(this.pad)\n\n  this.pad.fill(0x5c)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.outer.update(this.pad)\n\n  this.pad.fill(0)\n  keyhash.fill(0)\n}\n\nHMAC.prototype.update = function (input, enc) {\n  this.inner.update(input, enc)\n  return this\n}\n\nHMAC.prototype.digest = function (enc, offset = 0) {\n  this.outer.update(this.inner.digest())\n  return this.outer.digest(enc, offset)\n}\n\nSha512.HMAC = HMAC\n\nfunction noop () {}\n\nfunction formatInput (input, enc) {\n  var result = b4a.from(input, enc)\n\n  return [result, result.byteLength]\n}\n\n// only works for base that is power of 2\nfunction roundUp (n, base) {\n  return (n + base - 1) & -base\n}\n","start":1670465471567,"end":1670465471567,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as sha512WasmModule, exports as sha512Wasm } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sha512-wasm@2.3.4/node_modules/sha512-wasm/index.js?commonjs-module\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-proxy\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sha512-wasm@2.3.4/node_modules/sha512-wasm/sha512.js?commonjs-wrapped\";\n\nvar SHA512_BYTES_1;\nconst assert = require$$0\nconst b4a = require$$1\n\nconst wasm = typeof WebAssembly !== 'undefined' && require$$2()({\n  imports: {\n    debug: {\n      log (...args) {\n        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')))\n      },\n      log_tee (arg) {\n        console.log((arg >>> 0).toString(16).padStart(8, '0'))\n        return arg\n      }\n    }\n  }\n})\n\nlet head = 0\n// assetrt head % 8 === 0 to guarantee alignment\nconst freeList = []\n\nsha512WasmModule.exports = Sha512\nconst SHA512_BYTES = SHA512_BYTES_1 = sha512Wasm.SHA512_BYTES = 64\nconst INPUT_OFFSET = 80\nconst STATEBYTES = 216\nconst BLOCKSIZE = 128\n\nfunction Sha512 () {\n  if (!(this instanceof Sha512)) return new Sha512()\n  if (!(wasm)) throw new Error('WASM not loaded. Wait for Sha512.ready(cb)')\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += STATEBYTES\n  }\n\n  this.finalized = false\n  this.digestLength = SHA512_BYTES\n  this.pointer = freeList.pop()\n  this.pos = 0\n  this.wasm = wasm\n\n  this._memory = new Uint8Array(wasm.memory.buffer)\n  this._memory.fill(0, this.pointer, this.pointer + STATEBYTES)\n\n  if (this.pointer + this.digestLength > this._memory.length) this._realloc(this.pointer + STATEBYTES)\n}\n\nSha512.prototype._realloc = function (size) {\n  wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)))\n  this._memory = new Uint8Array(wasm.memory.buffer)\n}\n\nSha512.prototype.update = function (input, enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  if (head % 8 !== 0) head += 8 - head % 8\n  assert(head % 8 === 0, 'input should be aligned for int64')\n\n  const [inputBuf, length] = formatInput(input, enc)\n\n  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer')\n\n  if (head + input.length > this._memory.length) this._realloc(head + input.length)\n\n  this._memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE)\n  this._memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos)\n  this._memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head)\n\n  this.pos = (this.pos + length) & 0x7f\n  wasm.sha512(this.pointer, head, length, 0)\n\n  return this\n}\n\nSha512.prototype.digest = function (enc, offset = 0) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  this.finalized = true\n  freeList.push(this.pointer)\n\n  const paddingStart = this.pointer + INPUT_OFFSET + this.pos\n  this._memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE)\n  wasm.sha512(this.pointer, head, 0, 1)\n\n  const resultBuf = this._memory.subarray(this.pointer, this.pointer + this.digestLength)\n\n  if (!enc) {\n    return resultBuf\n  }\n\n  if (typeof enc === 'string') {\n    return b4a.toString(resultBuf, enc)\n  }\n\n  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer')\n  assert(enc.byteLength >= this.digestLength + offset,\n    \"output must have at least 'SHA512_BYTES' bytes remaining\")\n\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i + offset] = resultBuf[i]\n  }\n\n  return enc\n}\n\nSha512.WASM = wasm\nSha512.WASM_SUPPORTED = typeof WebAssembly !== 'undefined'\n\nSha512.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n  cb()\n  return Promise.resolve()\n}\n\nSha512.prototype.ready = Sha512.ready\n\nfunction HMAC (key) {\n  if (!(this instanceof HMAC)) return new HMAC(key)\n\n  this.pad = b4a.alloc(128)\n  this.inner = Sha512()\n  this.outer = Sha512()\n\n  const keyhash = b4a.alloc(64)\n  if (key.byteLength > 128) {\n    Sha512().update(key).digest(keyhash)\n    key = keyhash\n  }\n\n  this.pad.fill(0x36)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.inner.update(this.pad)\n\n  this.pad.fill(0x5c)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.outer.update(this.pad)\n\n  this.pad.fill(0)\n  keyhash.fill(0)\n}\n\nHMAC.prototype.update = function (input, enc) {\n  this.inner.update(input, enc)\n  return this\n}\n\nHMAC.prototype.digest = function (enc, offset = 0) {\n  this.outer.update(this.inner.digest())\n  return this.outer.digest(enc, offset)\n}\n\nSha512.HMAC = HMAC\n\nfunction noop () {}\n\nfunction formatInput (input, enc) {\n  var result = b4a.from(input, enc)\n\n  return [result, result.byteLength]\n}\n\n// only works for base that is power of 2\nfunction roundUp (n, base) {\n  return (n + base - 1) & -base\n}\n\nexport { sha512Wasm as __moduleExports, SHA512_BYTES_1 as SHA512_BYTES, sha512Wasm as default };","start":1670465471567,"end":1670465471677,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as sha512WasmModule, exports as sha512Wasm } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sha512-wasm@2.3.4/node_modules/sha512-wasm/index.js?commonjs-module\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-proxy\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sha512-wasm@2.3.4/node_modules/sha512-wasm/sha512.js?commonjs-wrapped\";\n\nvar SHA512_BYTES_1;\nconst assert = require$$0\nconst b4a = require$$1\n\nconst wasm = typeof WebAssembly !== 'undefined' && require$$2()({\n  imports: {\n    debug: {\n      log (...args) {\n        console.log(...args.map(int => (int >>> 0).toString(16).padStart(8, '0')))\n      },\n      log_tee (arg) {\n        console.log((arg >>> 0).toString(16).padStart(8, '0'))\n        return arg\n      }\n    }\n  }\n})\n\nlet head = 0\n// assetrt head % 8 === 0 to guarantee alignment\nconst freeList = []\n\nsha512WasmModule.exports = Sha512\nconst SHA512_BYTES = SHA512_BYTES_1 = sha512Wasm.SHA512_BYTES = 64\nconst INPUT_OFFSET = 80\nconst STATEBYTES = 216\nconst BLOCKSIZE = 128\n\nfunction Sha512 () {\n  if (!(this instanceof Sha512)) return new Sha512()\n  if (!(wasm)) throw new Error('WASM not loaded. Wait for Sha512.ready(cb)')\n\n  if (!freeList.length) {\n    freeList.push(head)\n    head += STATEBYTES\n  }\n\n  this.finalized = false\n  this.digestLength = SHA512_BYTES\n  this.pointer = freeList.pop()\n  this.pos = 0\n  this.wasm = wasm\n\n  this._memory = new Uint8Array(wasm.memory.buffer)\n  this._memory.fill(0, this.pointer, this.pointer + STATEBYTES)\n\n  if (this.pointer + this.digestLength > this._memory.length) this._realloc(this.pointer + STATEBYTES)\n}\n\nSha512.prototype._realloc = function (size) {\n  wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)))\n  this._memory = new Uint8Array(wasm.memory.buffer)\n}\n\nSha512.prototype.update = function (input, enc) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  if (head % 8 !== 0) head += 8 - head % 8\n  assert(head % 8 === 0, 'input should be aligned for int64')\n\n  const [inputBuf, length] = formatInput(input, enc)\n\n  assert(inputBuf instanceof Uint8Array, 'input must be Uint8Array or Buffer')\n\n  if (head + input.length > this._memory.length) this._realloc(head + input.length)\n\n  this._memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE)\n  this._memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos)\n  this._memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head)\n\n  this.pos = (this.pos + length) & 0x7f\n  wasm.sha512(this.pointer, head, length, 0)\n\n  return this\n}\n\nSha512.prototype.digest = function (enc, offset = 0) {\n  assert(this.finalized === false, 'Hash instance finalized')\n\n  this.finalized = true\n  freeList.push(this.pointer)\n\n  const paddingStart = this.pointer + INPUT_OFFSET + this.pos\n  this._memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE)\n  wasm.sha512(this.pointer, head, 0, 1)\n\n  const resultBuf = this._memory.subarray(this.pointer, this.pointer + this.digestLength)\n\n  if (!enc) {\n    return resultBuf\n  }\n\n  if (typeof enc === 'string') {\n    return b4a.toString(resultBuf, enc)\n  }\n\n  assert(enc instanceof Uint8Array, 'output must be Uint8Array or Buffer')\n  assert(enc.byteLength >= this.digestLength + offset,\n    \"output must have at least 'SHA512_BYTES' bytes remaining\")\n\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i + offset] = resultBuf[i]\n  }\n\n  return enc\n}\n\nSha512.WASM = wasm\nSha512.WASM_SUPPORTED = typeof WebAssembly !== 'undefined'\n\nSha512.ready = function (cb) {\n  if (!cb) cb = noop\n  if (!wasm) return cb(new Error('WebAssembly not supported'))\n  cb()\n  return Promise.resolve()\n}\n\nSha512.prototype.ready = Sha512.ready\n\nfunction HMAC (key) {\n  if (!(this instanceof HMAC)) return new HMAC(key)\n\n  this.pad = b4a.alloc(128)\n  this.inner = Sha512()\n  this.outer = Sha512()\n\n  const keyhash = b4a.alloc(64)\n  if (key.byteLength > 128) {\n    Sha512().update(key).digest(keyhash)\n    key = keyhash\n  }\n\n  this.pad.fill(0x36)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.inner.update(this.pad)\n\n  this.pad.fill(0x5c)\n  for (let i = 0; i < key.byteLength; i++) {\n    this.pad[i] ^= key[i]\n  }\n  this.outer.update(this.pad)\n\n  this.pad.fill(0)\n  keyhash.fill(0)\n}\n\nHMAC.prototype.update = function (input, enc) {\n  this.inner.update(input, enc)\n  return this\n}\n\nHMAC.prototype.digest = function (enc, offset = 0) {\n  this.outer.update(this.inner.digest())\n  return this.outer.digest(enc, offset)\n}\n\nSha512.HMAC = HMAC\n\nfunction noop () {}\n\nfunction formatInput (input, enc) {\n  var result = b4a.from(input, enc)\n\n  return [result, result.byteLength]\n}\n\n// only works for base that is power of 2\nfunction roundUp (n, base) {\n  return (n + base - 1) & -base\n}\n\nexport { sha512Wasm as __moduleExports, SHA512_BYTES_1 as SHA512_BYTES, sha512Wasm as default };","start":1670465471678,"end":1670465471680,"order":"normal"}]}
