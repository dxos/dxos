{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/@radix-ui+react-roving-focus@1.0.1_biqbaboplfbrettd7655fr4n2y/node_modules/@radix-ui/react-roving-focus/dist/index.module.js","transforms":[{"name":"vite:load-fallback","result":"import $98Iye$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport {forwardRef as $98Iye$forwardRef, createElement as $98Iye$createElement, useRef as $98Iye$useRef, useState as $98Iye$useState, useEffect as $98Iye$useEffect, useCallback as $98Iye$useCallback} from \"react\";\nimport {composeEventHandlers as $98Iye$composeEventHandlers} from \"@radix-ui/primitive\";\nimport {createCollection as $98Iye$createCollection} from \"@radix-ui/react-collection\";\nimport {useComposedRefs as $98Iye$useComposedRefs} from \"@radix-ui/react-compose-refs\";\nimport {createContextScope as $98Iye$createContextScope} from \"@radix-ui/react-context\";\nimport {useId as $98Iye$useId} from \"@radix-ui/react-id\";\nimport {Primitive as $98Iye$Primitive} from \"@radix-ui/react-primitive\";\nimport {useCallbackRef as $98Iye$useCallbackRef} from \"@radix-ui/react-use-callback-ref\";\nimport {useControllableState as $98Iye$useControllableState} from \"@radix-ui/react-use-controllable-state\";\nimport {useDirection as $98Iye$useDirection} from \"@radix-ui/react-direction\";\n\n\n\n\n\n\n\n\n\n\n\n\nconst $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {\n    bubbles: false,\n    cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$GROUP_NAME = 'RovingFocusGroup';\nconst [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $98Iye$createCollection($d7bdfb9eb0fdf311$var$GROUP_NAME);\nconst [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $98Iye$createContextScope($d7bdfb9eb0fdf311$var$GROUP_NAME, [\n    $d7bdfb9eb0fdf311$var$createCollectionScope\n]);\nconst [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);\nconst $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {\n        scope: props.__scopeRovingFocusGroup\n    }, /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {\n        scope: props.__scopeRovingFocusGroup\n    }, /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, $98Iye$babelruntimehelpersesmextends({}, props, {\n        ref: forwardedRef\n    }))));\n});\n/*#__PURE__*/ Object.assign($d7bdfb9eb0fdf311$export$8699f7c8af148338, {\n    displayName: $d7bdfb9eb0fdf311$var$GROUP_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , orientation: orientation , loop: loop = false , dir: dir , currentTabStopId: currentTabStopIdProp , defaultCurrentTabStopId: defaultCurrentTabStopId , onCurrentTabStopIdChange: onCurrentTabStopIdChange , onEntryFocus: onEntryFocus , ...groupProps } = props;\n    const ref = $98Iye$useRef(null);\n    const composedRefs = $98Iye$useComposedRefs(forwardedRef, ref);\n    const direction = $98Iye$useDirection(dir);\n    const [currentTabStopId = null, setCurrentTabStopId] = $98Iye$useControllableState({\n        prop: currentTabStopIdProp,\n        defaultProp: defaultCurrentTabStopId,\n        onChange: onCurrentTabStopIdChange\n    });\n    const [isTabbingBackOut, setIsTabbingBackOut] = $98Iye$useState(false);\n    const handleEntryFocus = $98Iye$useCallbackRef(onEntryFocus);\n    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n    const isClickFocusRef = $98Iye$useRef(false);\n    const [focusableItemsCount, setFocusableItemsCount] = $98Iye$useState(0);\n    $98Iye$useEffect(()=>{\n        const node = ref.current;\n        if (node) {\n            node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n            return ()=>node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus)\n            ;\n        }\n    }, [\n        handleEntryFocus\n    ]);\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {\n        scope: __scopeRovingFocusGroup,\n        orientation: orientation,\n        dir: direction,\n        loop: loop,\n        currentTabStopId: currentTabStopId,\n        onItemFocus: $98Iye$useCallback((tabStopId)=>setCurrentTabStopId(tabStopId)\n        , [\n            setCurrentTabStopId\n        ]),\n        onItemShiftTab: $98Iye$useCallback(()=>setIsTabbingBackOut(true)\n        , []),\n        onFocusableItemAdd: $98Iye$useCallback(()=>setFocusableItemsCount((prevCount)=>prevCount + 1\n            )\n        , []),\n        onFocusableItemRemove: $98Iye$useCallback(()=>setFocusableItemsCount((prevCount)=>prevCount - 1\n            )\n        , [])\n    }, /*#__PURE__*/ $98Iye$createElement($98Iye$Primitive.div, $98Iye$babelruntimehelpersesmextends({\n        tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n        \"data-orientation\": orientation\n    }, groupProps, {\n        ref: composedRefs,\n        style: {\n            outline: 'none',\n            ...props.style\n        },\n        onMouseDown: $98Iye$composeEventHandlers(props.onMouseDown, ()=>{\n            isClickFocusRef.current = true;\n        }),\n        onFocus: $98Iye$composeEventHandlers(props.onFocus, (event)=>{\n            // We normally wouldn't need this check, because we already check\n            // that the focus is on the current target and not bubbling to it.\n            // We do this because Safari doesn't focus buttons when clicked, and\n            // instead, the wrapper will get focused and not through a bubbling event.\n            const isKeyboardFocus = !isClickFocusRef.current;\n            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n                const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);\n                event.currentTarget.dispatchEvent(entryFocusEvent);\n                if (!entryFocusEvent.defaultPrevented) {\n                    const items = getItems().filter((item)=>item.focusable\n                    );\n                    const activeItem = items.find((item)=>item.active\n                    );\n                    const currentItem = items.find((item)=>item.id === currentTabStopId\n                    );\n                    const candidateItems = [\n                        activeItem,\n                        currentItem,\n                        ...items\n                    ].filter(Boolean);\n                    const candidateNodes = candidateItems.map((item)=>item.ref.current\n                    );\n                    $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);\n                }\n            }\n            isClickFocusRef.current = false;\n        }),\n        onBlur: $98Iye$composeEventHandlers(props.onBlur, ()=>setIsTabbingBackOut(false)\n        )\n    })));\n});\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$ITEM_NAME = 'RovingFocusGroupItem';\nconst $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , focusable: focusable = true , active: active = false , ...itemProps } = props;\n    const id = $98Iye$useId();\n    const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n    const { onFocusableItemAdd: onFocusableItemAdd , onFocusableItemRemove: onFocusableItemRemove  } = context;\n    $98Iye$useEffect(()=>{\n        if (focusable) {\n            onFocusableItemAdd();\n            return ()=>onFocusableItemRemove()\n            ;\n        }\n    }, [\n        focusable,\n        onFocusableItemAdd,\n        onFocusableItemRemove\n    ]);\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {\n        scope: __scopeRovingFocusGroup,\n        id: id,\n        focusable: focusable,\n        active: active\n    }, /*#__PURE__*/ $98Iye$createElement($98Iye$Primitive.span, $98Iye$babelruntimehelpersesmextends({\n        tabIndex: isCurrentTabStop ? 0 : -1,\n        \"data-orientation\": context.orientation\n    }, itemProps, {\n        ref: forwardedRef,\n        onMouseDown: $98Iye$composeEventHandlers(props.onMouseDown, (event)=>{\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault(); // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n        }),\n        onFocus: $98Iye$composeEventHandlers(props.onFocus, ()=>context.onItemFocus(id)\n        ),\n        onKeyDown: $98Iye$composeEventHandlers(props.onKeyDown, (event)=>{\n            if (event.key === 'Tab' && event.shiftKey) {\n                context.onItemShiftTab();\n                return;\n            }\n            if (event.target !== event.currentTarget) return;\n            const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);\n            if (focusIntent !== undefined) {\n                event.preventDefault();\n                const items = getItems().filter((item)=>item.focusable\n                );\n                let candidateNodes = items.map((item)=>item.ref.current\n                );\n                if (focusIntent === 'last') candidateNodes.reverse();\n                else if (focusIntent === 'prev' || focusIntent === 'next') {\n                    if (focusIntent === 'prev') candidateNodes.reverse();\n                    const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                    candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n                }\n                /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */ setTimeout(()=>$d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)\n                );\n            }\n        })\n    })));\n});\n/*#__PURE__*/ Object.assign($d7bdfb9eb0fdf311$export$ab9df7c53fe8454, {\n    displayName: $d7bdfb9eb0fdf311$var$ITEM_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/ // prettier-ignore\nconst $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {\n    ArrowLeft: 'prev',\n    ArrowUp: 'prev',\n    ArrowRight: 'next',\n    ArrowDown: 'next',\n    PageUp: 'first',\n    Home: 'first',\n    PageDown: 'last',\n    End: 'last'\n};\nfunction $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {\n    if (dir !== 'rtl') return key;\n    return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\nfunction $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {\n    const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);\n    if (orientation === 'vertical' && [\n        'ArrowLeft',\n        'ArrowRight'\n    ].includes(key)) return undefined;\n    if (orientation === 'horizontal' && [\n        'ArrowUp',\n        'ArrowDown'\n    ].includes(key)) return undefined;\n    return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction $d7bdfb9eb0fdf311$var$focusFirst(candidates) {\n    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n    for (const candidate of candidates){\n        // if focus is already where we want to go, we don't want to keep going through the candidates\n        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n        candidate.focus();\n        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n    }\n}\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */ function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {\n    return array.map((_, index)=>array[(startIndex + index) % array.length]\n    );\n}\nconst $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;\nconst $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;\n\n\n\n\nexport {$d7bdfb9eb0fdf311$export$c7109489551a4f4 as createRovingFocusGroupScope, $d7bdfb9eb0fdf311$export$8699f7c8af148338 as RovingFocusGroup, $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 as RovingFocusGroupItem, $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 as Root, $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 as Item};\n//# sourceMappingURL=index.module.js.map\n","start":1670465466454,"end":1670465466570},{"name":"vite:react-babel","result":"import $98Iye$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport {forwardRef as $98Iye$forwardRef, createElement as $98Iye$createElement, useRef as $98Iye$useRef, useState as $98Iye$useState, useEffect as $98Iye$useEffect, useCallback as $98Iye$useCallback} from \"react\";\nimport {composeEventHandlers as $98Iye$composeEventHandlers} from \"@radix-ui/primitive\";\nimport {createCollection as $98Iye$createCollection} from \"@radix-ui/react-collection\";\nimport {useComposedRefs as $98Iye$useComposedRefs} from \"@radix-ui/react-compose-refs\";\nimport {createContextScope as $98Iye$createContextScope} from \"@radix-ui/react-context\";\nimport {useId as $98Iye$useId} from \"@radix-ui/react-id\";\nimport {Primitive as $98Iye$Primitive} from \"@radix-ui/react-primitive\";\nimport {useCallbackRef as $98Iye$useCallbackRef} from \"@radix-ui/react-use-callback-ref\";\nimport {useControllableState as $98Iye$useControllableState} from \"@radix-ui/react-use-controllable-state\";\nimport {useDirection as $98Iye$useDirection} from \"@radix-ui/react-direction\";\n\n\n\n\n\n\n\n\n\n\n\n\nconst $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {\n    bubbles: false,\n    cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$GROUP_NAME = 'RovingFocusGroup';\nconst [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $98Iye$createCollection($d7bdfb9eb0fdf311$var$GROUP_NAME);\nconst [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $98Iye$createContextScope($d7bdfb9eb0fdf311$var$GROUP_NAME, [\n    $d7bdfb9eb0fdf311$var$createCollectionScope\n]);\nconst [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);\nconst $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {\n        scope: props.__scopeRovingFocusGroup\n    }, /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {\n        scope: props.__scopeRovingFocusGroup\n    }, /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, $98Iye$babelruntimehelpersesmextends({}, props, {\n        ref: forwardedRef\n    }))));\n});\n/*#__PURE__*/ Object.assign($d7bdfb9eb0fdf311$export$8699f7c8af148338, {\n    displayName: $d7bdfb9eb0fdf311$var$GROUP_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , orientation: orientation , loop: loop = false , dir: dir , currentTabStopId: currentTabStopIdProp , defaultCurrentTabStopId: defaultCurrentTabStopId , onCurrentTabStopIdChange: onCurrentTabStopIdChange , onEntryFocus: onEntryFocus , ...groupProps } = props;\n    const ref = $98Iye$useRef(null);\n    const composedRefs = $98Iye$useComposedRefs(forwardedRef, ref);\n    const direction = $98Iye$useDirection(dir);\n    const [currentTabStopId = null, setCurrentTabStopId] = $98Iye$useControllableState({\n        prop: currentTabStopIdProp,\n        defaultProp: defaultCurrentTabStopId,\n        onChange: onCurrentTabStopIdChange\n    });\n    const [isTabbingBackOut, setIsTabbingBackOut] = $98Iye$useState(false);\n    const handleEntryFocus = $98Iye$useCallbackRef(onEntryFocus);\n    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n    const isClickFocusRef = $98Iye$useRef(false);\n    const [focusableItemsCount, setFocusableItemsCount] = $98Iye$useState(0);\n    $98Iye$useEffect(()=>{\n        const node = ref.current;\n        if (node) {\n            node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);\n            return ()=>node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus)\n            ;\n        }\n    }, [\n        handleEntryFocus\n    ]);\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {\n        scope: __scopeRovingFocusGroup,\n        orientation: orientation,\n        dir: direction,\n        loop: loop,\n        currentTabStopId: currentTabStopId,\n        onItemFocus: $98Iye$useCallback((tabStopId)=>setCurrentTabStopId(tabStopId)\n        , [\n            setCurrentTabStopId\n        ]),\n        onItemShiftTab: $98Iye$useCallback(()=>setIsTabbingBackOut(true)\n        , []),\n        onFocusableItemAdd: $98Iye$useCallback(()=>setFocusableItemsCount((prevCount)=>prevCount + 1\n            )\n        , []),\n        onFocusableItemRemove: $98Iye$useCallback(()=>setFocusableItemsCount((prevCount)=>prevCount - 1\n            )\n        , [])\n    }, /*#__PURE__*/ $98Iye$createElement($98Iye$Primitive.div, $98Iye$babelruntimehelpersesmextends({\n        tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n        \"data-orientation\": orientation\n    }, groupProps, {\n        ref: composedRefs,\n        style: {\n            outline: 'none',\n            ...props.style\n        },\n        onMouseDown: $98Iye$composeEventHandlers(props.onMouseDown, ()=>{\n            isClickFocusRef.current = true;\n        }),\n        onFocus: $98Iye$composeEventHandlers(props.onFocus, (event)=>{\n            // We normally wouldn't need this check, because we already check\n            // that the focus is on the current target and not bubbling to it.\n            // We do this because Safari doesn't focus buttons when clicked, and\n            // instead, the wrapper will get focused and not through a bubbling event.\n            const isKeyboardFocus = !isClickFocusRef.current;\n            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n                const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);\n                event.currentTarget.dispatchEvent(entryFocusEvent);\n                if (!entryFocusEvent.defaultPrevented) {\n                    const items = getItems().filter((item)=>item.focusable\n                    );\n                    const activeItem = items.find((item)=>item.active\n                    );\n                    const currentItem = items.find((item)=>item.id === currentTabStopId\n                    );\n                    const candidateItems = [\n                        activeItem,\n                        currentItem,\n                        ...items\n                    ].filter(Boolean);\n                    const candidateNodes = candidateItems.map((item)=>item.ref.current\n                    );\n                    $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);\n                }\n            }\n            isClickFocusRef.current = false;\n        }),\n        onBlur: $98Iye$composeEventHandlers(props.onBlur, ()=>setIsTabbingBackOut(false)\n        )\n    })));\n});\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$ITEM_NAME = 'RovingFocusGroupItem';\nconst $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /*#__PURE__*/ $98Iye$forwardRef((props, forwardedRef)=>{\n    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , focusable: focusable = true , active: active = false , ...itemProps } = props;\n    const id = $98Iye$useId();\n    const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);\n    const { onFocusableItemAdd: onFocusableItemAdd , onFocusableItemRemove: onFocusableItemRemove  } = context;\n    $98Iye$useEffect(()=>{\n        if (focusable) {\n            onFocusableItemAdd();\n            return ()=>onFocusableItemRemove()\n            ;\n        }\n    }, [\n        focusable,\n        onFocusableItemAdd,\n        onFocusableItemRemove\n    ]);\n    return /*#__PURE__*/ $98Iye$createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {\n        scope: __scopeRovingFocusGroup,\n        id: id,\n        focusable: focusable,\n        active: active\n    }, /*#__PURE__*/ $98Iye$createElement($98Iye$Primitive.span, $98Iye$babelruntimehelpersesmextends({\n        tabIndex: isCurrentTabStop ? 0 : -1,\n        \"data-orientation\": context.orientation\n    }, itemProps, {\n        ref: forwardedRef,\n        onMouseDown: $98Iye$composeEventHandlers(props.onMouseDown, (event)=>{\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault(); // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n        }),\n        onFocus: $98Iye$composeEventHandlers(props.onFocus, ()=>context.onItemFocus(id)\n        ),\n        onKeyDown: $98Iye$composeEventHandlers(props.onKeyDown, (event)=>{\n            if (event.key === 'Tab' && event.shiftKey) {\n                context.onItemShiftTab();\n                return;\n            }\n            if (event.target !== event.currentTarget) return;\n            const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);\n            if (focusIntent !== undefined) {\n                event.preventDefault();\n                const items = getItems().filter((item)=>item.focusable\n                );\n                let candidateNodes = items.map((item)=>item.ref.current\n                );\n                if (focusIntent === 'last') candidateNodes.reverse();\n                else if (focusIntent === 'prev' || focusIntent === 'next') {\n                    if (focusIntent === 'prev') candidateNodes.reverse();\n                    const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                    candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n                }\n                /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */ setTimeout(()=>$d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)\n                );\n            }\n        })\n    })));\n});\n/*#__PURE__*/ Object.assign($d7bdfb9eb0fdf311$export$ab9df7c53fe8454, {\n    displayName: $d7bdfb9eb0fdf311$var$ITEM_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/ // prettier-ignore\nconst $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {\n    ArrowLeft: 'prev',\n    ArrowUp: 'prev',\n    ArrowRight: 'next',\n    ArrowDown: 'next',\n    PageUp: 'first',\n    Home: 'first',\n    PageDown: 'last',\n    End: 'last'\n};\nfunction $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {\n    if (dir !== 'rtl') return key;\n    return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\nfunction $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {\n    const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);\n    if (orientation === 'vertical' && [\n        'ArrowLeft',\n        'ArrowRight'\n    ].includes(key)) return undefined;\n    if (orientation === 'horizontal' && [\n        'ArrowUp',\n        'ArrowDown'\n    ].includes(key)) return undefined;\n    return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction $d7bdfb9eb0fdf311$var$focusFirst(candidates) {\n    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n    for (const candidate of candidates){\n        // if focus is already where we want to go, we don't want to keep going through the candidates\n        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n        candidate.focus();\n        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n    }\n}\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */ function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {\n    return array.map((_, index)=>array[(startIndex + index) % array.length]\n    );\n}\nconst $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;\nconst $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;\n\n\n\n\nexport {$d7bdfb9eb0fdf311$export$c7109489551a4f4 as createRovingFocusGroupScope, $d7bdfb9eb0fdf311$export$8699f7c8af148338 as RovingFocusGroup, $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 as RovingFocusGroupItem, $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 as Root, $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 as Item};\n//# sourceMappingURL=index.module.js.map\n","start":1670465466570,"end":1670465466570,"order":"pre"}]}
