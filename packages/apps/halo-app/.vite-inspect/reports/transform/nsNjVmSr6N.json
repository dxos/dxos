{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/sdk/client-services/src/packlets/deprecated/space.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { todo } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { humanize } from \"@dxos/util\";\nvar SpaceServiceImpl = class {\n  constructor(serviceContext) {\n    this.serviceContext = serviceContext;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeToSpace(request) {\n    return new Stream(({ next }) => {\n      next({\n        space: {\n          publicKey: request.spaceKey,\n          isOpen: true,\n          isActive: true,\n          members: []\n        }\n      });\n    });\n  }\n  subscribeSpaces() {\n    return new Stream(({ next }) => {\n      const subscriptions = new EventSubscriptions();\n      const onUpdate = () => {\n        const spaces = Array.from(this.serviceContext.spaceManager.spaces.values()).map((space) => ({\n          publicKey: space.key,\n          isOpen: true,\n          isActive: true,\n          members: Array.from(space.spaceState.members.values()).map((member) => {\n            var _a, _b;\n            return {\n              identityKey: member.key,\n              profile: {\n                identityKey: member.key,\n                displayName: (_b = (_a = member.assertion.profile) == null ? void 0 : _a.displayName) != null ? _b : humanize(member.key)\n              }\n            };\n          })\n        }));\n        log(\"update\", {\n          spaces\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/deprecated/space.ts\",\n          line: 114,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        next({\n          spaces\n        });\n      };\n      setTimeout(async () => {\n        if (!this.serviceContext.spaceManager) {\n          next({\n            spaces: []\n          });\n        }\n        await this.serviceContext.initialized.wait();\n        subscriptions.add(this.serviceContext.spaceManager.updated.on(() => {\n          this.serviceContext.spaceManager.spaces.forEach((space) => {\n            subscriptions.add(space.stateUpdate.on(onUpdate));\n          });\n          onUpdate();\n        }));\n        this.serviceContext.spaceManager.spaces.forEach((space) => {\n          subscriptions.add(space.stateUpdate.on(onUpdate));\n        });\n        onUpdate();\n      });\n      return () => subscriptions.clear();\n    });\n  }\n  async getSpaceDetails(request) {\n    return todo();\n  }\n  async createSpace() {\n    await this.serviceContext.initialized.wait();\n    const space = await this.serviceContext.spaceManager.createSpace();\n    return {\n      publicKey: space.key,\n      isOpen: true,\n      isActive: true\n    };\n  }\n  async cloneSpace(snapshot) {\n    return todo();\n  }\n  async setSpaceState(request) {\n    return todo();\n  }\n  async authenticateInvitation(request) {\n    var _a;\n    assert(request.processId, \"Process ID is missing.\");\n    const invitation = this.inviteeInvitations.get(request.processId);\n    assert(invitation, \"Invitation not found.\");\n    assert(request.secret, \"Secret not provided.\");\n    invitation.secret = request.secret;\n    (_a = invitation.secretTrigger) == null ? void 0 : _a.call(invitation);\n  }\n  subscribeMembers(request) {\n    return todo();\n  }\n  async createSnapshot(request) {\n    return todo();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/profile.ts\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { todo as todo2 } from \"@dxos/debug\";\nvar ProfileServiceImpl = class {\n  constructor(context) {\n    this.context = context;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeProfile() {\n    return new Stream2(({ next }) => {\n      const emitNext = () => {\n        var _a;\n        return next({\n          profile: this.context.identityManager.identity ? {\n            identityKey: this.context.identityManager.identity.identityKey,\n            deviceKey: this.context.identityManager.identity.deviceKey,\n            displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n          } : void 0\n        });\n      };\n      emitNext();\n      return this.context.identityManager.stateUpdate.on(emitNext);\n    });\n  }\n  async createProfile(request) {\n    var _a;\n    await this.context.createIdentity({\n      displayName: request.displayName\n    });\n    return {\n      identityKey: this.context.identityManager.identity.identityKey,\n      deviceKey: this.context.identityManager.identity.deviceKey,\n      displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n    };\n  }\n  async recoverProfile(request) {\n    return todo2();\n    if (!request.seedPhrase) {\n      throw new Error(\"Recovery SeedPhrase not provided.\");\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/system.ts\nvar SystemServiceImpl = class {\n  constructor(_config, _serviceContext) {\n    this._config = _config;\n    this._serviceContext = _serviceContext;\n  }\n  async initSession() {\n  }\n  async getConfig(request) {\n    return this._config.values;\n  }\n  async getStatus(request) {\n    return {\n      message: `ok: ${Date.now()}`\n    };\n  }\n  async reset(request) {\n    await this._serviceContext.reset();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/tracing.ts\nvar TracingServiceImpl = class {\n  constructor(_config) {\n    this._config = _config;\n  }\n  async setTracingOptions() {\n    throw new Error(\"Tracing not available.\");\n  }\n  subscribeToRpcTrace() {\n    throw new Error(\"Tracing not available.\");\n  }\n};\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nimport { Event as AsyncEvent } from \"@dxos/async\";\nimport { Stream as Stream7 } from \"@dxos/codec-protobuf\";\n\n// packages/sdk/client-services/src/packlets/devtools/feeds.ts\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\nimport { Stream as Stream3 } from \"@dxos/codec-protobuf\";\nimport { FeedIterator } from \"@dxos/feed-store\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar subscribeToFeeds = ({ feedStore }, { feedKeys }) => new Stream3(({ next }) => {\n  if ((feedKeys == null ? void 0 : feedKeys.length) === 0) {\n    return;\n  }\n  const feedMap = new ComplexMap(PublicKey.hash);\n  const subscriptions = new EventSubscriptions2();\n  const update = () => {\n    const feeds = feedStore.feeds;\n    feeds.filter((feed) => !(feedKeys == null ? void 0 : feedKeys.length) || feedKeys.some((feedKey) => feedKey.equals(feed.key))).forEach((feed) => {\n      if (!feedMap.has(feed.key)) {\n        feedMap.set(feed.key, feed);\n        feed.on(\"close\", update);\n        subscriptions.add(feed.off(\"close\", update));\n      }\n    });\n    next({\n      feeds: Array.from(feedMap.values()).map((feed) => ({\n        feedKey: feed.key,\n        length: feed.properties.length\n      }))\n    });\n  };\n  subscriptions.add(feedStore.feedOpened.on(update));\n  update();\n  return () => {\n    subscriptions.clear();\n  };\n});\nvar subscribeToFeedBlocks = ({ feedStore }, { feedKey, maxBlocks = 10 }) => new Stream3(({ next }) => {\n  if (!feedKey) {\n    return;\n  }\n  const subscriptions = new EventSubscriptions2();\n  const timeout = setTimeout(async () => {\n    const feed = feedStore.getFeed(feedKey);\n    if (!feed) {\n      return;\n    }\n    const update = async () => {\n      const iterator = new FeedIterator(feed);\n      await iterator.open();\n      const blocks = [];\n      for await (const block of iterator) {\n        blocks.push(block);\n        if (blocks.length >= feed.properties.length) {\n          break;\n        }\n      }\n      next({\n        blocks: blocks.slice(-maxBlocks)\n      });\n      await iterator.close();\n    };\n    feed.on(\"append\", update);\n    subscriptions.add(() => feed.off(\"append\", update));\n    feed.on(\"truncate\", update);\n    subscriptions.add(() => feed.off(\"truncate\", update));\n    await update();\n  });\n  return () => {\n    subscriptions.clear();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/keys.ts\nimport { Stream as Stream4 } from \"@dxos/codec-protobuf\";\nvar subscribeToKeyringKeys = ({ keyring }) => new Stream4(({ next }) => {\n  const update = () => {\n    next({\n      keys: keyring.list()\n    });\n  };\n  const unsubscribe = keyring.keysUpdate.on(update);\n  update();\n  return unsubscribe;\n});\n\n// packages/sdk/client-services/src/packlets/devtools/network.ts\nimport { Stream as Stream5 } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar subscribeToNetworkStatus = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const status = networkManager.signalManager.getStatus();\n      next({\n        servers: status\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.signalManager.statusChanged.on(update);\n  update();\n});\nvar subscribeToSignalTrace = ({ networkManager }) => new Stream5(({ next }) => {\n  next({\n    events: []\n  });\n  const trace = [];\n  networkManager.signalManager.commandTrace.on((msg) => {\n    trace.push(msg);\n    next({\n      events: trace.map((msg2) => JSON.stringify(msg2))\n    });\n  });\n});\nvar subscribeToNetworkTopics = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const topics = networkManager.topics;\n      const labeledTopics = topics.map((topic) => {\n        var _a, _b;\n        return {\n          topic,\n          label: (_b = (_a = networkManager.getSwarm(topic)) == null ? void 0 : _a.label) != null ? _b : topic.toHex()\n        };\n      });\n      next({\n        topics: labeledTopics\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.topicsUpdated.on(update);\n  update();\n});\nvar subscribeToSwarmInfo = ({ networkManager }) => new Stream5(({ next }) => {\n  var _a;\n  const update = () => {\n    var _a2;\n    const info = (_a2 = networkManager.connectionLog) == null ? void 0 : _a2.swarms;\n    if (info) {\n      next({\n        data: info\n      });\n    }\n  };\n  (_a = networkManager.connectionLog) == null ? void 0 : _a.update.on(update);\n  update();\n});\nvar getNetworkPeers = ({ networkManager }, request) => {\n  if (!request.topic) {\n    throw new Error(\"Expected a network topic\");\n  }\n  const map = networkManager.getSwarmMap(PublicKey2.from(request.topic));\n  return {\n    peers: map == null ? void 0 : map.peers.map((peer) => ({\n      ...peer,\n      connections: peer.connections.map((connection) => connection.asUint8Array())\n    }))\n  };\n};\n\n// packages/sdk/client-services/src/packlets/devtools/spaces.ts\nimport { Stream as Stream6 } from \"@dxos/codec-protobuf\";\nvar subscribeToSpaces = (context, { spaceKeys = [] }) => new Stream6(({ next }) => {\n  let unsubscribe;\n  const update = async () => {\n    const spaces = [\n      ...context.spaceManager.spaces.values()\n    ];\n    const filteredSpaces = spaces.filter((space) => !(spaceKeys == null ? void 0 : spaceKeys.length) || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)));\n    next({\n      spaces: filteredSpaces.map((space) => {\n        const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata2) => spaceMetadata2.key.equals(space.key));\n        return {\n          key: space.key,\n          isOpen: space.isOpen,\n          timeframe: spaceMetadata.latestTimeframe,\n          genesisFeed: space.genesisFeedKey,\n          controlFeed: space.controlFeedKey,\n          dataFeed: space.dataFeedKey\n        };\n      })\n    });\n  };\n  const timeout = setTimeout(async () => {\n    await context.initialized.wait();\n    unsubscribe = context.spaceManager.updated.on(() => update());\n    await update();\n  });\n  return () => {\n    unsubscribe == null ? void 0 : unsubscribe();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nvar DevtoolsHostEvents = class {\n  constructor() {\n    this.ready = new AsyncEvent();\n  }\n};\nvar DevtoolsServiceImpl = class {\n  constructor(params) {\n    this.params = params;\n  }\n  events(request) {\n    return new Stream7(({ next }) => {\n      this.params.events.ready.on(() => {\n        next({\n          ready: {}\n        });\n      });\n    });\n  }\n  getConfig(request) {\n    throw new Error();\n  }\n  resetStorage(request) {\n    throw new Error();\n  }\n  enableDebugLogging(request) {\n    throw new Error();\n  }\n  disableDebugLogging(request) {\n    throw new Error();\n  }\n  subscribeToKeyringKeys(request) {\n    return subscribeToKeyringKeys({\n      keyring: this.params.context.keyring\n    });\n  }\n  subscribeToCredentialMessages(request) {\n    throw new Error();\n  }\n  subscribeToSpaces(request) {\n    return subscribeToSpaces(this.params.context, request);\n  }\n  subscribeToItems(request) {\n    throw new Error();\n  }\n  subscribeToFeeds(request) {\n    return subscribeToFeeds({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  subscribeToFeedBlocks(request) {\n    return subscribeToFeedBlocks({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  getSpaceSnapshot(request) {\n    throw new Error();\n  }\n  saveSpaceSnapshot(request) {\n    throw new Error();\n  }\n  clearSnapshots(request) {\n    throw new Error();\n  }\n  getNetworkPeers(request) {\n    throw new Error();\n  }\n  subscribeToNetworkTopics(request) {\n    throw new Error();\n  }\n  subscribeToSignalStatus(request) {\n    return subscribeToNetworkStatus({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSignalTrace() {\n    return subscribeToSignalTrace({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSwarmInfo() {\n    return subscribeToSwarmInfo({\n      networkManager: this.params.context.networkManager\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/authenticator.ts\nimport { verifyCredential } from \"@dxos/credentials\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar createHaloAuthProvider = (signer) => async (nonce) => {\n  const credential = await signer.createCredential({\n    assertion: {\n      \"@type\": \"dxos.halo.credentials.Auth\"\n    },\n    subject: signer.getIssuer(),\n    nonce\n  });\n  return schema.getCodecForType(\"dxos.halo.credentials.Credential\").encode(credential);\n};\nvar createHaloAuthVerifier = (getDeviceSet) => async (nonce, auth) => {\n  const credential = schema.getCodecForType(\"dxos.halo.credentials.Credential\").decode(auth);\n  const deviceSet = getDeviceSet();\n  const result = await verifyCredential(credential);\n  if (result.kind === \"fail\") {\n    log2(\"Invalid credential\", {\n      result\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 34,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!credential.proof.nonce || !Buffer.from(nonce).equals(credential.proof.nonce)) {\n    log2(\"Invalid nonce\", {\n      nonce,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 39,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!deviceSet.has(credential.issuer)) {\n    log2(\"Device not in allowed set\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 44,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  return true;\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { DeviceStateMachine, createCredentialSignerWithKey, createCredentialSignerWithChain, ProfileStateMachine } from \"@dxos/credentials\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { writeMessages } from \"@dxos/feed-store\";\nimport { log as log3 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar Identity = class {\n  constructor({ space, signer, identityKey, deviceKey }) {\n    this.stateUpdate = new Event();\n    this._space = space;\n    this._signer = signer;\n    this.identityKey = identityKey;\n    this.deviceKey = deviceKey;\n    this._deviceStateMachine = new DeviceStateMachine(this.identityKey, this.deviceKey);\n    this._profileStateMachine = new ProfileStateMachine(this.identityKey);\n    this._space.onCredentialProcessed.set(async (credential) => {\n      await this._deviceStateMachine.process(credential);\n      await this._profileStateMachine.process(credential);\n      this.stateUpdate.emit();\n    });\n  }\n  get authorizedDeviceKeys() {\n    return this._deviceStateMachine.authorizedDeviceKeys;\n  }\n  async open() {\n    await this._space.open();\n  }\n  async close() {\n    await this._space.close();\n  }\n  async ready() {\n    await this._deviceStateMachine.deviceChainReady.wait();\n  }\n  get profileDocument() {\n    return this._profileStateMachine.profile;\n  }\n  get controlPipeline() {\n    return this._space.controlPipeline;\n  }\n  get haloSpaceKey() {\n    return this._space.key;\n  }\n  get haloGenesisFeedKey() {\n    return this._space.genesisFeedKey;\n  }\n  get haloDatabase() {\n    var _a;\n    return (_a = this._space.database) != null ? _a : failUndefined();\n  }\n  getAdmissionCredentials() {\n    return {\n      deviceKey: this.deviceKey,\n      controlFeedKey: this._space.controlFeedKey,\n      dataFeedKey: this._space.dataFeedKey\n    };\n  }\n  getIdentityCredentialSigner() {\n    assert2(this._deviceStateMachine.deviceCredentialChain, \"Device credential chain is not ready.\");\n    return createCredentialSignerWithChain(this._signer, this._deviceStateMachine.deviceCredentialChain, this.deviceKey);\n  }\n  getDeviceCredentialSigner() {\n    return createCredentialSignerWithKey(this._signer, this.deviceKey);\n  }\n  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }) {\n    log3(\"Admitting device:\", {\n      identityKey: this.identityKey,\n      hostDevice: this.deviceKey,\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity.ts\",\n      line: 137,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const signer = this.getIdentityCredentialSigner();\n    await writeMessages(this.controlPipeline.writer, [\n      await signer.createCredential({\n        subject: deviceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n          identityKey: this.identityKey,\n          deviceKey\n        }\n      }),\n      await signer.createCredential({\n        subject: controlFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.CONTROL\n        }\n      }),\n      await signer.createCredential({\n        subject: dataFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.DATA\n        }\n      })\n    ].map((credential) => ({\n      \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n      credential\n    })));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity-manager.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event2 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { MOCK_AUTH_PROVIDER, MOCK_AUTH_VERIFIER, Space, Database, SpaceProtocol } from \"@dxos/echo-db\";\nimport { log as log4 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar IdentityManager = class {\n  constructor(_metadataStore, _feedStore, _keyring, _networkManager, _modelFactory) {\n    this._metadataStore = _metadataStore;\n    this._feedStore = _feedStore;\n    this._keyring = _keyring;\n    this._networkManager = _networkManager;\n    this._modelFactory = _modelFactory;\n    this.stateUpdate = new Event2();\n  }\n  get identity() {\n    return this._identity;\n  }\n  async open() {\n    await this._metadataStore.load();\n    const identityRecord = this._metadataStore.getIdentityRecord();\n    if (identityRecord) {\n      this._identity = await this._constructIdentity(identityRecord);\n      await this._identity.open();\n      await this._identity.ready();\n      this.stateUpdate.emit();\n    }\n  }\n  async close() {\n    var _a;\n    await ((_a = this._identity) == null ? void 0 : _a.close());\n  }\n  async createIdentity({ displayName } = {}) {\n    assert3(!this._identity, \"Identity already exists.\");\n    log4(\"creating identity...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeedKey = await this._keyring.createKey();\n    const identityRecord = {\n      identityKey: await this._keyring.createKey(),\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: await this._keyring.createKey(),\n        genesisFeedKey: controlFeedKey,\n        writeControlFeedKey: controlFeedKey,\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.genesisFeedKey),\n        await generator.createFeedAdmission(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.writeDataFeedKey, AdmittedFeed2.Designation.DATA)\n      ];\n      if (displayName) {\n        credentials.push(await generator.createProfileCredential({\n          displayName\n        }));\n      }\n      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));\n      for (const credential of credentials) {\n        await identity.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this._identity = identity;\n    await this._identity.ready();\n    this.stateUpdate.emit();\n    log4(\"created identity\", {\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return identity;\n  }\n  async acceptIdentity(params) {\n    log4(\"accepting identity\", {\n      params\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 150,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this._identity, \"Identity already exists.\");\n    const identityRecord = {\n      identityKey: params.identityKey,\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: params.haloSpaceKey,\n        genesisFeedKey: params.haloGenesisFeedKey,\n        writeControlFeedKey: await this._keyring.createKey(),\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    this._identity = identity;\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this.stateUpdate.emit();\n    return identity;\n  }\n  async _constructIdentity(identityRecord) {\n    assert3(!this._identity);\n    log4(\"constructing identity\", {\n      identityRecord\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace({\n      spaceRecord: identityRecord.haloSpace,\n      swarmIdentity: {\n        peerKey: identityRecord.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER\n      }\n    });\n    log4(\"done\", {\n      identityKey: identityRecord.identityKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 185,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return new Identity({\n      space,\n      signer: this._keyring,\n      identityKey: identityRecord.identityKey,\n      deviceKey: identityRecord.deviceKey\n    });\n  }\n  async _constructSpace({ spaceRecord, swarmIdentity }) {\n    const controlFeed = await this._feedStore.openFeed(spaceRecord.writeControlFeedKey, {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed(spaceRecord.writeDataFeedKey, {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed(spaceRecord.genesisFeedKey);\n    const protocol = new SpaceProtocol({\n      topic: spaceRecord.spaceKey,\n      identity: swarmIdentity,\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey: spaceRecord.spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, swarmIdentity.peerKey)\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/encoder.ts\nimport base from \"base-x\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar base62 = base(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\nvar codec = schema2.getCodecForType(\"dxos.client.services.Invitation\");\nvar InvitationEncoder = class {\n  static decode(text) {\n    return codec.decode(base62.decode(text));\n  }\n  static encode(invitation) {\n    return base62.encode(codec.encode(invitation));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { scheduleTask, sleep, Trigger } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { generatePasscode } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createTeleportProtocolFactory, StarTopology } from \"@dxos/network-manager\";\nimport { schema as schema3 } from \"@dxos/protocols\";\nimport { Invitation as Invitation2 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse } from \"@dxos/protocols/proto/dxos/halo/invitations\";\n\n// packages/sdk/client-services/src/packlets/invitations/invitations.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { CancellableObservableProvider } from \"@dxos/async\";\nimport { Invitation } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AUTHENTICATION_CODE_LENGTH = 6;\nvar INVITATION_TIMEOUT = 3 * 6e4;\nvar ON_CLOSE_DELAY = 500;\nvar InvitationObservableProvider = class extends CancellableObservableProvider {\n  get invitation() {\n    return this._invitation;\n  }\n  setInvitation(invitation) {\n    this._invitation = invitation;\n  }\n};\nvar AuthenticatingInvitationProvider = class extends InvitationObservableProvider {\n  constructor(_actions) {\n    super(() => this._actions.onCancel());\n    this._actions = _actions;\n  }\n  async authenticate(authenticationCode) {\n    return this._actions.onAuthenticate(authenticationCode);\n  }\n};\nvar wrapObservable = async (observable) => {\n  return new Promise((resolve, reject) => {\n    const unsubscribe = observable.subscribe({\n      onSuccess: (invitation) => {\n        assert4(invitation.state === Invitation.State.SUCCESS);\n        unsubscribe();\n        resolve(invitation);\n      },\n      onError: (err) => {\n        unsubscribe();\n        reject(err);\n      }\n    });\n  });\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts\nvar AbstractInvitationsHandler = class {\n  constructor(_networkManager) {\n    this._networkManager = _networkManager;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/rpc-extension.ts\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar RpcExtension = class {\n  constructor(_params) {\n    this._params = _params;\n  }\n  get initiator() {\n    return this._extensionContext.initiator;\n  }\n  get localPeerId() {\n    return this._extensionContext.localPeerId;\n  }\n  get remotePeerId() {\n    return this._extensionContext.remotePeerId;\n  }\n  get rpc() {\n    return this._rpc.rpc;\n  }\n  async onOpen(context) {\n    this._extensionContext = context;\n    const handlers = await this.getHandlers();\n    const port = context.createPort(\"rpc\", {\n      contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n    });\n    this._rpc = createProtoRpcPeer({\n      ...this._params,\n      handlers,\n      port\n    });\n    await this._rpc.open();\n  }\n  async onClose(err) {\n    await this._rpc.close();\n  }\n  close() {\n    this._extensionContext.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nvar HaloInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _identityManager) {\n    super(networkManager);\n    this._identityManager = _identityManager;\n  }\n  createInvitation(context, options) {\n    var _a;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert5(type !== Invitation2.Type.OFFLINE);\n    const identity = (_a = this._identityManager.identity) != null ? _a : failUndefined2();\n    const invitation = {\n      type,\n      invitationId: PublicKey3.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey3.random(),\n      authenticationCode: generatePasscode(AUTHENTICATION_CODE_LENGTH)\n    };\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const observable = new InvitationObservableProvider(async () => {\n      await ctx.dispose();\n    });\n    let authenticationCode;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const hostInvitationExtension = new HostHaloInvitationExtension({\n        requestAdmission: async () => {\n          var _a2, _b;\n          log5(\"responding with admission offer\", {\n            host: identity.deviceKey\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 84,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          (_b = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b.call(_a2, invitation);\n          return {\n            identityKey: identity.identityKey,\n            haloSpaceKey: identity.haloSpaceKey,\n            genesisFeedKey: identity.haloGenesisFeedKey\n          };\n        },\n        authenticate: async ({ authenticationCode: code }) => {\n          log5(\"received authentication request\", {\n            authenticationCode: code\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 98,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          authenticationCode = code;\n          return {\n            status: AuthenticationResponse.Status.OK\n          };\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          try {\n            if (invitation.type !== Invitation2.Type.INTERACTIVE_TESTING) {\n              if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                throw new Error(`invalid authentication code: ${authenticationCode}`);\n              }\n            }\n            log5(\"writing guest credentials\", {\n              host: identity.deviceKey,\n              guest: credentials.deviceKey\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n              line: 113,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            await identity.admitDevice(credentials);\n            complete.wake(credentials.deviceKey);\n          } catch (err) {\n            observable.callback.onError(err);\n            throw err;\n          }\n        },\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a2, _b;\n            try {\n              log5(\"connected\", {\n                host: identity.deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 129,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a2 = observable.callback).onConnected) == null ? void 0 : _b.call(_a2, invitation);\n              const deviceKey = await complete.wait({\n                timeout\n              });\n              log5(\"admitted guest\", {\n                host: identity.deviceKey,\n                guest: deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 132,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              observable.callback.onSuccess(invitation);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.error(\"failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 136,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await sleep(ON_CLOSE_DELAY);\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return hostInvitationExtension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a2, _b;\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a2 = observable.callback).onConnecting) == null ? void 0 : _b.call(_a2, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const authenticated = new Trigger();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await ctx.dispose();\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const extension = new GuestHaloInvitationExtension({\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a, _b, _c, _d;\n            try {\n              if (++connectionCount > 1) {\n                throw new Error(`multiple connections detected: ${connectionCount}`);\n              }\n              log5(\"connected\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 208,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n              log5(\"sending admission request\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 212,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              const { identityKey, haloSpaceKey, genesisFeedKey } = await extension.rpc.HaloHostService.requestAdmission();\n              if (invitation.type === void 0 || invitation.type === Invitation2.Type.INTERACTIVE) {\n                log5(\"guest waiting for authentication code...\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 219,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n                const authenticationCode = await authenticated.wait({\n                  timeout\n                });\n                log5(\"sending authentication request\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 222,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await extension.rpc.HaloHostService.authenticate({\n                  authenticationCode\n                });\n              }\n              const identity = await this._identityManager.acceptIdentity({\n                identityKey,\n                haloSpaceKey,\n                haloGenesisFeedKey: genesisFeedKey\n              });\n              log5(\"presenting admission credentials\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 235,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              await extension.rpc.HaloHostService.presentAdmissionCredentials(identity.getAdmissionCredentials());\n              log5(\"admitted by host\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 239,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              complete.wake(identityKey);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.warn(\"auth failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 243,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return extension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a, _b;\n      assert5(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey3.random(),\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      invitation.identityKey = await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await ctx.dispose();\n    });\n    return observable;\n  }\n};\nvar HostHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      exposed: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {\n      HaloHostService: {\n        requestAdmission: async () => {\n          return this._callbacks.requestAdmission();\n        },\n        authenticate: async (credentials) => {\n          return this._callbacks.authenticate(credentials);\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          return this._callbacks.presentAdmissionCredentials(credentials);\n        }\n      }\n    };\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\nvar GuestHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      requested: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {};\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { observableError } from \"@dxos/async\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Invitation as Invitation3 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsProxy = class {\n  constructor(_invitationsService) {\n    this._invitationsService = _invitationsService;\n  }\n  createInvitation(context, options) {\n    let invitationId;\n    const observable = new InvitationObservableProvider(async () => {\n      if (invitationId) {\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      }\n    });\n    const invitation = {\n      ...this.getInvitationOptions(context),\n      ...options\n    };\n    const stream = this._invitationsService.createInvitation(invitation);\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          assert6(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 81,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    assert6(invitation && invitation.swarmKey);\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      },\n      onAuthenticate: async (authenticationCode) => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.authenticate({\n          invitationId,\n          authenticationCode\n        });\n      }\n    });\n    const stream = this._invitationsService.acceptInvitation({\n      ...invitation,\n      ...options\n    });\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      assert6(invitation2.invitationId);\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 146,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-proxy.ts\nvar HaloInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions() {\n    return {};\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { Stream as Stream8 } from \"@dxos/codec-protobuf\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Invitation as Invitation4 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsService = class {\n  constructor(_identityManager, _getInvitationsHandler) {\n    this._identityManager = _identityManager;\n    this._getInvitationsHandler = _getInvitationsHandler;\n    this._createInvitations = /* @__PURE__ */ new Map();\n    this._acceptInvitations = /* @__PURE__ */ new Map();\n  }\n  getLoggingContext() {\n    var _a;\n    return {\n      deviceKey: (_a = this._identityManager.identity) == null ? void 0 : _a.deviceKey\n    };\n  }\n  createInvitation(invitation) {\n    return new Stream8(({ next, close }) => {\n      const invitationsHandler = this._getInvitationsHandler();\n      const context = this.getContext(invitation);\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 43,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      let invitationId;\n      const { type, swarmKey } = invitation;\n      const observable = invitationsHandler.createInvitation(context, {\n        type,\n        swarmKey\n      });\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._createInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context2 = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context2,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 92,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context2, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 94,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._createInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  acceptInvitation(invitation, options) {\n    return new Stream8(({ next, close }) => {\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 104,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const invitationsHandler = this._getInvitationsHandler();\n      let invitationId;\n      const observable = invitationsHandler.acceptInvitation(invitation, options);\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._acceptInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 152,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 154,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._acceptInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  async authenticate({ invitationId, authenticationCode }) {\n    log7(\"authenticating...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 163,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitationId);\n    const observable = this._acceptInvitations.get(invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 167,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await observable.authenticate(authenticationCode);\n    }\n  }\n  async cancelInvitation(invitation) {\n    var _a;\n    log7(\"cancelling...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitation.invitationId);\n    const observable = (_a = this._createInvitations.get(invitation.invitationId)) != null ? _a : this._acceptInvitations.get(invitation.invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId: invitation.invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await (observable == null ? void 0 : observable.cancel());\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-service.ts\nvar HaloInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler) {\n    super(identityManager, () => invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n  }\n  getContext(invitation) {\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport { sleep as sleep2, Trigger as Trigger2 } from \"@dxos/async\";\nimport { createAdmissionCredentials, generatePasscode as generatePasscode2 } from \"@dxos/credentials\";\nimport { writeMessages as writeMessages2 } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log8 } from \"@dxos/log\";\nimport { adaptProtocolProvider, createProtocolFactory, StarTopology as StarTopology2 } from \"@dxos/network-manager\";\nimport { createRpcPlugin, RpcPlugin } from \"@dxos/protocol-plugin-rpc\";\nimport { schema as schema4 } from \"@dxos/protocols\";\nimport { Invitation as Invitation5 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse as AuthenticationResponse2 } from \"@dxos/protocols/proto/dxos/halo/invitations\";\nimport { createProtoRpcPeer as createProtoRpcPeer2 } from \"@dxos/rpc\";\nvar MAX_OTP_ATTEMPTS = 3;\nvar SpaceInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _spaceManager, _signingContext) {\n    super(networkManager);\n    this._spaceManager = _spaceManager;\n    this._signingContext = _signingContext;\n  }\n  createInvitation(space, options) {\n    let swarmConnection;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert8(type !== Invitation5.Type.OFFLINE);\n    assert8(space);\n    const invitation = {\n      type,\n      invitationId: PublicKey4.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey4.random(),\n      spaceKey: space.key,\n      authenticationCode: generatePasscode2(AUTHENTICATION_CODE_LENGTH)\n    };\n    const observable = new InvitationObservableProvider(async () => {\n      await (swarmConnection == null ? void 0 : swarmConnection.close());\n    });\n    let authenticationCode;\n    let authenticationRetry = 0;\n    const complete = new Trigger2();\n    const plugin = new RpcPlugin(async (port) => {\n      var _a, _b;\n      let guestProfile;\n      const peer = createProtoRpcPeer2({\n        exposed: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        handlers: {\n          SpaceHostService: {\n            requestAdmission: async ({ profile }) => {\n              var _a2, _b2;\n              log8(\"responding with admission offer\", {\n                guestProfile: profile,\n                host: this._signingContext.deviceKey,\n                spaceKey: space.key\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 89,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              guestProfile = profile;\n              (_b2 = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b2.call(_a2, invitation);\n              return {\n                spaceKey: space.key,\n                genesisFeedKey: space.genesisFeedKey\n              };\n            },\n            authenticate: async ({ authenticationCode: code }) => {\n              log8(\"received authentication request\", {\n                authenticationCode: code\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 107,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              let status = AuthenticationResponse2.Status.OK;\n              if (invitation.authenticationCode) {\n                if (authenticationRetry++ > MAX_OTP_ATTEMPTS) {\n                  status = AuthenticationResponse2.Status.INVALID_OPT_ATTEMPTS;\n                } else if (code !== invitation.authenticationCode) {\n                  status = AuthenticationResponse2.Status.INVALID_OTP;\n                } else {\n                  authenticationCode = code;\n                }\n              }\n              return {\n                status\n              };\n            },\n            presentAdmissionCredentials: async ({ identityKey, deviceKey, controlFeedKey, dataFeedKey }) => {\n              try {\n                if (invitation.type !== Invitation5.Type.INTERACTIVE_TESTING) {\n                  if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                    throw new Error(`invalid authentication code: ${authenticationCode}`);\n                  }\n                }\n                log8(\"writing guest credentials\", {\n                  host: this._signingContext.deviceKey,\n                  guest: deviceKey\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 134,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await writeMessages2(space.controlPipeline.writer, await createAdmissionCredentials(this._signingContext.credentialSigner, identityKey, deviceKey, space.key, controlFeedKey, dataFeedKey, guestProfile));\n                complete.wake(deviceKey);\n              } catch (err) {\n                observable.callback.onError(err);\n                throw err;\n              }\n            }\n          }\n        },\n        port\n      });\n      try {\n        await peer.open();\n        log8(\"connected\", {\n          host: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 164,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        const deviceKey = await complete.wait({\n          timeout\n        });\n        log8(\"admitted guest\", {\n          host: this._signingContext.deviceKey,\n          guest: deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 167,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        observable.callback.onSuccess(invitation);\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.error(\"failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 171,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await sleep2(ON_CLOSE_DELAY);\n        await peer.close();\n        await swarmConnection.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    let swarmConnection;\n    const authenticated = new Trigger2();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await (swarmConnection == null ? void 0 : swarmConnection.close());\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger2();\n    const plugin = createRpcPlugin(async (port) => {\n      var _a, _b, _c, _d;\n      const peer = createProtoRpcPeer2({\n        requested: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        port\n      });\n      try {\n        await peer.open();\n        if (++connectionCount > 1) {\n          throw new Error(`multiple connections detected: ${connectionCount}`);\n        }\n        log8(\"connected\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 235,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        log8(\"sending admission request\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 239,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const { spaceKey, genesisFeedKey } = await peer.rpc.SpaceHostService.requestAdmission({\n          profile: this._signingContext.profile\n        });\n        if (invitation.type === void 0 || invitation.type === Invitation5.Type.INTERACTIVE) {\n          for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {\n            log8(\"guest waiting for authentication code...\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 248,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n            const authenticationCode = await authenticated.wait({\n              timeout\n            });\n            log8(\"sending authentication request\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 252,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            const response = await peer.rpc.SpaceHostService.authenticate({\n              authenticationCode\n            });\n            if (response.status === void 0 || response.status === AuthenticationResponse2.Status.OK) {\n              break;\n            }\n            if (response.status === AuthenticationResponse2.Status.INVALID_OTP) {\n              if (attempt === MAX_OTP_ATTEMPTS) {\n                throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);\n              } else {\n                log8(\"retrying invalid code\", {\n                  attempt\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 262,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                authenticated.reset();\n              }\n            }\n          }\n        }\n        const space = await this._spaceManager.acceptSpace({\n          spaceKey,\n          genesisFeedKey\n        });\n        log8(\"presenting admission credentials\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await peer.rpc.SpaceHostService.presentAdmissionCredentials({\n          identityKey: this._signingContext.identityKey,\n          deviceKey: this._signingContext.deviceKey,\n          controlFeedKey: space.controlFeedKey,\n          dataFeedKey: space.dataFeedKey\n        });\n        log8(\"admitted by host\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 283,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        complete.wake();\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.warn(\"auth failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 287,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await peer.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      assert8(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey4.random(),\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await swarmConnection.close();\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-proxy.ts\nvar SpaceInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions(context) {\n    return {\n      spaceKey: context\n    };\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-service.ts\nimport assert9 from \"@dxos/node-std/assert\";\nvar SpaceInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler, _getSpaceManager) {\n    super(identityManager, invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n    this._getSpaceManager = _getSpaceManager;\n  }\n  getContext(invitation) {\n    assert9(invitation.spaceKey);\n    const spaceManager = this._getSpaceManager();\n    const space = spaceManager.spaces.get(invitation.spaceKey);\n    assert9(space);\n    return space;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-context.ts\nimport { Trigger as Trigger3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nimport { MOCK_AUTH_PROVIDER as MOCK_AUTH_PROVIDER2, MOCK_AUTH_VERIFIER as MOCK_AUTH_VERIFIER2, valueEncoding, DataServiceSubscriptions, MetadataStore, SpaceManager } from \"@dxos/echo-db\";\nimport { FeedFactory, FeedStore } from \"@dxos/feed-store\";\nimport { Keyring } from \"@dxos/keyring\";\nimport { log as log9 } from \"@dxos/log\";\nvar ServiceContext = class {\n  constructor(storage, networkManager, modelFactory) {\n    this.storage = storage;\n    this.networkManager = networkManager;\n    this.modelFactory = modelFactory;\n    this.initialized = new Trigger3();\n    this.dataServiceSubscriptions = new DataServiceSubscriptions();\n    this.metadataStore = new MetadataStore(storage.createDirectory(\"metadata\"));\n    this.keyring = new Keyring(storage.createDirectory(\"keyring\"));\n    this.feedStore = new FeedStore({\n      factory: new FeedFactory({\n        root: storage.createDirectory(\"feeds\"),\n        signer: this.keyring,\n        hypercore: {\n          valueEncoding\n        }\n      })\n    });\n    this.identityManager = new IdentityManager(this.metadataStore, this.feedStore, this.keyring, networkManager, modelFactory);\n    this.haloInvitations = new HaloInvitationsHandler(this.networkManager, this.identityManager);\n  }\n  async open() {\n    log9(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 78,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.open();\n    if (this.identityManager.identity) {\n      await this._initialize();\n    }\n    log9(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    log9(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 87,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.close();\n    await ((_a = this.spaceManager) == null ? void 0 : _a.close());\n    await this.feedStore.close();\n    await this.networkManager.close();\n    this.dataServiceSubscriptions.clear();\n    log9(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async reset() {\n    log9(\"resetting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.close();\n    await this.storage.reset();\n    log9(\"reset\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async createIdentity(params = {}) {\n    const identity = await this.identityManager.createIdentity(params);\n    this.dataServiceSubscriptions.registerSpace(identity.haloSpaceKey, identity.haloDatabase.createDataServiceHost());\n    await this._initialize();\n    return identity;\n  }\n  async _initialize() {\n    var _a;\n    const identity = (_a = this.identityManager.identity) != null ? _a : failUndefined3();\n    const signingContext = {\n      credentialProvider: MOCK_AUTH_PROVIDER2,\n      credentialAuthenticator: MOCK_AUTH_VERIFIER2,\n      credentialSigner: identity.getIdentityCredentialSigner(),\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey,\n      profile: identity.profileDocument\n    };\n    const spaceManager = new SpaceManager({\n      metadataStore: this.metadataStore,\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      keyring: this.keyring,\n      dataServiceSubscriptions: this.dataServiceSubscriptions,\n      modelFactory: this.modelFactory,\n      signingContext\n    });\n    await spaceManager.open();\n    this.spaceManager = spaceManager;\n    this.spaceInvitations = new SpaceInvitationsHandler(this.networkManager, this.spaceManager, signingContext);\n    this.initialized.wake();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-definitions.ts\nimport { schema as schema5 } from \"@dxos/protocols\";\nimport { createServiceBundle } from \"@dxos/rpc\";\nvar clientServiceBundle = createServiceBundle({\n  HaloInvitationsService: schema5.getService(\"dxos.client.services.HaloInvitationsService\"),\n  DevicesService: schema5.getService(\"dxos.client.services.DevicesService\"),\n  SpaceInvitationsService: schema5.getService(\"dxos.client.services.SpaceInvitationsService\"),\n  SpacesService: schema5.getService(\"dxos.client.services.SpacesService\"),\n  SpaceService: schema5.getService(\"dxos.client.SpaceService\"),\n  DataService: schema5.getService(\"dxos.echo.service.DataService\"),\n  ProfileService: schema5.getService(\"dxos.client.ProfileService\"),\n  SystemService: schema5.getService(\"dxos.client.SystemService\"),\n  DevtoolsHost: schema5.getService(\"dxos.devtools.host.DevtoolsHost\"),\n  TracingService: schema5.getService(\"dxos.devtools.host.TracingService\")\n});\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nimport { raise } from \"@dxos/debug\";\nimport { DataServiceImpl } from \"@dxos/echo-db\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ModelFactory } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nimport { TextModel } from \"@dxos/text-model\";\n\n// packages/sdk/client-services/src/packlets/identity/devices-service-impl.ts\nimport { EventSubscriptions as EventSubscriptions3 } from \"@dxos/async\";\nimport { Stream as Stream9 } from \"@dxos/codec-protobuf\";\nvar DevicesServiceImpl = class {\n  constructor(_identityManager) {\n    this._identityManager = _identityManager;\n  }\n  updateDevice() {\n    throw new Error(\"Method not implemented.\");\n  }\n  queryDevices() {\n    return new Stream9(({ next }) => {\n      const update = () => {\n        var _a;\n        const deviceKeys = (_a = this._identityManager.identity) == null ? void 0 : _a.authorizedDeviceKeys;\n        if (!deviceKeys) {\n          next({\n            devices: []\n          });\n        } else {\n          next({\n            devices: Array.from(deviceKeys.values()).map((key) => ({\n              deviceKey: key\n            }))\n          });\n        }\n      };\n      const dispose = new EventSubscriptions3();\n      dispose.add(this._identityManager.stateUpdate.on(() => {\n        update();\n        if (this._identityManager.identity) {\n          dispose.add(this._identityManager.identity.stateUpdate.on(() => {\n            update();\n          }));\n        }\n      }));\n      update();\n      return () => dispose.clear();\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/spaces/spaces-service.ts\nvar SpacesServiceImpl = class {\n  async createSpace() {\n    throw new Error();\n  }\n  querySpaces() {\n    throw new Error();\n  }\n  queryMembers(query) {\n    throw new Error();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/storage/storage.ts\nimport jsondown from \"jsondown\";\nimport leveljs from \"level-js\";\nimport memdown from \"memdown\";\nimport { InvalidConfigError } from \"@dxos/errors\";\nimport { Runtime } from \"@dxos/protocols/proto/dxos/config\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { isNode } from \"@dxos/util\";\nvar StorageDriver = Runtime.Client.Storage.StorageDriver;\nvar createStorageObjects = (config) => {\n  const { path = \"dxos/storage\", storageType, keyStorage, persistent = false } = config != null ? config : {};\n  if (persistent && storageType === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && storageType !== void 0 && storageType !== StorageDriver.RAM) {\n    throw new InvalidConfigError(\"Cannot use a persistent storage in not persistent mode.\");\n  }\n  if (persistent && keyStorage === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM key storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && keyStorage !== StorageDriver.RAM && keyStorage !== void 0) {\n    throw new InvalidConfigError(\"Cannot use a persistent key storage in not persistent mode.\");\n  }\n  return {\n    storage: createStorage({\n      type: persistent ? toStorageType(storageType) : StorageType.RAM,\n      root: `${path}/`\n    }),\n    keyStorage: createKeyStorage(`${path}/keystore`, persistent ? toKeyStorageType(keyStorage) : \"ram\")\n  };\n};\nvar createKeyStorage = (path, type) => {\n  const defaultedType = type != null ? type : isNode() ? \"jsondown\" : \"leveljs\";\n  switch (defaultedType) {\n    case \"leveljs\":\n      return leveljs(path);\n    case \"jsondown\":\n      return jsondown(path);\n    case \"ram\":\n      return memdown();\n    default:\n      throw new InvalidConfigError(`Invalid key storage type: ${defaultedType}`);\n  }\n};\nvar toStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return StorageType.RAM;\n    case StorageDriver.CHROME:\n      return StorageType.CHROME;\n    case StorageDriver.FIREFOX:\n      return StorageType.FIREFOX;\n    case StorageDriver.IDB:\n      return StorageType.IDB;\n    case StorageDriver.NODE:\n      return StorageType.NODE;\n    default:\n      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);\n  }\n};\nvar toKeyStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return \"ram\";\n    case StorageDriver.LEVELJS:\n      return \"leveljs\";\n    case StorageDriver.JSONDOWN:\n      return \"jsondown\";\n    default:\n      throw new Error(`Invalid key storage type: ${StorageDriver[type]}`);\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-registry.ts\nvar ServiceRegistry = class {\n  constructor(_serviceBundle, _handlers) {\n    this._serviceBundle = _serviceBundle;\n    this._handlers = _handlers;\n  }\n  get descriptors() {\n    return this._serviceBundle;\n  }\n  get services() {\n    return this._handlers;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nvar createDefaultModelFactory = () => {\n  return new ModelFactory().registerModel(ObjectModel).registerModel(TextModel);\n};\nvar ClientServicesHost = class {\n  constructor({\n    config,\n    modelFactory = createDefaultModelFactory(),\n    networkManager\n  }) {\n    this._config = config;\n    this._modelFactory = modelFactory;\n    this._networkManager = networkManager;\n  }\n  get descriptors() {\n    return this._serviceRegistry.descriptors;\n  }\n  get services() {\n    return this._serviceRegistry.services;\n  }\n  async open() {\n    var _a;\n    await this._initialize();\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"opening...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._initialize();\n    await this._serviceContext.open();\n    log10(\"opened\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"closing...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._serviceContext.close();\n    log10(\"closed\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 79,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _initialize() {\n    const { storage } = createStorageObjects(this._config.get(\"runtime.client.storage\", {}));\n    this._serviceContext = new ServiceContext(storage, this._networkManager, this._modelFactory);\n    this._serviceRegistry = new ServiceRegistry(clientServiceBundle, {\n      HaloInvitationsService: new HaloInvitationsServiceImpl(this._serviceContext.identityManager, this._serviceContext.haloInvitations),\n      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager),\n      SpaceInvitationsService: new SpaceInvitationsServiceImpl(this._serviceContext.identityManager, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceInvitations) != null ? _a : raise(new Error(\"SpaceInvitations not initialized\"));\n      }, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceManager) != null ? _a : raise(new Error(\"SpaceManager not initialized\"));\n      }),\n      SpacesService: new SpacesServiceImpl(),\n      DataService: new DataServiceImpl(this._serviceContext.dataServiceSubscriptions),\n      ProfileService: new ProfileServiceImpl(this._serviceContext),\n      SpaceService: new SpaceServiceImpl(this._serviceContext),\n      SystemService: new SystemServiceImpl(this._config, this._serviceContext),\n      TracingService: new TracingServiceImpl(this._config),\n      DevtoolsHost: new DevtoolsServiceImpl({\n        events: new DevtoolsHostEvents(),\n        config: this._config,\n        context: this._serviceContext\n      })\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-proxy.ts\nimport { asyncTimeout } from \"@dxos/async\";\nimport { RemoteServiceConnectionTimeout } from \"@dxos/errors\";\nimport { createProtoRpcPeer as createProtoRpcPeer3 } from \"@dxos/rpc\";\nvar ClientServicesProxy = class {\n  constructor(port, _timeout = 3e4) {\n    this._timeout = _timeout;\n    this._proxy = createProtoRpcPeer3({\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n      port\n    });\n  }\n  get proxy() {\n    return this._proxy;\n  }\n  get descriptors() {\n    return clientServiceBundle;\n  }\n  get services() {\n    return this._proxy.rpc;\n  }\n  async open() {\n    await asyncTimeout(this._proxy.open(), this._timeout, new RemoteServiceConnectionTimeout());\n  }\n  async close() {\n    await this._proxy.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nimport { WebRTCTransportService } from \"@dxos/network-manager\";\nimport { createProtoRpcPeer as createProtoRpcPeer4 } from \"@dxos/rpc\";\n\n// packages/sdk/client-services/src/packlets/vault/services.ts\nimport { schema as schema6 } from \"@dxos/protocols\";\nvar iframeServiceBundle = {\n  IframeService: schema6.getService(\"dxos.iframe.IframeService\"),\n  BridgeService: schema6.getService(\"dxos.mesh.bridge.BridgeService\")\n};\nvar workerServiceBundle = {\n  WorkerService: schema6.getService(\"dxos.iframe.WorkerService\")\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nvar IFrameRuntime = class {\n  constructor({ systemPort, workerAppPort, windowAppPort }) {\n    this._transportService = new WebRTCTransportService();\n    this._systemPort = systemPort;\n    this._windowAppPort = windowAppPort;\n    this._workerAppPort = workerAppPort;\n    this._systemRpc = createProtoRpcPeer4({\n      requested: workerServiceBundle,\n      exposed: iframeServiceBundle,\n      handlers: {\n        BridgeService: this._transportService,\n        IframeService: {\n          async heartbeat() {\n          }\n        }\n      },\n      port: this._systemPort,\n      timeout: 200\n    });\n    this._workerAppPort.subscribe((msg) => this._windowAppPort.send(msg));\n    this._windowAppPort.subscribe((msg) => this._workerAppPort.send(msg));\n  }\n  async open(origin) {\n    await this._systemRpc.open();\n    await this._systemRpc.rpc.WorkerService.start({\n      origin\n    });\n  }\n  async close() {\n    await this._systemRpc.rpc.WorkerService.stop();\n    await this._systemRpc.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nimport { Trigger as Trigger5 } from \"@dxos/async\";\nimport { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from \"@dxos/messaging\";\nimport { NetworkManager, WebRTCTransportProxyFactory } from \"@dxos/network-manager\";\n\n// packages/sdk/client-services/src/packlets/vault/worker-session.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger4 } from \"@dxos/async\";\nimport { log as log11, logInfo } from \"@dxos/log\";\nimport { createProtoRpcPeer as createProtoRpcPeer5 } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WorkerSession = class {\n  constructor({ getServices, systemPort, appPort, options = {\n    heartbeatInterval: 1e3\n  } }) {\n    this._startTrigger = new Trigger4();\n    this.onClose = new Callback();\n    assert10(options);\n    assert10(getServices);\n    this._options = options;\n    this._getServices = getServices;\n    this._clientRpc = createProtoRpcPeer5({\n      exposed: clientServiceBundle,\n      handlers: {\n        HaloInvitationsService: async () => (await this._getServices()).services.HaloInvitationsService,\n        DevicesService: async () => (await this._getServices()).services.DevicesService,\n        SpaceInvitationsService: async () => (await this._getServices()).services.SpaceInvitationsService,\n        SpacesService: async () => (await this._getServices()).services.SpacesService,\n        SpaceService: async () => (await this._getServices()).services.SpaceService,\n        DataService: async () => (await this._getServices()).services.DataService,\n        ProfileService: async () => (await this._getServices()).services.ProfileService,\n        SystemService: async () => (await this._getServices()).services.SystemService,\n        DevtoolsHost: async () => (await this._getServices()).services.DevtoolsHost,\n        TracingService: async () => (await this._getServices()).services.TracingService\n      },\n      port: appPort\n    });\n    this._iframeRpc = createProtoRpcPeer5({\n      requested: iframeServiceBundle,\n      exposed: workerServiceBundle,\n      handlers: {\n        WorkerService: {\n          start: async (request) => {\n            this.origin = request.origin;\n            this._startTrigger.wake();\n          },\n          stop: async () => {\n            setTimeout(async () => {\n              try {\n                await this.close();\n              } catch (err) {\n                log11.catch(err, {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n                  line: 89,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n              }\n            });\n          }\n        }\n      },\n      port: systemPort,\n      timeout: 1e3\n    });\n    this.bridgeService = this._iframeRpc.rpc.BridgeService;\n  }\n  async open() {\n    log11.info(\"opening..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 103,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      this._clientRpc.open(),\n      this._iframeRpc.open()\n    ]);\n    await this._startTrigger.wait({\n      timeout: 3e3\n    });\n    this._heartbeatTimer = setInterval(async () => {\n      try {\n        await this._iframeRpc.rpc.IframeService.heartbeat();\n      } catch (err1) {\n        log11.warn(\"Heartbeat failed\", {\n          err: err1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n          line: 115,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          await this.close();\n        } catch (err) {\n          log11.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n            line: 119,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, this._options.heartbeatInterval);\n  }\n  async close() {\n    log11.info(\"closing..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this.onClose.callIfSet();\n    } catch (err) {\n      log11.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    if (this._heartbeatTimer !== void 0) {\n      clearInterval(this._heartbeatTimer);\n    }\n    await Promise.all([\n      this._clientRpc.close(),\n      this._iframeRpc.close()\n    ]);\n  }\n};\n__decorate([\n  logInfo\n], WorkerSession.prototype, \"origin\", void 0);\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nvar WorkerRuntime = class {\n  constructor(_configProvider) {\n    this._configProvider = _configProvider;\n    this._transportFactory = new WebRTCTransportProxyFactory();\n    this._ready = new Trigger5();\n    this.sessions = /* @__PURE__ */ new Set();\n  }\n  async start() {\n    try {\n      this._config = await this._configProvider();\n      const signalServer = this._config.get(\"runtime.services.signal.server\");\n      this._clientServices = new ClientServicesHost({\n        config: this._config,\n        networkManager: new NetworkManager({\n          log: true,\n          signalManager: signalServer ? new WebsocketSignalManager([\n            signalServer\n          ]) : new MemorySignalManager(new MemorySignalManagerContext()),\n          transportFactory: this._transportFactory\n        })\n      });\n      await this._clientServices.open();\n      this._ready.wake(void 0);\n    } catch (err) {\n      this._ready.wake(err);\n    }\n  }\n  async stop() {\n    await this._clientServices.close();\n  }\n  async createSession({ appPort, systemPort }) {\n    const session = new WorkerSession({\n      getServices: async () => {\n        const error = await this._ready.wait();\n        if (error !== void 0) {\n          throw error;\n        }\n        return this._clientServices;\n      },\n      appPort,\n      systemPort,\n      readySignal: this._ready\n    });\n    session.onClose.set(async () => {\n      this.sessions.delete(session);\n      this._reconnectWebrtc();\n    });\n    await session.open();\n    this.sessions.add(session);\n    this._reconnectWebrtc();\n  }\n  _reconnectWebrtc() {\n    if (this._sessionForNetworking) {\n      if (!this.sessions.has(this._sessionForNetworking)) {\n        this._sessionForNetworking = void 0;\n      }\n    }\n    if (!this._sessionForNetworking) {\n      const selected = Array.from(this.sessions).find((session) => session.bridgeService);\n      if (selected) {\n        this._sessionForNetworking = selected;\n        this._transportFactory.setBridgeService(selected.bridgeService);\n      } else {\n        this._transportFactory.setBridgeService(void 0);\n      }\n    }\n  }\n};\nexport {\n  AUTHENTICATION_CODE_LENGTH,\n  AbstractInvitationsHandler,\n  AbstractInvitationsProxy,\n  AbstractInvitationsService,\n  AuthenticatingInvitationProvider,\n  ClientServicesHost,\n  ClientServicesProxy,\n  DevtoolsHostEvents,\n  DevtoolsServiceImpl,\n  HaloInvitationsHandler,\n  HaloInvitationsProxy,\n  HaloInvitationsServiceImpl,\n  IFrameRuntime,\n  INVITATION_TIMEOUT,\n  Identity,\n  IdentityManager,\n  InvitationEncoder,\n  InvitationObservableProvider,\n  ON_CLOSE_DELAY,\n  ProfileServiceImpl,\n  ServiceContext,\n  ServiceRegistry,\n  SpaceInvitationsHandler,\n  SpaceInvitationsProxy,\n  SpaceInvitationsServiceImpl,\n  SpaceServiceImpl,\n  SystemServiceImpl,\n  TracingServiceImpl,\n  WorkerRuntime,\n  WorkerSession,\n  clientServiceBundle,\n  createDefaultModelFactory,\n  createHaloAuthProvider,\n  createHaloAuthVerifier,\n  createStorageObjects,\n  getNetworkPeers,\n  subscribeToFeedBlocks,\n  subscribeToFeeds,\n  subscribeToNetworkStatus,\n  subscribeToNetworkTopics,\n  subscribeToSignalTrace,\n  subscribeToSpaces,\n  subscribeToSwarmInfo,\n  wrapObservable\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465343,"end":1670465466119},{"name":"vite:react-babel","result":"// packages/sdk/client-services/src/packlets/deprecated/space.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { todo } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { humanize } from \"@dxos/util\";\nvar SpaceServiceImpl = class {\n  constructor(serviceContext) {\n    this.serviceContext = serviceContext;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeToSpace(request) {\n    return new Stream(({ next }) => {\n      next({\n        space: {\n          publicKey: request.spaceKey,\n          isOpen: true,\n          isActive: true,\n          members: []\n        }\n      });\n    });\n  }\n  subscribeSpaces() {\n    return new Stream(({ next }) => {\n      const subscriptions = new EventSubscriptions();\n      const onUpdate = () => {\n        const spaces = Array.from(this.serviceContext.spaceManager.spaces.values()).map((space) => ({\n          publicKey: space.key,\n          isOpen: true,\n          isActive: true,\n          members: Array.from(space.spaceState.members.values()).map((member) => {\n            var _a, _b;\n            return {\n              identityKey: member.key,\n              profile: {\n                identityKey: member.key,\n                displayName: (_b = (_a = member.assertion.profile) == null ? void 0 : _a.displayName) != null ? _b : humanize(member.key)\n              }\n            };\n          })\n        }));\n        log(\"update\", {\n          spaces\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/deprecated/space.ts\",\n          line: 114,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        next({\n          spaces\n        });\n      };\n      setTimeout(async () => {\n        if (!this.serviceContext.spaceManager) {\n          next({\n            spaces: []\n          });\n        }\n        await this.serviceContext.initialized.wait();\n        subscriptions.add(this.serviceContext.spaceManager.updated.on(() => {\n          this.serviceContext.spaceManager.spaces.forEach((space) => {\n            subscriptions.add(space.stateUpdate.on(onUpdate));\n          });\n          onUpdate();\n        }));\n        this.serviceContext.spaceManager.spaces.forEach((space) => {\n          subscriptions.add(space.stateUpdate.on(onUpdate));\n        });\n        onUpdate();\n      });\n      return () => subscriptions.clear();\n    });\n  }\n  async getSpaceDetails(request) {\n    return todo();\n  }\n  async createSpace() {\n    await this.serviceContext.initialized.wait();\n    const space = await this.serviceContext.spaceManager.createSpace();\n    return {\n      publicKey: space.key,\n      isOpen: true,\n      isActive: true\n    };\n  }\n  async cloneSpace(snapshot) {\n    return todo();\n  }\n  async setSpaceState(request) {\n    return todo();\n  }\n  async authenticateInvitation(request) {\n    var _a;\n    assert(request.processId, \"Process ID is missing.\");\n    const invitation = this.inviteeInvitations.get(request.processId);\n    assert(invitation, \"Invitation not found.\");\n    assert(request.secret, \"Secret not provided.\");\n    invitation.secret = request.secret;\n    (_a = invitation.secretTrigger) == null ? void 0 : _a.call(invitation);\n  }\n  subscribeMembers(request) {\n    return todo();\n  }\n  async createSnapshot(request) {\n    return todo();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/profile.ts\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { todo as todo2 } from \"@dxos/debug\";\nvar ProfileServiceImpl = class {\n  constructor(context) {\n    this.context = context;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeProfile() {\n    return new Stream2(({ next }) => {\n      const emitNext = () => {\n        var _a;\n        return next({\n          profile: this.context.identityManager.identity ? {\n            identityKey: this.context.identityManager.identity.identityKey,\n            deviceKey: this.context.identityManager.identity.deviceKey,\n            displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n          } : void 0\n        });\n      };\n      emitNext();\n      return this.context.identityManager.stateUpdate.on(emitNext);\n    });\n  }\n  async createProfile(request) {\n    var _a;\n    await this.context.createIdentity({\n      displayName: request.displayName\n    });\n    return {\n      identityKey: this.context.identityManager.identity.identityKey,\n      deviceKey: this.context.identityManager.identity.deviceKey,\n      displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n    };\n  }\n  async recoverProfile(request) {\n    return todo2();\n    if (!request.seedPhrase) {\n      throw new Error(\"Recovery SeedPhrase not provided.\");\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/system.ts\nvar SystemServiceImpl = class {\n  constructor(_config, _serviceContext) {\n    this._config = _config;\n    this._serviceContext = _serviceContext;\n  }\n  async initSession() {\n  }\n  async getConfig(request) {\n    return this._config.values;\n  }\n  async getStatus(request) {\n    return {\n      message: `ok: ${Date.now()}`\n    };\n  }\n  async reset(request) {\n    await this._serviceContext.reset();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/tracing.ts\nvar TracingServiceImpl = class {\n  constructor(_config) {\n    this._config = _config;\n  }\n  async setTracingOptions() {\n    throw new Error(\"Tracing not available.\");\n  }\n  subscribeToRpcTrace() {\n    throw new Error(\"Tracing not available.\");\n  }\n};\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nimport { Event as AsyncEvent } from \"@dxos/async\";\nimport { Stream as Stream7 } from \"@dxos/codec-protobuf\";\n\n// packages/sdk/client-services/src/packlets/devtools/feeds.ts\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\nimport { Stream as Stream3 } from \"@dxos/codec-protobuf\";\nimport { FeedIterator } from \"@dxos/feed-store\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar subscribeToFeeds = ({ feedStore }, { feedKeys }) => new Stream3(({ next }) => {\n  if ((feedKeys == null ? void 0 : feedKeys.length) === 0) {\n    return;\n  }\n  const feedMap = new ComplexMap(PublicKey.hash);\n  const subscriptions = new EventSubscriptions2();\n  const update = () => {\n    const feeds = feedStore.feeds;\n    feeds.filter((feed) => !(feedKeys == null ? void 0 : feedKeys.length) || feedKeys.some((feedKey) => feedKey.equals(feed.key))).forEach((feed) => {\n      if (!feedMap.has(feed.key)) {\n        feedMap.set(feed.key, feed);\n        feed.on(\"close\", update);\n        subscriptions.add(feed.off(\"close\", update));\n      }\n    });\n    next({\n      feeds: Array.from(feedMap.values()).map((feed) => ({\n        feedKey: feed.key,\n        length: feed.properties.length\n      }))\n    });\n  };\n  subscriptions.add(feedStore.feedOpened.on(update));\n  update();\n  return () => {\n    subscriptions.clear();\n  };\n});\nvar subscribeToFeedBlocks = ({ feedStore }, { feedKey, maxBlocks = 10 }) => new Stream3(({ next }) => {\n  if (!feedKey) {\n    return;\n  }\n  const subscriptions = new EventSubscriptions2();\n  const timeout = setTimeout(async () => {\n    const feed = feedStore.getFeed(feedKey);\n    if (!feed) {\n      return;\n    }\n    const update = async () => {\n      const iterator = new FeedIterator(feed);\n      await iterator.open();\n      const blocks = [];\n      for await (const block of iterator) {\n        blocks.push(block);\n        if (blocks.length >= feed.properties.length) {\n          break;\n        }\n      }\n      next({\n        blocks: blocks.slice(-maxBlocks)\n      });\n      await iterator.close();\n    };\n    feed.on(\"append\", update);\n    subscriptions.add(() => feed.off(\"append\", update));\n    feed.on(\"truncate\", update);\n    subscriptions.add(() => feed.off(\"truncate\", update));\n    await update();\n  });\n  return () => {\n    subscriptions.clear();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/keys.ts\nimport { Stream as Stream4 } from \"@dxos/codec-protobuf\";\nvar subscribeToKeyringKeys = ({ keyring }) => new Stream4(({ next }) => {\n  const update = () => {\n    next({\n      keys: keyring.list()\n    });\n  };\n  const unsubscribe = keyring.keysUpdate.on(update);\n  update();\n  return unsubscribe;\n});\n\n// packages/sdk/client-services/src/packlets/devtools/network.ts\nimport { Stream as Stream5 } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar subscribeToNetworkStatus = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const status = networkManager.signalManager.getStatus();\n      next({\n        servers: status\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.signalManager.statusChanged.on(update);\n  update();\n});\nvar subscribeToSignalTrace = ({ networkManager }) => new Stream5(({ next }) => {\n  next({\n    events: []\n  });\n  const trace = [];\n  networkManager.signalManager.commandTrace.on((msg) => {\n    trace.push(msg);\n    next({\n      events: trace.map((msg2) => JSON.stringify(msg2))\n    });\n  });\n});\nvar subscribeToNetworkTopics = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const topics = networkManager.topics;\n      const labeledTopics = topics.map((topic) => {\n        var _a, _b;\n        return {\n          topic,\n          label: (_b = (_a = networkManager.getSwarm(topic)) == null ? void 0 : _a.label) != null ? _b : topic.toHex()\n        };\n      });\n      next({\n        topics: labeledTopics\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.topicsUpdated.on(update);\n  update();\n});\nvar subscribeToSwarmInfo = ({ networkManager }) => new Stream5(({ next }) => {\n  var _a;\n  const update = () => {\n    var _a2;\n    const info = (_a2 = networkManager.connectionLog) == null ? void 0 : _a2.swarms;\n    if (info) {\n      next({\n        data: info\n      });\n    }\n  };\n  (_a = networkManager.connectionLog) == null ? void 0 : _a.update.on(update);\n  update();\n});\nvar getNetworkPeers = ({ networkManager }, request) => {\n  if (!request.topic) {\n    throw new Error(\"Expected a network topic\");\n  }\n  const map = networkManager.getSwarmMap(PublicKey2.from(request.topic));\n  return {\n    peers: map == null ? void 0 : map.peers.map((peer) => ({\n      ...peer,\n      connections: peer.connections.map((connection) => connection.asUint8Array())\n    }))\n  };\n};\n\n// packages/sdk/client-services/src/packlets/devtools/spaces.ts\nimport { Stream as Stream6 } from \"@dxos/codec-protobuf\";\nvar subscribeToSpaces = (context, { spaceKeys = [] }) => new Stream6(({ next }) => {\n  let unsubscribe;\n  const update = async () => {\n    const spaces = [\n      ...context.spaceManager.spaces.values()\n    ];\n    const filteredSpaces = spaces.filter((space) => !(spaceKeys == null ? void 0 : spaceKeys.length) || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)));\n    next({\n      spaces: filteredSpaces.map((space) => {\n        const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata2) => spaceMetadata2.key.equals(space.key));\n        return {\n          key: space.key,\n          isOpen: space.isOpen,\n          timeframe: spaceMetadata.latestTimeframe,\n          genesisFeed: space.genesisFeedKey,\n          controlFeed: space.controlFeedKey,\n          dataFeed: space.dataFeedKey\n        };\n      })\n    });\n  };\n  const timeout = setTimeout(async () => {\n    await context.initialized.wait();\n    unsubscribe = context.spaceManager.updated.on(() => update());\n    await update();\n  });\n  return () => {\n    unsubscribe == null ? void 0 : unsubscribe();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nvar DevtoolsHostEvents = class {\n  constructor() {\n    this.ready = new AsyncEvent();\n  }\n};\nvar DevtoolsServiceImpl = class {\n  constructor(params) {\n    this.params = params;\n  }\n  events(request) {\n    return new Stream7(({ next }) => {\n      this.params.events.ready.on(() => {\n        next({\n          ready: {}\n        });\n      });\n    });\n  }\n  getConfig(request) {\n    throw new Error();\n  }\n  resetStorage(request) {\n    throw new Error();\n  }\n  enableDebugLogging(request) {\n    throw new Error();\n  }\n  disableDebugLogging(request) {\n    throw new Error();\n  }\n  subscribeToKeyringKeys(request) {\n    return subscribeToKeyringKeys({\n      keyring: this.params.context.keyring\n    });\n  }\n  subscribeToCredentialMessages(request) {\n    throw new Error();\n  }\n  subscribeToSpaces(request) {\n    return subscribeToSpaces(this.params.context, request);\n  }\n  subscribeToItems(request) {\n    throw new Error();\n  }\n  subscribeToFeeds(request) {\n    return subscribeToFeeds({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  subscribeToFeedBlocks(request) {\n    return subscribeToFeedBlocks({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  getSpaceSnapshot(request) {\n    throw new Error();\n  }\n  saveSpaceSnapshot(request) {\n    throw new Error();\n  }\n  clearSnapshots(request) {\n    throw new Error();\n  }\n  getNetworkPeers(request) {\n    throw new Error();\n  }\n  subscribeToNetworkTopics(request) {\n    throw new Error();\n  }\n  subscribeToSignalStatus(request) {\n    return subscribeToNetworkStatus({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSignalTrace() {\n    return subscribeToSignalTrace({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSwarmInfo() {\n    return subscribeToSwarmInfo({\n      networkManager: this.params.context.networkManager\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/authenticator.ts\nimport { verifyCredential } from \"@dxos/credentials\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar createHaloAuthProvider = (signer) => async (nonce) => {\n  const credential = await signer.createCredential({\n    assertion: {\n      \"@type\": \"dxos.halo.credentials.Auth\"\n    },\n    subject: signer.getIssuer(),\n    nonce\n  });\n  return schema.getCodecForType(\"dxos.halo.credentials.Credential\").encode(credential);\n};\nvar createHaloAuthVerifier = (getDeviceSet) => async (nonce, auth) => {\n  const credential = schema.getCodecForType(\"dxos.halo.credentials.Credential\").decode(auth);\n  const deviceSet = getDeviceSet();\n  const result = await verifyCredential(credential);\n  if (result.kind === \"fail\") {\n    log2(\"Invalid credential\", {\n      result\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 34,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!credential.proof.nonce || !Buffer.from(nonce).equals(credential.proof.nonce)) {\n    log2(\"Invalid nonce\", {\n      nonce,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 39,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!deviceSet.has(credential.issuer)) {\n    log2(\"Device not in allowed set\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 44,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  return true;\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { DeviceStateMachine, createCredentialSignerWithKey, createCredentialSignerWithChain, ProfileStateMachine } from \"@dxos/credentials\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { writeMessages } from \"@dxos/feed-store\";\nimport { log as log3 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar Identity = class {\n  constructor({ space, signer, identityKey, deviceKey }) {\n    this.stateUpdate = new Event();\n    this._space = space;\n    this._signer = signer;\n    this.identityKey = identityKey;\n    this.deviceKey = deviceKey;\n    this._deviceStateMachine = new DeviceStateMachine(this.identityKey, this.deviceKey);\n    this._profileStateMachine = new ProfileStateMachine(this.identityKey);\n    this._space.onCredentialProcessed.set(async (credential) => {\n      await this._deviceStateMachine.process(credential);\n      await this._profileStateMachine.process(credential);\n      this.stateUpdate.emit();\n    });\n  }\n  get authorizedDeviceKeys() {\n    return this._deviceStateMachine.authorizedDeviceKeys;\n  }\n  async open() {\n    await this._space.open();\n  }\n  async close() {\n    await this._space.close();\n  }\n  async ready() {\n    await this._deviceStateMachine.deviceChainReady.wait();\n  }\n  get profileDocument() {\n    return this._profileStateMachine.profile;\n  }\n  get controlPipeline() {\n    return this._space.controlPipeline;\n  }\n  get haloSpaceKey() {\n    return this._space.key;\n  }\n  get haloGenesisFeedKey() {\n    return this._space.genesisFeedKey;\n  }\n  get haloDatabase() {\n    var _a;\n    return (_a = this._space.database) != null ? _a : failUndefined();\n  }\n  getAdmissionCredentials() {\n    return {\n      deviceKey: this.deviceKey,\n      controlFeedKey: this._space.controlFeedKey,\n      dataFeedKey: this._space.dataFeedKey\n    };\n  }\n  getIdentityCredentialSigner() {\n    assert2(this._deviceStateMachine.deviceCredentialChain, \"Device credential chain is not ready.\");\n    return createCredentialSignerWithChain(this._signer, this._deviceStateMachine.deviceCredentialChain, this.deviceKey);\n  }\n  getDeviceCredentialSigner() {\n    return createCredentialSignerWithKey(this._signer, this.deviceKey);\n  }\n  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }) {\n    log3(\"Admitting device:\", {\n      identityKey: this.identityKey,\n      hostDevice: this.deviceKey,\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity.ts\",\n      line: 137,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const signer = this.getIdentityCredentialSigner();\n    await writeMessages(this.controlPipeline.writer, [\n      await signer.createCredential({\n        subject: deviceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n          identityKey: this.identityKey,\n          deviceKey\n        }\n      }),\n      await signer.createCredential({\n        subject: controlFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.CONTROL\n        }\n      }),\n      await signer.createCredential({\n        subject: dataFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.DATA\n        }\n      })\n    ].map((credential) => ({\n      \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n      credential\n    })));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity-manager.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event2 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { MOCK_AUTH_PROVIDER, MOCK_AUTH_VERIFIER, Space, Database, SpaceProtocol } from \"@dxos/echo-db\";\nimport { log as log4 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar IdentityManager = class {\n  constructor(_metadataStore, _feedStore, _keyring, _networkManager, _modelFactory) {\n    this._metadataStore = _metadataStore;\n    this._feedStore = _feedStore;\n    this._keyring = _keyring;\n    this._networkManager = _networkManager;\n    this._modelFactory = _modelFactory;\n    this.stateUpdate = new Event2();\n  }\n  get identity() {\n    return this._identity;\n  }\n  async open() {\n    await this._metadataStore.load();\n    const identityRecord = this._metadataStore.getIdentityRecord();\n    if (identityRecord) {\n      this._identity = await this._constructIdentity(identityRecord);\n      await this._identity.open();\n      await this._identity.ready();\n      this.stateUpdate.emit();\n    }\n  }\n  async close() {\n    var _a;\n    await ((_a = this._identity) == null ? void 0 : _a.close());\n  }\n  async createIdentity({ displayName } = {}) {\n    assert3(!this._identity, \"Identity already exists.\");\n    log4(\"creating identity...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeedKey = await this._keyring.createKey();\n    const identityRecord = {\n      identityKey: await this._keyring.createKey(),\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: await this._keyring.createKey(),\n        genesisFeedKey: controlFeedKey,\n        writeControlFeedKey: controlFeedKey,\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.genesisFeedKey),\n        await generator.createFeedAdmission(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.writeDataFeedKey, AdmittedFeed2.Designation.DATA)\n      ];\n      if (displayName) {\n        credentials.push(await generator.createProfileCredential({\n          displayName\n        }));\n      }\n      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));\n      for (const credential of credentials) {\n        await identity.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this._identity = identity;\n    await this._identity.ready();\n    this.stateUpdate.emit();\n    log4(\"created identity\", {\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return identity;\n  }\n  async acceptIdentity(params) {\n    log4(\"accepting identity\", {\n      params\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 150,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this._identity, \"Identity already exists.\");\n    const identityRecord = {\n      identityKey: params.identityKey,\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: params.haloSpaceKey,\n        genesisFeedKey: params.haloGenesisFeedKey,\n        writeControlFeedKey: await this._keyring.createKey(),\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    this._identity = identity;\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this.stateUpdate.emit();\n    return identity;\n  }\n  async _constructIdentity(identityRecord) {\n    assert3(!this._identity);\n    log4(\"constructing identity\", {\n      identityRecord\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace({\n      spaceRecord: identityRecord.haloSpace,\n      swarmIdentity: {\n        peerKey: identityRecord.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER\n      }\n    });\n    log4(\"done\", {\n      identityKey: identityRecord.identityKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 185,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return new Identity({\n      space,\n      signer: this._keyring,\n      identityKey: identityRecord.identityKey,\n      deviceKey: identityRecord.deviceKey\n    });\n  }\n  async _constructSpace({ spaceRecord, swarmIdentity }) {\n    const controlFeed = await this._feedStore.openFeed(spaceRecord.writeControlFeedKey, {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed(spaceRecord.writeDataFeedKey, {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed(spaceRecord.genesisFeedKey);\n    const protocol = new SpaceProtocol({\n      topic: spaceRecord.spaceKey,\n      identity: swarmIdentity,\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey: spaceRecord.spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, swarmIdentity.peerKey)\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/encoder.ts\nimport base from \"base-x\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar base62 = base(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\nvar codec = schema2.getCodecForType(\"dxos.client.services.Invitation\");\nvar InvitationEncoder = class {\n  static decode(text) {\n    return codec.decode(base62.decode(text));\n  }\n  static encode(invitation) {\n    return base62.encode(codec.encode(invitation));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { scheduleTask, sleep, Trigger } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { generatePasscode } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createTeleportProtocolFactory, StarTopology } from \"@dxos/network-manager\";\nimport { schema as schema3 } from \"@dxos/protocols\";\nimport { Invitation as Invitation2 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse } from \"@dxos/protocols/proto/dxos/halo/invitations\";\n\n// packages/sdk/client-services/src/packlets/invitations/invitations.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { CancellableObservableProvider } from \"@dxos/async\";\nimport { Invitation } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AUTHENTICATION_CODE_LENGTH = 6;\nvar INVITATION_TIMEOUT = 3 * 6e4;\nvar ON_CLOSE_DELAY = 500;\nvar InvitationObservableProvider = class extends CancellableObservableProvider {\n  get invitation() {\n    return this._invitation;\n  }\n  setInvitation(invitation) {\n    this._invitation = invitation;\n  }\n};\nvar AuthenticatingInvitationProvider = class extends InvitationObservableProvider {\n  constructor(_actions) {\n    super(() => this._actions.onCancel());\n    this._actions = _actions;\n  }\n  async authenticate(authenticationCode) {\n    return this._actions.onAuthenticate(authenticationCode);\n  }\n};\nvar wrapObservable = async (observable) => {\n  return new Promise((resolve, reject) => {\n    const unsubscribe = observable.subscribe({\n      onSuccess: (invitation) => {\n        assert4(invitation.state === Invitation.State.SUCCESS);\n        unsubscribe();\n        resolve(invitation);\n      },\n      onError: (err) => {\n        unsubscribe();\n        reject(err);\n      }\n    });\n  });\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts\nvar AbstractInvitationsHandler = class {\n  constructor(_networkManager) {\n    this._networkManager = _networkManager;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/rpc-extension.ts\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar RpcExtension = class {\n  constructor(_params) {\n    this._params = _params;\n  }\n  get initiator() {\n    return this._extensionContext.initiator;\n  }\n  get localPeerId() {\n    return this._extensionContext.localPeerId;\n  }\n  get remotePeerId() {\n    return this._extensionContext.remotePeerId;\n  }\n  get rpc() {\n    return this._rpc.rpc;\n  }\n  async onOpen(context) {\n    this._extensionContext = context;\n    const handlers = await this.getHandlers();\n    const port = context.createPort(\"rpc\", {\n      contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n    });\n    this._rpc = createProtoRpcPeer({\n      ...this._params,\n      handlers,\n      port\n    });\n    await this._rpc.open();\n  }\n  async onClose(err) {\n    await this._rpc.close();\n  }\n  close() {\n    this._extensionContext.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nvar HaloInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _identityManager) {\n    super(networkManager);\n    this._identityManager = _identityManager;\n  }\n  createInvitation(context, options) {\n    var _a;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert5(type !== Invitation2.Type.OFFLINE);\n    const identity = (_a = this._identityManager.identity) != null ? _a : failUndefined2();\n    const invitation = {\n      type,\n      invitationId: PublicKey3.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey3.random(),\n      authenticationCode: generatePasscode(AUTHENTICATION_CODE_LENGTH)\n    };\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const observable = new InvitationObservableProvider(async () => {\n      await ctx.dispose();\n    });\n    let authenticationCode;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const hostInvitationExtension = new HostHaloInvitationExtension({\n        requestAdmission: async () => {\n          var _a2, _b;\n          log5(\"responding with admission offer\", {\n            host: identity.deviceKey\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 84,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          (_b = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b.call(_a2, invitation);\n          return {\n            identityKey: identity.identityKey,\n            haloSpaceKey: identity.haloSpaceKey,\n            genesisFeedKey: identity.haloGenesisFeedKey\n          };\n        },\n        authenticate: async ({ authenticationCode: code }) => {\n          log5(\"received authentication request\", {\n            authenticationCode: code\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 98,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          authenticationCode = code;\n          return {\n            status: AuthenticationResponse.Status.OK\n          };\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          try {\n            if (invitation.type !== Invitation2.Type.INTERACTIVE_TESTING) {\n              if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                throw new Error(`invalid authentication code: ${authenticationCode}`);\n              }\n            }\n            log5(\"writing guest credentials\", {\n              host: identity.deviceKey,\n              guest: credentials.deviceKey\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n              line: 113,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            await identity.admitDevice(credentials);\n            complete.wake(credentials.deviceKey);\n          } catch (err) {\n            observable.callback.onError(err);\n            throw err;\n          }\n        },\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a2, _b;\n            try {\n              log5(\"connected\", {\n                host: identity.deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 129,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a2 = observable.callback).onConnected) == null ? void 0 : _b.call(_a2, invitation);\n              const deviceKey = await complete.wait({\n                timeout\n              });\n              log5(\"admitted guest\", {\n                host: identity.deviceKey,\n                guest: deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 132,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              observable.callback.onSuccess(invitation);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.error(\"failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 136,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await sleep(ON_CLOSE_DELAY);\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return hostInvitationExtension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a2, _b;\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a2 = observable.callback).onConnecting) == null ? void 0 : _b.call(_a2, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const authenticated = new Trigger();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await ctx.dispose();\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const extension = new GuestHaloInvitationExtension({\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a, _b, _c, _d;\n            try {\n              if (++connectionCount > 1) {\n                throw new Error(`multiple connections detected: ${connectionCount}`);\n              }\n              log5(\"connected\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 208,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n              log5(\"sending admission request\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 212,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              const { identityKey, haloSpaceKey, genesisFeedKey } = await extension.rpc.HaloHostService.requestAdmission();\n              if (invitation.type === void 0 || invitation.type === Invitation2.Type.INTERACTIVE) {\n                log5(\"guest waiting for authentication code...\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 219,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n                const authenticationCode = await authenticated.wait({\n                  timeout\n                });\n                log5(\"sending authentication request\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 222,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await extension.rpc.HaloHostService.authenticate({\n                  authenticationCode\n                });\n              }\n              const identity = await this._identityManager.acceptIdentity({\n                identityKey,\n                haloSpaceKey,\n                haloGenesisFeedKey: genesisFeedKey\n              });\n              log5(\"presenting admission credentials\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 235,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              await extension.rpc.HaloHostService.presentAdmissionCredentials(identity.getAdmissionCredentials());\n              log5(\"admitted by host\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 239,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              complete.wake(identityKey);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.warn(\"auth failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 243,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return extension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a, _b;\n      assert5(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey3.random(),\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      invitation.identityKey = await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await ctx.dispose();\n    });\n    return observable;\n  }\n};\nvar HostHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      exposed: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {\n      HaloHostService: {\n        requestAdmission: async () => {\n          return this._callbacks.requestAdmission();\n        },\n        authenticate: async (credentials) => {\n          return this._callbacks.authenticate(credentials);\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          return this._callbacks.presentAdmissionCredentials(credentials);\n        }\n      }\n    };\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\nvar GuestHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      requested: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {};\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { observableError } from \"@dxos/async\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Invitation as Invitation3 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsProxy = class {\n  constructor(_invitationsService) {\n    this._invitationsService = _invitationsService;\n  }\n  createInvitation(context, options) {\n    let invitationId;\n    const observable = new InvitationObservableProvider(async () => {\n      if (invitationId) {\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      }\n    });\n    const invitation = {\n      ...this.getInvitationOptions(context),\n      ...options\n    };\n    const stream = this._invitationsService.createInvitation(invitation);\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          assert6(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 81,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    assert6(invitation && invitation.swarmKey);\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      },\n      onAuthenticate: async (authenticationCode) => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.authenticate({\n          invitationId,\n          authenticationCode\n        });\n      }\n    });\n    const stream = this._invitationsService.acceptInvitation({\n      ...invitation,\n      ...options\n    });\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      assert6(invitation2.invitationId);\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 146,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-proxy.ts\nvar HaloInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions() {\n    return {};\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { Stream as Stream8 } from \"@dxos/codec-protobuf\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Invitation as Invitation4 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsService = class {\n  constructor(_identityManager, _getInvitationsHandler) {\n    this._identityManager = _identityManager;\n    this._getInvitationsHandler = _getInvitationsHandler;\n    this._createInvitations = /* @__PURE__ */ new Map();\n    this._acceptInvitations = /* @__PURE__ */ new Map();\n  }\n  getLoggingContext() {\n    var _a;\n    return {\n      deviceKey: (_a = this._identityManager.identity) == null ? void 0 : _a.deviceKey\n    };\n  }\n  createInvitation(invitation) {\n    return new Stream8(({ next, close }) => {\n      const invitationsHandler = this._getInvitationsHandler();\n      const context = this.getContext(invitation);\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 43,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      let invitationId;\n      const { type, swarmKey } = invitation;\n      const observable = invitationsHandler.createInvitation(context, {\n        type,\n        swarmKey\n      });\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._createInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context2 = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context2,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 92,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context2, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 94,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._createInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  acceptInvitation(invitation, options) {\n    return new Stream8(({ next, close }) => {\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 104,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const invitationsHandler = this._getInvitationsHandler();\n      let invitationId;\n      const observable = invitationsHandler.acceptInvitation(invitation, options);\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._acceptInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 152,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 154,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._acceptInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  async authenticate({ invitationId, authenticationCode }) {\n    log7(\"authenticating...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 163,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitationId);\n    const observable = this._acceptInvitations.get(invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 167,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await observable.authenticate(authenticationCode);\n    }\n  }\n  async cancelInvitation(invitation) {\n    var _a;\n    log7(\"cancelling...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitation.invitationId);\n    const observable = (_a = this._createInvitations.get(invitation.invitationId)) != null ? _a : this._acceptInvitations.get(invitation.invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId: invitation.invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await (observable == null ? void 0 : observable.cancel());\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-service.ts\nvar HaloInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler) {\n    super(identityManager, () => invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n  }\n  getContext(invitation) {\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport { sleep as sleep2, Trigger as Trigger2 } from \"@dxos/async\";\nimport { createAdmissionCredentials, generatePasscode as generatePasscode2 } from \"@dxos/credentials\";\nimport { writeMessages as writeMessages2 } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log8 } from \"@dxos/log\";\nimport { adaptProtocolProvider, createProtocolFactory, StarTopology as StarTopology2 } from \"@dxos/network-manager\";\nimport { createRpcPlugin, RpcPlugin } from \"@dxos/protocol-plugin-rpc\";\nimport { schema as schema4 } from \"@dxos/protocols\";\nimport { Invitation as Invitation5 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse as AuthenticationResponse2 } from \"@dxos/protocols/proto/dxos/halo/invitations\";\nimport { createProtoRpcPeer as createProtoRpcPeer2 } from \"@dxos/rpc\";\nvar MAX_OTP_ATTEMPTS = 3;\nvar SpaceInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _spaceManager, _signingContext) {\n    super(networkManager);\n    this._spaceManager = _spaceManager;\n    this._signingContext = _signingContext;\n  }\n  createInvitation(space, options) {\n    let swarmConnection;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert8(type !== Invitation5.Type.OFFLINE);\n    assert8(space);\n    const invitation = {\n      type,\n      invitationId: PublicKey4.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey4.random(),\n      spaceKey: space.key,\n      authenticationCode: generatePasscode2(AUTHENTICATION_CODE_LENGTH)\n    };\n    const observable = new InvitationObservableProvider(async () => {\n      await (swarmConnection == null ? void 0 : swarmConnection.close());\n    });\n    let authenticationCode;\n    let authenticationRetry = 0;\n    const complete = new Trigger2();\n    const plugin = new RpcPlugin(async (port) => {\n      var _a, _b;\n      let guestProfile;\n      const peer = createProtoRpcPeer2({\n        exposed: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        handlers: {\n          SpaceHostService: {\n            requestAdmission: async ({ profile }) => {\n              var _a2, _b2;\n              log8(\"responding with admission offer\", {\n                guestProfile: profile,\n                host: this._signingContext.deviceKey,\n                spaceKey: space.key\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 89,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              guestProfile = profile;\n              (_b2 = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b2.call(_a2, invitation);\n              return {\n                spaceKey: space.key,\n                genesisFeedKey: space.genesisFeedKey\n              };\n            },\n            authenticate: async ({ authenticationCode: code }) => {\n              log8(\"received authentication request\", {\n                authenticationCode: code\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 107,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              let status = AuthenticationResponse2.Status.OK;\n              if (invitation.authenticationCode) {\n                if (authenticationRetry++ > MAX_OTP_ATTEMPTS) {\n                  status = AuthenticationResponse2.Status.INVALID_OPT_ATTEMPTS;\n                } else if (code !== invitation.authenticationCode) {\n                  status = AuthenticationResponse2.Status.INVALID_OTP;\n                } else {\n                  authenticationCode = code;\n                }\n              }\n              return {\n                status\n              };\n            },\n            presentAdmissionCredentials: async ({ identityKey, deviceKey, controlFeedKey, dataFeedKey }) => {\n              try {\n                if (invitation.type !== Invitation5.Type.INTERACTIVE_TESTING) {\n                  if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                    throw new Error(`invalid authentication code: ${authenticationCode}`);\n                  }\n                }\n                log8(\"writing guest credentials\", {\n                  host: this._signingContext.deviceKey,\n                  guest: deviceKey\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 134,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await writeMessages2(space.controlPipeline.writer, await createAdmissionCredentials(this._signingContext.credentialSigner, identityKey, deviceKey, space.key, controlFeedKey, dataFeedKey, guestProfile));\n                complete.wake(deviceKey);\n              } catch (err) {\n                observable.callback.onError(err);\n                throw err;\n              }\n            }\n          }\n        },\n        port\n      });\n      try {\n        await peer.open();\n        log8(\"connected\", {\n          host: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 164,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        const deviceKey = await complete.wait({\n          timeout\n        });\n        log8(\"admitted guest\", {\n          host: this._signingContext.deviceKey,\n          guest: deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 167,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        observable.callback.onSuccess(invitation);\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.error(\"failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 171,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await sleep2(ON_CLOSE_DELAY);\n        await peer.close();\n        await swarmConnection.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    let swarmConnection;\n    const authenticated = new Trigger2();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await (swarmConnection == null ? void 0 : swarmConnection.close());\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger2();\n    const plugin = createRpcPlugin(async (port) => {\n      var _a, _b, _c, _d;\n      const peer = createProtoRpcPeer2({\n        requested: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        port\n      });\n      try {\n        await peer.open();\n        if (++connectionCount > 1) {\n          throw new Error(`multiple connections detected: ${connectionCount}`);\n        }\n        log8(\"connected\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 235,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        log8(\"sending admission request\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 239,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const { spaceKey, genesisFeedKey } = await peer.rpc.SpaceHostService.requestAdmission({\n          profile: this._signingContext.profile\n        });\n        if (invitation.type === void 0 || invitation.type === Invitation5.Type.INTERACTIVE) {\n          for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {\n            log8(\"guest waiting for authentication code...\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 248,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n            const authenticationCode = await authenticated.wait({\n              timeout\n            });\n            log8(\"sending authentication request\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 252,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            const response = await peer.rpc.SpaceHostService.authenticate({\n              authenticationCode\n            });\n            if (response.status === void 0 || response.status === AuthenticationResponse2.Status.OK) {\n              break;\n            }\n            if (response.status === AuthenticationResponse2.Status.INVALID_OTP) {\n              if (attempt === MAX_OTP_ATTEMPTS) {\n                throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);\n              } else {\n                log8(\"retrying invalid code\", {\n                  attempt\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 262,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                authenticated.reset();\n              }\n            }\n          }\n        }\n        const space = await this._spaceManager.acceptSpace({\n          spaceKey,\n          genesisFeedKey\n        });\n        log8(\"presenting admission credentials\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await peer.rpc.SpaceHostService.presentAdmissionCredentials({\n          identityKey: this._signingContext.identityKey,\n          deviceKey: this._signingContext.deviceKey,\n          controlFeedKey: space.controlFeedKey,\n          dataFeedKey: space.dataFeedKey\n        });\n        log8(\"admitted by host\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 283,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        complete.wake();\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.warn(\"auth failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 287,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await peer.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      assert8(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey4.random(),\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await swarmConnection.close();\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-proxy.ts\nvar SpaceInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions(context) {\n    return {\n      spaceKey: context\n    };\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-service.ts\nimport assert9 from \"@dxos/node-std/assert\";\nvar SpaceInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler, _getSpaceManager) {\n    super(identityManager, invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n    this._getSpaceManager = _getSpaceManager;\n  }\n  getContext(invitation) {\n    assert9(invitation.spaceKey);\n    const spaceManager = this._getSpaceManager();\n    const space = spaceManager.spaces.get(invitation.spaceKey);\n    assert9(space);\n    return space;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-context.ts\nimport { Trigger as Trigger3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nimport { MOCK_AUTH_PROVIDER as MOCK_AUTH_PROVIDER2, MOCK_AUTH_VERIFIER as MOCK_AUTH_VERIFIER2, valueEncoding, DataServiceSubscriptions, MetadataStore, SpaceManager } from \"@dxos/echo-db\";\nimport { FeedFactory, FeedStore } from \"@dxos/feed-store\";\nimport { Keyring } from \"@dxos/keyring\";\nimport { log as log9 } from \"@dxos/log\";\nvar ServiceContext = class {\n  constructor(storage, networkManager, modelFactory) {\n    this.storage = storage;\n    this.networkManager = networkManager;\n    this.modelFactory = modelFactory;\n    this.initialized = new Trigger3();\n    this.dataServiceSubscriptions = new DataServiceSubscriptions();\n    this.metadataStore = new MetadataStore(storage.createDirectory(\"metadata\"));\n    this.keyring = new Keyring(storage.createDirectory(\"keyring\"));\n    this.feedStore = new FeedStore({\n      factory: new FeedFactory({\n        root: storage.createDirectory(\"feeds\"),\n        signer: this.keyring,\n        hypercore: {\n          valueEncoding\n        }\n      })\n    });\n    this.identityManager = new IdentityManager(this.metadataStore, this.feedStore, this.keyring, networkManager, modelFactory);\n    this.haloInvitations = new HaloInvitationsHandler(this.networkManager, this.identityManager);\n  }\n  async open() {\n    log9(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 78,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.open();\n    if (this.identityManager.identity) {\n      await this._initialize();\n    }\n    log9(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    log9(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 87,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.close();\n    await ((_a = this.spaceManager) == null ? void 0 : _a.close());\n    await this.feedStore.close();\n    await this.networkManager.close();\n    this.dataServiceSubscriptions.clear();\n    log9(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async reset() {\n    log9(\"resetting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.close();\n    await this.storage.reset();\n    log9(\"reset\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async createIdentity(params = {}) {\n    const identity = await this.identityManager.createIdentity(params);\n    this.dataServiceSubscriptions.registerSpace(identity.haloSpaceKey, identity.haloDatabase.createDataServiceHost());\n    await this._initialize();\n    return identity;\n  }\n  async _initialize() {\n    var _a;\n    const identity = (_a = this.identityManager.identity) != null ? _a : failUndefined3();\n    const signingContext = {\n      credentialProvider: MOCK_AUTH_PROVIDER2,\n      credentialAuthenticator: MOCK_AUTH_VERIFIER2,\n      credentialSigner: identity.getIdentityCredentialSigner(),\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey,\n      profile: identity.profileDocument\n    };\n    const spaceManager = new SpaceManager({\n      metadataStore: this.metadataStore,\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      keyring: this.keyring,\n      dataServiceSubscriptions: this.dataServiceSubscriptions,\n      modelFactory: this.modelFactory,\n      signingContext\n    });\n    await spaceManager.open();\n    this.spaceManager = spaceManager;\n    this.spaceInvitations = new SpaceInvitationsHandler(this.networkManager, this.spaceManager, signingContext);\n    this.initialized.wake();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-definitions.ts\nimport { schema as schema5 } from \"@dxos/protocols\";\nimport { createServiceBundle } from \"@dxos/rpc\";\nvar clientServiceBundle = createServiceBundle({\n  HaloInvitationsService: schema5.getService(\"dxos.client.services.HaloInvitationsService\"),\n  DevicesService: schema5.getService(\"dxos.client.services.DevicesService\"),\n  SpaceInvitationsService: schema5.getService(\"dxos.client.services.SpaceInvitationsService\"),\n  SpacesService: schema5.getService(\"dxos.client.services.SpacesService\"),\n  SpaceService: schema5.getService(\"dxos.client.SpaceService\"),\n  DataService: schema5.getService(\"dxos.echo.service.DataService\"),\n  ProfileService: schema5.getService(\"dxos.client.ProfileService\"),\n  SystemService: schema5.getService(\"dxos.client.SystemService\"),\n  DevtoolsHost: schema5.getService(\"dxos.devtools.host.DevtoolsHost\"),\n  TracingService: schema5.getService(\"dxos.devtools.host.TracingService\")\n});\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nimport { raise } from \"@dxos/debug\";\nimport { DataServiceImpl } from \"@dxos/echo-db\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ModelFactory } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nimport { TextModel } from \"@dxos/text-model\";\n\n// packages/sdk/client-services/src/packlets/identity/devices-service-impl.ts\nimport { EventSubscriptions as EventSubscriptions3 } from \"@dxos/async\";\nimport { Stream as Stream9 } from \"@dxos/codec-protobuf\";\nvar DevicesServiceImpl = class {\n  constructor(_identityManager) {\n    this._identityManager = _identityManager;\n  }\n  updateDevice() {\n    throw new Error(\"Method not implemented.\");\n  }\n  queryDevices() {\n    return new Stream9(({ next }) => {\n      const update = () => {\n        var _a;\n        const deviceKeys = (_a = this._identityManager.identity) == null ? void 0 : _a.authorizedDeviceKeys;\n        if (!deviceKeys) {\n          next({\n            devices: []\n          });\n        } else {\n          next({\n            devices: Array.from(deviceKeys.values()).map((key) => ({\n              deviceKey: key\n            }))\n          });\n        }\n      };\n      const dispose = new EventSubscriptions3();\n      dispose.add(this._identityManager.stateUpdate.on(() => {\n        update();\n        if (this._identityManager.identity) {\n          dispose.add(this._identityManager.identity.stateUpdate.on(() => {\n            update();\n          }));\n        }\n      }));\n      update();\n      return () => dispose.clear();\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/spaces/spaces-service.ts\nvar SpacesServiceImpl = class {\n  async createSpace() {\n    throw new Error();\n  }\n  querySpaces() {\n    throw new Error();\n  }\n  queryMembers(query) {\n    throw new Error();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/storage/storage.ts\nimport jsondown from \"jsondown\";\nimport leveljs from \"level-js\";\nimport memdown from \"memdown\";\nimport { InvalidConfigError } from \"@dxos/errors\";\nimport { Runtime } from \"@dxos/protocols/proto/dxos/config\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { isNode } from \"@dxos/util\";\nvar StorageDriver = Runtime.Client.Storage.StorageDriver;\nvar createStorageObjects = (config) => {\n  const { path = \"dxos/storage\", storageType, keyStorage, persistent = false } = config != null ? config : {};\n  if (persistent && storageType === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && storageType !== void 0 && storageType !== StorageDriver.RAM) {\n    throw new InvalidConfigError(\"Cannot use a persistent storage in not persistent mode.\");\n  }\n  if (persistent && keyStorage === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM key storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && keyStorage !== StorageDriver.RAM && keyStorage !== void 0) {\n    throw new InvalidConfigError(\"Cannot use a persistent key storage in not persistent mode.\");\n  }\n  return {\n    storage: createStorage({\n      type: persistent ? toStorageType(storageType) : StorageType.RAM,\n      root: `${path}/`\n    }),\n    keyStorage: createKeyStorage(`${path}/keystore`, persistent ? toKeyStorageType(keyStorage) : \"ram\")\n  };\n};\nvar createKeyStorage = (path, type) => {\n  const defaultedType = type != null ? type : isNode() ? \"jsondown\" : \"leveljs\";\n  switch (defaultedType) {\n    case \"leveljs\":\n      return leveljs(path);\n    case \"jsondown\":\n      return jsondown(path);\n    case \"ram\":\n      return memdown();\n    default:\n      throw new InvalidConfigError(`Invalid key storage type: ${defaultedType}`);\n  }\n};\nvar toStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return StorageType.RAM;\n    case StorageDriver.CHROME:\n      return StorageType.CHROME;\n    case StorageDriver.FIREFOX:\n      return StorageType.FIREFOX;\n    case StorageDriver.IDB:\n      return StorageType.IDB;\n    case StorageDriver.NODE:\n      return StorageType.NODE;\n    default:\n      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);\n  }\n};\nvar toKeyStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return \"ram\";\n    case StorageDriver.LEVELJS:\n      return \"leveljs\";\n    case StorageDriver.JSONDOWN:\n      return \"jsondown\";\n    default:\n      throw new Error(`Invalid key storage type: ${StorageDriver[type]}`);\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-registry.ts\nvar ServiceRegistry = class {\n  constructor(_serviceBundle, _handlers) {\n    this._serviceBundle = _serviceBundle;\n    this._handlers = _handlers;\n  }\n  get descriptors() {\n    return this._serviceBundle;\n  }\n  get services() {\n    return this._handlers;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nvar createDefaultModelFactory = () => {\n  return new ModelFactory().registerModel(ObjectModel).registerModel(TextModel);\n};\nvar ClientServicesHost = class {\n  constructor({\n    config,\n    modelFactory = createDefaultModelFactory(),\n    networkManager\n  }) {\n    this._config = config;\n    this._modelFactory = modelFactory;\n    this._networkManager = networkManager;\n  }\n  get descriptors() {\n    return this._serviceRegistry.descriptors;\n  }\n  get services() {\n    return this._serviceRegistry.services;\n  }\n  async open() {\n    var _a;\n    await this._initialize();\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"opening...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._initialize();\n    await this._serviceContext.open();\n    log10(\"opened\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"closing...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._serviceContext.close();\n    log10(\"closed\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 79,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _initialize() {\n    const { storage } = createStorageObjects(this._config.get(\"runtime.client.storage\", {}));\n    this._serviceContext = new ServiceContext(storage, this._networkManager, this._modelFactory);\n    this._serviceRegistry = new ServiceRegistry(clientServiceBundle, {\n      HaloInvitationsService: new HaloInvitationsServiceImpl(this._serviceContext.identityManager, this._serviceContext.haloInvitations),\n      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager),\n      SpaceInvitationsService: new SpaceInvitationsServiceImpl(this._serviceContext.identityManager, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceInvitations) != null ? _a : raise(new Error(\"SpaceInvitations not initialized\"));\n      }, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceManager) != null ? _a : raise(new Error(\"SpaceManager not initialized\"));\n      }),\n      SpacesService: new SpacesServiceImpl(),\n      DataService: new DataServiceImpl(this._serviceContext.dataServiceSubscriptions),\n      ProfileService: new ProfileServiceImpl(this._serviceContext),\n      SpaceService: new SpaceServiceImpl(this._serviceContext),\n      SystemService: new SystemServiceImpl(this._config, this._serviceContext),\n      TracingService: new TracingServiceImpl(this._config),\n      DevtoolsHost: new DevtoolsServiceImpl({\n        events: new DevtoolsHostEvents(),\n        config: this._config,\n        context: this._serviceContext\n      })\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-proxy.ts\nimport { asyncTimeout } from \"@dxos/async\";\nimport { RemoteServiceConnectionTimeout } from \"@dxos/errors\";\nimport { createProtoRpcPeer as createProtoRpcPeer3 } from \"@dxos/rpc\";\nvar ClientServicesProxy = class {\n  constructor(port, _timeout = 3e4) {\n    this._timeout = _timeout;\n    this._proxy = createProtoRpcPeer3({\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n      port\n    });\n  }\n  get proxy() {\n    return this._proxy;\n  }\n  get descriptors() {\n    return clientServiceBundle;\n  }\n  get services() {\n    return this._proxy.rpc;\n  }\n  async open() {\n    await asyncTimeout(this._proxy.open(), this._timeout, new RemoteServiceConnectionTimeout());\n  }\n  async close() {\n    await this._proxy.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nimport { WebRTCTransportService } from \"@dxos/network-manager\";\nimport { createProtoRpcPeer as createProtoRpcPeer4 } from \"@dxos/rpc\";\n\n// packages/sdk/client-services/src/packlets/vault/services.ts\nimport { schema as schema6 } from \"@dxos/protocols\";\nvar iframeServiceBundle = {\n  IframeService: schema6.getService(\"dxos.iframe.IframeService\"),\n  BridgeService: schema6.getService(\"dxos.mesh.bridge.BridgeService\")\n};\nvar workerServiceBundle = {\n  WorkerService: schema6.getService(\"dxos.iframe.WorkerService\")\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nvar IFrameRuntime = class {\n  constructor({ systemPort, workerAppPort, windowAppPort }) {\n    this._transportService = new WebRTCTransportService();\n    this._systemPort = systemPort;\n    this._windowAppPort = windowAppPort;\n    this._workerAppPort = workerAppPort;\n    this._systemRpc = createProtoRpcPeer4({\n      requested: workerServiceBundle,\n      exposed: iframeServiceBundle,\n      handlers: {\n        BridgeService: this._transportService,\n        IframeService: {\n          async heartbeat() {\n          }\n        }\n      },\n      port: this._systemPort,\n      timeout: 200\n    });\n    this._workerAppPort.subscribe((msg) => this._windowAppPort.send(msg));\n    this._windowAppPort.subscribe((msg) => this._workerAppPort.send(msg));\n  }\n  async open(origin) {\n    await this._systemRpc.open();\n    await this._systemRpc.rpc.WorkerService.start({\n      origin\n    });\n  }\n  async close() {\n    await this._systemRpc.rpc.WorkerService.stop();\n    await this._systemRpc.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nimport { Trigger as Trigger5 } from \"@dxos/async\";\nimport { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from \"@dxos/messaging\";\nimport { NetworkManager, WebRTCTransportProxyFactory } from \"@dxos/network-manager\";\n\n// packages/sdk/client-services/src/packlets/vault/worker-session.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger4 } from \"@dxos/async\";\nimport { log as log11, logInfo } from \"@dxos/log\";\nimport { createProtoRpcPeer as createProtoRpcPeer5 } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WorkerSession = class {\n  constructor({ getServices, systemPort, appPort, options = {\n    heartbeatInterval: 1e3\n  } }) {\n    this._startTrigger = new Trigger4();\n    this.onClose = new Callback();\n    assert10(options);\n    assert10(getServices);\n    this._options = options;\n    this._getServices = getServices;\n    this._clientRpc = createProtoRpcPeer5({\n      exposed: clientServiceBundle,\n      handlers: {\n        HaloInvitationsService: async () => (await this._getServices()).services.HaloInvitationsService,\n        DevicesService: async () => (await this._getServices()).services.DevicesService,\n        SpaceInvitationsService: async () => (await this._getServices()).services.SpaceInvitationsService,\n        SpacesService: async () => (await this._getServices()).services.SpacesService,\n        SpaceService: async () => (await this._getServices()).services.SpaceService,\n        DataService: async () => (await this._getServices()).services.DataService,\n        ProfileService: async () => (await this._getServices()).services.ProfileService,\n        SystemService: async () => (await this._getServices()).services.SystemService,\n        DevtoolsHost: async () => (await this._getServices()).services.DevtoolsHost,\n        TracingService: async () => (await this._getServices()).services.TracingService\n      },\n      port: appPort\n    });\n    this._iframeRpc = createProtoRpcPeer5({\n      requested: iframeServiceBundle,\n      exposed: workerServiceBundle,\n      handlers: {\n        WorkerService: {\n          start: async (request) => {\n            this.origin = request.origin;\n            this._startTrigger.wake();\n          },\n          stop: async () => {\n            setTimeout(async () => {\n              try {\n                await this.close();\n              } catch (err) {\n                log11.catch(err, {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n                  line: 89,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n              }\n            });\n          }\n        }\n      },\n      port: systemPort,\n      timeout: 1e3\n    });\n    this.bridgeService = this._iframeRpc.rpc.BridgeService;\n  }\n  async open() {\n    log11.info(\"opening..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 103,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      this._clientRpc.open(),\n      this._iframeRpc.open()\n    ]);\n    await this._startTrigger.wait({\n      timeout: 3e3\n    });\n    this._heartbeatTimer = setInterval(async () => {\n      try {\n        await this._iframeRpc.rpc.IframeService.heartbeat();\n      } catch (err1) {\n        log11.warn(\"Heartbeat failed\", {\n          err: err1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n          line: 115,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          await this.close();\n        } catch (err) {\n          log11.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n            line: 119,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, this._options.heartbeatInterval);\n  }\n  async close() {\n    log11.info(\"closing..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this.onClose.callIfSet();\n    } catch (err) {\n      log11.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    if (this._heartbeatTimer !== void 0) {\n      clearInterval(this._heartbeatTimer);\n    }\n    await Promise.all([\n      this._clientRpc.close(),\n      this._iframeRpc.close()\n    ]);\n  }\n};\n__decorate([\n  logInfo\n], WorkerSession.prototype, \"origin\", void 0);\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nvar WorkerRuntime = class {\n  constructor(_configProvider) {\n    this._configProvider = _configProvider;\n    this._transportFactory = new WebRTCTransportProxyFactory();\n    this._ready = new Trigger5();\n    this.sessions = /* @__PURE__ */ new Set();\n  }\n  async start() {\n    try {\n      this._config = await this._configProvider();\n      const signalServer = this._config.get(\"runtime.services.signal.server\");\n      this._clientServices = new ClientServicesHost({\n        config: this._config,\n        networkManager: new NetworkManager({\n          log: true,\n          signalManager: signalServer ? new WebsocketSignalManager([\n            signalServer\n          ]) : new MemorySignalManager(new MemorySignalManagerContext()),\n          transportFactory: this._transportFactory\n        })\n      });\n      await this._clientServices.open();\n      this._ready.wake(void 0);\n    } catch (err) {\n      this._ready.wake(err);\n    }\n  }\n  async stop() {\n    await this._clientServices.close();\n  }\n  async createSession({ appPort, systemPort }) {\n    const session = new WorkerSession({\n      getServices: async () => {\n        const error = await this._ready.wait();\n        if (error !== void 0) {\n          throw error;\n        }\n        return this._clientServices;\n      },\n      appPort,\n      systemPort,\n      readySignal: this._ready\n    });\n    session.onClose.set(async () => {\n      this.sessions.delete(session);\n      this._reconnectWebrtc();\n    });\n    await session.open();\n    this.sessions.add(session);\n    this._reconnectWebrtc();\n  }\n  _reconnectWebrtc() {\n    if (this._sessionForNetworking) {\n      if (!this.sessions.has(this._sessionForNetworking)) {\n        this._sessionForNetworking = void 0;\n      }\n    }\n    if (!this._sessionForNetworking) {\n      const selected = Array.from(this.sessions).find((session) => session.bridgeService);\n      if (selected) {\n        this._sessionForNetworking = selected;\n        this._transportFactory.setBridgeService(selected.bridgeService);\n      } else {\n        this._transportFactory.setBridgeService(void 0);\n      }\n    }\n  }\n};\nexport {\n  AUTHENTICATION_CODE_LENGTH,\n  AbstractInvitationsHandler,\n  AbstractInvitationsProxy,\n  AbstractInvitationsService,\n  AuthenticatingInvitationProvider,\n  ClientServicesHost,\n  ClientServicesProxy,\n  DevtoolsHostEvents,\n  DevtoolsServiceImpl,\n  HaloInvitationsHandler,\n  HaloInvitationsProxy,\n  HaloInvitationsServiceImpl,\n  IFrameRuntime,\n  INVITATION_TIMEOUT,\n  Identity,\n  IdentityManager,\n  InvitationEncoder,\n  InvitationObservableProvider,\n  ON_CLOSE_DELAY,\n  ProfileServiceImpl,\n  ServiceContext,\n  ServiceRegistry,\n  SpaceInvitationsHandler,\n  SpaceInvitationsProxy,\n  SpaceInvitationsServiceImpl,\n  SpaceServiceImpl,\n  SystemServiceImpl,\n  TracingServiceImpl,\n  WorkerRuntime,\n  WorkerSession,\n  clientServiceBundle,\n  createDefaultModelFactory,\n  createHaloAuthProvider,\n  createHaloAuthVerifier,\n  createStorageObjects,\n  getNetworkPeers,\n  subscribeToFeedBlocks,\n  subscribeToFeeds,\n  subscribeToNetworkStatus,\n  subscribeToNetworkTopics,\n  subscribeToSignalTrace,\n  subscribeToSpaces,\n  subscribeToSwarmInfo,\n  wrapObservable\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466119,"end":1670465466119,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/sdk/client-services/src/packlets/deprecated/space.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { todo } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { humanize } from \"@dxos/util\";\nvar SpaceServiceImpl = class {\n  constructor(serviceContext) {\n    this.serviceContext = serviceContext;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeToSpace(request) {\n    return new Stream(({ next }) => {\n      next({\n        space: {\n          publicKey: request.spaceKey,\n          isOpen: true,\n          isActive: true,\n          members: []\n        }\n      });\n    });\n  }\n  subscribeSpaces() {\n    return new Stream(({ next }) => {\n      const subscriptions = new EventSubscriptions();\n      const onUpdate = () => {\n        const spaces = Array.from(this.serviceContext.spaceManager.spaces.values()).map((space) => ({\n          publicKey: space.key,\n          isOpen: true,\n          isActive: true,\n          members: Array.from(space.spaceState.members.values()).map((member) => {\n            var _a, _b;\n            return {\n              identityKey: member.key,\n              profile: {\n                identityKey: member.key,\n                displayName: (_b = (_a = member.assertion.profile) == null ? void 0 : _a.displayName) != null ? _b : humanize(member.key)\n              }\n            };\n          })\n        }));\n        log(\"update\", {\n          spaces\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/deprecated/space.ts\",\n          line: 114,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        next({\n          spaces\n        });\n      };\n      setTimeout(async () => {\n        if (!this.serviceContext.spaceManager) {\n          next({\n            spaces: []\n          });\n        }\n        await this.serviceContext.initialized.wait();\n        subscriptions.add(this.serviceContext.spaceManager.updated.on(() => {\n          this.serviceContext.spaceManager.spaces.forEach((space) => {\n            subscriptions.add(space.stateUpdate.on(onUpdate));\n          });\n          onUpdate();\n        }));\n        this.serviceContext.spaceManager.spaces.forEach((space) => {\n          subscriptions.add(space.stateUpdate.on(onUpdate));\n        });\n        onUpdate();\n      });\n      return () => subscriptions.clear();\n    });\n  }\n  async getSpaceDetails(request) {\n    return todo();\n  }\n  async createSpace() {\n    await this.serviceContext.initialized.wait();\n    const space = await this.serviceContext.spaceManager.createSpace();\n    return {\n      publicKey: space.key,\n      isOpen: true,\n      isActive: true\n    };\n  }\n  async cloneSpace(snapshot) {\n    return todo();\n  }\n  async setSpaceState(request) {\n    return todo();\n  }\n  async authenticateInvitation(request) {\n    var _a;\n    assert(request.processId, \"Process ID is missing.\");\n    const invitation = this.inviteeInvitations.get(request.processId);\n    assert(invitation, \"Invitation not found.\");\n    assert(request.secret, \"Secret not provided.\");\n    invitation.secret = request.secret;\n    (_a = invitation.secretTrigger) == null ? void 0 : _a.call(invitation);\n  }\n  subscribeMembers(request) {\n    return todo();\n  }\n  async createSnapshot(request) {\n    return todo();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/profile.ts\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { todo as todo2 } from \"@dxos/debug\";\nvar ProfileServiceImpl = class {\n  constructor(context) {\n    this.context = context;\n    this.inviteeInvitations = /* @__PURE__ */ new Map();\n  }\n  subscribeProfile() {\n    return new Stream2(({ next }) => {\n      const emitNext = () => {\n        var _a;\n        return next({\n          profile: this.context.identityManager.identity ? {\n            identityKey: this.context.identityManager.identity.identityKey,\n            deviceKey: this.context.identityManager.identity.deviceKey,\n            displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n          } : void 0\n        });\n      };\n      emitNext();\n      return this.context.identityManager.stateUpdate.on(emitNext);\n    });\n  }\n  async createProfile(request) {\n    var _a;\n    await this.context.createIdentity({\n      displayName: request.displayName\n    });\n    return {\n      identityKey: this.context.identityManager.identity.identityKey,\n      deviceKey: this.context.identityManager.identity.deviceKey,\n      displayName: (_a = this.context.identityManager.identity.profileDocument) == null ? void 0 : _a.displayName\n    };\n  }\n  async recoverProfile(request) {\n    return todo2();\n    if (!request.seedPhrase) {\n      throw new Error(\"Recovery SeedPhrase not provided.\");\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/system.ts\nvar SystemServiceImpl = class {\n  constructor(_config, _serviceContext) {\n    this._config = _config;\n    this._serviceContext = _serviceContext;\n  }\n  async initSession() {\n  }\n  async getConfig(request) {\n    return this._config.values;\n  }\n  async getStatus(request) {\n    return {\n      message: `ok: ${Date.now()}`\n    };\n  }\n  async reset(request) {\n    await this._serviceContext.reset();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/deprecated/tracing.ts\nvar TracingServiceImpl = class {\n  constructor(_config) {\n    this._config = _config;\n  }\n  async setTracingOptions() {\n    throw new Error(\"Tracing not available.\");\n  }\n  subscribeToRpcTrace() {\n    throw new Error(\"Tracing not available.\");\n  }\n};\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nimport { Event as AsyncEvent } from \"@dxos/async\";\nimport { Stream as Stream7 } from \"@dxos/codec-protobuf\";\n\n// packages/sdk/client-services/src/packlets/devtools/feeds.ts\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\nimport { Stream as Stream3 } from \"@dxos/codec-protobuf\";\nimport { FeedIterator } from \"@dxos/feed-store\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar subscribeToFeeds = ({ feedStore }, { feedKeys }) => new Stream3(({ next }) => {\n  if ((feedKeys == null ? void 0 : feedKeys.length) === 0) {\n    return;\n  }\n  const feedMap = new ComplexMap(PublicKey.hash);\n  const subscriptions = new EventSubscriptions2();\n  const update = () => {\n    const feeds = feedStore.feeds;\n    feeds.filter((feed) => !(feedKeys == null ? void 0 : feedKeys.length) || feedKeys.some((feedKey) => feedKey.equals(feed.key))).forEach((feed) => {\n      if (!feedMap.has(feed.key)) {\n        feedMap.set(feed.key, feed);\n        feed.on(\"close\", update);\n        subscriptions.add(feed.off(\"close\", update));\n      }\n    });\n    next({\n      feeds: Array.from(feedMap.values()).map((feed) => ({\n        feedKey: feed.key,\n        length: feed.properties.length\n      }))\n    });\n  };\n  subscriptions.add(feedStore.feedOpened.on(update));\n  update();\n  return () => {\n    subscriptions.clear();\n  };\n});\nvar subscribeToFeedBlocks = ({ feedStore }, { feedKey, maxBlocks = 10 }) => new Stream3(({ next }) => {\n  if (!feedKey) {\n    return;\n  }\n  const subscriptions = new EventSubscriptions2();\n  const timeout = setTimeout(async () => {\n    const feed = feedStore.getFeed(feedKey);\n    if (!feed) {\n      return;\n    }\n    const update = async () => {\n      const iterator = new FeedIterator(feed);\n      await iterator.open();\n      const blocks = [];\n      for await (const block of iterator) {\n        blocks.push(block);\n        if (blocks.length >= feed.properties.length) {\n          break;\n        }\n      }\n      next({\n        blocks: blocks.slice(-maxBlocks)\n      });\n      await iterator.close();\n    };\n    feed.on(\"append\", update);\n    subscriptions.add(() => feed.off(\"append\", update));\n    feed.on(\"truncate\", update);\n    subscriptions.add(() => feed.off(\"truncate\", update));\n    await update();\n  });\n  return () => {\n    subscriptions.clear();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/keys.ts\nimport { Stream as Stream4 } from \"@dxos/codec-protobuf\";\nvar subscribeToKeyringKeys = ({ keyring }) => new Stream4(({ next }) => {\n  const update = () => {\n    next({\n      keys: keyring.list()\n    });\n  };\n  const unsubscribe = keyring.keysUpdate.on(update);\n  update();\n  return unsubscribe;\n});\n\n// packages/sdk/client-services/src/packlets/devtools/network.ts\nimport { Stream as Stream5 } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar subscribeToNetworkStatus = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const status = networkManager.signalManager.getStatus();\n      next({\n        servers: status\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.signalManager.statusChanged.on(update);\n  update();\n});\nvar subscribeToSignalTrace = ({ networkManager }) => new Stream5(({ next }) => {\n  next({\n    events: []\n  });\n  const trace = [];\n  networkManager.signalManager.commandTrace.on((msg) => {\n    trace.push(msg);\n    next({\n      events: trace.map((msg2) => JSON.stringify(msg2))\n    });\n  });\n});\nvar subscribeToNetworkTopics = ({ networkManager }) => new Stream5(({ next, close }) => {\n  const update = () => {\n    try {\n      const topics = networkManager.topics;\n      const labeledTopics = topics.map((topic) => {\n        var _a, _b;\n        return {\n          topic,\n          label: (_b = (_a = networkManager.getSwarm(topic)) == null ? void 0 : _a.label) != null ? _b : topic.toHex()\n        };\n      });\n      next({\n        topics: labeledTopics\n      });\n    } catch (err) {\n      close(err);\n    }\n  };\n  networkManager.topicsUpdated.on(update);\n  update();\n});\nvar subscribeToSwarmInfo = ({ networkManager }) => new Stream5(({ next }) => {\n  var _a;\n  const update = () => {\n    var _a2;\n    const info = (_a2 = networkManager.connectionLog) == null ? void 0 : _a2.swarms;\n    if (info) {\n      next({\n        data: info\n      });\n    }\n  };\n  (_a = networkManager.connectionLog) == null ? void 0 : _a.update.on(update);\n  update();\n});\nvar getNetworkPeers = ({ networkManager }, request) => {\n  if (!request.topic) {\n    throw new Error(\"Expected a network topic\");\n  }\n  const map = networkManager.getSwarmMap(PublicKey2.from(request.topic));\n  return {\n    peers: map == null ? void 0 : map.peers.map((peer) => ({\n      ...peer,\n      connections: peer.connections.map((connection) => connection.asUint8Array())\n    }))\n  };\n};\n\n// packages/sdk/client-services/src/packlets/devtools/spaces.ts\nimport { Stream as Stream6 } from \"@dxos/codec-protobuf\";\nvar subscribeToSpaces = (context, { spaceKeys = [] }) => new Stream6(({ next }) => {\n  let unsubscribe;\n  const update = async () => {\n    const spaces = [\n      ...context.spaceManager.spaces.values()\n    ];\n    const filteredSpaces = spaces.filter((space) => !(spaceKeys == null ? void 0 : spaceKeys.length) || spaceKeys.some((spaceKey) => spaceKey.equals(space.key)));\n    next({\n      spaces: filteredSpaces.map((space) => {\n        const spaceMetadata = context.metadataStore.spaces.find((spaceMetadata2) => spaceMetadata2.key.equals(space.key));\n        return {\n          key: space.key,\n          isOpen: space.isOpen,\n          timeframe: spaceMetadata.latestTimeframe,\n          genesisFeed: space.genesisFeedKey,\n          controlFeed: space.controlFeedKey,\n          dataFeed: space.dataFeedKey\n        };\n      })\n    });\n  };\n  const timeout = setTimeout(async () => {\n    await context.initialized.wait();\n    unsubscribe = context.spaceManager.updated.on(() => update());\n    await update();\n  });\n  return () => {\n    unsubscribe == null ? void 0 : unsubscribe();\n    clearTimeout(timeout);\n  };\n});\n\n// packages/sdk/client-services/src/packlets/devtools/devtools.ts\nvar DevtoolsHostEvents = class {\n  constructor() {\n    this.ready = new AsyncEvent();\n  }\n};\nvar DevtoolsServiceImpl = class {\n  constructor(params) {\n    this.params = params;\n  }\n  events(request) {\n    return new Stream7(({ next }) => {\n      this.params.events.ready.on(() => {\n        next({\n          ready: {}\n        });\n      });\n    });\n  }\n  getConfig(request) {\n    throw new Error();\n  }\n  resetStorage(request) {\n    throw new Error();\n  }\n  enableDebugLogging(request) {\n    throw new Error();\n  }\n  disableDebugLogging(request) {\n    throw new Error();\n  }\n  subscribeToKeyringKeys(request) {\n    return subscribeToKeyringKeys({\n      keyring: this.params.context.keyring\n    });\n  }\n  subscribeToCredentialMessages(request) {\n    throw new Error();\n  }\n  subscribeToSpaces(request) {\n    return subscribeToSpaces(this.params.context, request);\n  }\n  subscribeToItems(request) {\n    throw new Error();\n  }\n  subscribeToFeeds(request) {\n    return subscribeToFeeds({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  subscribeToFeedBlocks(request) {\n    return subscribeToFeedBlocks({\n      feedStore: this.params.context.feedStore\n    }, request);\n  }\n  getSpaceSnapshot(request) {\n    throw new Error();\n  }\n  saveSpaceSnapshot(request) {\n    throw new Error();\n  }\n  clearSnapshots(request) {\n    throw new Error();\n  }\n  getNetworkPeers(request) {\n    throw new Error();\n  }\n  subscribeToNetworkTopics(request) {\n    throw new Error();\n  }\n  subscribeToSignalStatus(request) {\n    return subscribeToNetworkStatus({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSignalTrace() {\n    return subscribeToSignalTrace({\n      networkManager: this.params.context.networkManager\n    });\n  }\n  subscribeToSwarmInfo() {\n    return subscribeToSwarmInfo({\n      networkManager: this.params.context.networkManager\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/authenticator.ts\nimport { verifyCredential } from \"@dxos/credentials\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar createHaloAuthProvider = (signer) => async (nonce) => {\n  const credential = await signer.createCredential({\n    assertion: {\n      \"@type\": \"dxos.halo.credentials.Auth\"\n    },\n    subject: signer.getIssuer(),\n    nonce\n  });\n  return schema.getCodecForType(\"dxos.halo.credentials.Credential\").encode(credential);\n};\nvar createHaloAuthVerifier = (getDeviceSet) => async (nonce, auth) => {\n  const credential = schema.getCodecForType(\"dxos.halo.credentials.Credential\").decode(auth);\n  const deviceSet = getDeviceSet();\n  const result = await verifyCredential(credential);\n  if (result.kind === \"fail\") {\n    log2(\"Invalid credential\", {\n      result\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 34,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!credential.proof.nonce || !Buffer.from(nonce).equals(credential.proof.nonce)) {\n    log2(\"Invalid nonce\", {\n      nonce,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 39,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  if (!deviceSet.has(credential.issuer)) {\n    log2(\"Device not in allowed set\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/authenticator.ts\",\n      line: 44,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return false;\n  }\n  return true;\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { DeviceStateMachine, createCredentialSignerWithKey, createCredentialSignerWithChain, ProfileStateMachine } from \"@dxos/credentials\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { writeMessages } from \"@dxos/feed-store\";\nimport { log as log3 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar Identity = class {\n  constructor({ space, signer, identityKey, deviceKey }) {\n    this.stateUpdate = new Event();\n    this._space = space;\n    this._signer = signer;\n    this.identityKey = identityKey;\n    this.deviceKey = deviceKey;\n    this._deviceStateMachine = new DeviceStateMachine(this.identityKey, this.deviceKey);\n    this._profileStateMachine = new ProfileStateMachine(this.identityKey);\n    this._space.onCredentialProcessed.set(async (credential) => {\n      await this._deviceStateMachine.process(credential);\n      await this._profileStateMachine.process(credential);\n      this.stateUpdate.emit();\n    });\n  }\n  get authorizedDeviceKeys() {\n    return this._deviceStateMachine.authorizedDeviceKeys;\n  }\n  async open() {\n    await this._space.open();\n  }\n  async close() {\n    await this._space.close();\n  }\n  async ready() {\n    await this._deviceStateMachine.deviceChainReady.wait();\n  }\n  get profileDocument() {\n    return this._profileStateMachine.profile;\n  }\n  get controlPipeline() {\n    return this._space.controlPipeline;\n  }\n  get haloSpaceKey() {\n    return this._space.key;\n  }\n  get haloGenesisFeedKey() {\n    return this._space.genesisFeedKey;\n  }\n  get haloDatabase() {\n    var _a;\n    return (_a = this._space.database) != null ? _a : failUndefined();\n  }\n  getAdmissionCredentials() {\n    return {\n      deviceKey: this.deviceKey,\n      controlFeedKey: this._space.controlFeedKey,\n      dataFeedKey: this._space.dataFeedKey\n    };\n  }\n  getIdentityCredentialSigner() {\n    assert2(this._deviceStateMachine.deviceCredentialChain, \"Device credential chain is not ready.\");\n    return createCredentialSignerWithChain(this._signer, this._deviceStateMachine.deviceCredentialChain, this.deviceKey);\n  }\n  getDeviceCredentialSigner() {\n    return createCredentialSignerWithKey(this._signer, this.deviceKey);\n  }\n  async admitDevice({ deviceKey, controlFeedKey, dataFeedKey }) {\n    log3(\"Admitting device:\", {\n      identityKey: this.identityKey,\n      hostDevice: this.deviceKey,\n      deviceKey,\n      controlFeedKey,\n      dataFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity.ts\",\n      line: 137,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const signer = this.getIdentityCredentialSigner();\n    await writeMessages(this.controlPipeline.writer, [\n      await signer.createCredential({\n        subject: deviceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n          identityKey: this.identityKey,\n          deviceKey\n        }\n      }),\n      await signer.createCredential({\n        subject: controlFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.CONTROL\n        }\n      }),\n      await signer.createCredential({\n        subject: dataFeedKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n          spaceKey: this.haloSpaceKey,\n          deviceKey,\n          identityKey: this.identityKey,\n          designation: AdmittedFeed.Designation.DATA\n        }\n      })\n    ].map((credential) => ({\n      \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n      credential\n    })));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/identity/identity-manager.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event2 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { MOCK_AUTH_PROVIDER, MOCK_AUTH_VERIFIER, Space, Database, SpaceProtocol } from \"@dxos/echo-db\";\nimport { log as log4 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar IdentityManager = class {\n  constructor(_metadataStore, _feedStore, _keyring, _networkManager, _modelFactory) {\n    this._metadataStore = _metadataStore;\n    this._feedStore = _feedStore;\n    this._keyring = _keyring;\n    this._networkManager = _networkManager;\n    this._modelFactory = _modelFactory;\n    this.stateUpdate = new Event2();\n  }\n  get identity() {\n    return this._identity;\n  }\n  async open() {\n    await this._metadataStore.load();\n    const identityRecord = this._metadataStore.getIdentityRecord();\n    if (identityRecord) {\n      this._identity = await this._constructIdentity(identityRecord);\n      await this._identity.open();\n      await this._identity.ready();\n      this.stateUpdate.emit();\n    }\n  }\n  async close() {\n    var _a;\n    await ((_a = this._identity) == null ? void 0 : _a.close());\n  }\n  async createIdentity({ displayName } = {}) {\n    assert3(!this._identity, \"Identity already exists.\");\n    log4(\"creating identity...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeedKey = await this._keyring.createKey();\n    const identityRecord = {\n      identityKey: await this._keyring.createKey(),\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: await this._keyring.createKey(),\n        genesisFeedKey: controlFeedKey,\n        writeControlFeedKey: controlFeedKey,\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, identityRecord.identityKey, identityRecord.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.genesisFeedKey),\n        await generator.createFeedAdmission(identityRecord.haloSpace.spaceKey, identityRecord.haloSpace.writeDataFeedKey, AdmittedFeed2.Designation.DATA)\n      ];\n      if (displayName) {\n        credentials.push(await generator.createProfileCredential({\n          displayName\n        }));\n      }\n      credentials.push(await generator.createDeviceAuthorization(identityRecord.deviceKey));\n      for (const credential of credentials) {\n        await identity.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this._identity = identity;\n    await this._identity.ready();\n    this.stateUpdate.emit();\n    log4(\"created identity\", {\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return identity;\n  }\n  async acceptIdentity(params) {\n    log4(\"accepting identity\", {\n      params\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 150,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this._identity, \"Identity already exists.\");\n    const identityRecord = {\n      identityKey: params.identityKey,\n      deviceKey: await this._keyring.createKey(),\n      haloSpace: {\n        spaceKey: params.haloSpaceKey,\n        genesisFeedKey: params.haloGenesisFeedKey,\n        writeControlFeedKey: await this._keyring.createKey(),\n        writeDataFeedKey: await this._keyring.createKey()\n      }\n    };\n    const identity = await this._constructIdentity(identityRecord);\n    await identity.open();\n    this._identity = identity;\n    await this._metadataStore.setIdentityRecord(identityRecord);\n    this.stateUpdate.emit();\n    return identity;\n  }\n  async _constructIdentity(identityRecord) {\n    assert3(!this._identity);\n    log4(\"constructing identity\", {\n      identityRecord\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace({\n      spaceRecord: identityRecord.haloSpace,\n      swarmIdentity: {\n        peerKey: identityRecord.deviceKey,\n        credentialProvider: MOCK_AUTH_PROVIDER,\n        credentialAuthenticator: MOCK_AUTH_VERIFIER\n      }\n    });\n    log4(\"done\", {\n      identityKey: identityRecord.identityKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/identity/identity-manager.ts\",\n      line: 185,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return new Identity({\n      space,\n      signer: this._keyring,\n      identityKey: identityRecord.identityKey,\n      deviceKey: identityRecord.deviceKey\n    });\n  }\n  async _constructSpace({ spaceRecord, swarmIdentity }) {\n    const controlFeed = await this._feedStore.openFeed(spaceRecord.writeControlFeedKey, {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed(spaceRecord.writeDataFeedKey, {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed(spaceRecord.genesisFeedKey);\n    const protocol = new SpaceProtocol({\n      topic: spaceRecord.spaceKey,\n      identity: swarmIdentity,\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey: spaceRecord.spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, swarmIdentity.peerKey)\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/encoder.ts\nimport base from \"base-x\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar base62 = base(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\nvar codec = schema2.getCodecForType(\"dxos.client.services.Invitation\");\nvar InvitationEncoder = class {\n  static decode(text) {\n    return codec.decode(base62.decode(text));\n  }\n  static encode(invitation) {\n    return base62.encode(codec.encode(invitation));\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { scheduleTask, sleep, Trigger } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { generatePasscode } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createTeleportProtocolFactory, StarTopology } from \"@dxos/network-manager\";\nimport { schema as schema3 } from \"@dxos/protocols\";\nimport { Invitation as Invitation2 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse } from \"@dxos/protocols/proto/dxos/halo/invitations\";\n\n// packages/sdk/client-services/src/packlets/invitations/invitations.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { CancellableObservableProvider } from \"@dxos/async\";\nimport { Invitation } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AUTHENTICATION_CODE_LENGTH = 6;\nvar INVITATION_TIMEOUT = 3 * 6e4;\nvar ON_CLOSE_DELAY = 500;\nvar InvitationObservableProvider = class extends CancellableObservableProvider {\n  get invitation() {\n    return this._invitation;\n  }\n  setInvitation(invitation) {\n    this._invitation = invitation;\n  }\n};\nvar AuthenticatingInvitationProvider = class extends InvitationObservableProvider {\n  constructor(_actions) {\n    super(() => this._actions.onCancel());\n    this._actions = _actions;\n  }\n  async authenticate(authenticationCode) {\n    return this._actions.onAuthenticate(authenticationCode);\n  }\n};\nvar wrapObservable = async (observable) => {\n  return new Promise((resolve, reject) => {\n    const unsubscribe = observable.subscribe({\n      onSuccess: (invitation) => {\n        assert4(invitation.state === Invitation.State.SUCCESS);\n        unsubscribe();\n        resolve(invitation);\n      },\n      onError: (err) => {\n        unsubscribe();\n        reject(err);\n      }\n    });\n  });\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-handler.ts\nvar AbstractInvitationsHandler = class {\n  constructor(_networkManager) {\n    this._networkManager = _networkManager;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/rpc-extension.ts\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar RpcExtension = class {\n  constructor(_params) {\n    this._params = _params;\n  }\n  get initiator() {\n    return this._extensionContext.initiator;\n  }\n  get localPeerId() {\n    return this._extensionContext.localPeerId;\n  }\n  get remotePeerId() {\n    return this._extensionContext.remotePeerId;\n  }\n  get rpc() {\n    return this._rpc.rpc;\n  }\n  async onOpen(context) {\n    this._extensionContext = context;\n    const handlers = await this.getHandlers();\n    const port = context.createPort(\"rpc\", {\n      contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n    });\n    this._rpc = createProtoRpcPeer({\n      ...this._params,\n      handlers,\n      port\n    });\n    await this._rpc.open();\n  }\n  async onClose(err) {\n    await this._rpc.close();\n  }\n  close() {\n    this._extensionContext.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\nvar HaloInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _identityManager) {\n    super(networkManager);\n    this._identityManager = _identityManager;\n  }\n  createInvitation(context, options) {\n    var _a;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert5(type !== Invitation2.Type.OFFLINE);\n    const identity = (_a = this._identityManager.identity) != null ? _a : failUndefined2();\n    const invitation = {\n      type,\n      invitationId: PublicKey3.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey3.random(),\n      authenticationCode: generatePasscode(AUTHENTICATION_CODE_LENGTH)\n    };\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const observable = new InvitationObservableProvider(async () => {\n      await ctx.dispose();\n    });\n    let authenticationCode;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const hostInvitationExtension = new HostHaloInvitationExtension({\n        requestAdmission: async () => {\n          var _a2, _b;\n          log5(\"responding with admission offer\", {\n            host: identity.deviceKey\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 84,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          (_b = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b.call(_a2, invitation);\n          return {\n            identityKey: identity.identityKey,\n            haloSpaceKey: identity.haloSpaceKey,\n            genesisFeedKey: identity.haloGenesisFeedKey\n          };\n        },\n        authenticate: async ({ authenticationCode: code }) => {\n          log5(\"received authentication request\", {\n            authenticationCode: code\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n            line: 98,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          authenticationCode = code;\n          return {\n            status: AuthenticationResponse.Status.OK\n          };\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          try {\n            if (invitation.type !== Invitation2.Type.INTERACTIVE_TESTING) {\n              if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                throw new Error(`invalid authentication code: ${authenticationCode}`);\n              }\n            }\n            log5(\"writing guest credentials\", {\n              host: identity.deviceKey,\n              guest: credentials.deviceKey\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n              line: 113,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            await identity.admitDevice(credentials);\n            complete.wake(credentials.deviceKey);\n          } catch (err) {\n            observable.callback.onError(err);\n            throw err;\n          }\n        },\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a2, _b;\n            try {\n              log5(\"connected\", {\n                host: identity.deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 129,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a2 = observable.callback).onConnected) == null ? void 0 : _b.call(_a2, invitation);\n              const deviceKey = await complete.wait({\n                timeout\n              });\n              log5(\"admitted guest\", {\n                host: identity.deviceKey,\n                guest: deviceKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 132,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              observable.callback.onSuccess(invitation);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.error(\"failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 136,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await sleep(ON_CLOSE_DELAY);\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return hostInvitationExtension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a2, _b;\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a2 = observable.callback).onConnecting) == null ? void 0 : _b.call(_a2, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    const ctx = new Context({\n      onError: (err) => {\n        void ctx.dispose();\n        observable.callback.onError(err);\n      }\n    });\n    const authenticated = new Trigger();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await ctx.dispose();\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger();\n    const createExtension = () => {\n      const extension = new GuestHaloInvitationExtension({\n        onOpen: () => {\n          scheduleTask(ctx, async () => {\n            var _a, _b, _c, _d;\n            try {\n              if (++connectionCount > 1) {\n                throw new Error(`multiple connections detected: ${connectionCount}`);\n              }\n              log5(\"connected\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 208,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n              log5(\"sending admission request\", {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 212,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              const { identityKey, haloSpaceKey, genesisFeedKey } = await extension.rpc.HaloHostService.requestAdmission();\n              if (invitation.type === void 0 || invitation.type === Invitation2.Type.INTERACTIVE) {\n                log5(\"guest waiting for authentication code...\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 219,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n                const authenticationCode = await authenticated.wait({\n                  timeout\n                });\n                log5(\"sending authentication request\", {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 222,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await extension.rpc.HaloHostService.authenticate({\n                  authenticationCode\n                });\n              }\n              const identity = await this._identityManager.acceptIdentity({\n                identityKey,\n                haloSpaceKey,\n                haloGenesisFeedKey: genesisFeedKey\n              });\n              log5(\"presenting admission credentials\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 235,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              await extension.rpc.HaloHostService.presentAdmissionCredentials(identity.getAdmissionCredentials());\n              log5(\"admitted by host\", {\n                guest: identity.deviceKey,\n                identityKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                line: 239,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              complete.wake(identityKey);\n            } catch (err) {\n              if (!observable.cancelled) {\n                log5.warn(\"auth failed\", err, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/halo-invitations-handler.ts\",\n                  line: 243,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                observable.callback.onError(err);\n              }\n            } finally {\n              await ctx.dispose();\n            }\n          });\n        }\n      });\n      return extension;\n    };\n    scheduleTask(ctx, async () => {\n      var _a, _b;\n      assert5(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey3.random(),\n        protocolProvider: createTeleportProtocolFactory(async (teleport) => {\n          teleport.addExtension(\"dxos.halo.invitations\", createExtension());\n        }),\n        topology: new StarTopology(topic)\n      });\n      ctx.onDispose(() => swarmConnection.close());\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      invitation.identityKey = await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await ctx.dispose();\n    });\n    return observable;\n  }\n};\nvar HostHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      exposed: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {\n      HaloHostService: {\n        requestAdmission: async () => {\n          return this._callbacks.requestAdmission();\n        },\n        authenticate: async (credentials) => {\n          return this._callbacks.authenticate(credentials);\n        },\n        presentAdmissionCredentials: async (credentials) => {\n          return this._callbacks.presentAdmissionCredentials(credentials);\n        }\n      }\n    };\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\nvar GuestHaloInvitationExtension = class extends RpcExtension {\n  constructor(_callbacks) {\n    super({\n      requested: {\n        HaloHostService: schema3.getService(\"dxos.halo.invitations.HaloHostService\")\n      }\n    });\n    this._callbacks = _callbacks;\n  }\n  async getHandlers() {\n    return {};\n  }\n  async onOpen(context) {\n    await super.onOpen(context);\n    this._callbacks.onOpen();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { observableError } from \"@dxos/async\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Invitation as Invitation3 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsProxy = class {\n  constructor(_invitationsService) {\n    this._invitationsService = _invitationsService;\n  }\n  createInvitation(context, options) {\n    let invitationId;\n    const observable = new InvitationObservableProvider(async () => {\n      if (invitationId) {\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      }\n    });\n    const invitation = {\n      ...this.getInvitationOptions(context),\n      ...options\n    };\n    const stream = this._invitationsService.createInvitation(invitation);\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          assert6(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 81,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    assert6(invitation && invitation.swarmKey);\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.cancelInvitation({\n          invitationId\n        });\n      },\n      onAuthenticate: async (authenticationCode) => {\n        var _a;\n        const invitationId = (_a = observable.invitation) == null ? void 0 : _a.invitationId;\n        assert6(invitationId);\n        await this._invitationsService.authenticate({\n          invitationId,\n          authenticationCode\n        });\n      }\n    });\n    const stream = this._invitationsService.acceptInvitation({\n      ...invitation,\n      ...options\n    });\n    stream.subscribe((invitation2) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n      assert6(invitation2.invitationId);\n      observable.setInvitation(invitation2);\n      switch (invitation2.state) {\n        case Invitation3.State.CONNECTING: {\n          (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation2);\n          break;\n        }\n        case Invitation3.State.CONNECTED: {\n          (_d = (_c = observable.callback).onConnected) == null ? void 0 : _d.call(_c, invitation2);\n          break;\n        }\n        case Invitation3.State.AUTHENTICATING: {\n          (_f = (_e = observable.callback).onAuthenticating) == null ? void 0 : _f.call(_e, invitation2);\n          break;\n        }\n        case Invitation3.State.SUCCESS: {\n          (_h = (_g = observable.callback).onSuccess) == null ? void 0 : _h.call(_g, invitation2);\n          break;\n        }\n        case Invitation3.State.CANCELLED: {\n          (_j = (_i = observable.callback).onCancelled) == null ? void 0 : _j.call(_i);\n          break;\n        }\n        default: {\n          log6.error(`Invalid state: ${invitation2.state}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-proxy.ts\",\n            line: 146,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, (err) => {\n      if (err) {\n        observableError(observable, err);\n      }\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-proxy.ts\nvar HaloInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions() {\n    return {};\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { Stream as Stream8 } from \"@dxos/codec-protobuf\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Invitation as Invitation4 } from \"@dxos/protocols/proto/dxos/client/services\";\nvar AbstractInvitationsService = class {\n  constructor(_identityManager, _getInvitationsHandler) {\n    this._identityManager = _identityManager;\n    this._getInvitationsHandler = _getInvitationsHandler;\n    this._createInvitations = /* @__PURE__ */ new Map();\n    this._acceptInvitations = /* @__PURE__ */ new Map();\n  }\n  getLoggingContext() {\n    var _a;\n    return {\n      deviceKey: (_a = this._identityManager.identity) == null ? void 0 : _a.deviceKey\n    };\n  }\n  createInvitation(invitation) {\n    return new Stream8(({ next, close }) => {\n      const invitationsHandler = this._getInvitationsHandler();\n      const context = this.getContext(invitation);\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 43,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      let invitationId;\n      const { type, swarmKey } = invitation;\n      const observable = invitationsHandler.createInvitation(context, {\n        type,\n        swarmKey\n      });\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._createInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context2 = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context2,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 92,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context2, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 94,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._createInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  acceptInvitation(invitation, options) {\n    return new Stream8(({ next, close }) => {\n      log7(\"stream opened\", this.getLoggingContext(), {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 104,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const invitationsHandler = this._getInvitationsHandler();\n      let invitationId;\n      const observable = invitationsHandler.acceptInvitation(invitation, options);\n      observable.subscribe({\n        onConnecting: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitationId = invitation2.invitationId;\n          this._acceptInvitations.set(invitation2.invitationId, observable);\n          invitation2.state = Invitation4.State.CONNECTING;\n          next(invitation2);\n        },\n        onConnected: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.CONNECTED;\n          next(invitation2);\n        },\n        onAuthenticating: (invitation2) => {\n          assert7(invitation2.invitationId);\n          invitation2.state = Invitation4.State.AUTHENTICATING;\n          next(invitation2);\n        },\n        onSuccess: (invitation2) => {\n          invitation2.state = Invitation4.State.SUCCESS;\n          next(invitation2);\n          close();\n        },\n        onCancelled: () => {\n          assert7(invitationId);\n          invitation.invitationId = invitationId;\n          invitation.state = Invitation4.State.CANCELLED;\n          next(invitation);\n          close();\n        },\n        onTimeout: (err) => {\n          invitation.state = Invitation4.State.TIMEOUT;\n          close(err);\n        },\n        onError: (err) => {\n          invitation.state = Invitation4.State.ERROR;\n          close(err);\n        }\n      });\n      return (err) => {\n        const context = this.getLoggingContext();\n        if (err) {\n          log7.warn(\"stream closed\", {\n            ...context,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 152,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        } else {\n          log7(\"stream closed\", context, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n            line: 154,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n        this._acceptInvitations.delete(invitation.invitationId);\n      };\n    });\n  }\n  async authenticate({ invitationId, authenticationCode }) {\n    log7(\"authenticating...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 163,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitationId);\n    const observable = this._acceptInvitations.get(invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 167,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await observable.authenticate(authenticationCode);\n    }\n  }\n  async cancelInvitation(invitation) {\n    var _a;\n    log7(\"cancelling...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n      line: 174,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert7(invitation.invitationId);\n    const observable = (_a = this._createInvitations.get(invitation.invitationId)) != null ? _a : this._acceptInvitations.get(invitation.invitationId);\n    if (!observable) {\n      log7.warn(\"invalid invitation\", {\n        invitationId: invitation.invitationId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/invitations-service.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } else {\n      await (observable == null ? void 0 : observable.cancel());\n    }\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/halo-invitations-service.ts\nvar HaloInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler) {\n    super(identityManager, () => invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n  }\n  getContext(invitation) {\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport { sleep as sleep2, Trigger as Trigger2 } from \"@dxos/async\";\nimport { createAdmissionCredentials, generatePasscode as generatePasscode2 } from \"@dxos/credentials\";\nimport { writeMessages as writeMessages2 } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log8 } from \"@dxos/log\";\nimport { adaptProtocolProvider, createProtocolFactory, StarTopology as StarTopology2 } from \"@dxos/network-manager\";\nimport { createRpcPlugin, RpcPlugin } from \"@dxos/protocol-plugin-rpc\";\nimport { schema as schema4 } from \"@dxos/protocols\";\nimport { Invitation as Invitation5 } from \"@dxos/protocols/proto/dxos/client/services\";\nimport { AuthenticationResponse as AuthenticationResponse2 } from \"@dxos/protocols/proto/dxos/halo/invitations\";\nimport { createProtoRpcPeer as createProtoRpcPeer2 } from \"@dxos/rpc\";\nvar MAX_OTP_ATTEMPTS = 3;\nvar SpaceInvitationsHandler = class extends AbstractInvitationsHandler {\n  constructor(networkManager, _spaceManager, _signingContext) {\n    super(networkManager);\n    this._spaceManager = _spaceManager;\n    this._signingContext = _signingContext;\n  }\n  createInvitation(space, options) {\n    let swarmConnection;\n    const { type, timeout = INVITATION_TIMEOUT, swarmKey } = options != null ? options : {};\n    assert8(type !== Invitation5.Type.OFFLINE);\n    assert8(space);\n    const invitation = {\n      type,\n      invitationId: PublicKey4.random().toHex(),\n      swarmKey: swarmKey != null ? swarmKey : PublicKey4.random(),\n      spaceKey: space.key,\n      authenticationCode: generatePasscode2(AUTHENTICATION_CODE_LENGTH)\n    };\n    const observable = new InvitationObservableProvider(async () => {\n      await (swarmConnection == null ? void 0 : swarmConnection.close());\n    });\n    let authenticationCode;\n    let authenticationRetry = 0;\n    const complete = new Trigger2();\n    const plugin = new RpcPlugin(async (port) => {\n      var _a, _b;\n      let guestProfile;\n      const peer = createProtoRpcPeer2({\n        exposed: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        handlers: {\n          SpaceHostService: {\n            requestAdmission: async ({ profile }) => {\n              var _a2, _b2;\n              log8(\"responding with admission offer\", {\n                guestProfile: profile,\n                host: this._signingContext.deviceKey,\n                spaceKey: space.key\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 89,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              guestProfile = profile;\n              (_b2 = (_a2 = observable.callback).onAuthenticating) == null ? void 0 : _b2.call(_a2, invitation);\n              return {\n                spaceKey: space.key,\n                genesisFeedKey: space.genesisFeedKey\n              };\n            },\n            authenticate: async ({ authenticationCode: code }) => {\n              log8(\"received authentication request\", {\n                authenticationCode: code\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                line: 107,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              let status = AuthenticationResponse2.Status.OK;\n              if (invitation.authenticationCode) {\n                if (authenticationRetry++ > MAX_OTP_ATTEMPTS) {\n                  status = AuthenticationResponse2.Status.INVALID_OPT_ATTEMPTS;\n                } else if (code !== invitation.authenticationCode) {\n                  status = AuthenticationResponse2.Status.INVALID_OTP;\n                } else {\n                  authenticationCode = code;\n                }\n              }\n              return {\n                status\n              };\n            },\n            presentAdmissionCredentials: async ({ identityKey, deviceKey, controlFeedKey, dataFeedKey }) => {\n              try {\n                if (invitation.type !== Invitation5.Type.INTERACTIVE_TESTING) {\n                  if (invitation.authenticationCode === void 0 || invitation.authenticationCode !== authenticationCode) {\n                    throw new Error(`invalid authentication code: ${authenticationCode}`);\n                  }\n                }\n                log8(\"writing guest credentials\", {\n                  host: this._signingContext.deviceKey,\n                  guest: deviceKey\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 134,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                await writeMessages2(space.controlPipeline.writer, await createAdmissionCredentials(this._signingContext.credentialSigner, identityKey, deviceKey, space.key, controlFeedKey, dataFeedKey, guestProfile));\n                complete.wake(deviceKey);\n              } catch (err) {\n                observable.callback.onError(err);\n                throw err;\n              }\n            }\n          }\n        },\n        port\n      });\n      try {\n        await peer.open();\n        log8(\"connected\", {\n          host: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 164,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        const deviceKey = await complete.wait({\n          timeout\n        });\n        log8(\"admitted guest\", {\n          host: this._signingContext.deviceKey,\n          guest: deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 167,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        observable.callback.onSuccess(invitation);\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.error(\"failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 171,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await sleep2(ON_CLOSE_DELAY);\n        await peer.close();\n        await swarmConnection.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: topic,\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n    });\n    return observable;\n  }\n  acceptInvitation(invitation, options) {\n    const { timeout = INVITATION_TIMEOUT } = options != null ? options : {};\n    let swarmConnection;\n    const authenticated = new Trigger2();\n    const observable = new AuthenticatingInvitationProvider({\n      onCancel: async () => {\n        await (swarmConnection == null ? void 0 : swarmConnection.close());\n      },\n      onAuthenticate: async (code) => {\n        authenticated.wake(code);\n      }\n    });\n    let connectionCount = 0;\n    const complete = new Trigger2();\n    const plugin = createRpcPlugin(async (port) => {\n      var _a, _b, _c, _d;\n      const peer = createProtoRpcPeer2({\n        requested: {\n          SpaceHostService: schema4.getService(\"dxos.halo.invitations.SpaceHostService\")\n        },\n        port\n      });\n      try {\n        await peer.open();\n        if (++connectionCount > 1) {\n          throw new Error(`multiple connections detected: ${connectionCount}`);\n        }\n        log8(\"connected\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 235,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        (_b = (_a = observable.callback).onConnected) == null ? void 0 : _b.call(_a, invitation);\n        log8(\"sending admission request\", {\n          guest: this._signingContext.deviceKey\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 239,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const { spaceKey, genesisFeedKey } = await peer.rpc.SpaceHostService.requestAdmission({\n          profile: this._signingContext.profile\n        });\n        if (invitation.type === void 0 || invitation.type === Invitation5.Type.INTERACTIVE) {\n          for (let attempt = 1; attempt <= MAX_OTP_ATTEMPTS; attempt++) {\n            log8(\"guest waiting for authentication code...\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 248,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            (_d = (_c = observable.callback).onAuthenticating) == null ? void 0 : _d.call(_c, invitation);\n            const authenticationCode = await authenticated.wait({\n              timeout\n            });\n            log8(\"sending authentication request\", {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n              line: 252,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            const response = await peer.rpc.SpaceHostService.authenticate({\n              authenticationCode\n            });\n            if (response.status === void 0 || response.status === AuthenticationResponse2.Status.OK) {\n              break;\n            }\n            if (response.status === AuthenticationResponse2.Status.INVALID_OTP) {\n              if (attempt === MAX_OTP_ATTEMPTS) {\n                throw new Error(`Maximum retry attempts: ${MAX_OTP_ATTEMPTS}`);\n              } else {\n                log8(\"retrying invalid code\", {\n                  attempt\n                }, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n                  line: 262,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n                authenticated.reset();\n              }\n            }\n          }\n        }\n        const space = await this._spaceManager.acceptSpace({\n          spaceKey,\n          genesisFeedKey\n        });\n        log8(\"presenting admission credentials\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await peer.rpc.SpaceHostService.presentAdmissionCredentials({\n          identityKey: this._signingContext.identityKey,\n          deviceKey: this._signingContext.deviceKey,\n          controlFeedKey: space.controlFeedKey,\n          dataFeedKey: space.dataFeedKey\n        });\n        log8(\"admitted by host\", {\n          guest: this._signingContext.deviceKey,\n          spaceKey: space.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n          line: 283,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        complete.wake();\n      } catch (err) {\n        if (!observable.cancelled) {\n          log8.warn(\"auth failed\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/invitations/space-invitations-handler.ts\",\n            line: 287,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          observable.callback.onError(err);\n        }\n      } finally {\n        await peer.close();\n      }\n    });\n    setTimeout(async () => {\n      var _a, _b;\n      assert8(invitation.swarmKey);\n      const topic = invitation.swarmKey;\n      const peerId = PublicKey4.random();\n      swarmConnection = await this._networkManager.joinSwarm({\n        topic,\n        peerId: PublicKey4.random(),\n        protocolProvider: adaptProtocolProvider(createProtocolFactory(topic, peerId, [\n          plugin\n        ])),\n        topology: new StarTopology2(topic)\n      });\n      (_b = (_a = observable.callback).onConnecting) == null ? void 0 : _b.call(_a, invitation);\n      await complete.wait();\n      observable.callback.onSuccess(invitation);\n      await swarmConnection.close();\n    });\n    return observable;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-proxy.ts\nvar SpaceInvitationsProxy = class extends AbstractInvitationsProxy {\n  getInvitationOptions(context) {\n    return {\n      spaceKey: context\n    };\n  }\n};\n\n// packages/sdk/client-services/src/packlets/invitations/space-invitations-service.ts\nimport assert9 from \"@dxos/node-std/assert\";\nvar SpaceInvitationsServiceImpl = class extends AbstractInvitationsService {\n  constructor(identityManager, invitationsHandler, _getSpaceManager) {\n    super(identityManager, invitationsHandler);\n    this.invitationsHandler = invitationsHandler;\n    this._getSpaceManager = _getSpaceManager;\n  }\n  getContext(invitation) {\n    assert9(invitation.spaceKey);\n    const spaceManager = this._getSpaceManager();\n    const space = spaceManager.spaces.get(invitation.spaceKey);\n    assert9(space);\n    return space;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-context.ts\nimport { Trigger as Trigger3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nimport { MOCK_AUTH_PROVIDER as MOCK_AUTH_PROVIDER2, MOCK_AUTH_VERIFIER as MOCK_AUTH_VERIFIER2, valueEncoding, DataServiceSubscriptions, MetadataStore, SpaceManager } from \"@dxos/echo-db\";\nimport { FeedFactory, FeedStore } from \"@dxos/feed-store\";\nimport { Keyring } from \"@dxos/keyring\";\nimport { log as log9 } from \"@dxos/log\";\nvar ServiceContext = class {\n  constructor(storage, networkManager, modelFactory) {\n    this.storage = storage;\n    this.networkManager = networkManager;\n    this.modelFactory = modelFactory;\n    this.initialized = new Trigger3();\n    this.dataServiceSubscriptions = new DataServiceSubscriptions();\n    this.metadataStore = new MetadataStore(storage.createDirectory(\"metadata\"));\n    this.keyring = new Keyring(storage.createDirectory(\"keyring\"));\n    this.feedStore = new FeedStore({\n      factory: new FeedFactory({\n        root: storage.createDirectory(\"feeds\"),\n        signer: this.keyring,\n        hypercore: {\n          valueEncoding\n        }\n      })\n    });\n    this.identityManager = new IdentityManager(this.metadataStore, this.feedStore, this.keyring, networkManager, modelFactory);\n    this.haloInvitations = new HaloInvitationsHandler(this.networkManager, this.identityManager);\n  }\n  async open() {\n    log9(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 78,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.open();\n    if (this.identityManager.identity) {\n      await this._initialize();\n    }\n    log9(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 83,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    log9(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 87,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.identityManager.close();\n    await ((_a = this.spaceManager) == null ? void 0 : _a.close());\n    await this.feedStore.close();\n    await this.networkManager.close();\n    this.dataServiceSubscriptions.clear();\n    log9(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async reset() {\n    log9(\"resetting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.close();\n    await this.storage.reset();\n    log9(\"reset\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-context.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async createIdentity(params = {}) {\n    const identity = await this.identityManager.createIdentity(params);\n    this.dataServiceSubscriptions.registerSpace(identity.haloSpaceKey, identity.haloDatabase.createDataServiceHost());\n    await this._initialize();\n    return identity;\n  }\n  async _initialize() {\n    var _a;\n    const identity = (_a = this.identityManager.identity) != null ? _a : failUndefined3();\n    const signingContext = {\n      credentialProvider: MOCK_AUTH_PROVIDER2,\n      credentialAuthenticator: MOCK_AUTH_VERIFIER2,\n      credentialSigner: identity.getIdentityCredentialSigner(),\n      identityKey: identity.identityKey,\n      deviceKey: identity.deviceKey,\n      profile: identity.profileDocument\n    };\n    const spaceManager = new SpaceManager({\n      metadataStore: this.metadataStore,\n      feedStore: this.feedStore,\n      networkManager: this.networkManager,\n      keyring: this.keyring,\n      dataServiceSubscriptions: this.dataServiceSubscriptions,\n      modelFactory: this.modelFactory,\n      signingContext\n    });\n    await spaceManager.open();\n    this.spaceManager = spaceManager;\n    this.spaceInvitations = new SpaceInvitationsHandler(this.networkManager, this.spaceManager, signingContext);\n    this.initialized.wake();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-definitions.ts\nimport { schema as schema5 } from \"@dxos/protocols\";\nimport { createServiceBundle } from \"@dxos/rpc\";\nvar clientServiceBundle = createServiceBundle({\n  HaloInvitationsService: schema5.getService(\"dxos.client.services.HaloInvitationsService\"),\n  DevicesService: schema5.getService(\"dxos.client.services.DevicesService\"),\n  SpaceInvitationsService: schema5.getService(\"dxos.client.services.SpaceInvitationsService\"),\n  SpacesService: schema5.getService(\"dxos.client.services.SpacesService\"),\n  SpaceService: schema5.getService(\"dxos.client.SpaceService\"),\n  DataService: schema5.getService(\"dxos.echo.service.DataService\"),\n  ProfileService: schema5.getService(\"dxos.client.ProfileService\"),\n  SystemService: schema5.getService(\"dxos.client.SystemService\"),\n  DevtoolsHost: schema5.getService(\"dxos.devtools.host.DevtoolsHost\"),\n  TracingService: schema5.getService(\"dxos.devtools.host.TracingService\")\n});\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nimport { raise } from \"@dxos/debug\";\nimport { DataServiceImpl } from \"@dxos/echo-db\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ModelFactory } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nimport { TextModel } from \"@dxos/text-model\";\n\n// packages/sdk/client-services/src/packlets/identity/devices-service-impl.ts\nimport { EventSubscriptions as EventSubscriptions3 } from \"@dxos/async\";\nimport { Stream as Stream9 } from \"@dxos/codec-protobuf\";\nvar DevicesServiceImpl = class {\n  constructor(_identityManager) {\n    this._identityManager = _identityManager;\n  }\n  updateDevice() {\n    throw new Error(\"Method not implemented.\");\n  }\n  queryDevices() {\n    return new Stream9(({ next }) => {\n      const update = () => {\n        var _a;\n        const deviceKeys = (_a = this._identityManager.identity) == null ? void 0 : _a.authorizedDeviceKeys;\n        if (!deviceKeys) {\n          next({\n            devices: []\n          });\n        } else {\n          next({\n            devices: Array.from(deviceKeys.values()).map((key) => ({\n              deviceKey: key\n            }))\n          });\n        }\n      };\n      const dispose = new EventSubscriptions3();\n      dispose.add(this._identityManager.stateUpdate.on(() => {\n        update();\n        if (this._identityManager.identity) {\n          dispose.add(this._identityManager.identity.stateUpdate.on(() => {\n            update();\n          }));\n        }\n      }));\n      update();\n      return () => dispose.clear();\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/spaces/spaces-service.ts\nvar SpacesServiceImpl = class {\n  async createSpace() {\n    throw new Error();\n  }\n  querySpaces() {\n    throw new Error();\n  }\n  queryMembers(query) {\n    throw new Error();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/storage/storage.ts\nimport jsondown from \"jsondown\";\nimport leveljs from \"level-js\";\nimport memdown from \"memdown\";\nimport { InvalidConfigError } from \"@dxos/errors\";\nimport { Runtime } from \"@dxos/protocols/proto/dxos/config\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { isNode } from \"@dxos/util\";\nvar StorageDriver = Runtime.Client.Storage.StorageDriver;\nvar createStorageObjects = (config) => {\n  const { path = \"dxos/storage\", storageType, keyStorage, persistent = false } = config != null ? config : {};\n  if (persistent && storageType === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && storageType !== void 0 && storageType !== StorageDriver.RAM) {\n    throw new InvalidConfigError(\"Cannot use a persistent storage in not persistent mode.\");\n  }\n  if (persistent && keyStorage === StorageDriver.RAM) {\n    throw new InvalidConfigError(\"RAM key storage cannot be used in persistent mode.\");\n  }\n  if (!persistent && keyStorage !== StorageDriver.RAM && keyStorage !== void 0) {\n    throw new InvalidConfigError(\"Cannot use a persistent key storage in not persistent mode.\");\n  }\n  return {\n    storage: createStorage({\n      type: persistent ? toStorageType(storageType) : StorageType.RAM,\n      root: `${path}/`\n    }),\n    keyStorage: createKeyStorage(`${path}/keystore`, persistent ? toKeyStorageType(keyStorage) : \"ram\")\n  };\n};\nvar createKeyStorage = (path, type) => {\n  const defaultedType = type != null ? type : isNode() ? \"jsondown\" : \"leveljs\";\n  switch (defaultedType) {\n    case \"leveljs\":\n      return leveljs(path);\n    case \"jsondown\":\n      return jsondown(path);\n    case \"ram\":\n      return memdown();\n    default:\n      throw new InvalidConfigError(`Invalid key storage type: ${defaultedType}`);\n  }\n};\nvar toStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return StorageType.RAM;\n    case StorageDriver.CHROME:\n      return StorageType.CHROME;\n    case StorageDriver.FIREFOX:\n      return StorageType.FIREFOX;\n    case StorageDriver.IDB:\n      return StorageType.IDB;\n    case StorageDriver.NODE:\n      return StorageType.NODE;\n    default:\n      throw new Error(`Invalid storage type: ${StorageDriver[type]}`);\n  }\n};\nvar toKeyStorageType = (type) => {\n  switch (type) {\n    case void 0:\n      return void 0;\n    case StorageDriver.RAM:\n      return \"ram\";\n    case StorageDriver.LEVELJS:\n      return \"leveljs\";\n    case StorageDriver.JSONDOWN:\n      return \"jsondown\";\n    default:\n      throw new Error(`Invalid key storage type: ${StorageDriver[type]}`);\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-registry.ts\nvar ServiceRegistry = class {\n  constructor(_serviceBundle, _handlers) {\n    this._serviceBundle = _serviceBundle;\n    this._handlers = _handlers;\n  }\n  get descriptors() {\n    return this._serviceBundle;\n  }\n  get services() {\n    return this._handlers;\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-host.ts\nvar createDefaultModelFactory = () => {\n  return new ModelFactory().registerModel(ObjectModel).registerModel(TextModel);\n};\nvar ClientServicesHost = class {\n  constructor({\n    config,\n    modelFactory = createDefaultModelFactory(),\n    networkManager\n  }) {\n    this._config = config;\n    this._modelFactory = modelFactory;\n    this._networkManager = networkManager;\n  }\n  get descriptors() {\n    return this._serviceRegistry.descriptors;\n  }\n  get services() {\n    return this._serviceRegistry.services;\n  }\n  async open() {\n    var _a;\n    await this._initialize();\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"opening...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._initialize();\n    await this._serviceContext.open();\n    log10(\"opened\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    const deviceKey = (_a = this._serviceContext.identityManager.identity) == null ? void 0 : _a.deviceKey;\n    log10(\"closing...\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._serviceContext.close();\n    log10(\"closed\", {\n      deviceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/services/service-host.ts\",\n      line: 79,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _initialize() {\n    const { storage } = createStorageObjects(this._config.get(\"runtime.client.storage\", {}));\n    this._serviceContext = new ServiceContext(storage, this._networkManager, this._modelFactory);\n    this._serviceRegistry = new ServiceRegistry(clientServiceBundle, {\n      HaloInvitationsService: new HaloInvitationsServiceImpl(this._serviceContext.identityManager, this._serviceContext.haloInvitations),\n      DevicesService: new DevicesServiceImpl(this._serviceContext.identityManager),\n      SpaceInvitationsService: new SpaceInvitationsServiceImpl(this._serviceContext.identityManager, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceInvitations) != null ? _a : raise(new Error(\"SpaceInvitations not initialized\"));\n      }, () => {\n        var _a;\n        return (_a = this._serviceContext.spaceManager) != null ? _a : raise(new Error(\"SpaceManager not initialized\"));\n      }),\n      SpacesService: new SpacesServiceImpl(),\n      DataService: new DataServiceImpl(this._serviceContext.dataServiceSubscriptions),\n      ProfileService: new ProfileServiceImpl(this._serviceContext),\n      SpaceService: new SpaceServiceImpl(this._serviceContext),\n      SystemService: new SystemServiceImpl(this._config, this._serviceContext),\n      TracingService: new TracingServiceImpl(this._config),\n      DevtoolsHost: new DevtoolsServiceImpl({\n        events: new DevtoolsHostEvents(),\n        config: this._config,\n        context: this._serviceContext\n      })\n    });\n  }\n};\n\n// packages/sdk/client-services/src/packlets/services/service-proxy.ts\nimport { asyncTimeout } from \"@dxos/async\";\nimport { RemoteServiceConnectionTimeout } from \"@dxos/errors\";\nimport { createProtoRpcPeer as createProtoRpcPeer3 } from \"@dxos/rpc\";\nvar ClientServicesProxy = class {\n  constructor(port, _timeout = 3e4) {\n    this._timeout = _timeout;\n    this._proxy = createProtoRpcPeer3({\n      requested: clientServiceBundle,\n      exposed: {},\n      handlers: {},\n      port\n    });\n  }\n  get proxy() {\n    return this._proxy;\n  }\n  get descriptors() {\n    return clientServiceBundle;\n  }\n  get services() {\n    return this._proxy.rpc;\n  }\n  async open() {\n    await asyncTimeout(this._proxy.open(), this._timeout, new RemoteServiceConnectionTimeout());\n  }\n  async close() {\n    await this._proxy.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nimport { WebRTCTransportService } from \"@dxos/network-manager\";\nimport { createProtoRpcPeer as createProtoRpcPeer4 } from \"@dxos/rpc\";\n\n// packages/sdk/client-services/src/packlets/vault/services.ts\nimport { schema as schema6 } from \"@dxos/protocols\";\nvar iframeServiceBundle = {\n  IframeService: schema6.getService(\"dxos.iframe.IframeService\"),\n  BridgeService: schema6.getService(\"dxos.mesh.bridge.BridgeService\")\n};\nvar workerServiceBundle = {\n  WorkerService: schema6.getService(\"dxos.iframe.WorkerService\")\n};\n\n// packages/sdk/client-services/src/packlets/vault/iframe-runtime.ts\nvar IFrameRuntime = class {\n  constructor({ systemPort, workerAppPort, windowAppPort }) {\n    this._transportService = new WebRTCTransportService();\n    this._systemPort = systemPort;\n    this._windowAppPort = windowAppPort;\n    this._workerAppPort = workerAppPort;\n    this._systemRpc = createProtoRpcPeer4({\n      requested: workerServiceBundle,\n      exposed: iframeServiceBundle,\n      handlers: {\n        BridgeService: this._transportService,\n        IframeService: {\n          async heartbeat() {\n          }\n        }\n      },\n      port: this._systemPort,\n      timeout: 200\n    });\n    this._workerAppPort.subscribe((msg) => this._windowAppPort.send(msg));\n    this._windowAppPort.subscribe((msg) => this._workerAppPort.send(msg));\n  }\n  async open(origin) {\n    await this._systemRpc.open();\n    await this._systemRpc.rpc.WorkerService.start({\n      origin\n    });\n  }\n  async close() {\n    await this._systemRpc.rpc.WorkerService.stop();\n    await this._systemRpc.close();\n  }\n};\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nimport { Trigger as Trigger5 } from \"@dxos/async\";\nimport { MemorySignalManager, MemorySignalManagerContext, WebsocketSignalManager } from \"@dxos/messaging\";\nimport { NetworkManager, WebRTCTransportProxyFactory } from \"@dxos/network-manager\";\n\n// packages/sdk/client-services/src/packlets/vault/worker-session.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger4 } from \"@dxos/async\";\nimport { log as log11, logInfo } from \"@dxos/log\";\nimport { createProtoRpcPeer as createProtoRpcPeer5 } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WorkerSession = class {\n  constructor({ getServices, systemPort, appPort, options = {\n    heartbeatInterval: 1e3\n  } }) {\n    this._startTrigger = new Trigger4();\n    this.onClose = new Callback();\n    assert10(options);\n    assert10(getServices);\n    this._options = options;\n    this._getServices = getServices;\n    this._clientRpc = createProtoRpcPeer5({\n      exposed: clientServiceBundle,\n      handlers: {\n        HaloInvitationsService: async () => (await this._getServices()).services.HaloInvitationsService,\n        DevicesService: async () => (await this._getServices()).services.DevicesService,\n        SpaceInvitationsService: async () => (await this._getServices()).services.SpaceInvitationsService,\n        SpacesService: async () => (await this._getServices()).services.SpacesService,\n        SpaceService: async () => (await this._getServices()).services.SpaceService,\n        DataService: async () => (await this._getServices()).services.DataService,\n        ProfileService: async () => (await this._getServices()).services.ProfileService,\n        SystemService: async () => (await this._getServices()).services.SystemService,\n        DevtoolsHost: async () => (await this._getServices()).services.DevtoolsHost,\n        TracingService: async () => (await this._getServices()).services.TracingService\n      },\n      port: appPort\n    });\n    this._iframeRpc = createProtoRpcPeer5({\n      requested: iframeServiceBundle,\n      exposed: workerServiceBundle,\n      handlers: {\n        WorkerService: {\n          start: async (request) => {\n            this.origin = request.origin;\n            this._startTrigger.wake();\n          },\n          stop: async () => {\n            setTimeout(async () => {\n              try {\n                await this.close();\n              } catch (err) {\n                log11.catch(err, {}, {\n                  file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n                  line: 89,\n                  scope: this,\n                  callSite: (f, a) => f(...a)\n                });\n              }\n            });\n          }\n        }\n      },\n      port: systemPort,\n      timeout: 1e3\n    });\n    this.bridgeService = this._iframeRpc.rpc.BridgeService;\n  }\n  async open() {\n    log11.info(\"opening..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 103,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      this._clientRpc.open(),\n      this._iframeRpc.open()\n    ]);\n    await this._startTrigger.wait({\n      timeout: 3e3\n    });\n    this._heartbeatTimer = setInterval(async () => {\n      try {\n        await this._iframeRpc.rpc.IframeService.heartbeat();\n      } catch (err1) {\n        log11.warn(\"Heartbeat failed\", {\n          err: err1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n          line: 115,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          await this.close();\n        } catch (err) {\n          log11.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n            line: 119,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    }, this._options.heartbeatInterval);\n  }\n  async close() {\n    log11.info(\"closing..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this.onClose.callIfSet();\n    } catch (err) {\n      log11.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/sdk/client-services/src/packlets/vault/worker-session.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    if (this._heartbeatTimer !== void 0) {\n      clearInterval(this._heartbeatTimer);\n    }\n    await Promise.all([\n      this._clientRpc.close(),\n      this._iframeRpc.close()\n    ]);\n  }\n};\n__decorate([\n  logInfo\n], WorkerSession.prototype, \"origin\", void 0);\n\n// packages/sdk/client-services/src/packlets/vault/worker-runtime.ts\nvar WorkerRuntime = class {\n  constructor(_configProvider) {\n    this._configProvider = _configProvider;\n    this._transportFactory = new WebRTCTransportProxyFactory();\n    this._ready = new Trigger5();\n    this.sessions = /* @__PURE__ */ new Set();\n  }\n  async start() {\n    try {\n      this._config = await this._configProvider();\n      const signalServer = this._config.get(\"runtime.services.signal.server\");\n      this._clientServices = new ClientServicesHost({\n        config: this._config,\n        networkManager: new NetworkManager({\n          log: true,\n          signalManager: signalServer ? new WebsocketSignalManager([\n            signalServer\n          ]) : new MemorySignalManager(new MemorySignalManagerContext()),\n          transportFactory: this._transportFactory\n        })\n      });\n      await this._clientServices.open();\n      this._ready.wake(void 0);\n    } catch (err) {\n      this._ready.wake(err);\n    }\n  }\n  async stop() {\n    await this._clientServices.close();\n  }\n  async createSession({ appPort, systemPort }) {\n    const session = new WorkerSession({\n      getServices: async () => {\n        const error = await this._ready.wait();\n        if (error !== void 0) {\n          throw error;\n        }\n        return this._clientServices;\n      },\n      appPort,\n      systemPort,\n      readySignal: this._ready\n    });\n    session.onClose.set(async () => {\n      this.sessions.delete(session);\n      this._reconnectWebrtc();\n    });\n    await session.open();\n    this.sessions.add(session);\n    this._reconnectWebrtc();\n  }\n  _reconnectWebrtc() {\n    if (this._sessionForNetworking) {\n      if (!this.sessions.has(this._sessionForNetworking)) {\n        this._sessionForNetworking = void 0;\n      }\n    }\n    if (!this._sessionForNetworking) {\n      const selected = Array.from(this.sessions).find((session) => session.bridgeService);\n      if (selected) {\n        this._sessionForNetworking = selected;\n        this._transportFactory.setBridgeService(selected.bridgeService);\n      } else {\n        this._transportFactory.setBridgeService(void 0);\n      }\n    }\n  }\n};\nexport {\n  AUTHENTICATION_CODE_LENGTH,\n  AbstractInvitationsHandler,\n  AbstractInvitationsProxy,\n  AbstractInvitationsService,\n  AuthenticatingInvitationProvider,\n  ClientServicesHost,\n  ClientServicesProxy,\n  DevtoolsHostEvents,\n  DevtoolsServiceImpl,\n  HaloInvitationsHandler,\n  HaloInvitationsProxy,\n  HaloInvitationsServiceImpl,\n  IFrameRuntime,\n  INVITATION_TIMEOUT,\n  Identity,\n  IdentityManager,\n  InvitationEncoder,\n  InvitationObservableProvider,\n  ON_CLOSE_DELAY,\n  ProfileServiceImpl,\n  ServiceContext,\n  ServiceRegistry,\n  SpaceInvitationsHandler,\n  SpaceInvitationsProxy,\n  SpaceInvitationsServiceImpl,\n  SpaceServiceImpl,\n  SystemServiceImpl,\n  TracingServiceImpl,\n  WorkerRuntime,\n  WorkerSession,\n  clientServiceBundle,\n  createDefaultModelFactory,\n  createHaloAuthProvider,\n  createHaloAuthVerifier,\n  createStorageObjects,\n  getNetworkPeers,\n  subscribeToFeedBlocks,\n  subscribeToFeeds,\n  subscribeToNetworkStatus,\n  subscribeToNetworkTopics,\n  subscribeToSignalTrace,\n  subscribeToSpaces,\n  subscribeToSwarmInfo,\n  wrapObservable\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466120,"end":1670465466161,"order":"normal"}]}
