{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch   = require(\"@protobufjs/fetch\");\nutil.path    = require(\"@protobufjs/path\");\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(\"./type\");\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(\"./enum\");\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n    }\n});\n","start":1670465470614,"end":1670465470687},{"name":"vite:react-babel","result":"\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch   = require(\"@protobufjs/fetch\");\nutil.path    = require(\"@protobufjs/path\");\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(\"./type\");\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(\"./enum\");\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n    }\n});\n","start":1670465470687,"end":1670465470687,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as utilModule, exports as util_1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-module\"\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util/minimal.js?commonjs-wrapped\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/roots.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/@protobufjs+codegen@2.0.4/node_modules/@protobufjs/codegen/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/@protobufjs+fetch@1.1.0/node_modules/@protobufjs/fetch/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/@protobufjs+path@1.1.2/node_modules/@protobufjs/path/index.js?commonjs-proxy\";\nimport { __require as require$$5 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/type.js?commonjs-wrapped\";\nimport { __require as require$$6 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$7 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/root.js?commonjs-wrapped\";\n\nvar hasRequiredUtil;\n\nfunction requireUtil () {\n\tif (hasRequiredUtil) return util_1;\n\thasRequiredUtil = 1;\n\t(function (module) {\n\t\t\"use strict\";\n\n\t\t/**\n\t\t * Various utility functions.\n\t\t * @namespace\n\t\t */\n\t\tvar util = module.exports = require$$0();\n\n\t\tvar roots = require$$1;\n\n\t\tvar Type, // cyclic\n\t\t    Enum;\n\n\t\tutil.codegen = require$$2;\n\t\tutil.fetch   = require$$3;\n\t\tutil.path    = require$$4;\n\n\t\t/**\n\t\t * Node's fs module if available.\n\t\t * @type {Object.<string,*>}\n\t\t */\n\t\tutil.fs = util.inquire(\"fs\");\n\n\t\t/**\n\t\t * Converts an object's values to an array.\n\t\t * @param {Object.<string,*>} object Object to convert\n\t\t * @returns {Array.<*>} Converted array\n\t\t */\n\t\tutil.toArray = function toArray(object) {\n\t\t    if (object) {\n\t\t        var keys  = Object.keys(object),\n\t\t            array = new Array(keys.length),\n\t\t            index = 0;\n\t\t        while (index < keys.length)\n\t\t            array[index] = object[keys[index++]];\n\t\t        return array;\n\t\t    }\n\t\t    return [];\n\t\t};\n\n\t\t/**\n\t\t * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n\t\t * @param {Array.<*>} array Array to convert\n\t\t * @returns {Object.<string,*>} Converted object\n\t\t */\n\t\tutil.toObject = function toObject(array) {\n\t\t    var object = {},\n\t\t        index  = 0;\n\t\t    while (index < array.length) {\n\t\t        var key = array[index++],\n\t\t            val = array[index++];\n\t\t        if (val !== undefined)\n\t\t            object[key] = val;\n\t\t    }\n\t\t    return object;\n\t\t};\n\n\t\tvar safePropBackslashRe = /\\\\/g,\n\t\t    safePropQuoteRe     = /\"/g;\n\n\t\t/**\n\t\t * Tests whether the specified name is a reserved word in JS.\n\t\t * @param {string} name Name to test\n\t\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t\t */\n\t\tutil.isReserved = function isReserved(name) {\n\t\t    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n\t\t};\n\n\t\t/**\n\t\t * Returns a safe property accessor for the specified property name.\n\t\t * @param {string} prop Property name\n\t\t * @returns {string} Safe accessor\n\t\t */\n\t\tutil.safeProp = function safeProp(prop) {\n\t\t    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n\t\t        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n\t\t    return \".\" + prop;\n\t\t};\n\n\t\t/**\n\t\t * Converts the first character of a string to upper case.\n\t\t * @param {string} str String to convert\n\t\t * @returns {string} Converted string\n\t\t */\n\t\tutil.ucFirst = function ucFirst(str) {\n\t\t    return str.charAt(0).toUpperCase() + str.substring(1);\n\t\t};\n\n\t\tvar camelCaseRe = /_([a-z])/g;\n\n\t\t/**\n\t\t * Converts a string to camel case.\n\t\t * @param {string} str String to convert\n\t\t * @returns {string} Converted string\n\t\t */\n\t\tutil.camelCase = function camelCase(str) {\n\t\t    return str.substring(0, 1)\n\t\t         + str.substring(1)\n\t\t               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n\t\t};\n\n\t\t/**\n\t\t * Compares reflected fields by id.\n\t\t * @param {Field} a First field\n\t\t * @param {Field} b Second field\n\t\t * @returns {number} Comparison value\n\t\t */\n\t\tutil.compareFieldsById = function compareFieldsById(a, b) {\n\t\t    return a.id - b.id;\n\t\t};\n\n\t\t/**\n\t\t * Decorator helper for types (TypeScript).\n\t\t * @param {Constructor<T>} ctor Constructor function\n\t\t * @param {string} [typeName] Type name, defaults to the constructor's name\n\t\t * @returns {Type} Reflected type\n\t\t * @template T extends Message<T>\n\t\t * @property {Root} root Decorators root\n\t\t */\n\t\tutil.decorateType = function decorateType(ctor, typeName) {\n\n\t\t    /* istanbul ignore if */\n\t\t    if (ctor.$type) {\n\t\t        if (typeName && ctor.$type.name !== typeName) {\n\t\t            util.decorateRoot.remove(ctor.$type);\n\t\t            ctor.$type.name = typeName;\n\t\t            util.decorateRoot.add(ctor.$type);\n\t\t        }\n\t\t        return ctor.$type;\n\t\t    }\n\n\t\t    /* istanbul ignore next */\n\t\t    if (!Type)\n\t\t        Type = require$$5();\n\n\t\t    var type = new Type(typeName || ctor.name);\n\t\t    util.decorateRoot.add(type);\n\t\t    type.ctor = ctor; // sets up .encode, .decode etc.\n\t\t    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n\t\t    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n\t\t    return type;\n\t\t};\n\n\t\tvar decorateEnumIndex = 0;\n\n\t\t/**\n\t\t * Decorator helper for enums (TypeScript).\n\t\t * @param {Object} object Enum object\n\t\t * @returns {Enum} Reflected enum\n\t\t */\n\t\tutil.decorateEnum = function decorateEnum(object) {\n\n\t\t    /* istanbul ignore if */\n\t\t    if (object.$type)\n\t\t        return object.$type;\n\n\t\t    /* istanbul ignore next */\n\t\t    if (!Enum)\n\t\t        Enum = require$$6();\n\n\t\t    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n\t\t    util.decorateRoot.add(enm);\n\t\t    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n\t\t    return enm;\n\t\t};\n\n\n\t\t/**\n\t\t * Sets the value of a property by property path. If a value already exists, it is turned to an array\n\t\t * @param {Object.<string,*>} dst Destination object\n\t\t * @param {string} path dot '.' delimited path of the property to set\n\t\t * @param {Object} value the value to set\n\t\t * @returns {Object.<string,*>} Destination object\n\t\t */\n\t\tutil.setProperty = function setProperty(dst, path, value) {\n\t\t    function setProp(dst, path, value) {\n\t\t        var part = path.shift();\n\t\t        if (part === \"__proto__\") {\n\t\t          return dst;\n\t\t        }\n\t\t        if (path.length > 0) {\n\t\t            dst[part] = setProp(dst[part] || {}, path, value);\n\t\t        } else {\n\t\t            var prevValue = dst[part];\n\t\t            if (prevValue)\n\t\t                value = [].concat(prevValue).concat(value);\n\t\t            dst[part] = value;\n\t\t        }\n\t\t        return dst;\n\t\t    }\n\n\t\t    if (typeof dst !== \"object\")\n\t\t        throw TypeError(\"dst must be an object\");\n\t\t    if (!path)\n\t\t        throw TypeError(\"path must be specified\");\n\n\t\t    path = path.split(\".\");\n\t\t    return setProp(dst, path, value);\n\t\t};\n\n\t\t/**\n\t\t * Decorator root (TypeScript).\n\t\t * @name util.decorateRoot\n\t\t * @type {Root}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty(util, \"decorateRoot\", {\n\t\t    get: function() {\n\t\t        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require$$7())());\n\t\t    }\n\t\t});\n} (utilModule));\n\treturn util_1;\n}\n\nexport { requireUtil as __require };","start":1670465470687,"end":1670465471331,"order":"normal"}]}
