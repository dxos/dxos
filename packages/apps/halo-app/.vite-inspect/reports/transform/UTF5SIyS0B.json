{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js","transforms":[{"name":"vite:load-fallback","result":"/* eslint-disable camelcase */\nvar { sodium_malloc, sodium_memzero } = require('sodium-universal/memory')\nvar { crypto_generichash, crypto_generichash_batch } = require('sodium-universal/crypto_generichash')\nvar assert = require('nanoassert')\n\nvar HASHLEN = 64\nvar BLOCKLEN = 128\nvar scratch = sodium_malloc(BLOCKLEN * 3)\nvar HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1)\nvar OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2)\nvar InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3)\n\n// Post-fill is done in the cases where someone caught an exception that\n// happened before we were able to clear data at the end\nmodule.exports = function hmac (out, data, key) {\n  assert(out.byteLength === HASHLEN)\n  assert(key.byteLength != null)\n  assert(Array.isArray(data) ? data.every(d => d.byteLength != null) : data.byteLength != null)\n\n  if (key.byteLength > BLOCKLEN) {\n    crypto_generichash(HMACKey.subarray(0, HASHLEN), key)\n    sodium_memzero(HMACKey.subarray(HASHLEN))\n  } else {\n    // Covers key <= BLOCKLEN\n    HMACKey.set(key)\n    sodium_memzero(HMACKey.subarray(key.byteLength))\n  }\n\n  for (var i = 0; i < HMACKey.byteLength; i++) {\n    OuterKeyPad[i] = 0x5c ^ HMACKey[i]\n    InnerKeyPad[i] = 0x36 ^ HMACKey[i]\n  }\n  sodium_memzero(HMACKey)\n\n  crypto_generichash_batch(out, [InnerKeyPad].concat(data))\n  sodium_memzero(InnerKeyPad)\n  crypto_generichash_batch(out, [OuterKeyPad].concat(out))\n  sodium_memzero(OuterKeyPad)\n}\n\nmodule.exports.BYTES = HASHLEN\nmodule.exports.KEYBYTES = BLOCKLEN\n","start":1670465471490,"end":1670465471672},{"name":"vite:react-babel","result":"/* eslint-disable camelcase */\nvar { sodium_malloc, sodium_memzero } = require('sodium-universal/memory')\nvar { crypto_generichash, crypto_generichash_batch } = require('sodium-universal/crypto_generichash')\nvar assert = require('nanoassert')\n\nvar HASHLEN = 64\nvar BLOCKLEN = 128\nvar scratch = sodium_malloc(BLOCKLEN * 3)\nvar HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1)\nvar OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2)\nvar InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3)\n\n// Post-fill is done in the cases where someone caught an exception that\n// happened before we were able to clear data at the end\nmodule.exports = function hmac (out, data, key) {\n  assert(out.byteLength === HASHLEN)\n  assert(key.byteLength != null)\n  assert(Array.isArray(data) ? data.every(d => d.byteLength != null) : data.byteLength != null)\n\n  if (key.byteLength > BLOCKLEN) {\n    crypto_generichash(HMACKey.subarray(0, HASHLEN), key)\n    sodium_memzero(HMACKey.subarray(HASHLEN))\n  } else {\n    // Covers key <= BLOCKLEN\n    HMACKey.set(key)\n    sodium_memzero(HMACKey.subarray(key.byteLength))\n  }\n\n  for (var i = 0; i < HMACKey.byteLength; i++) {\n    OuterKeyPad[i] = 0x5c ^ HMACKey[i]\n    InnerKeyPad[i] = 0x36 ^ HMACKey[i]\n  }\n  sodium_memzero(HMACKey)\n\n  crypto_generichash_batch(out, [InnerKeyPad].concat(data))\n  sodium_memzero(InnerKeyPad)\n  crypto_generichash_batch(out, [OuterKeyPad].concat(out))\n  sodium_memzero(OuterKeyPad)\n}\n\nmodule.exports.BYTES = HASHLEN\nmodule.exports.KEYBYTES = BLOCKLEN\n","start":1670465471672,"end":1670465471672,"order":"pre"},{"name":"commonjs","result":"/* eslint-disable camelcase */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as hmacBlake2bModule, exports as hmacBlake2b } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js?commonjs-module\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/memory.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/crypto_generichash.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@1.1.0/node_modules/nanoassert/index.js?commonjs-proxy\";\n\nvar { sodium_malloc, sodium_memzero } = require$$0\nvar { crypto_generichash, crypto_generichash_batch } = require$$1\nvar assert = require$$2\n\nvar HASHLEN = 64\nvar BLOCKLEN = 128\nvar scratch = sodium_malloc(BLOCKLEN * 3)\nvar HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1)\nvar OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2)\nvar InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3)\n\n// Post-fill is done in the cases where someone caught an exception that\n// happened before we were able to clear data at the end\nhmacBlake2bModule.exports = function hmac (out, data, key) {\n  assert(out.byteLength === HASHLEN)\n  assert(key.byteLength != null)\n  assert(Array.isArray(data) ? data.every(d => d.byteLength != null) : data.byteLength != null)\n\n  if (key.byteLength > BLOCKLEN) {\n    crypto_generichash(HMACKey.subarray(0, HASHLEN), key)\n    sodium_memzero(HMACKey.subarray(HASHLEN))\n  } else {\n    // Covers key <= BLOCKLEN\n    HMACKey.set(key)\n    sodium_memzero(HMACKey.subarray(key.byteLength))\n  }\n\n  for (var i = 0; i < HMACKey.byteLength; i++) {\n    OuterKeyPad[i] = 0x5c ^ HMACKey[i]\n    InnerKeyPad[i] = 0x36 ^ HMACKey[i]\n  }\n  sodium_memzero(HMACKey)\n\n  crypto_generichash_batch(out, [InnerKeyPad].concat(data))\n  sodium_memzero(InnerKeyPad)\n  crypto_generichash_batch(out, [OuterKeyPad].concat(out))\n  sodium_memzero(OuterKeyPad)\n}\n\nvar BYTES = hmacBlake2b.BYTES = HASHLEN\nvar KEYBYTES = hmacBlake2b.KEYBYTES = BLOCKLEN\n\nexport { hmacBlake2b as __moduleExports, BYTES, KEYBYTES, hmacBlake2b as default };","start":1670465471672,"end":1670465471788,"order":"normal"}]}
