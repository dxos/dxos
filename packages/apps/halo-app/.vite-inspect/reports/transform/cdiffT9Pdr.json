{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/sdk/config/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/sdk/config/src/index.ts\nimport * as defs from \"@dxos/protocols/proto/dxos/config\";\nimport { Config as Config2 } from \"@dxos/protocols/proto/dxos/config\";\n\n// packages/sdk/config/src/config.ts\nimport { boolean } from \"boolean\";\nimport defaultsDeep from \"lodash.defaultsdeep\";\nimport get from \"lodash.get\";\nimport set from \"lodash.set\";\n\n// packages/sdk/config/src/sanitizer.ts\nimport { sanitize } from \"@dxos/codec-protobuf\";\nimport { InvalidConfigError } from \"@dxos/errors\";\nimport { schema } from \"@dxos/protocols\";\nvar configRootType = schema.getCodecForType(\"dxos.config.Config\");\nvar sanitizeConfig = (config) => {\n  if (!(\"version\" in config)) {\n    throw new InvalidConfigError(\"Version not specified\");\n  }\n  if ((config == null ? void 0 : config.version) !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n  const ctx = {\n    errors: []\n  };\n  sanitize(configRootType.protoType, config, \"\", ctx);\n  if (ctx.errors.length > 0) {\n    throw new InvalidConfigError(ctx.errors.join(\"\\n\"));\n  }\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n  return config;\n};\n\n// packages/sdk/config/src/config.ts\nvar mapFromKeyValues = (spec, values) => {\n  const config = {};\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n    if (value !== void 0) {\n      if (type) {\n        switch (type) {\n          case \"boolean\": {\n            value = boolean(value);\n            break;\n          }\n          case \"number\": {\n            value = Number(value);\n            break;\n          }\n          case \"string\": {\n            break;\n          }\n          case \"json\": {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n      set(config, path, value);\n    }\n  }\n  return config;\n};\nvar mapToKeyValues = (spec, values) => {\n  const config = {};\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = get(values, path);\n    if (value !== void 0) {\n      switch (type) {\n        case \"json\":\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n  return config;\n};\nvar Config = class {\n  constructor(config = {}, ...objects) {\n    this._config = sanitizeConfig(defaultsDeep(config, ...objects, {\n      version: 1\n    }));\n  }\n  get values() {\n    return this._config;\n  }\n  get(key, defaultValue) {\n    return get(this._config, key, defaultValue);\n  }\n  getUnchecked(key, defaultValue) {\n    return get(this._config, key, defaultValue);\n  }\n  getOrThrow(key) {\n    const value = get(this._config, key);\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n};\n\n// packages/sdk/config/src/loaders/browser.js\nvar CONFIG_ENDPOINT = \"/.well-known/dx/config\";\nvar LocalStorage = (item = \"options\") => JSON.parse(window.localStorage.getItem(item) || \"{}\");\nvar Dynamics = async () => {\n  const { publicUrl = \"\", dynamic } = __DXOS_CONFIG__;\n  return dynamic ? await fetch(`${publicUrl}${CONFIG_ENDPOINT}`).then((res) => res.json()).catch((error) => {\n    console.warn(\"Failed to fetch dynamic config.\", error);\n    return __CONFIG_DYNAMICS__;\n  }) : __CONFIG_DYNAMICS__;\n};\nvar Envs = () => __CONFIG_ENVS__;\nvar Defaults = () => __CONFIG_DEFAULTS__;\n\n// packages/sdk/config/src/types.ts\nvar FILE_DEFAULTS = \"defaults.yml\";\nvar FILE_ENVS = \"envs-map.yml\";\nvar FILE_DYNAMICS = \"config.yml\";\nexport {\n  Config,\n  Config2 as ConfigProto,\n  Defaults,\n  Dynamics,\n  Envs,\n  FILE_DEFAULTS,\n  FILE_DYNAMICS,\n  FILE_ENVS,\n  LocalStorage,\n  defs,\n  mapFromKeyValues,\n  mapToKeyValues\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440097,"end":1670465440946},{"name":"vite:react-babel","result":"// packages/sdk/config/src/index.ts\nimport * as defs from \"@dxos/protocols/proto/dxos/config\";\nimport { Config as Config2 } from \"@dxos/protocols/proto/dxos/config\";\n\n// packages/sdk/config/src/config.ts\nimport { boolean } from \"boolean\";\nimport defaultsDeep from \"lodash.defaultsdeep\";\nimport get from \"lodash.get\";\nimport set from \"lodash.set\";\n\n// packages/sdk/config/src/sanitizer.ts\nimport { sanitize } from \"@dxos/codec-protobuf\";\nimport { InvalidConfigError } from \"@dxos/errors\";\nimport { schema } from \"@dxos/protocols\";\nvar configRootType = schema.getCodecForType(\"dxos.config.Config\");\nvar sanitizeConfig = (config) => {\n  if (!(\"version\" in config)) {\n    throw new InvalidConfigError(\"Version not specified\");\n  }\n  if ((config == null ? void 0 : config.version) !== 1) {\n    throw new InvalidConfigError(`Invalid config version: ${config.version}`);\n  }\n  const ctx = {\n    errors: []\n  };\n  sanitize(configRootType.protoType, config, \"\", ctx);\n  if (ctx.errors.length > 0) {\n    throw new InvalidConfigError(ctx.errors.join(\"\\n\"));\n  }\n  const error = configRootType.protoType.verify(config);\n  if (error) {\n    throw new InvalidConfigError(error);\n  }\n  return config;\n};\n\n// packages/sdk/config/src/config.ts\nvar mapFromKeyValues = (spec, values) => {\n  const config = {};\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    let value = values[key];\n    if (value !== void 0) {\n      if (type) {\n        switch (type) {\n          case \"boolean\": {\n            value = boolean(value);\n            break;\n          }\n          case \"number\": {\n            value = Number(value);\n            break;\n          }\n          case \"string\": {\n            break;\n          }\n          case \"json\": {\n            value = value ? JSON.parse(value) : null;\n            break;\n          }\n          default: {\n            throw new Error(`Invalid type: ${type}`);\n          }\n        }\n      }\n      set(config, path, value);\n    }\n  }\n  return config;\n};\nvar mapToKeyValues = (spec, values) => {\n  const config = {};\n  for (const [key, { path, type }] of Object.entries(spec)) {\n    const value = get(values, path);\n    if (value !== void 0) {\n      switch (type) {\n        case \"json\":\n          config[key] = JSON.stringify(value);\n          break;\n        default:\n          config[key] = value;\n      }\n    }\n  }\n  return config;\n};\nvar Config = class {\n  constructor(config = {}, ...objects) {\n    this._config = sanitizeConfig(defaultsDeep(config, ...objects, {\n      version: 1\n    }));\n  }\n  get values() {\n    return this._config;\n  }\n  get(key, defaultValue) {\n    return get(this._config, key, defaultValue);\n  }\n  getUnchecked(key, defaultValue) {\n    return get(this._config, key, defaultValue);\n  }\n  getOrThrow(key) {\n    const value = get(this._config, key);\n    if (!value) {\n      throw new Error(`Config option not present: ${key}`);\n    }\n    return value;\n  }\n};\n\n// packages/sdk/config/src/loaders/browser.js\nvar CONFIG_ENDPOINT = \"/.well-known/dx/config\";\nvar LocalStorage = (item = \"options\") => JSON.parse(window.localStorage.getItem(item) || \"{}\");\nvar Dynamics = async () => {\n  const { publicUrl = \"\", dynamic } = __DXOS_CONFIG__;\n  return dynamic ? await fetch(`${publicUrl}${CONFIG_ENDPOINT}`).then((res) => res.json()).catch((error) => {\n    console.warn(\"Failed to fetch dynamic config.\", error);\n    return __CONFIG_DYNAMICS__;\n  }) : __CONFIG_DYNAMICS__;\n};\nvar Envs = () => __CONFIG_ENVS__;\nvar Defaults = () => __CONFIG_DEFAULTS__;\n\n// packages/sdk/config/src/types.ts\nvar FILE_DEFAULTS = \"defaults.yml\";\nvar FILE_ENVS = \"envs-map.yml\";\nvar FILE_DYNAMICS = \"config.yml\";\nexport {\n  Config,\n  Config2 as ConfigProto,\n  Defaults,\n  Dynamics,\n  Envs,\n  FILE_DEFAULTS,\n  FILE_DYNAMICS,\n  FILE_ENVS,\n  LocalStorage,\n  defs,\n  mapFromKeyValues,\n  mapToKeyValues\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440946,"end":1670465440946,"order":"pre"}]}
