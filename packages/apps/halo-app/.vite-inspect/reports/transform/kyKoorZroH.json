{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/hypercore/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/hypercore/src/crypto.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { callbackify } from \"@dxos/node-std/util\";\nimport { verifySignature } from \"@dxos/crypto\";\nvar createCodecEncoding = (codec) => ({\n  encode: (obj) => Buffer.from(codec.encode(obj)),\n  decode: (buffer) => codec.decode(buffer)\n});\nvar createCrypto = (signer, publicKey) => {\n  assert(signer);\n  assert(publicKey);\n  return {\n    sign: (message, secretKey, cb) => {\n      callbackify(signer.sign.bind(signer))(publicKey, message, (err, result) => {\n        if (err) {\n          cb(err, null);\n          return;\n        }\n        cb(null, Buffer.from(result));\n      });\n    },\n    verify: async (message, signature, key, cb) => {\n      callbackify(verifySignature)(publicKey, message, signature, cb);\n    }\n  };\n};\n\n// packages/common/hypercore/src/defaults.ts\nvar defaultFeedOptions = {\n  createIfMissing: true,\n  valueEncoding: \"binary\"\n};\nvar defaultReadStreamOptions = {\n  start: 0,\n  end: Infinity,\n  snapshot: true,\n  tail: false,\n  live: false,\n  timeout: 0,\n  wait: true,\n  batch: 1\n};\nvar defaultWriteStreamOptions = {\n  maxBlockSize: Infinity\n};\nvar defaultReplicateOptions = {\n  live: false,\n  ack: false,\n  download: true,\n  upload: true,\n  encrypted: true,\n  noise: true\n};\n\n// packages/common/hypercore/src/hypercore-factory.ts\nimport hypercore from \"hypercore\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\n\n// packages/common/hypercore/src/util.ts\nimport util from \"@dxos/node-std/util\";\nvar py = (obj, fn) => util.promisify(fn.bind(obj));\n\n// packages/common/hypercore/src/hypercore-factory.ts\nvar HypercoreFactory = class {\n  constructor(_root = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(), _options) {\n    this._root = _root;\n    this._options = _options;\n    assert2(this._root);\n  }\n  createFeed(publicKey, options) {\n    const directory = this._root.createDirectory(publicKey.toString());\n    const storage = (filename) => directory.getOrCreateFile(filename).native;\n    return hypercore(storage, publicKey, Object.assign({}, this._options, options));\n  }\n  async openFeed(publicKey, options) {\n    const feed = this.createFeed(publicKey, options);\n    await py(feed, feed.open)();\n    return feed;\n  }\n};\n\n// packages/common/hypercore/src/iterator.ts\nimport { Readable } from \"readable-stream\";\nvar createReadable = (stream) => {\n  return new Readable({\n    objectMode: true\n  }).wrap(stream);\n};\nvar createAsyncIterator = (stream) => {\n  return stream[Symbol.asyncIterator]();\n};\nexport {\n  HypercoreFactory,\n  createAsyncIterator,\n  createCodecEncoding,\n  createCrypto,\n  createReadable,\n  defaultFeedOptions,\n  defaultReadStreamOptions,\n  defaultReplicateOptions,\n  defaultWriteStreamOptions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466953,"end":1670465466992},{"name":"vite:react-babel","result":"// packages/common/hypercore/src/crypto.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { callbackify } from \"@dxos/node-std/util\";\nimport { verifySignature } from \"@dxos/crypto\";\nvar createCodecEncoding = (codec) => ({\n  encode: (obj) => Buffer.from(codec.encode(obj)),\n  decode: (buffer) => codec.decode(buffer)\n});\nvar createCrypto = (signer, publicKey) => {\n  assert(signer);\n  assert(publicKey);\n  return {\n    sign: (message, secretKey, cb) => {\n      callbackify(signer.sign.bind(signer))(publicKey, message, (err, result) => {\n        if (err) {\n          cb(err, null);\n          return;\n        }\n        cb(null, Buffer.from(result));\n      });\n    },\n    verify: async (message, signature, key, cb) => {\n      callbackify(verifySignature)(publicKey, message, signature, cb);\n    }\n  };\n};\n\n// packages/common/hypercore/src/defaults.ts\nvar defaultFeedOptions = {\n  createIfMissing: true,\n  valueEncoding: \"binary\"\n};\nvar defaultReadStreamOptions = {\n  start: 0,\n  end: Infinity,\n  snapshot: true,\n  tail: false,\n  live: false,\n  timeout: 0,\n  wait: true,\n  batch: 1\n};\nvar defaultWriteStreamOptions = {\n  maxBlockSize: Infinity\n};\nvar defaultReplicateOptions = {\n  live: false,\n  ack: false,\n  download: true,\n  upload: true,\n  encrypted: true,\n  noise: true\n};\n\n// packages/common/hypercore/src/hypercore-factory.ts\nimport hypercore from \"hypercore\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\n\n// packages/common/hypercore/src/util.ts\nimport util from \"@dxos/node-std/util\";\nvar py = (obj, fn) => util.promisify(fn.bind(obj));\n\n// packages/common/hypercore/src/hypercore-factory.ts\nvar HypercoreFactory = class {\n  constructor(_root = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(), _options) {\n    this._root = _root;\n    this._options = _options;\n    assert2(this._root);\n  }\n  createFeed(publicKey, options) {\n    const directory = this._root.createDirectory(publicKey.toString());\n    const storage = (filename) => directory.getOrCreateFile(filename).native;\n    return hypercore(storage, publicKey, Object.assign({}, this._options, options));\n  }\n  async openFeed(publicKey, options) {\n    const feed = this.createFeed(publicKey, options);\n    await py(feed, feed.open)();\n    return feed;\n  }\n};\n\n// packages/common/hypercore/src/iterator.ts\nimport { Readable } from \"readable-stream\";\nvar createReadable = (stream) => {\n  return new Readable({\n    objectMode: true\n  }).wrap(stream);\n};\nvar createAsyncIterator = (stream) => {\n  return stream[Symbol.asyncIterator]();\n};\nexport {\n  HypercoreFactory,\n  createAsyncIterator,\n  createCodecEncoding,\n  createCrypto,\n  createReadable,\n  defaultFeedOptions,\n  defaultReadStreamOptions,\n  defaultReplicateOptions,\n  defaultWriteStreamOptions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466992,"end":1670465466992,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/hypercore/src/crypto.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { callbackify } from \"@dxos/node-std/util\";\nimport { verifySignature } from \"@dxos/crypto\";\nvar createCodecEncoding = (codec) => ({\n  encode: (obj) => Buffer.from(codec.encode(obj)),\n  decode: (buffer) => codec.decode(buffer)\n});\nvar createCrypto = (signer, publicKey) => {\n  assert(signer);\n  assert(publicKey);\n  return {\n    sign: (message, secretKey, cb) => {\n      callbackify(signer.sign.bind(signer))(publicKey, message, (err, result) => {\n        if (err) {\n          cb(err, null);\n          return;\n        }\n        cb(null, Buffer.from(result));\n      });\n    },\n    verify: async (message, signature, key, cb) => {\n      callbackify(verifySignature)(publicKey, message, signature, cb);\n    }\n  };\n};\n\n// packages/common/hypercore/src/defaults.ts\nvar defaultFeedOptions = {\n  createIfMissing: true,\n  valueEncoding: \"binary\"\n};\nvar defaultReadStreamOptions = {\n  start: 0,\n  end: Infinity,\n  snapshot: true,\n  tail: false,\n  live: false,\n  timeout: 0,\n  wait: true,\n  batch: 1\n};\nvar defaultWriteStreamOptions = {\n  maxBlockSize: Infinity\n};\nvar defaultReplicateOptions = {\n  live: false,\n  ack: false,\n  download: true,\n  upload: true,\n  encrypted: true,\n  noise: true\n};\n\n// packages/common/hypercore/src/hypercore-factory.ts\nimport hypercore from \"hypercore\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\n\n// packages/common/hypercore/src/util.ts\nimport util from \"@dxos/node-std/util\";\nvar py = (obj, fn) => util.promisify(fn.bind(obj));\n\n// packages/common/hypercore/src/hypercore-factory.ts\nvar HypercoreFactory = class {\n  constructor(_root = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(), _options) {\n    this._root = _root;\n    this._options = _options;\n    assert2(this._root);\n  }\n  createFeed(publicKey, options) {\n    const directory = this._root.createDirectory(publicKey.toString());\n    const storage = (filename) => directory.getOrCreateFile(filename).native;\n    return hypercore(storage, publicKey, Object.assign({}, this._options, options));\n  }\n  async openFeed(publicKey, options) {\n    const feed = this.createFeed(publicKey, options);\n    await py(feed, feed.open)();\n    return feed;\n  }\n};\n\n// packages/common/hypercore/src/iterator.ts\nimport { Readable } from \"readable-stream\";\nvar createReadable = (stream) => {\n  return new Readable({\n    objectMode: true\n  }).wrap(stream);\n};\nvar createAsyncIterator = (stream) => {\n  return stream[Symbol.asyncIterator]();\n};\nexport {\n  HypercoreFactory,\n  createAsyncIterator,\n  createCodecEncoding,\n  createCrypto,\n  createReadable,\n  defaultFeedOptions,\n  defaultReadStreamOptions,\n  defaultReplicateOptions,\n  defaultWriteStreamOptions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466992,"end":1670465466993,"order":"normal"}]}
