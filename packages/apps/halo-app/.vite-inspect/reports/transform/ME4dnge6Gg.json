{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/teleport/src/muxing/framer.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport * as varint from \"varint\";\nvar Framer = class {\n  constructor() {\n    this._stream = new Duplex({\n      objectMode: false,\n      read: () => {\n      },\n      write: (chunk, encoding, callback) => {\n        assert(!this._subscribeCb, \"Internal Framer bug. Concurrent writes detected.\");\n        if (this._buffer && this._buffer.length > 0) {\n          this._buffer = Buffer.concat([\n            this._buffer,\n            chunk\n          ]);\n        } else {\n          this._buffer = chunk;\n        }\n        if (this._messageCb) {\n          this._popFrames();\n          callback();\n        } else {\n          this._subscribeCb = () => {\n            this._popFrames();\n            this._subscribeCb = void 0;\n            callback();\n          };\n        }\n      }\n    });\n    this.port = {\n      send: (message) => {\n        this._stream.push(encodeLength(message.length));\n        this._stream.push(message);\n      },\n      subscribe: (callback) => {\n        var _a;\n        assert(!this._messageCb, \"Rpc port already has a message listener.\");\n        this._messageCb = callback;\n        (_a = this._subscribeCb) == null ? void 0 : _a.call(this);\n        return () => {\n          this._messageCb = void 0;\n        };\n      }\n    };\n  }\n  get stream() {\n    return this._stream;\n  }\n  _popFrames() {\n    let offset = 0;\n    while (offset < this._buffer.length) {\n      const frame = readFrame(this._buffer, offset);\n      if (!frame) {\n        break;\n      }\n      offset += frame.bytesConsumed;\n      this._messageCb(frame.payload);\n    }\n    if (offset < this._buffer.length) {\n      this._buffer = this._buffer.subarray(offset);\n    } else {\n      this._buffer = void 0;\n    }\n  }\n  destroy() {\n    this._stream.destroy();\n  }\n};\nvar readFrame = (buffer, offset) => {\n  try {\n    const frameLength = varint.decode(buffer, offset);\n    const tagLength = varint.decode.bytes;\n    if (buffer.length < offset + tagLength + frameLength) {\n      return void 0;\n    }\n    const payload = buffer.subarray(offset + tagLength, offset + tagLength + frameLength);\n    return {\n      payload,\n      bytesConsumed: tagLength + frameLength\n    };\n  } catch (err) {\n    if (err instanceof RangeError) {\n      return void 0;\n    } else {\n      throw err;\n    }\n  }\n};\nvar encodeLength = (length) => {\n  const res = varint.encode(length, Buffer.allocUnsafe(4)).subarray(0, varint.encode.bytes);\n  if (varint.encode.bytes > 4) {\n    throw new Error(\"Frame too large\");\n  }\n  return res;\n};\n\n// packages/core/mesh/teleport/src/muxing/muxer.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Duplex as Duplex2 } from \"@dxos/node-std/stream\";\nimport { Event } from \"@dxos/async\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.mesh.muxer.Command\");\nvar Muxer = class {\n  constructor() {\n    this._framer = new Framer();\n    this.stream = this._framer.stream;\n    this._channelsByLocalId = /* @__PURE__ */ new Map();\n    this._channelsByTag = /* @__PURE__ */ new Map();\n    this._nextId = 0;\n    this._destroyed = false;\n    this._destroying = false;\n    this.close = new Event();\n    this._framer.port.subscribe((msg) => {\n      this._handleCommand(codec.decode(msg));\n    });\n  }\n  createStream(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    const stream = new Duplex2({\n      write: (data, encoding, callback) => {\n        this._sendData(channel, data);\n        callback();\n      },\n      read: () => {\n      }\n    });\n    channel.push = (data) => {\n      stream.push(data);\n    };\n    channel.destroy = (err) => {\n      stream.destroy(err);\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return stream;\n  }\n  createPort(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    let inboundBuffer = [];\n    let callback;\n    channel.push = (data) => {\n      if (callback) {\n        callback(data);\n      } else {\n        inboundBuffer.push(data);\n      }\n    };\n    const port = {\n      send: (data) => {\n        this._sendData(channel, data);\n      },\n      subscribe: (cb) => {\n        assert2(!callback, \"Only one subscriber is allowed\");\n        callback = cb;\n        for (const data of inboundBuffer) {\n          cb(data);\n        }\n        inboundBuffer = [];\n      }\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return port;\n  }\n  destroy(err) {\n    if (this._destroying) {\n      return;\n    }\n    this._destroying = true;\n    this._sendCommand({\n      destroy: {\n        error: err == null ? void 0 : err.message\n      }\n    });\n    this._dispose();\n  }\n  _dispose(err) {\n    var _a;\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this._framer.destroy();\n    for (const channel of this._channelsByTag.values()) {\n      (_a = channel.destroy) == null ? void 0 : _a.call(channel, err);\n    }\n    this.close.emit(err);\n    this._channelsByLocalId.clear();\n    this._channelsByTag.clear();\n  }\n  _handleCommand(cmd) {\n    var _a;\n    log(\"Received command\", {\n      cmd\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n      line: 194,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._destroyed || this._destroying) {\n      log.warn(\"Received command after destroy\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n        line: 197,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (cmd.openChannel) {\n      const channel = this._getOrCreateStream({\n        tag: cmd.openChannel.tag,\n        contentType: cmd.openChannel.contentType\n      });\n      channel.remoteId = cmd.openChannel.id;\n      for (const data of channel.buffer) {\n        this._sendCommand({\n          data: {\n            channelId: channel.remoteId,\n            data\n          }\n        });\n      }\n      channel.buffer = [];\n    } else if (cmd.data) {\n      const stream = (_a = this._channelsByLocalId.get(cmd.data.channelId)) != null ? _a : failUndefined();\n      if (!stream.push) {\n        log.warn(\"Received data for channel before it was opened\", {\n          tag: stream.tag\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n          line: 221,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      stream.push(cmd.data.data);\n    } else if (cmd.destroy) {\n      this._dispose();\n    }\n  }\n  _sendCommand(cmd) {\n    Promise.resolve(this._framer.port.send(codec.encode(cmd))).catch((err) => {\n      this.destroy(err);\n    });\n  }\n  _getOrCreateStream(params) {\n    let channel = this._channelsByTag.get(params.tag);\n    if (!channel) {\n      channel = {\n        id: this._nextId++,\n        remoteId: null,\n        tag: params.tag,\n        contentType: params.contentType,\n        buffer: [],\n        push: null,\n        destroy: null\n      };\n      this._channelsByTag.set(channel.tag, channel);\n      this._channelsByLocalId.set(channel.id, channel);\n    }\n    return channel;\n  }\n  _sendData(channel, data) {\n    if (channel.remoteId === null) {\n      channel.buffer.push(data);\n    } else {\n      this._sendCommand({\n        data: {\n          channelId: channel.remoteId,\n          data\n        }\n      });\n    }\n  }\n};\n\n// packages/core/mesh/teleport/src/teleport.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { asyncTimeout, scheduleTaskInterval, runInContextAsync, synchronized, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer, RpcClosedError } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Teleport = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this._ctx = new Context({\n      onError: (err) => {\n        void this.destroy(err).catch(() => {\n          log2.error(\"Error during destroy\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n            line: 34,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      }\n    });\n    this._muxer = new Muxer();\n    this._control = new ControlExtension({\n      heartbeatInterval: 3e3,\n      heartbeatTimeout: 3e3\n    });\n    this._extensions = /* @__PURE__ */ new Map();\n    this._remoteExtensions = /* @__PURE__ */ new Set();\n    this._open = false;\n    assert3(typeof initiator === \"boolean\");\n    assert3(PublicKey.isPublicKey(localPeerId));\n    assert3(PublicKey.isPublicKey(remotePeerId));\n    assert3(typeof initiator === \"boolean\");\n    this.initiator = initiator;\n    this.localPeerId = localPeerId;\n    this.remotePeerId = remotePeerId;\n    this._control.onExtensionRegistered.set(async (name) => {\n      log2(\"remote extension\", {\n        name\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n        line: 61,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert3(!this._remoteExtensions.has(name), \"Remote extension already exists\");\n      this._remoteExtensions.add(name);\n      if (this._extensions.has(name)) {\n        try {\n          await this._openExtension(name);\n        } catch (err) {\n          await this.destroy(err);\n        }\n      }\n    });\n    {\n      this._muxer.stream.on(\"close\", async () => {\n        await this.destroy();\n      });\n      this._muxer.stream.on(\"error\", async (err) => {\n        await this.destroy(err);\n      });\n    }\n  }\n  get stream() {\n    return this._muxer.stream;\n  }\n  async open() {\n    this._setExtension(\"dxos.mesh.teleport.control\", this._control);\n    await this._openExtension(\"dxos.mesh.teleport.control\");\n    this._open = true;\n  }\n  async close(err) {\n    await this.destroy(err);\n  }\n  async destroy(err) {\n    if (this._ctx.disposed) {\n      return;\n    }\n    await this._ctx.dispose();\n    for (const extension of this._extensions.values()) {\n      try {\n        await extension.onClose(err);\n      } catch (err1) {\n        log2.catch(err1, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n          line: 117,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this._muxer.destroy(err);\n  }\n  addExtension(name, extension) {\n    if (!this._open) {\n      throw new Error(\"Not open\");\n    }\n    log2(\"addExtension\", {\n      name\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 129,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._setExtension(name, extension);\n    scheduleTask(this._ctx, async () => {\n      try {\n        await this._control.registerExtension(name);\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n        throw err;\n      }\n    });\n    if (this._remoteExtensions.has(name)) {\n      scheduleTask(this._ctx, async () => {\n        await this._openExtension(name);\n      });\n    }\n  }\n  _setExtension(extensionName, extension) {\n    assert3(!extensionName.includes(\"/\"), \"Invalid extension name\");\n    assert3(!this._extensions.has(extensionName), \"Extension already exists\");\n    this._extensions.set(extensionName, extension);\n  }\n  async _openExtension(extensionName) {\n    var _a;\n    log2(\"open extension\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 159,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const extension = (_a = this._extensions.get(extensionName)) != null ? _a : failUndefined2();\n    const context = {\n      initiator: this.initiator,\n      localPeerId: this.localPeerId,\n      remotePeerId: this.remotePeerId,\n      createPort: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);\n      },\n      createStream: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);\n      },\n      close: (err) => {\n        void runInContextAsync(this._ctx, async () => {\n          await this.close(err);\n        });\n      }\n    };\n    await extension.onOpen(context);\n    log2(\"extension opened\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n__decorate([\n  synchronized\n], Teleport.prototype, \"destroy\", null);\nvar ControlExtension = class {\n  constructor(opts) {\n    this.opts = opts;\n    this._ctx = new Context({\n      onError: (err) => {\n        this._extensionContext.close(err);\n      }\n    });\n    this.onExtensionRegistered = new Callback();\n    this.onTimeout = new Callback();\n  }\n  async onOpen(extensionContext) {\n    this._extensionContext = extensionContext;\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      exposed: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      handlers: {\n        Control: {\n          registerExtension: async (request) => {\n            this.onExtensionRegistered.call(request.name);\n          },\n          heartbeat: async (request) => {\n          }\n        }\n      },\n      port: extensionContext.createPort(\"rpc\", {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n      })\n    });\n    await this._rpc.open();\n    scheduleTaskInterval(this._ctx, async () => {\n      try {\n        await asyncTimeout(this._rpc.rpc.Control.heartbeat(), this.opts.heartbeatTimeout);\n      } catch (err) {\n        this.onTimeout.call();\n      }\n    }, this.opts.heartbeatInterval);\n  }\n  async onClose(err) {\n    await this._ctx.dispose();\n    await this._rpc.close();\n  }\n  async registerExtension(name) {\n    await this._rpc.rpc.Control.registerExtension({\n      name\n    });\n  }\n};\nexport {\n  Framer,\n  Muxer,\n  Teleport,\n  readFrame\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466974,"end":1670465467072},{"name":"vite:react-babel","result":"// packages/core/mesh/teleport/src/muxing/framer.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport * as varint from \"varint\";\nvar Framer = class {\n  constructor() {\n    this._stream = new Duplex({\n      objectMode: false,\n      read: () => {\n      },\n      write: (chunk, encoding, callback) => {\n        assert(!this._subscribeCb, \"Internal Framer bug. Concurrent writes detected.\");\n        if (this._buffer && this._buffer.length > 0) {\n          this._buffer = Buffer.concat([\n            this._buffer,\n            chunk\n          ]);\n        } else {\n          this._buffer = chunk;\n        }\n        if (this._messageCb) {\n          this._popFrames();\n          callback();\n        } else {\n          this._subscribeCb = () => {\n            this._popFrames();\n            this._subscribeCb = void 0;\n            callback();\n          };\n        }\n      }\n    });\n    this.port = {\n      send: (message) => {\n        this._stream.push(encodeLength(message.length));\n        this._stream.push(message);\n      },\n      subscribe: (callback) => {\n        var _a;\n        assert(!this._messageCb, \"Rpc port already has a message listener.\");\n        this._messageCb = callback;\n        (_a = this._subscribeCb) == null ? void 0 : _a.call(this);\n        return () => {\n          this._messageCb = void 0;\n        };\n      }\n    };\n  }\n  get stream() {\n    return this._stream;\n  }\n  _popFrames() {\n    let offset = 0;\n    while (offset < this._buffer.length) {\n      const frame = readFrame(this._buffer, offset);\n      if (!frame) {\n        break;\n      }\n      offset += frame.bytesConsumed;\n      this._messageCb(frame.payload);\n    }\n    if (offset < this._buffer.length) {\n      this._buffer = this._buffer.subarray(offset);\n    } else {\n      this._buffer = void 0;\n    }\n  }\n  destroy() {\n    this._stream.destroy();\n  }\n};\nvar readFrame = (buffer, offset) => {\n  try {\n    const frameLength = varint.decode(buffer, offset);\n    const tagLength = varint.decode.bytes;\n    if (buffer.length < offset + tagLength + frameLength) {\n      return void 0;\n    }\n    const payload = buffer.subarray(offset + tagLength, offset + tagLength + frameLength);\n    return {\n      payload,\n      bytesConsumed: tagLength + frameLength\n    };\n  } catch (err) {\n    if (err instanceof RangeError) {\n      return void 0;\n    } else {\n      throw err;\n    }\n  }\n};\nvar encodeLength = (length) => {\n  const res = varint.encode(length, Buffer.allocUnsafe(4)).subarray(0, varint.encode.bytes);\n  if (varint.encode.bytes > 4) {\n    throw new Error(\"Frame too large\");\n  }\n  return res;\n};\n\n// packages/core/mesh/teleport/src/muxing/muxer.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Duplex as Duplex2 } from \"@dxos/node-std/stream\";\nimport { Event } from \"@dxos/async\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.mesh.muxer.Command\");\nvar Muxer = class {\n  constructor() {\n    this._framer = new Framer();\n    this.stream = this._framer.stream;\n    this._channelsByLocalId = /* @__PURE__ */ new Map();\n    this._channelsByTag = /* @__PURE__ */ new Map();\n    this._nextId = 0;\n    this._destroyed = false;\n    this._destroying = false;\n    this.close = new Event();\n    this._framer.port.subscribe((msg) => {\n      this._handleCommand(codec.decode(msg));\n    });\n  }\n  createStream(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    const stream = new Duplex2({\n      write: (data, encoding, callback) => {\n        this._sendData(channel, data);\n        callback();\n      },\n      read: () => {\n      }\n    });\n    channel.push = (data) => {\n      stream.push(data);\n    };\n    channel.destroy = (err) => {\n      stream.destroy(err);\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return stream;\n  }\n  createPort(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    let inboundBuffer = [];\n    let callback;\n    channel.push = (data) => {\n      if (callback) {\n        callback(data);\n      } else {\n        inboundBuffer.push(data);\n      }\n    };\n    const port = {\n      send: (data) => {\n        this._sendData(channel, data);\n      },\n      subscribe: (cb) => {\n        assert2(!callback, \"Only one subscriber is allowed\");\n        callback = cb;\n        for (const data of inboundBuffer) {\n          cb(data);\n        }\n        inboundBuffer = [];\n      }\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return port;\n  }\n  destroy(err) {\n    if (this._destroying) {\n      return;\n    }\n    this._destroying = true;\n    this._sendCommand({\n      destroy: {\n        error: err == null ? void 0 : err.message\n      }\n    });\n    this._dispose();\n  }\n  _dispose(err) {\n    var _a;\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this._framer.destroy();\n    for (const channel of this._channelsByTag.values()) {\n      (_a = channel.destroy) == null ? void 0 : _a.call(channel, err);\n    }\n    this.close.emit(err);\n    this._channelsByLocalId.clear();\n    this._channelsByTag.clear();\n  }\n  _handleCommand(cmd) {\n    var _a;\n    log(\"Received command\", {\n      cmd\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n      line: 194,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._destroyed || this._destroying) {\n      log.warn(\"Received command after destroy\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n        line: 197,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (cmd.openChannel) {\n      const channel = this._getOrCreateStream({\n        tag: cmd.openChannel.tag,\n        contentType: cmd.openChannel.contentType\n      });\n      channel.remoteId = cmd.openChannel.id;\n      for (const data of channel.buffer) {\n        this._sendCommand({\n          data: {\n            channelId: channel.remoteId,\n            data\n          }\n        });\n      }\n      channel.buffer = [];\n    } else if (cmd.data) {\n      const stream = (_a = this._channelsByLocalId.get(cmd.data.channelId)) != null ? _a : failUndefined();\n      if (!stream.push) {\n        log.warn(\"Received data for channel before it was opened\", {\n          tag: stream.tag\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n          line: 221,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      stream.push(cmd.data.data);\n    } else if (cmd.destroy) {\n      this._dispose();\n    }\n  }\n  _sendCommand(cmd) {\n    Promise.resolve(this._framer.port.send(codec.encode(cmd))).catch((err) => {\n      this.destroy(err);\n    });\n  }\n  _getOrCreateStream(params) {\n    let channel = this._channelsByTag.get(params.tag);\n    if (!channel) {\n      channel = {\n        id: this._nextId++,\n        remoteId: null,\n        tag: params.tag,\n        contentType: params.contentType,\n        buffer: [],\n        push: null,\n        destroy: null\n      };\n      this._channelsByTag.set(channel.tag, channel);\n      this._channelsByLocalId.set(channel.id, channel);\n    }\n    return channel;\n  }\n  _sendData(channel, data) {\n    if (channel.remoteId === null) {\n      channel.buffer.push(data);\n    } else {\n      this._sendCommand({\n        data: {\n          channelId: channel.remoteId,\n          data\n        }\n      });\n    }\n  }\n};\n\n// packages/core/mesh/teleport/src/teleport.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { asyncTimeout, scheduleTaskInterval, runInContextAsync, synchronized, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer, RpcClosedError } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Teleport = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this._ctx = new Context({\n      onError: (err) => {\n        void this.destroy(err).catch(() => {\n          log2.error(\"Error during destroy\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n            line: 34,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      }\n    });\n    this._muxer = new Muxer();\n    this._control = new ControlExtension({\n      heartbeatInterval: 3e3,\n      heartbeatTimeout: 3e3\n    });\n    this._extensions = /* @__PURE__ */ new Map();\n    this._remoteExtensions = /* @__PURE__ */ new Set();\n    this._open = false;\n    assert3(typeof initiator === \"boolean\");\n    assert3(PublicKey.isPublicKey(localPeerId));\n    assert3(PublicKey.isPublicKey(remotePeerId));\n    assert3(typeof initiator === \"boolean\");\n    this.initiator = initiator;\n    this.localPeerId = localPeerId;\n    this.remotePeerId = remotePeerId;\n    this._control.onExtensionRegistered.set(async (name) => {\n      log2(\"remote extension\", {\n        name\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n        line: 61,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert3(!this._remoteExtensions.has(name), \"Remote extension already exists\");\n      this._remoteExtensions.add(name);\n      if (this._extensions.has(name)) {\n        try {\n          await this._openExtension(name);\n        } catch (err) {\n          await this.destroy(err);\n        }\n      }\n    });\n    {\n      this._muxer.stream.on(\"close\", async () => {\n        await this.destroy();\n      });\n      this._muxer.stream.on(\"error\", async (err) => {\n        await this.destroy(err);\n      });\n    }\n  }\n  get stream() {\n    return this._muxer.stream;\n  }\n  async open() {\n    this._setExtension(\"dxos.mesh.teleport.control\", this._control);\n    await this._openExtension(\"dxos.mesh.teleport.control\");\n    this._open = true;\n  }\n  async close(err) {\n    await this.destroy(err);\n  }\n  async destroy(err) {\n    if (this._ctx.disposed) {\n      return;\n    }\n    await this._ctx.dispose();\n    for (const extension of this._extensions.values()) {\n      try {\n        await extension.onClose(err);\n      } catch (err1) {\n        log2.catch(err1, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n          line: 117,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this._muxer.destroy(err);\n  }\n  addExtension(name, extension) {\n    if (!this._open) {\n      throw new Error(\"Not open\");\n    }\n    log2(\"addExtension\", {\n      name\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 129,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._setExtension(name, extension);\n    scheduleTask(this._ctx, async () => {\n      try {\n        await this._control.registerExtension(name);\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n        throw err;\n      }\n    });\n    if (this._remoteExtensions.has(name)) {\n      scheduleTask(this._ctx, async () => {\n        await this._openExtension(name);\n      });\n    }\n  }\n  _setExtension(extensionName, extension) {\n    assert3(!extensionName.includes(\"/\"), \"Invalid extension name\");\n    assert3(!this._extensions.has(extensionName), \"Extension already exists\");\n    this._extensions.set(extensionName, extension);\n  }\n  async _openExtension(extensionName) {\n    var _a;\n    log2(\"open extension\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 159,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const extension = (_a = this._extensions.get(extensionName)) != null ? _a : failUndefined2();\n    const context = {\n      initiator: this.initiator,\n      localPeerId: this.localPeerId,\n      remotePeerId: this.remotePeerId,\n      createPort: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);\n      },\n      createStream: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);\n      },\n      close: (err) => {\n        void runInContextAsync(this._ctx, async () => {\n          await this.close(err);\n        });\n      }\n    };\n    await extension.onOpen(context);\n    log2(\"extension opened\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n__decorate([\n  synchronized\n], Teleport.prototype, \"destroy\", null);\nvar ControlExtension = class {\n  constructor(opts) {\n    this.opts = opts;\n    this._ctx = new Context({\n      onError: (err) => {\n        this._extensionContext.close(err);\n      }\n    });\n    this.onExtensionRegistered = new Callback();\n    this.onTimeout = new Callback();\n  }\n  async onOpen(extensionContext) {\n    this._extensionContext = extensionContext;\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      exposed: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      handlers: {\n        Control: {\n          registerExtension: async (request) => {\n            this.onExtensionRegistered.call(request.name);\n          },\n          heartbeat: async (request) => {\n          }\n        }\n      },\n      port: extensionContext.createPort(\"rpc\", {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n      })\n    });\n    await this._rpc.open();\n    scheduleTaskInterval(this._ctx, async () => {\n      try {\n        await asyncTimeout(this._rpc.rpc.Control.heartbeat(), this.opts.heartbeatTimeout);\n      } catch (err) {\n        this.onTimeout.call();\n      }\n    }, this.opts.heartbeatInterval);\n  }\n  async onClose(err) {\n    await this._ctx.dispose();\n    await this._rpc.close();\n  }\n  async registerExtension(name) {\n    await this._rpc.rpc.Control.registerExtension({\n      name\n    });\n  }\n};\nexport {\n  Framer,\n  Muxer,\n  Teleport,\n  readFrame\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467072,"end":1670465467072,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/mesh/teleport/src/muxing/framer.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport * as varint from \"varint\";\nvar Framer = class {\n  constructor() {\n    this._stream = new Duplex({\n      objectMode: false,\n      read: () => {\n      },\n      write: (chunk, encoding, callback) => {\n        assert(!this._subscribeCb, \"Internal Framer bug. Concurrent writes detected.\");\n        if (this._buffer && this._buffer.length > 0) {\n          this._buffer = Buffer.concat([\n            this._buffer,\n            chunk\n          ]);\n        } else {\n          this._buffer = chunk;\n        }\n        if (this._messageCb) {\n          this._popFrames();\n          callback();\n        } else {\n          this._subscribeCb = () => {\n            this._popFrames();\n            this._subscribeCb = void 0;\n            callback();\n          };\n        }\n      }\n    });\n    this.port = {\n      send: (message) => {\n        this._stream.push(encodeLength(message.length));\n        this._stream.push(message);\n      },\n      subscribe: (callback) => {\n        var _a;\n        assert(!this._messageCb, \"Rpc port already has a message listener.\");\n        this._messageCb = callback;\n        (_a = this._subscribeCb) == null ? void 0 : _a.call(this);\n        return () => {\n          this._messageCb = void 0;\n        };\n      }\n    };\n  }\n  get stream() {\n    return this._stream;\n  }\n  _popFrames() {\n    let offset = 0;\n    while (offset < this._buffer.length) {\n      const frame = readFrame(this._buffer, offset);\n      if (!frame) {\n        break;\n      }\n      offset += frame.bytesConsumed;\n      this._messageCb(frame.payload);\n    }\n    if (offset < this._buffer.length) {\n      this._buffer = this._buffer.subarray(offset);\n    } else {\n      this._buffer = void 0;\n    }\n  }\n  destroy() {\n    this._stream.destroy();\n  }\n};\nvar readFrame = (buffer, offset) => {\n  try {\n    const frameLength = varint.decode(buffer, offset);\n    const tagLength = varint.decode.bytes;\n    if (buffer.length < offset + tagLength + frameLength) {\n      return void 0;\n    }\n    const payload = buffer.subarray(offset + tagLength, offset + tagLength + frameLength);\n    return {\n      payload,\n      bytesConsumed: tagLength + frameLength\n    };\n  } catch (err) {\n    if (err instanceof RangeError) {\n      return void 0;\n    } else {\n      throw err;\n    }\n  }\n};\nvar encodeLength = (length) => {\n  const res = varint.encode(length, Buffer.allocUnsafe(4)).subarray(0, varint.encode.bytes);\n  if (varint.encode.bytes > 4) {\n    throw new Error(\"Frame too large\");\n  }\n  return res;\n};\n\n// packages/core/mesh/teleport/src/muxing/muxer.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Duplex as Duplex2 } from \"@dxos/node-std/stream\";\nimport { Event } from \"@dxos/async\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.mesh.muxer.Command\");\nvar Muxer = class {\n  constructor() {\n    this._framer = new Framer();\n    this.stream = this._framer.stream;\n    this._channelsByLocalId = /* @__PURE__ */ new Map();\n    this._channelsByTag = /* @__PURE__ */ new Map();\n    this._nextId = 0;\n    this._destroyed = false;\n    this._destroying = false;\n    this.close = new Event();\n    this._framer.port.subscribe((msg) => {\n      this._handleCommand(codec.decode(msg));\n    });\n  }\n  createStream(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    const stream = new Duplex2({\n      write: (data, encoding, callback) => {\n        this._sendData(channel, data);\n        callback();\n      },\n      read: () => {\n      }\n    });\n    channel.push = (data) => {\n      stream.push(data);\n    };\n    channel.destroy = (err) => {\n      stream.destroy(err);\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return stream;\n  }\n  createPort(tag, opts = {}) {\n    const channel = this._getOrCreateStream({\n      tag,\n      contentType: opts.contentType\n    });\n    assert2(!channel.push, `Channel already open: ${tag}`);\n    let inboundBuffer = [];\n    let callback;\n    channel.push = (data) => {\n      if (callback) {\n        callback(data);\n      } else {\n        inboundBuffer.push(data);\n      }\n    };\n    const port = {\n      send: (data) => {\n        this._sendData(channel, data);\n      },\n      subscribe: (cb) => {\n        assert2(!callback, \"Only one subscriber is allowed\");\n        callback = cb;\n        for (const data of inboundBuffer) {\n          cb(data);\n        }\n        inboundBuffer = [];\n      }\n    };\n    this._sendCommand({\n      openChannel: {\n        id: channel.id,\n        tag: channel.tag,\n        contentType: channel.contentType\n      }\n    });\n    return port;\n  }\n  destroy(err) {\n    if (this._destroying) {\n      return;\n    }\n    this._destroying = true;\n    this._sendCommand({\n      destroy: {\n        error: err == null ? void 0 : err.message\n      }\n    });\n    this._dispose();\n  }\n  _dispose(err) {\n    var _a;\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this._framer.destroy();\n    for (const channel of this._channelsByTag.values()) {\n      (_a = channel.destroy) == null ? void 0 : _a.call(channel, err);\n    }\n    this.close.emit(err);\n    this._channelsByLocalId.clear();\n    this._channelsByTag.clear();\n  }\n  _handleCommand(cmd) {\n    var _a;\n    log(\"Received command\", {\n      cmd\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n      line: 194,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._destroyed || this._destroying) {\n      log.warn(\"Received command after destroy\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n        line: 197,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (cmd.openChannel) {\n      const channel = this._getOrCreateStream({\n        tag: cmd.openChannel.tag,\n        contentType: cmd.openChannel.contentType\n      });\n      channel.remoteId = cmd.openChannel.id;\n      for (const data of channel.buffer) {\n        this._sendCommand({\n          data: {\n            channelId: channel.remoteId,\n            data\n          }\n        });\n      }\n      channel.buffer = [];\n    } else if (cmd.data) {\n      const stream = (_a = this._channelsByLocalId.get(cmd.data.channelId)) != null ? _a : failUndefined();\n      if (!stream.push) {\n        log.warn(\"Received data for channel before it was opened\", {\n          tag: stream.tag\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/muxing/muxer.ts\",\n          line: 221,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      stream.push(cmd.data.data);\n    } else if (cmd.destroy) {\n      this._dispose();\n    }\n  }\n  _sendCommand(cmd) {\n    Promise.resolve(this._framer.port.send(codec.encode(cmd))).catch((err) => {\n      this.destroy(err);\n    });\n  }\n  _getOrCreateStream(params) {\n    let channel = this._channelsByTag.get(params.tag);\n    if (!channel) {\n      channel = {\n        id: this._nextId++,\n        remoteId: null,\n        tag: params.tag,\n        contentType: params.contentType,\n        buffer: [],\n        push: null,\n        destroy: null\n      };\n      this._channelsByTag.set(channel.tag, channel);\n      this._channelsByLocalId.set(channel.id, channel);\n    }\n    return channel;\n  }\n  _sendData(channel, data) {\n    if (channel.remoteId === null) {\n      channel.buffer.push(data);\n    } else {\n      this._sendCommand({\n        data: {\n          channelId: channel.remoteId,\n          data\n        }\n      });\n    }\n  }\n};\n\n// packages/core/mesh/teleport/src/teleport.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { asyncTimeout, scheduleTaskInterval, runInContextAsync, synchronized, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer, RpcClosedError } from \"@dxos/rpc\";\nimport { Callback } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Teleport = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this._ctx = new Context({\n      onError: (err) => {\n        void this.destroy(err).catch(() => {\n          log2.error(\"Error during destroy\", err, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n            line: 34,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      }\n    });\n    this._muxer = new Muxer();\n    this._control = new ControlExtension({\n      heartbeatInterval: 3e3,\n      heartbeatTimeout: 3e3\n    });\n    this._extensions = /* @__PURE__ */ new Map();\n    this._remoteExtensions = /* @__PURE__ */ new Set();\n    this._open = false;\n    assert3(typeof initiator === \"boolean\");\n    assert3(PublicKey.isPublicKey(localPeerId));\n    assert3(PublicKey.isPublicKey(remotePeerId));\n    assert3(typeof initiator === \"boolean\");\n    this.initiator = initiator;\n    this.localPeerId = localPeerId;\n    this.remotePeerId = remotePeerId;\n    this._control.onExtensionRegistered.set(async (name) => {\n      log2(\"remote extension\", {\n        name\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n        line: 61,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert3(!this._remoteExtensions.has(name), \"Remote extension already exists\");\n      this._remoteExtensions.add(name);\n      if (this._extensions.has(name)) {\n        try {\n          await this._openExtension(name);\n        } catch (err) {\n          await this.destroy(err);\n        }\n      }\n    });\n    {\n      this._muxer.stream.on(\"close\", async () => {\n        await this.destroy();\n      });\n      this._muxer.stream.on(\"error\", async (err) => {\n        await this.destroy(err);\n      });\n    }\n  }\n  get stream() {\n    return this._muxer.stream;\n  }\n  async open() {\n    this._setExtension(\"dxos.mesh.teleport.control\", this._control);\n    await this._openExtension(\"dxos.mesh.teleport.control\");\n    this._open = true;\n  }\n  async close(err) {\n    await this.destroy(err);\n  }\n  async destroy(err) {\n    if (this._ctx.disposed) {\n      return;\n    }\n    await this._ctx.dispose();\n    for (const extension of this._extensions.values()) {\n      try {\n        await extension.onClose(err);\n      } catch (err1) {\n        log2.catch(err1, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n          line: 117,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this._muxer.destroy(err);\n  }\n  addExtension(name, extension) {\n    if (!this._open) {\n      throw new Error(\"Not open\");\n    }\n    log2(\"addExtension\", {\n      name\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 129,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._setExtension(name, extension);\n    scheduleTask(this._ctx, async () => {\n      try {\n        await this._control.registerExtension(name);\n      } catch (err) {\n        if (err instanceof RpcClosedError) {\n          return;\n        }\n        throw err;\n      }\n    });\n    if (this._remoteExtensions.has(name)) {\n      scheduleTask(this._ctx, async () => {\n        await this._openExtension(name);\n      });\n    }\n  }\n  _setExtension(extensionName, extension) {\n    assert3(!extensionName.includes(\"/\"), \"Invalid extension name\");\n    assert3(!this._extensions.has(extensionName), \"Extension already exists\");\n    this._extensions.set(extensionName, extension);\n  }\n  async _openExtension(extensionName) {\n    var _a;\n    log2(\"open extension\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 159,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const extension = (_a = this._extensions.get(extensionName)) != null ? _a : failUndefined2();\n    const context = {\n      initiator: this.initiator,\n      localPeerId: this.localPeerId,\n      remotePeerId: this.remotePeerId,\n      createPort: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createPort(`${extensionName}/${channelName}`, opts);\n      },\n      createStream: (channelName, opts) => {\n        assert3(!channelName.includes(\"/\"), \"Invalid channel name\");\n        return this._muxer.createStream(`${extensionName}/${channelName}`, opts);\n      },\n      close: (err) => {\n        void runInContextAsync(this._ctx, async () => {\n          await this.close(err);\n        });\n      }\n    };\n    await extension.onOpen(context);\n    log2(\"extension opened\", {\n      extensionName\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/teleport/src/teleport.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n__decorate([\n  synchronized\n], Teleport.prototype, \"destroy\", null);\nvar ControlExtension = class {\n  constructor(opts) {\n    this.opts = opts;\n    this._ctx = new Context({\n      onError: (err) => {\n        this._extensionContext.close(err);\n      }\n    });\n    this.onExtensionRegistered = new Callback();\n    this.onTimeout = new Callback();\n  }\n  async onOpen(extensionContext) {\n    this._extensionContext = extensionContext;\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      exposed: {\n        Control: schema2.getService(\"dxos.mesh.teleport.control.ControlService\")\n      },\n      handlers: {\n        Control: {\n          registerExtension: async (request) => {\n            this.onExtensionRegistered.call(request.name);\n          },\n          heartbeat: async (request) => {\n          }\n        }\n      },\n      port: extensionContext.createPort(\"rpc\", {\n        contentType: 'application/x-protobuf; messageType=\"dxos.rpc.Message\"'\n      })\n    });\n    await this._rpc.open();\n    scheduleTaskInterval(this._ctx, async () => {\n      try {\n        await asyncTimeout(this._rpc.rpc.Control.heartbeat(), this.opts.heartbeatTimeout);\n      } catch (err) {\n        this.onTimeout.call();\n      }\n    }, this.opts.heartbeatInterval);\n  }\n  async onClose(err) {\n    await this._ctx.dispose();\n    await this._rpc.close();\n  }\n  async registerExtension(name) {\n    await this._rpc.rpc.Control.registerExtension({\n      name\n    });\n  }\n};\nexport {\n  Framer,\n  Muxer,\n  Teleport,\n  readFrame\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467072,"end":1670465467077,"order":"normal"}]}
