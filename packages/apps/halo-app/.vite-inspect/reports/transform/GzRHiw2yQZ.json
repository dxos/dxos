{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/protocol-plugin-presence/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/protocol-plugin-presence/src/presence-plugin.ts\nimport bufferJson from \"buffer-json-encoding\";\nimport debug from \"debug\";\nimport createGraph from \"ngraph.graph\";\nimport assert from \"@dxos/node-std/assert\";\nimport pLimit from \"p-limit\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Event } from \"@dxos/async\";\nimport { Broadcast } from \"@dxos/broadcast\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nimport { schema } from \"@dxos/protocols\";\nvar log = debug(\"dxos:mesh:presence\");\nvar _PresencePlugin = class {\n  constructor(_peerId, options = {}) {\n    this._peerId = _peerId;\n    this._limit = pLimit(1);\n    this._codec = schema.getCodecForType(\"dxos.mesh.presence.Alive\");\n    this._neighbors = /* @__PURE__ */ new Map();\n    this._error = new Event();\n    this._peerJoined = new Event();\n    this._peerLeft = new Event();\n    this._connectionJoined = new Event();\n    this._connectionLeft = new Event();\n    this._protocolMessage = new Event();\n    this._remotePing = new Event();\n    this._neighborAlreadyConnected = new Event();\n    this._neighborJoined = new Event();\n    this._neighborLeft = new Event();\n    this.graphUpdated = new Event();\n    this._scheduler = null;\n    this._extensionsCreated = 0;\n    assert(Buffer.isBuffer(_peerId));\n    const { peerTimeout = 2 * 60 * 1e3, metadata } = options;\n    this._peerTimeout = peerTimeout;\n    this._metadata = metadata;\n    this._buildGraph();\n    this._buildBroadcast();\n    this._error.on((err) => {\n      log(\"broadcast-error\", err);\n    });\n  }\n  get peerId() {\n    return this._peerId;\n  }\n  get peers() {\n    const list = [];\n    this._graph.forEachNode((node) => {\n      list.push(Buffer.from(node.id, \"hex\"));\n    });\n    return list;\n  }\n  get graph() {\n    return this._graph;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  setMetadata(metadata) {\n    this._metadata = metadata;\n  }\n  createExtension() {\n    this.start();\n    this._extensionsCreated++;\n    return new Extension(_PresencePlugin.EXTENSION).setInitHandler(async (protocol) => this._addPeer(protocol)).setMessageHandler(async (protocol, chunk) => this._peerMessageHandler(protocol, chunk)).setCloseHandler(async (protocol) => {\n      await this._removePeer(protocol);\n      if (--this._extensionsCreated === 0) {\n        await this.stop();\n      }\n    });\n  }\n  _pingLimit() {\n    void this._limit(() => this.ping());\n  }\n  start() {\n    if (this._scheduler) {\n      return;\n    }\n    log(\"Start\");\n    this._broadcast.open();\n    void this.ping();\n    this._scheduler = setInterval(() => {\n      this._pingLimit();\n      queueMicrotask(() => this._pruneGraph());\n    }, Math.floor(this._peerTimeout / 2));\n  }\n  stop() {\n    log(\"Stop\");\n    this._limit.clearQueue();\n    this._broadcast.close();\n    if (this._scheduler !== null) {\n      clearInterval(this._scheduler);\n      this._scheduler = null;\n    }\n  }\n  _buildGraph() {\n    this._graph = createGraph();\n    this._graph.addNode(this._peerId.toString(\"hex\"), {\n      metadata: this._metadata\n    });\n    this._graph.on(\"changed\", (changes) => {\n      let graphUpdated = false;\n      changes.forEach(({ changeType, node, link }) => {\n        if (changeType === \"update\") {\n          return;\n        }\n        graphUpdated = true;\n        if (node) {\n          if (changeType === \"add\") {\n            this._peerJoined.emit(Buffer.from(node.id, \"hex\"));\n          } else {\n            this._peerLeft.emit(Buffer.from(node.id, \"hex\"));\n          }\n        }\n        if (link) {\n          if (changeType === \"add\") {\n            this._connectionJoined.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          } else {\n            this._connectionLeft.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          }\n        }\n      });\n      if (graphUpdated) {\n        log(\"graph-updated\", changes);\n        this.graphUpdated.emit({\n          graph: this._graph,\n          changes\n        });\n      }\n    });\n  }\n  _buildBroadcast() {\n    const middleware = {\n      lookup: async () => {\n        return Array.from(this._neighbors.values()).map((peer) => {\n          const { peerId } = peer.getSession();\n          return {\n            id: PublicKey.bufferize(peerId),\n            protocol: peer\n          };\n        });\n      },\n      send: async (packet, { protocol }) => {\n        const presence = protocol.getExtension(_PresencePlugin.EXTENSION);\n        assert(presence);\n        await presence.send(packet, {\n          oneway: true\n        });\n      },\n      subscribe: (onPacket) => {\n        this._protocolMessage.on(({ protocol, message }) => {\n          if (message && message.data) {\n            onPacket(message.data);\n          }\n        });\n      }\n    };\n    this._broadcast = new Broadcast(middleware, {\n      id: this._peerId\n    });\n    this._broadcast.packet.on((packet) => {\n      assert(packet.data);\n      const data = this._codec.decode(packet.data);\n      if (data.metadata) {\n        data.metadata = bufferJson.decode(data.metadata);\n      }\n      this._remotePing.emit(data);\n    });\n    this._broadcast.sendError.on((err) => {\n      if (![\n        \"ERR_PROTOCOL_STREAM_CLOSED\",\n        \"NMSG_ERR_CLOSE\"\n      ].includes(err.code) && err.message !== \"Resource is closed\") {\n        console.warn(err);\n      }\n    });\n    this._broadcast.subscribeError.on((err) => console.warn(err));\n    this._remotePing.on((packet) => this._updateGraph(packet));\n  }\n  _peerMessageHandler(protocol, chunk) {\n    this._protocolMessage.emit({\n      protocol,\n      message: chunk\n    });\n  }\n  _pruneGraph() {\n    const now = Date.now();\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.beginUpdate();\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      if (this._neighbors.has(node.id)) {\n        return;\n      }\n      if (now - node.data.lastUpdate > this._peerTimeout) {\n        this._deleteNode(node.id);\n      }\n    });\n    this._graph.endUpdate();\n  }\n  _addPeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    assert(typeof peerId === \"string\");\n    log(`_addPeer ${peerId}`);\n    if (!peerId) {\n      this._error.emit(new Error(\"peer_id not found\"));\n      return;\n    }\n    if (this._neighbors.has(peerId)) {\n      this._neighborAlreadyConnected.emit(peerId);\n      return;\n    }\n    this._neighbors.set(peerId, protocol);\n    this._neighborJoined.emit({\n      peerId,\n      protocol\n    });\n    this._pingLimit();\n  }\n  async _removePeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    log(`_removePeer ${peerId}`);\n    if (!peerId) {\n      return;\n    }\n    this._neighbors.delete(peerId);\n    this._deleteNode(peerId);\n    this._neighborLeft.emit(peerId);\n    if (this._neighbors.size > 0) {\n      await this.ping();\n    }\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      this._deleteNode(node.id);\n    });\n  }\n  _updateGraph({ peerId: from, connections = [], metadata }) {\n    const fromHex = from.toString(\"hex\");\n    const lastUpdate = Date.now();\n    this._graph.beginUpdate();\n    this._graph.addNode(fromHex, {\n      lastUpdate,\n      metadata\n    });\n    connections = connections.map(({ peerId }) => {\n      peerId = peerId.toString(\"hex\");\n      this._graph.addNode(peerId, {\n        lastUpdate,\n        metadata\n      });\n      const [source, target] = [\n        fromHex,\n        peerId\n      ].sort();\n      return {\n        source,\n        target\n      };\n    });\n    connections.forEach((conn) => {\n      if (!this._graph.hasLink(conn.source, conn.target)) {\n        this._graph.addLink(conn.source, conn.target);\n      }\n    });\n    this._graph.forEachLinkedNode(fromHex, (_, link) => {\n      const toDelete = !connections.find((conn) => conn.source === link.fromId && conn.target === link.toId);\n      if (!toDelete) {\n        return;\n      }\n      this._graph.removeLink(link);\n      this._deleteNodeIfEmpty(link.fromId);\n      this._deleteNodeIfEmpty(link.toId);\n    }, false);\n    this._graph.endUpdate();\n  }\n  _deleteNode(id) {\n    this._graph.removeNode(id);\n    this._graph.forEachLinkedNode(id, (_, link) => {\n      this._graph.removeLink(link);\n    }, false);\n  }\n  _deleteNodeIfEmpty(id) {\n    const links = this._graph.getLinks(id) || [];\n    if (links.length === 0) {\n      this._graph.removeNode(id);\n    }\n  }\n  async ping() {\n    this._limit.clearQueue();\n    try {\n      const message = {\n        peerId: this._peerId,\n        connections: Array.from(this._neighbors.values()).map((peer) => ({\n          peerId: PublicKey.bufferize(peer.getSession().peerId)\n        })),\n        metadata: this._metadata && bufferJson.encode(this._metadata)\n      };\n      await this._broadcast.publish(Buffer.from(this._codec.encode(message)));\n      log(\"ping\", message);\n    } catch (err) {\n      process.nextTick(() => this._error.emit(err));\n    }\n  }\n};\nvar PresencePlugin = _PresencePlugin;\nPresencePlugin.EXTENSION = \"dxos.mesh.protocol.presence\";\nexport {\n  PresencePlugin\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466973,"end":1670465467059},{"name":"vite:react-babel","result":"// packages/core/mesh/protocol-plugin-presence/src/presence-plugin.ts\nimport bufferJson from \"buffer-json-encoding\";\nimport debug from \"debug\";\nimport createGraph from \"ngraph.graph\";\nimport assert from \"@dxos/node-std/assert\";\nimport pLimit from \"p-limit\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Event } from \"@dxos/async\";\nimport { Broadcast } from \"@dxos/broadcast\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nimport { schema } from \"@dxos/protocols\";\nvar log = debug(\"dxos:mesh:presence\");\nvar _PresencePlugin = class {\n  constructor(_peerId, options = {}) {\n    this._peerId = _peerId;\n    this._limit = pLimit(1);\n    this._codec = schema.getCodecForType(\"dxos.mesh.presence.Alive\");\n    this._neighbors = /* @__PURE__ */ new Map();\n    this._error = new Event();\n    this._peerJoined = new Event();\n    this._peerLeft = new Event();\n    this._connectionJoined = new Event();\n    this._connectionLeft = new Event();\n    this._protocolMessage = new Event();\n    this._remotePing = new Event();\n    this._neighborAlreadyConnected = new Event();\n    this._neighborJoined = new Event();\n    this._neighborLeft = new Event();\n    this.graphUpdated = new Event();\n    this._scheduler = null;\n    this._extensionsCreated = 0;\n    assert(Buffer.isBuffer(_peerId));\n    const { peerTimeout = 2 * 60 * 1e3, metadata } = options;\n    this._peerTimeout = peerTimeout;\n    this._metadata = metadata;\n    this._buildGraph();\n    this._buildBroadcast();\n    this._error.on((err) => {\n      log(\"broadcast-error\", err);\n    });\n  }\n  get peerId() {\n    return this._peerId;\n  }\n  get peers() {\n    const list = [];\n    this._graph.forEachNode((node) => {\n      list.push(Buffer.from(node.id, \"hex\"));\n    });\n    return list;\n  }\n  get graph() {\n    return this._graph;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  setMetadata(metadata) {\n    this._metadata = metadata;\n  }\n  createExtension() {\n    this.start();\n    this._extensionsCreated++;\n    return new Extension(_PresencePlugin.EXTENSION).setInitHandler(async (protocol) => this._addPeer(protocol)).setMessageHandler(async (protocol, chunk) => this._peerMessageHandler(protocol, chunk)).setCloseHandler(async (protocol) => {\n      await this._removePeer(protocol);\n      if (--this._extensionsCreated === 0) {\n        await this.stop();\n      }\n    });\n  }\n  _pingLimit() {\n    void this._limit(() => this.ping());\n  }\n  start() {\n    if (this._scheduler) {\n      return;\n    }\n    log(\"Start\");\n    this._broadcast.open();\n    void this.ping();\n    this._scheduler = setInterval(() => {\n      this._pingLimit();\n      queueMicrotask(() => this._pruneGraph());\n    }, Math.floor(this._peerTimeout / 2));\n  }\n  stop() {\n    log(\"Stop\");\n    this._limit.clearQueue();\n    this._broadcast.close();\n    if (this._scheduler !== null) {\n      clearInterval(this._scheduler);\n      this._scheduler = null;\n    }\n  }\n  _buildGraph() {\n    this._graph = createGraph();\n    this._graph.addNode(this._peerId.toString(\"hex\"), {\n      metadata: this._metadata\n    });\n    this._graph.on(\"changed\", (changes) => {\n      let graphUpdated = false;\n      changes.forEach(({ changeType, node, link }) => {\n        if (changeType === \"update\") {\n          return;\n        }\n        graphUpdated = true;\n        if (node) {\n          if (changeType === \"add\") {\n            this._peerJoined.emit(Buffer.from(node.id, \"hex\"));\n          } else {\n            this._peerLeft.emit(Buffer.from(node.id, \"hex\"));\n          }\n        }\n        if (link) {\n          if (changeType === \"add\") {\n            this._connectionJoined.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          } else {\n            this._connectionLeft.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          }\n        }\n      });\n      if (graphUpdated) {\n        log(\"graph-updated\", changes);\n        this.graphUpdated.emit({\n          graph: this._graph,\n          changes\n        });\n      }\n    });\n  }\n  _buildBroadcast() {\n    const middleware = {\n      lookup: async () => {\n        return Array.from(this._neighbors.values()).map((peer) => {\n          const { peerId } = peer.getSession();\n          return {\n            id: PublicKey.bufferize(peerId),\n            protocol: peer\n          };\n        });\n      },\n      send: async (packet, { protocol }) => {\n        const presence = protocol.getExtension(_PresencePlugin.EXTENSION);\n        assert(presence);\n        await presence.send(packet, {\n          oneway: true\n        });\n      },\n      subscribe: (onPacket) => {\n        this._protocolMessage.on(({ protocol, message }) => {\n          if (message && message.data) {\n            onPacket(message.data);\n          }\n        });\n      }\n    };\n    this._broadcast = new Broadcast(middleware, {\n      id: this._peerId\n    });\n    this._broadcast.packet.on((packet) => {\n      assert(packet.data);\n      const data = this._codec.decode(packet.data);\n      if (data.metadata) {\n        data.metadata = bufferJson.decode(data.metadata);\n      }\n      this._remotePing.emit(data);\n    });\n    this._broadcast.sendError.on((err) => {\n      if (![\n        \"ERR_PROTOCOL_STREAM_CLOSED\",\n        \"NMSG_ERR_CLOSE\"\n      ].includes(err.code) && err.message !== \"Resource is closed\") {\n        console.warn(err);\n      }\n    });\n    this._broadcast.subscribeError.on((err) => console.warn(err));\n    this._remotePing.on((packet) => this._updateGraph(packet));\n  }\n  _peerMessageHandler(protocol, chunk) {\n    this._protocolMessage.emit({\n      protocol,\n      message: chunk\n    });\n  }\n  _pruneGraph() {\n    const now = Date.now();\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.beginUpdate();\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      if (this._neighbors.has(node.id)) {\n        return;\n      }\n      if (now - node.data.lastUpdate > this._peerTimeout) {\n        this._deleteNode(node.id);\n      }\n    });\n    this._graph.endUpdate();\n  }\n  _addPeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    assert(typeof peerId === \"string\");\n    log(`_addPeer ${peerId}`);\n    if (!peerId) {\n      this._error.emit(new Error(\"peer_id not found\"));\n      return;\n    }\n    if (this._neighbors.has(peerId)) {\n      this._neighborAlreadyConnected.emit(peerId);\n      return;\n    }\n    this._neighbors.set(peerId, protocol);\n    this._neighborJoined.emit({\n      peerId,\n      protocol\n    });\n    this._pingLimit();\n  }\n  async _removePeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    log(`_removePeer ${peerId}`);\n    if (!peerId) {\n      return;\n    }\n    this._neighbors.delete(peerId);\n    this._deleteNode(peerId);\n    this._neighborLeft.emit(peerId);\n    if (this._neighbors.size > 0) {\n      await this.ping();\n    }\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      this._deleteNode(node.id);\n    });\n  }\n  _updateGraph({ peerId: from, connections = [], metadata }) {\n    const fromHex = from.toString(\"hex\");\n    const lastUpdate = Date.now();\n    this._graph.beginUpdate();\n    this._graph.addNode(fromHex, {\n      lastUpdate,\n      metadata\n    });\n    connections = connections.map(({ peerId }) => {\n      peerId = peerId.toString(\"hex\");\n      this._graph.addNode(peerId, {\n        lastUpdate,\n        metadata\n      });\n      const [source, target] = [\n        fromHex,\n        peerId\n      ].sort();\n      return {\n        source,\n        target\n      };\n    });\n    connections.forEach((conn) => {\n      if (!this._graph.hasLink(conn.source, conn.target)) {\n        this._graph.addLink(conn.source, conn.target);\n      }\n    });\n    this._graph.forEachLinkedNode(fromHex, (_, link) => {\n      const toDelete = !connections.find((conn) => conn.source === link.fromId && conn.target === link.toId);\n      if (!toDelete) {\n        return;\n      }\n      this._graph.removeLink(link);\n      this._deleteNodeIfEmpty(link.fromId);\n      this._deleteNodeIfEmpty(link.toId);\n    }, false);\n    this._graph.endUpdate();\n  }\n  _deleteNode(id) {\n    this._graph.removeNode(id);\n    this._graph.forEachLinkedNode(id, (_, link) => {\n      this._graph.removeLink(link);\n    }, false);\n  }\n  _deleteNodeIfEmpty(id) {\n    const links = this._graph.getLinks(id) || [];\n    if (links.length === 0) {\n      this._graph.removeNode(id);\n    }\n  }\n  async ping() {\n    this._limit.clearQueue();\n    try {\n      const message = {\n        peerId: this._peerId,\n        connections: Array.from(this._neighbors.values()).map((peer) => ({\n          peerId: PublicKey.bufferize(peer.getSession().peerId)\n        })),\n        metadata: this._metadata && bufferJson.encode(this._metadata)\n      };\n      await this._broadcast.publish(Buffer.from(this._codec.encode(message)));\n      log(\"ping\", message);\n    } catch (err) {\n      process.nextTick(() => this._error.emit(err));\n    }\n  }\n};\nvar PresencePlugin = _PresencePlugin;\nPresencePlugin.EXTENSION = \"dxos.mesh.protocol.presence\";\nexport {\n  PresencePlugin\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467059,"end":1670465467059,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport { default as process } from '\u0000polyfill-node.process';\n\n// packages/core/mesh/protocol-plugin-presence/src/presence-plugin.ts\nimport bufferJson from \"buffer-json-encoding\";\nimport debug from \"debug\";\nimport createGraph from \"ngraph.graph\";\nimport assert from \"@dxos/node-std/assert\";\nimport pLimit from \"p-limit\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Event } from \"@dxos/async\";\nimport { Broadcast } from \"@dxos/broadcast\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nimport { schema } from \"@dxos/protocols\";\nvar log = debug(\"dxos:mesh:presence\");\nvar _PresencePlugin = class {\n  constructor(_peerId, options = {}) {\n    this._peerId = _peerId;\n    this._limit = pLimit(1);\n    this._codec = schema.getCodecForType(\"dxos.mesh.presence.Alive\");\n    this._neighbors = /* @__PURE__ */ new Map();\n    this._error = new Event();\n    this._peerJoined = new Event();\n    this._peerLeft = new Event();\n    this._connectionJoined = new Event();\n    this._connectionLeft = new Event();\n    this._protocolMessage = new Event();\n    this._remotePing = new Event();\n    this._neighborAlreadyConnected = new Event();\n    this._neighborJoined = new Event();\n    this._neighborLeft = new Event();\n    this.graphUpdated = new Event();\n    this._scheduler = null;\n    this._extensionsCreated = 0;\n    assert(Buffer.isBuffer(_peerId));\n    const { peerTimeout = 2 * 60 * 1e3, metadata } = options;\n    this._peerTimeout = peerTimeout;\n    this._metadata = metadata;\n    this._buildGraph();\n    this._buildBroadcast();\n    this._error.on((err) => {\n      log(\"broadcast-error\", err);\n    });\n  }\n  get peerId() {\n    return this._peerId;\n  }\n  get peers() {\n    const list = [];\n    this._graph.forEachNode((node) => {\n      list.push(Buffer.from(node.id, \"hex\"));\n    });\n    return list;\n  }\n  get graph() {\n    return this._graph;\n  }\n  get metadata() {\n    return this._metadata;\n  }\n  setMetadata(metadata) {\n    this._metadata = metadata;\n  }\n  createExtension() {\n    this.start();\n    this._extensionsCreated++;\n    return new Extension(_PresencePlugin.EXTENSION).setInitHandler(async (protocol) => this._addPeer(protocol)).setMessageHandler(async (protocol, chunk) => this._peerMessageHandler(protocol, chunk)).setCloseHandler(async (protocol) => {\n      await this._removePeer(protocol);\n      if (--this._extensionsCreated === 0) {\n        await this.stop();\n      }\n    });\n  }\n  _pingLimit() {\n    void this._limit(() => this.ping());\n  }\n  start() {\n    if (this._scheduler) {\n      return;\n    }\n    log(\"Start\");\n    this._broadcast.open();\n    void this.ping();\n    this._scheduler = setInterval(() => {\n      this._pingLimit();\n      queueMicrotask(() => this._pruneGraph());\n    }, Math.floor(this._peerTimeout / 2));\n  }\n  stop() {\n    log(\"Stop\");\n    this._limit.clearQueue();\n    this._broadcast.close();\n    if (this._scheduler !== null) {\n      clearInterval(this._scheduler);\n      this._scheduler = null;\n    }\n  }\n  _buildGraph() {\n    this._graph = createGraph();\n    this._graph.addNode(this._peerId.toString(\"hex\"), {\n      metadata: this._metadata\n    });\n    this._graph.on(\"changed\", (changes) => {\n      let graphUpdated = false;\n      changes.forEach(({ changeType, node, link }) => {\n        if (changeType === \"update\") {\n          return;\n        }\n        graphUpdated = true;\n        if (node) {\n          if (changeType === \"add\") {\n            this._peerJoined.emit(Buffer.from(node.id, \"hex\"));\n          } else {\n            this._peerLeft.emit(Buffer.from(node.id, \"hex\"));\n          }\n        }\n        if (link) {\n          if (changeType === \"add\") {\n            this._connectionJoined.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          } else {\n            this._connectionLeft.emit({\n              fromId: Buffer.from(link.fromId, \"hex\"),\n              toId: Buffer.from(link.toId, \"hex\")\n            });\n          }\n        }\n      });\n      if (graphUpdated) {\n        log(\"graph-updated\", changes);\n        this.graphUpdated.emit({\n          graph: this._graph,\n          changes\n        });\n      }\n    });\n  }\n  _buildBroadcast() {\n    const middleware = {\n      lookup: async () => {\n        return Array.from(this._neighbors.values()).map((peer) => {\n          const { peerId } = peer.getSession();\n          return {\n            id: PublicKey.bufferize(peerId),\n            protocol: peer\n          };\n        });\n      },\n      send: async (packet, { protocol }) => {\n        const presence = protocol.getExtension(_PresencePlugin.EXTENSION);\n        assert(presence);\n        await presence.send(packet, {\n          oneway: true\n        });\n      },\n      subscribe: (onPacket) => {\n        this._protocolMessage.on(({ protocol, message }) => {\n          if (message && message.data) {\n            onPacket(message.data);\n          }\n        });\n      }\n    };\n    this._broadcast = new Broadcast(middleware, {\n      id: this._peerId\n    });\n    this._broadcast.packet.on((packet) => {\n      assert(packet.data);\n      const data = this._codec.decode(packet.data);\n      if (data.metadata) {\n        data.metadata = bufferJson.decode(data.metadata);\n      }\n      this._remotePing.emit(data);\n    });\n    this._broadcast.sendError.on((err) => {\n      if (![\n        \"ERR_PROTOCOL_STREAM_CLOSED\",\n        \"NMSG_ERR_CLOSE\"\n      ].includes(err.code) && err.message !== \"Resource is closed\") {\n        console.warn(err);\n      }\n    });\n    this._broadcast.subscribeError.on((err) => console.warn(err));\n    this._remotePing.on((packet) => this._updateGraph(packet));\n  }\n  _peerMessageHandler(protocol, chunk) {\n    this._protocolMessage.emit({\n      protocol,\n      message: chunk\n    });\n  }\n  _pruneGraph() {\n    const now = Date.now();\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.beginUpdate();\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      if (this._neighbors.has(node.id)) {\n        return;\n      }\n      if (now - node.data.lastUpdate > this._peerTimeout) {\n        this._deleteNode(node.id);\n      }\n    });\n    this._graph.endUpdate();\n  }\n  _addPeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    assert(typeof peerId === \"string\");\n    log(`_addPeer ${peerId}`);\n    if (!peerId) {\n      this._error.emit(new Error(\"peer_id not found\"));\n      return;\n    }\n    if (this._neighbors.has(peerId)) {\n      this._neighborAlreadyConnected.emit(peerId);\n      return;\n    }\n    this._neighbors.set(peerId, protocol);\n    this._neighborJoined.emit({\n      peerId,\n      protocol\n    });\n    this._pingLimit();\n  }\n  async _removePeer(protocol) {\n    var _a;\n    assert(protocol);\n    const { peerId } = (_a = protocol.getSession()) != null ? _a : {};\n    log(`_removePeer ${peerId}`);\n    if (!peerId) {\n      return;\n    }\n    this._neighbors.delete(peerId);\n    this._deleteNode(peerId);\n    this._neighborLeft.emit(peerId);\n    if (this._neighbors.size > 0) {\n      await this.ping();\n    }\n    const localPeerId = this._peerId.toString(\"hex\");\n    this._graph.forEachNode((node) => {\n      if (node.id === localPeerId) {\n        return;\n      }\n      this._deleteNode(node.id);\n    });\n  }\n  _updateGraph({ peerId: from, connections = [], metadata }) {\n    const fromHex = from.toString(\"hex\");\n    const lastUpdate = Date.now();\n    this._graph.beginUpdate();\n    this._graph.addNode(fromHex, {\n      lastUpdate,\n      metadata\n    });\n    connections = connections.map(({ peerId }) => {\n      peerId = peerId.toString(\"hex\");\n      this._graph.addNode(peerId, {\n        lastUpdate,\n        metadata\n      });\n      const [source, target] = [\n        fromHex,\n        peerId\n      ].sort();\n      return {\n        source,\n        target\n      };\n    });\n    connections.forEach((conn) => {\n      if (!this._graph.hasLink(conn.source, conn.target)) {\n        this._graph.addLink(conn.source, conn.target);\n      }\n    });\n    this._graph.forEachLinkedNode(fromHex, (_, link) => {\n      const toDelete = !connections.find((conn) => conn.source === link.fromId && conn.target === link.toId);\n      if (!toDelete) {\n        return;\n      }\n      this._graph.removeLink(link);\n      this._deleteNodeIfEmpty(link.fromId);\n      this._deleteNodeIfEmpty(link.toId);\n    }, false);\n    this._graph.endUpdate();\n  }\n  _deleteNode(id) {\n    this._graph.removeNode(id);\n    this._graph.forEachLinkedNode(id, (_, link) => {\n      this._graph.removeLink(link);\n    }, false);\n  }\n  _deleteNodeIfEmpty(id) {\n    const links = this._graph.getLinks(id) || [];\n    if (links.length === 0) {\n      this._graph.removeNode(id);\n    }\n  }\n  async ping() {\n    this._limit.clearQueue();\n    try {\n      const message = {\n        peerId: this._peerId,\n        connections: Array.from(this._neighbors.values()).map((peer) => ({\n          peerId: PublicKey.bufferize(peer.getSession().peerId)\n        })),\n        metadata: this._metadata && bufferJson.encode(this._metadata)\n      };\n      await this._broadcast.publish(Buffer.from(this._codec.encode(message)));\n      log(\"ping\", message);\n    } catch (err) {\n      process.nextTick(() => this._error.emit(err));\n    }\n  }\n};\nvar PresencePlugin = _PresencePlugin;\nPresencePlugin.EXTENSION = \"dxos.mesh.protocol.presence\";\nexport {\n  PresencePlugin\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467060,"end":1670465467062,"order":"normal"}]}
