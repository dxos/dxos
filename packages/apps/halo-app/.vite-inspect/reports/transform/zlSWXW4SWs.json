{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/codec-protobuf/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/codec-protobuf/src/buffer-patch.ts\nvar patchBufferCodec = (codec) => ({\n  encode: (x) => Buffer.from(codec.encode(x)),\n  decode: codec.decode.bind(codec)\n});\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nimport assert from \"@dxos/node-std/assert\";\nimport * as pb from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/precompiled-mapping/codegen.ts\nvar Ref = Symbol(\"Ref\");\nvar ref = (value) => ({\n  [Ref]: true,\n  value\n});\nvar isRef = (value) => value[Ref] === true;\nvar codegen = (name, args, gen, ctx = {}) => {\n  const newCtx = {\n    ...ctx\n  };\n  let nextAnnon = 1;\n  let buf = \"\";\n  gen((parts, ...args2) => {\n    const preprocessArg = (arg) => {\n      if (isRef(arg)) {\n        const name2 = `anon${nextAnnon++}`;\n        newCtx[name2] = arg.value;\n        return name2;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args2.length ? preprocessArg(args2[i]) : \"\")).join(\"\") + \"\\n\";\n  });\n  const code = `return function ${name}(${args.join(\", \")}) {\n${buf}\n}`;\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nvar createMessageMapper = (type, substitutions) => createMessageMapperCached(type, substitutions, {}).map;\nvar createMessageMapperCached = (type, substitutions, cache) => {\n  if (!cache[type.fullName]) {\n    cache[type.fullName] = {};\n    cache[type.fullName].map = codegen(`${type.name}$map`, [\n      \"obj\",\n      \"extraArgs\"\n    ], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              c`${ref(substitution)}(${value}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar(\"item\");\n            c`);`;\n          } else if (field.map) {\n            assert(field instanceof pb.MapField);\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption(\"proto3_optional\") && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n  return cache[type.fullName];\n};\nvar getDefaultValue = (type) => {\n  switch (type) {\n    case \"double\":\n    case \"float\":\n    case \"int32\":\n    case \"sfixed32\":\n    case \"uint32\":\n    case \"sint32\":\n    case \"fixed32\":\n      return \"0\";\n    case \"sint64\":\n    case \"int64\":\n    case \"uint64\":\n    case \"fixed64\":\n    case \"sfixed64\":\n      return '\"0\"';\n    case \"bool\":\n      return \"false\";\n    case \"string\":\n      return '\"\"';\n    case \"bytes\":\n      return \"new Uint8Array()\";\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n\n// packages/common/codec-protobuf/src/codec.ts\nvar OBJECT_CONVERSION_OPTIONS = {\n  longs: String,\n  arrays: true\n};\nvar ProtoCodec = class {\n  constructor(_type, _mapping, _schema) {\n    this._type = _type;\n    this._mapping = _mapping;\n    this._schema = _schema;\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n  get protoType() {\n    return this._type;\n  }\n  get substitutionMappings() {\n    return this._mapping;\n  }\n  get schema() {\n    return this._schema;\n  }\n  encode(value, options = {}) {\n    const sub = this._encodeMapper(value, [\n      this._schema,\n      options\n    ]);\n    return this._type.encode(sub).finish();\n  }\n  decode(data, options = {}) {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [\n      this._schema,\n      options\n    ]);\n  }\n  addJson(schema) {\n    this._schema.addJson(schema);\n  }\n};\n\n// packages/common/codec-protobuf/src/encoding.ts\nimport * as protobuf from \"protobufjs\";\nvar encodeProtobuf = (root) => root.toJSON();\nvar decodeProtobuf = (struct) => protobuf.Root.fromJSON(struct);\n\n// packages/common/codec-protobuf/src/mapping.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport protobufjs from \"protobufjs\";\nvar createMappingDescriptors = (substitutions) => {\n  const encode = {};\n  const decode = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode\n  };\n};\nvar mapMessage = async (type, mapper, obj) => {\n  const res = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n  return res;\n};\nvar mapField = async (field, mapper, value) => {\n  if (!field.required && (value === null || value === void 0)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value2) => mapScalarField(field, mapper, value2)));\n  } else if (field.map) {\n    assert2(field instanceof protobufjs.MapField);\n    return await asyncObjectMap((value2) => mapScalarField(field, mapper, value2), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\nvar mapScalarField = async (field, mapper, value) => {\n  var _a;\n  if (!field.resolved) {\n    field.resolve();\n  }\n  const typeName = (_a = field.resolvedType) == null ? void 0 : _a.fullName.slice(1);\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n  return value;\n};\nvar asyncObjectMap = async (map, record) => {\n  const res = {};\n  await Promise.all(Object.entries(record).map(async ([key, value]) => {\n    res[key] = await map(value, key);\n  }));\n  return res;\n};\n\n// packages/common/codec-protobuf/src/sanitizer.ts\nimport { Enum as Enum2, Type as Type2 } from \"protobufjs\";\nvar sanitize = (type, value, path, context) => {\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      context.errors.push(`Unexpected key: ${path}.${key}`);\n      continue;\n    }\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue;\n    }\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof Type2) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof Enum2) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\nvar sanitizeEnum = (type, value, path, context) => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n  return value;\n};\n\n// packages/common/codec-protobuf/src/schema.ts\nimport merge from \"lodash.merge\";\nimport protobufjs2, { Root as Root2 } from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/service.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { getAsyncValue } from \"@dxos/util\";\n\n// packages/common/codec-protobuf/src/stream.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Context } from \"@dxos/context\";\nvar log = debug(\"dxos:codec-protobuf:stream\");\nvar Stream = class {\n  constructor(producer) {\n    this._isClosed = false;\n    this._isReady = false;\n    this._buffer = [];\n    this._readyPromise = new Promise((resolve) => {\n      this._resolveReadyPromise = resolve;\n    });\n    this._ctx = new Context({\n      onError: (err) => {\n        var _a, _b;\n        if (this._isClosed) {\n          return;\n        }\n        this._isClosed = true;\n        this._closeError = err;\n        (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n        (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n        void this._ctx.dispose();\n      }\n    });\n    this._ctx.onDispose(() => {\n      this.close();\n    });\n    try {\n      const producerCleanup = producer({\n        ctx: this._ctx,\n        ready: () => {\n          this._markAsReady();\n        },\n        next: (msg) => {\n          if (this._isClosed) {\n            log(\"Stream is closed, dropping message.\");\n            return;\n          }\n          this._markAsReady();\n          if (this._messageHandler) {\n            try {\n              this._messageHandler(msg);\n            } catch (err) {\n              throwUnhandledRejection(err);\n            }\n          } else {\n            assert3(this._buffer);\n            this._buffer.push(msg);\n          }\n        },\n        close: (err) => {\n          var _a, _b;\n          if (this._isClosed) {\n            return;\n          }\n          this._isClosed = true;\n          this._closeError = err;\n          (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n          try {\n            (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n          } catch (err1) {\n            throwUnhandledRejection(err1);\n          }\n          void this._ctx.dispose();\n        }\n      });\n      if (producerCleanup) {\n        this._producerCleanup = producerCleanup;\n      }\n    } catch (err) {\n      this._ctx.raise(err);\n    }\n  }\n  static consume(stream) {\n    return new Promise((resolve) => {\n      const items = [];\n      stream.onReady(() => {\n        items.push({\n          ready: true\n        });\n      });\n      stream.subscribe((data) => {\n        items.push({\n          data\n        });\n      }, (error) => {\n        if (error) {\n          items.push({\n            closed: true,\n            error\n          });\n        } else {\n          items.push({\n            closed: true\n          });\n        }\n        resolve(items);\n      });\n    });\n  }\n  static map(source, map) {\n    return new Stream(({ ready, next, close }) => {\n      source.onReady(ready);\n      source.subscribe((data) => next(map(data)), close);\n      return () => source.close();\n    });\n  }\n  static unwrapPromise(streamPromise) {\n    if (streamPromise instanceof Stream) {\n      return streamPromise;\n    }\n    return new Stream(({ ready, next, close }) => {\n      streamPromise.then((stream) => {\n        stream.onReady(ready);\n        stream.subscribe(next, close);\n      }, (err) => {\n        close(err);\n      });\n      return () => {\n        streamPromise.then(\n          (stream) => stream.close(),\n          (err) => {\n          }\n        );\n      };\n    });\n  }\n  _markAsReady() {\n    var _a;\n    if (!this._isReady) {\n      this._isReady = true;\n      (_a = this._readyHandler) == null ? void 0 : _a.call(this);\n      this._resolveReadyPromise();\n    }\n  }\n  subscribe(onMessage, onClose) {\n    assert3(!this._messageHandler, \"Stream is already subscribed to.\");\n    assert3(!this._closeHandler, \"Stream is already subscribed to.\");\n    assert3(this._buffer);\n    for (const message of this._buffer) {\n      try {\n        onMessage(message);\n      } catch (err) {\n        throwUnhandledRejection(err);\n      }\n    }\n    this._buffer = null;\n    if (this._isClosed) {\n      onClose == null ? void 0 : onClose(this._closeError);\n      return;\n    }\n    this._messageHandler = onMessage;\n    this._closeHandler = onClose;\n  }\n  waitUntilReady() {\n    return this._readyPromise;\n  }\n  onReady(onReady) {\n    assert3(!this._readyHandler, \"Stream already has a handler for the ready event.\");\n    this._readyHandler = onReady;\n    if (this._isReady) {\n      onReady();\n    }\n  }\n  close() {\n    var _a, _b;\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    (_a = this._producerCleanup) == null ? void 0 : _a.call(this);\n    (_b = this._closeHandler) == null ? void 0 : _b.call(this, void 0);\n    void this._ctx.dispose();\n    this._messageHandler = void 0;\n    this._closeHandler = void 0;\n    this._producerCleanup = void 0;\n  }\n};\nvar throwUnhandledRejection = (error) => {\n  setTimeout(() => {\n    throw error;\n  });\n};\n\n// packages/common/codec-protobuf/src/service.ts\nvar ServiceDescriptor = class {\n  constructor(_service, _schema) {\n    this._service = _service;\n    this._schema = _schema;\n  }\n  get serviceProto() {\n    return this._service;\n  }\n  createClient(backend, encodingOptions) {\n    return new Service(backend, this._service, this._schema, encodingOptions);\n  }\n  createServer(handlers, encodingOptions) {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n};\nvar Service = class {\n  constructor(backend, service, schema, encodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      assert4(method.resolvedRequestType);\n      assert4(method.resolvedResponseType);\n      assert4(!method.requestStream, \"Streaming RPC requests are not supported.\");\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n      if (method.responseStream) {\n        this[methodName] = (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return Stream.map(stream, (data) => responseCodec.decode(data.value, encodingOptions));\n        };\n      } else {\n        this[methodName] = async (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n      Object.defineProperty(this[methodName], \"name\", {\n        value: methodName\n      });\n    }\n  }\n};\nvar ServiceHandler = class {\n  constructor(_serviceDefinition, _schema, _serviceProvider, _encodingOptions) {\n    this._serviceDefinition = _serviceDefinition;\n    this._schema = _schema;\n    this._serviceProvider = _serviceProvider;\n    this._encodingOptions = _encodingOptions;\n  }\n  async call(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const response = await handler(requestDecoded);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType.fullName\n    };\n  }\n  callStream(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(handlerPromise.then((handler) => handler(requestDecoded)));\n    return Stream.map(responseStream, (data) => ({\n      value: responseCodec.encode(data, this._encodingOptions),\n      type_url: method.resolvedResponseType.fullName\n    }));\n  }\n  async _getHandler(method) {\n    const service = await getAsyncValue(this._serviceProvider);\n    const handler = service[method];\n    assert4(handler, `Handler is missing: ${method}`);\n    return handler.bind(service);\n  }\n  _getMethodInfo(methodName) {\n    const method = this._serviceDefinition.methods[methodName];\n    assert4(!!method, `Method not found: ${methodName}`);\n    method.resolve();\n    assert4(method.resolvedRequestType);\n    assert4(method.resolvedResponseType);\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n    return {\n      method,\n      requestCodec,\n      responseCodec\n    };\n  }\n};\nvar mapRpcMethodName = (name) => name[0].toLocaleLowerCase() + name.substring(1);\n\n// packages/common/codec-protobuf/src/schema.ts\nvar Schema = class {\n  static fromJson(schema, substitutions = {}) {\n    const root = protobufjs2.Root.fromJSON(schema);\n    return new Schema(root, substitutions);\n  }\n  constructor(_typesRoot, substitutions) {\n    this._typesRoot = _typesRoot;\n    this._codecCache = {};\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n  getCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  hasType(typeName) {\n    if (typeName === \"\") {\n      return false;\n    }\n    try {\n      this._typesRoot.lookupType(typeName);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  tryGetCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeName === \"\") {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  getService(name) {\n    if (typeof name !== \"string\") {\n      throw new TypeError(\"Expected `name` argument to be a string\");\n    }\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n  addJson(schema) {\n    if (!schema.nested) {\n      throw new Error(\"Invalid schema: missing nested object\");\n    }\n    this._typesRoot = Root2.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/any.ts\nvar anySubstitutions = {\n  \"google.protobuf.Any\": {\n    encode: (value, schema, options) => {\n      if (options.preserveAny) {\n        if (value[\"@type\"] && value[\"@type\"] !== \"google.protobuf.Any\") {\n          throw new Error(\"Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.\");\n        }\n        return value;\n      }\n      if (typeof value[\"@type\"] !== \"string\") {\n        throw new Error(\"Cannot encode google.protobuf.Any without @type string field\");\n      }\n      if (value[\"@type\"] === \"google.protobuf.Any\") {\n        const { type_url, value: payload } = value;\n        return {\n          type_url,\n          value: payload\n        };\n      }\n      const codec = schema.tryGetCodecForType(value[\"@type\"]);\n      const data = codec.encode(value);\n      return {\n        type_url: value[\"@type\"],\n        value: data\n      };\n    },\n    decode: (value, schema, options) => {\n      var _a, _b;\n      if (options.preserveAny) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          type_url: (_a = value.type_url) != null ? _a : \"\",\n          value: (_b = value.value) != null ? _b : new Uint8Array()\n        };\n      }\n      if (!schema.hasType(value.type_url)) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          ...value\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      const data = codec.decode(value.value);\n      return {\n        ...data,\n        \"@type\": value.type_url\n      };\n    }\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/struct.ts\nvar encodeStructValue = (structValue) => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case \"undefined\": {\n      return {\n        nullValue: 0\n      };\n    }\n    case \"number\": {\n      return {\n        numberValue: structValue\n      };\n    }\n    case \"string\": {\n      return {\n        stringValue: structValue\n      };\n    }\n    case \"boolean\": {\n      return {\n        boolValue: structValue\n      };\n    }\n    case \"object\": {\n      if (structValue === null) {\n        return {\n          nullValue: 0\n        };\n      }\n      if (Array.isArray(structValue)) {\n        return {\n          listValue: {\n            values: structValue.map(encodeStructValue)\n          }\n        };\n      }\n      return {\n        structValue: encodeStruct(structValue)\n      };\n    }\n    default: {\n      throw new Error(`Unsupported type: ${valueType}`);\n    }\n  }\n};\nvar encodeStruct = (struct) => ({\n  fields: Object.fromEntries(Object.entries(struct).map(([key, value]) => [\n    key,\n    encodeStructValue(value)\n  ]))\n});\nvar decodeStructValue = (structValue) => {\n  const [key, v] = Object.entries(structValue)[0];\n  switch (key) {\n    case \"nullValue\": {\n      return null;\n    }\n    case \"numberValue\": {\n      return v;\n    }\n    case \"stringValue\": {\n      return v;\n    }\n    case \"boolValue\": {\n      return v;\n    }\n    case \"structValue\": {\n      return decodeStruct(v);\n    }\n    case \"listValue\": {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\nvar decodeStruct = (struct) => Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [\n  key,\n  decodeStructValue(value)\n]));\nvar structSubstitutions = {\n  \"google.protobuf.Struct\": {\n    encode: (value) => encodeStruct(value),\n    decode: (value) => decodeStruct(value)\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/timestamp.ts\nvar timestampSubstitutions = {\n  \"google.protobuf.Timestamp\": {\n    encode: (value) => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1e3).toString(),\n        nanos: unixMilliseconds % 1e3 * 1e6\n      };\n    },\n    decode: (value) => {\n      var _a, _b;\n      return new Date(parseInt((_a = value.seconds) != null ? _a : \"0\") * 1e3 + ((_b = value.nanos) != null ? _b : 0) / 1e6);\n    }\n  }\n};\nexport {\n  OBJECT_CONVERSION_OPTIONS,\n  ProtoCodec,\n  Schema,\n  Service,\n  ServiceDescriptor,\n  ServiceHandler,\n  Stream,\n  anySubstitutions,\n  createMappingDescriptors,\n  decodeProtobuf,\n  encodeProtobuf,\n  mapMessage,\n  patchBufferCodec,\n  sanitize,\n  structSubstitutions,\n  timestampSubstitutions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466202,"end":1670465466442},{"name":"vite:react-babel","result":"// packages/common/codec-protobuf/src/buffer-patch.ts\nvar patchBufferCodec = (codec) => ({\n  encode: (x) => Buffer.from(codec.encode(x)),\n  decode: codec.decode.bind(codec)\n});\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nimport assert from \"@dxos/node-std/assert\";\nimport * as pb from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/precompiled-mapping/codegen.ts\nvar Ref = Symbol(\"Ref\");\nvar ref = (value) => ({\n  [Ref]: true,\n  value\n});\nvar isRef = (value) => value[Ref] === true;\nvar codegen = (name, args, gen, ctx = {}) => {\n  const newCtx = {\n    ...ctx\n  };\n  let nextAnnon = 1;\n  let buf = \"\";\n  gen((parts, ...args2) => {\n    const preprocessArg = (arg) => {\n      if (isRef(arg)) {\n        const name2 = `anon${nextAnnon++}`;\n        newCtx[name2] = arg.value;\n        return name2;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args2.length ? preprocessArg(args2[i]) : \"\")).join(\"\") + \"\\n\";\n  });\n  const code = `return function ${name}(${args.join(\", \")}) {\n${buf}\n}`;\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nvar createMessageMapper = (type, substitutions) => createMessageMapperCached(type, substitutions, {}).map;\nvar createMessageMapperCached = (type, substitutions, cache) => {\n  if (!cache[type.fullName]) {\n    cache[type.fullName] = {};\n    cache[type.fullName].map = codegen(`${type.name}$map`, [\n      \"obj\",\n      \"extraArgs\"\n    ], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              c`${ref(substitution)}(${value}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar(\"item\");\n            c`);`;\n          } else if (field.map) {\n            assert(field instanceof pb.MapField);\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption(\"proto3_optional\") && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n  return cache[type.fullName];\n};\nvar getDefaultValue = (type) => {\n  switch (type) {\n    case \"double\":\n    case \"float\":\n    case \"int32\":\n    case \"sfixed32\":\n    case \"uint32\":\n    case \"sint32\":\n    case \"fixed32\":\n      return \"0\";\n    case \"sint64\":\n    case \"int64\":\n    case \"uint64\":\n    case \"fixed64\":\n    case \"sfixed64\":\n      return '\"0\"';\n    case \"bool\":\n      return \"false\";\n    case \"string\":\n      return '\"\"';\n    case \"bytes\":\n      return \"new Uint8Array()\";\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n\n// packages/common/codec-protobuf/src/codec.ts\nvar OBJECT_CONVERSION_OPTIONS = {\n  longs: String,\n  arrays: true\n};\nvar ProtoCodec = class {\n  constructor(_type, _mapping, _schema) {\n    this._type = _type;\n    this._mapping = _mapping;\n    this._schema = _schema;\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n  get protoType() {\n    return this._type;\n  }\n  get substitutionMappings() {\n    return this._mapping;\n  }\n  get schema() {\n    return this._schema;\n  }\n  encode(value, options = {}) {\n    const sub = this._encodeMapper(value, [\n      this._schema,\n      options\n    ]);\n    return this._type.encode(sub).finish();\n  }\n  decode(data, options = {}) {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [\n      this._schema,\n      options\n    ]);\n  }\n  addJson(schema) {\n    this._schema.addJson(schema);\n  }\n};\n\n// packages/common/codec-protobuf/src/encoding.ts\nimport * as protobuf from \"protobufjs\";\nvar encodeProtobuf = (root) => root.toJSON();\nvar decodeProtobuf = (struct) => protobuf.Root.fromJSON(struct);\n\n// packages/common/codec-protobuf/src/mapping.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport protobufjs from \"protobufjs\";\nvar createMappingDescriptors = (substitutions) => {\n  const encode = {};\n  const decode = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode\n  };\n};\nvar mapMessage = async (type, mapper, obj) => {\n  const res = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n  return res;\n};\nvar mapField = async (field, mapper, value) => {\n  if (!field.required && (value === null || value === void 0)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value2) => mapScalarField(field, mapper, value2)));\n  } else if (field.map) {\n    assert2(field instanceof protobufjs.MapField);\n    return await asyncObjectMap((value2) => mapScalarField(field, mapper, value2), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\nvar mapScalarField = async (field, mapper, value) => {\n  var _a;\n  if (!field.resolved) {\n    field.resolve();\n  }\n  const typeName = (_a = field.resolvedType) == null ? void 0 : _a.fullName.slice(1);\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n  return value;\n};\nvar asyncObjectMap = async (map, record) => {\n  const res = {};\n  await Promise.all(Object.entries(record).map(async ([key, value]) => {\n    res[key] = await map(value, key);\n  }));\n  return res;\n};\n\n// packages/common/codec-protobuf/src/sanitizer.ts\nimport { Enum as Enum2, Type as Type2 } from \"protobufjs\";\nvar sanitize = (type, value, path, context) => {\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      context.errors.push(`Unexpected key: ${path}.${key}`);\n      continue;\n    }\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue;\n    }\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof Type2) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof Enum2) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\nvar sanitizeEnum = (type, value, path, context) => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n  return value;\n};\n\n// packages/common/codec-protobuf/src/schema.ts\nimport merge from \"lodash.merge\";\nimport protobufjs2, { Root as Root2 } from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/service.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { getAsyncValue } from \"@dxos/util\";\n\n// packages/common/codec-protobuf/src/stream.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Context } from \"@dxos/context\";\nvar log = debug(\"dxos:codec-protobuf:stream\");\nvar Stream = class {\n  constructor(producer) {\n    this._isClosed = false;\n    this._isReady = false;\n    this._buffer = [];\n    this._readyPromise = new Promise((resolve) => {\n      this._resolveReadyPromise = resolve;\n    });\n    this._ctx = new Context({\n      onError: (err) => {\n        var _a, _b;\n        if (this._isClosed) {\n          return;\n        }\n        this._isClosed = true;\n        this._closeError = err;\n        (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n        (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n        void this._ctx.dispose();\n      }\n    });\n    this._ctx.onDispose(() => {\n      this.close();\n    });\n    try {\n      const producerCleanup = producer({\n        ctx: this._ctx,\n        ready: () => {\n          this._markAsReady();\n        },\n        next: (msg) => {\n          if (this._isClosed) {\n            log(\"Stream is closed, dropping message.\");\n            return;\n          }\n          this._markAsReady();\n          if (this._messageHandler) {\n            try {\n              this._messageHandler(msg);\n            } catch (err) {\n              throwUnhandledRejection(err);\n            }\n          } else {\n            assert3(this._buffer);\n            this._buffer.push(msg);\n          }\n        },\n        close: (err) => {\n          var _a, _b;\n          if (this._isClosed) {\n            return;\n          }\n          this._isClosed = true;\n          this._closeError = err;\n          (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n          try {\n            (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n          } catch (err1) {\n            throwUnhandledRejection(err1);\n          }\n          void this._ctx.dispose();\n        }\n      });\n      if (producerCleanup) {\n        this._producerCleanup = producerCleanup;\n      }\n    } catch (err) {\n      this._ctx.raise(err);\n    }\n  }\n  static consume(stream) {\n    return new Promise((resolve) => {\n      const items = [];\n      stream.onReady(() => {\n        items.push({\n          ready: true\n        });\n      });\n      stream.subscribe((data) => {\n        items.push({\n          data\n        });\n      }, (error) => {\n        if (error) {\n          items.push({\n            closed: true,\n            error\n          });\n        } else {\n          items.push({\n            closed: true\n          });\n        }\n        resolve(items);\n      });\n    });\n  }\n  static map(source, map) {\n    return new Stream(({ ready, next, close }) => {\n      source.onReady(ready);\n      source.subscribe((data) => next(map(data)), close);\n      return () => source.close();\n    });\n  }\n  static unwrapPromise(streamPromise) {\n    if (streamPromise instanceof Stream) {\n      return streamPromise;\n    }\n    return new Stream(({ ready, next, close }) => {\n      streamPromise.then((stream) => {\n        stream.onReady(ready);\n        stream.subscribe(next, close);\n      }, (err) => {\n        close(err);\n      });\n      return () => {\n        streamPromise.then(\n          (stream) => stream.close(),\n          (err) => {\n          }\n        );\n      };\n    });\n  }\n  _markAsReady() {\n    var _a;\n    if (!this._isReady) {\n      this._isReady = true;\n      (_a = this._readyHandler) == null ? void 0 : _a.call(this);\n      this._resolveReadyPromise();\n    }\n  }\n  subscribe(onMessage, onClose) {\n    assert3(!this._messageHandler, \"Stream is already subscribed to.\");\n    assert3(!this._closeHandler, \"Stream is already subscribed to.\");\n    assert3(this._buffer);\n    for (const message of this._buffer) {\n      try {\n        onMessage(message);\n      } catch (err) {\n        throwUnhandledRejection(err);\n      }\n    }\n    this._buffer = null;\n    if (this._isClosed) {\n      onClose == null ? void 0 : onClose(this._closeError);\n      return;\n    }\n    this._messageHandler = onMessage;\n    this._closeHandler = onClose;\n  }\n  waitUntilReady() {\n    return this._readyPromise;\n  }\n  onReady(onReady) {\n    assert3(!this._readyHandler, \"Stream already has a handler for the ready event.\");\n    this._readyHandler = onReady;\n    if (this._isReady) {\n      onReady();\n    }\n  }\n  close() {\n    var _a, _b;\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    (_a = this._producerCleanup) == null ? void 0 : _a.call(this);\n    (_b = this._closeHandler) == null ? void 0 : _b.call(this, void 0);\n    void this._ctx.dispose();\n    this._messageHandler = void 0;\n    this._closeHandler = void 0;\n    this._producerCleanup = void 0;\n  }\n};\nvar throwUnhandledRejection = (error) => {\n  setTimeout(() => {\n    throw error;\n  });\n};\n\n// packages/common/codec-protobuf/src/service.ts\nvar ServiceDescriptor = class {\n  constructor(_service, _schema) {\n    this._service = _service;\n    this._schema = _schema;\n  }\n  get serviceProto() {\n    return this._service;\n  }\n  createClient(backend, encodingOptions) {\n    return new Service(backend, this._service, this._schema, encodingOptions);\n  }\n  createServer(handlers, encodingOptions) {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n};\nvar Service = class {\n  constructor(backend, service, schema, encodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      assert4(method.resolvedRequestType);\n      assert4(method.resolvedResponseType);\n      assert4(!method.requestStream, \"Streaming RPC requests are not supported.\");\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n      if (method.responseStream) {\n        this[methodName] = (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return Stream.map(stream, (data) => responseCodec.decode(data.value, encodingOptions));\n        };\n      } else {\n        this[methodName] = async (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n      Object.defineProperty(this[methodName], \"name\", {\n        value: methodName\n      });\n    }\n  }\n};\nvar ServiceHandler = class {\n  constructor(_serviceDefinition, _schema, _serviceProvider, _encodingOptions) {\n    this._serviceDefinition = _serviceDefinition;\n    this._schema = _schema;\n    this._serviceProvider = _serviceProvider;\n    this._encodingOptions = _encodingOptions;\n  }\n  async call(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const response = await handler(requestDecoded);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType.fullName\n    };\n  }\n  callStream(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(handlerPromise.then((handler) => handler(requestDecoded)));\n    return Stream.map(responseStream, (data) => ({\n      value: responseCodec.encode(data, this._encodingOptions),\n      type_url: method.resolvedResponseType.fullName\n    }));\n  }\n  async _getHandler(method) {\n    const service = await getAsyncValue(this._serviceProvider);\n    const handler = service[method];\n    assert4(handler, `Handler is missing: ${method}`);\n    return handler.bind(service);\n  }\n  _getMethodInfo(methodName) {\n    const method = this._serviceDefinition.methods[methodName];\n    assert4(!!method, `Method not found: ${methodName}`);\n    method.resolve();\n    assert4(method.resolvedRequestType);\n    assert4(method.resolvedResponseType);\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n    return {\n      method,\n      requestCodec,\n      responseCodec\n    };\n  }\n};\nvar mapRpcMethodName = (name) => name[0].toLocaleLowerCase() + name.substring(1);\n\n// packages/common/codec-protobuf/src/schema.ts\nvar Schema = class {\n  static fromJson(schema, substitutions = {}) {\n    const root = protobufjs2.Root.fromJSON(schema);\n    return new Schema(root, substitutions);\n  }\n  constructor(_typesRoot, substitutions) {\n    this._typesRoot = _typesRoot;\n    this._codecCache = {};\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n  getCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  hasType(typeName) {\n    if (typeName === \"\") {\n      return false;\n    }\n    try {\n      this._typesRoot.lookupType(typeName);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  tryGetCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeName === \"\") {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  getService(name) {\n    if (typeof name !== \"string\") {\n      throw new TypeError(\"Expected `name` argument to be a string\");\n    }\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n  addJson(schema) {\n    if (!schema.nested) {\n      throw new Error(\"Invalid schema: missing nested object\");\n    }\n    this._typesRoot = Root2.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/any.ts\nvar anySubstitutions = {\n  \"google.protobuf.Any\": {\n    encode: (value, schema, options) => {\n      if (options.preserveAny) {\n        if (value[\"@type\"] && value[\"@type\"] !== \"google.protobuf.Any\") {\n          throw new Error(\"Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.\");\n        }\n        return value;\n      }\n      if (typeof value[\"@type\"] !== \"string\") {\n        throw new Error(\"Cannot encode google.protobuf.Any without @type string field\");\n      }\n      if (value[\"@type\"] === \"google.protobuf.Any\") {\n        const { type_url, value: payload } = value;\n        return {\n          type_url,\n          value: payload\n        };\n      }\n      const codec = schema.tryGetCodecForType(value[\"@type\"]);\n      const data = codec.encode(value);\n      return {\n        type_url: value[\"@type\"],\n        value: data\n      };\n    },\n    decode: (value, schema, options) => {\n      var _a, _b;\n      if (options.preserveAny) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          type_url: (_a = value.type_url) != null ? _a : \"\",\n          value: (_b = value.value) != null ? _b : new Uint8Array()\n        };\n      }\n      if (!schema.hasType(value.type_url)) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          ...value\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      const data = codec.decode(value.value);\n      return {\n        ...data,\n        \"@type\": value.type_url\n      };\n    }\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/struct.ts\nvar encodeStructValue = (structValue) => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case \"undefined\": {\n      return {\n        nullValue: 0\n      };\n    }\n    case \"number\": {\n      return {\n        numberValue: structValue\n      };\n    }\n    case \"string\": {\n      return {\n        stringValue: structValue\n      };\n    }\n    case \"boolean\": {\n      return {\n        boolValue: structValue\n      };\n    }\n    case \"object\": {\n      if (structValue === null) {\n        return {\n          nullValue: 0\n        };\n      }\n      if (Array.isArray(structValue)) {\n        return {\n          listValue: {\n            values: structValue.map(encodeStructValue)\n          }\n        };\n      }\n      return {\n        structValue: encodeStruct(structValue)\n      };\n    }\n    default: {\n      throw new Error(`Unsupported type: ${valueType}`);\n    }\n  }\n};\nvar encodeStruct = (struct) => ({\n  fields: Object.fromEntries(Object.entries(struct).map(([key, value]) => [\n    key,\n    encodeStructValue(value)\n  ]))\n});\nvar decodeStructValue = (structValue) => {\n  const [key, v] = Object.entries(structValue)[0];\n  switch (key) {\n    case \"nullValue\": {\n      return null;\n    }\n    case \"numberValue\": {\n      return v;\n    }\n    case \"stringValue\": {\n      return v;\n    }\n    case \"boolValue\": {\n      return v;\n    }\n    case \"structValue\": {\n      return decodeStruct(v);\n    }\n    case \"listValue\": {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\nvar decodeStruct = (struct) => Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [\n  key,\n  decodeStructValue(value)\n]));\nvar structSubstitutions = {\n  \"google.protobuf.Struct\": {\n    encode: (value) => encodeStruct(value),\n    decode: (value) => decodeStruct(value)\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/timestamp.ts\nvar timestampSubstitutions = {\n  \"google.protobuf.Timestamp\": {\n    encode: (value) => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1e3).toString(),\n        nanos: unixMilliseconds % 1e3 * 1e6\n      };\n    },\n    decode: (value) => {\n      var _a, _b;\n      return new Date(parseInt((_a = value.seconds) != null ? _a : \"0\") * 1e3 + ((_b = value.nanos) != null ? _b : 0) / 1e6);\n    }\n  }\n};\nexport {\n  OBJECT_CONVERSION_OPTIONS,\n  ProtoCodec,\n  Schema,\n  Service,\n  ServiceDescriptor,\n  ServiceHandler,\n  Stream,\n  anySubstitutions,\n  createMappingDescriptors,\n  decodeProtobuf,\n  encodeProtobuf,\n  mapMessage,\n  patchBufferCodec,\n  sanitize,\n  structSubstitutions,\n  timestampSubstitutions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466442,"end":1670465466442,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/codec-protobuf/src/buffer-patch.ts\nvar patchBufferCodec = (codec) => ({\n  encode: (x) => Buffer.from(codec.encode(x)),\n  decode: codec.decode.bind(codec)\n});\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nimport assert from \"@dxos/node-std/assert\";\nimport * as pb from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/precompiled-mapping/codegen.ts\nvar Ref = Symbol(\"Ref\");\nvar ref = (value) => ({\n  [Ref]: true,\n  value\n});\nvar isRef = (value) => value[Ref] === true;\nvar codegen = (name, args, gen, ctx = {}) => {\n  const newCtx = {\n    ...ctx\n  };\n  let nextAnnon = 1;\n  let buf = \"\";\n  gen((parts, ...args2) => {\n    const preprocessArg = (arg) => {\n      if (isRef(arg)) {\n        const name2 = `anon${nextAnnon++}`;\n        newCtx[name2] = arg.value;\n        return name2;\n      } else {\n        return arg;\n      }\n    };\n    buf += parts.map((s, i) => s + (i < args2.length ? preprocessArg(args2[i]) : \"\")).join(\"\") + \"\\n\";\n  });\n  const code = `return function ${name}(${args.join(\", \")}) {\n${buf}\n}`;\n  return Function(...Object.keys(newCtx), code)(...Object.values(newCtx));\n};\n\n// packages/common/codec-protobuf/src/precompiled-mapping/create-message-mapper.ts\nvar createMessageMapper = (type, substitutions) => createMessageMapperCached(type, substitutions, {}).map;\nvar createMessageMapperCached = (type, substitutions, cache) => {\n  if (!cache[type.fullName]) {\n    cache[type.fullName] = {};\n    cache[type.fullName].map = codegen(`${type.name}$map`, [\n      \"obj\",\n      \"extraArgs\"\n    ], (c) => {\n      c`const res = {};`;\n      for (const field of type.fieldsArray) {\n        field.resolve();\n        c`if(obj.${field.name} !== undefined && obj.${field.name} !== null) {`;\n        {\n          const genMapScalar = (value) => {\n            const substitution = field.resolvedType && substitutions[field.resolvedType.fullName.slice(1)];\n            if (substitution) {\n              c`${ref(substitution)}(${value}, ...extraArgs)`;\n            } else if (field.resolvedType && field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`${ref(mapper)}.map(${value}, extraArgs)`;\n            } else {\n              c`${value}`;\n            }\n          };\n          if (field.repeated) {\n            c`res.${field.name} = obj.${field.name}.map(item => `;\n            genMapScalar(\"item\");\n            c`);`;\n          } else if (field.map) {\n            assert(field instanceof pb.MapField);\n            c`res.${field.name} = {};`;\n            c`for(const key of Object.keys(obj.${field.name})) {`;\n            {\n              c`res.${field.name}[key] = `;\n              genMapScalar(`obj.${field.name}[key]`);\n              c`;`;\n            }\n            c`}`;\n          } else {\n            c`res.${field.name} = `;\n            genMapScalar(`obj.${field.name}`);\n            c`;`;\n          }\n        }\n        c`}`;\n        if (!field.getOption(\"proto3_optional\") && !field.repeated && !field.map && !field.partOf) {\n          c`else {`;\n          {\n            if (field.resolvedType instanceof pb.Type) {\n              const mapper = createMessageMapperCached(field.resolvedType, substitutions, cache);\n              c`res.${field.name} = ${ref(mapper)}.map({}, extraArgs);`;\n            } else if (field.resolvedType instanceof pb.Enum) {\n              `res.${field.name} = 0;`;\n            } else {\n              c`res.${field.name} = ${getDefaultValue(field.type)};`;\n            }\n          }\n          c`}`;\n        }\n      }\n      c`return res;`;\n    });\n  }\n  return cache[type.fullName];\n};\nvar getDefaultValue = (type) => {\n  switch (type) {\n    case \"double\":\n    case \"float\":\n    case \"int32\":\n    case \"sfixed32\":\n    case \"uint32\":\n    case \"sint32\":\n    case \"fixed32\":\n      return \"0\";\n    case \"sint64\":\n    case \"int64\":\n    case \"uint64\":\n    case \"fixed64\":\n    case \"sfixed64\":\n      return '\"0\"';\n    case \"bool\":\n      return \"false\";\n    case \"string\":\n      return '\"\"';\n    case \"bytes\":\n      return \"new Uint8Array()\";\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n};\n\n// packages/common/codec-protobuf/src/codec.ts\nvar OBJECT_CONVERSION_OPTIONS = {\n  longs: String,\n  arrays: true\n};\nvar ProtoCodec = class {\n  constructor(_type, _mapping, _schema) {\n    this._type = _type;\n    this._mapping = _mapping;\n    this._schema = _schema;\n    this._encodeMapper = createMessageMapper(this._type, this._mapping.encode);\n    this._decodeMapper = createMessageMapper(this._type, this._mapping.decode);\n  }\n  get protoType() {\n    return this._type;\n  }\n  get substitutionMappings() {\n    return this._mapping;\n  }\n  get schema() {\n    return this._schema;\n  }\n  encode(value, options = {}) {\n    const sub = this._encodeMapper(value, [\n      this._schema,\n      options\n    ]);\n    return this._type.encode(sub).finish();\n  }\n  decode(data, options = {}) {\n    const obj = this._type.toObject(this._type.decode(data), OBJECT_CONVERSION_OPTIONS);\n    return this._decodeMapper(obj, [\n      this._schema,\n      options\n    ]);\n  }\n  addJson(schema) {\n    this._schema.addJson(schema);\n  }\n};\n\n// packages/common/codec-protobuf/src/encoding.ts\nimport * as protobuf from \"protobufjs\";\nvar encodeProtobuf = (root) => root.toJSON();\nvar decodeProtobuf = (struct) => protobuf.Root.fromJSON(struct);\n\n// packages/common/codec-protobuf/src/mapping.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport protobufjs from \"protobufjs\";\nvar createMappingDescriptors = (substitutions) => {\n  const encode = {};\n  const decode = {};\n  for (const type of Object.keys(substitutions)) {\n    encode[type] = substitutions[type].encode;\n    decode[type] = substitutions[type].decode;\n  }\n  return {\n    encode,\n    decode\n  };\n};\nvar mapMessage = async (type, mapper, obj) => {\n  const res = {};\n  for (const field of type.fieldsArray) {\n    if (!(field.name in obj)) {\n      continue;\n    }\n    res[field.name] = await mapField(field, mapper, obj[field.name]);\n  }\n  return res;\n};\nvar mapField = async (field, mapper, value) => {\n  if (!field.required && (value === null || value === void 0)) {\n    return value;\n  } else if (field.repeated) {\n    return await Promise.all(value.map((value2) => mapScalarField(field, mapper, value2)));\n  } else if (field.map) {\n    assert2(field instanceof protobufjs.MapField);\n    return await asyncObjectMap((value2) => mapScalarField(field, mapper, value2), value);\n  } else {\n    return mapScalarField(field, mapper, value);\n  }\n};\nvar mapScalarField = async (field, mapper, value) => {\n  var _a;\n  if (!field.resolved) {\n    field.resolve();\n  }\n  const typeName = (_a = field.resolvedType) == null ? void 0 : _a.fullName.slice(1);\n  if (typeName) {\n    return await mapper(value, typeName);\n  }\n  if (field.resolvedType && field.resolvedType instanceof protobufjs.Type) {\n    return await mapMessage(field.resolvedType, mapper, value);\n  }\n  return value;\n};\nvar asyncObjectMap = async (map, record) => {\n  const res = {};\n  await Promise.all(Object.entries(record).map(async ([key, value]) => {\n    res[key] = await map(value, key);\n  }));\n  return res;\n};\n\n// packages/common/codec-protobuf/src/sanitizer.ts\nimport { Enum as Enum2, Type as Type2 } from \"protobufjs\";\nvar sanitize = (type, value, path, context) => {\n  for (const key of Object.keys(value)) {\n    if (!type.fields[key]) {\n      context.errors.push(`Unexpected key: ${path}.${key}`);\n      continue;\n    }\n    const field = type.fields[key];\n    if (field.repeated) {\n      continue;\n    }\n    field.resolve();\n    if (!field.resolvedType) {\n      continue;\n    }\n    if (field.resolvedType instanceof Type2) {\n      sanitize(field.resolvedType, value[key], `${path}.${key}`, context);\n    } else if (field.resolvedType instanceof Enum2) {\n      value[key] = sanitizeEnum(field.resolvedType, value[key], `${path}.${key}`, context);\n    }\n  }\n};\nvar sanitizeEnum = (type, value, path, context) => {\n  if (type.valuesById[value]) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const normalizedValue = value.toLowerCase();\n    for (const [name, tag] of Object.entries(type.values)) {\n      if (name.toLowerCase() === normalizedValue) {\n        return tag;\n      }\n    }\n  }\n  context.errors.push(`Invalid enum value: value=${JSON.stringify(value)} enum=${type.fullName} path=${path}`);\n  return value;\n};\n\n// packages/common/codec-protobuf/src/schema.ts\nimport merge from \"lodash.merge\";\nimport protobufjs2, { Root as Root2 } from \"protobufjs\";\n\n// packages/common/codec-protobuf/src/service.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { getAsyncValue } from \"@dxos/util\";\n\n// packages/common/codec-protobuf/src/stream.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Context } from \"@dxos/context\";\nvar log = debug(\"dxos:codec-protobuf:stream\");\nvar Stream = class {\n  constructor(producer) {\n    this._isClosed = false;\n    this._isReady = false;\n    this._buffer = [];\n    this._readyPromise = new Promise((resolve) => {\n      this._resolveReadyPromise = resolve;\n    });\n    this._ctx = new Context({\n      onError: (err) => {\n        var _a, _b;\n        if (this._isClosed) {\n          return;\n        }\n        this._isClosed = true;\n        this._closeError = err;\n        (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n        (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n        void this._ctx.dispose();\n      }\n    });\n    this._ctx.onDispose(() => {\n      this.close();\n    });\n    try {\n      const producerCleanup = producer({\n        ctx: this._ctx,\n        ready: () => {\n          this._markAsReady();\n        },\n        next: (msg) => {\n          if (this._isClosed) {\n            log(\"Stream is closed, dropping message.\");\n            return;\n          }\n          this._markAsReady();\n          if (this._messageHandler) {\n            try {\n              this._messageHandler(msg);\n            } catch (err) {\n              throwUnhandledRejection(err);\n            }\n          } else {\n            assert3(this._buffer);\n            this._buffer.push(msg);\n          }\n        },\n        close: (err) => {\n          var _a, _b;\n          if (this._isClosed) {\n            return;\n          }\n          this._isClosed = true;\n          this._closeError = err;\n          (_a = this._producerCleanup) == null ? void 0 : _a.call(this, err);\n          try {\n            (_b = this._closeHandler) == null ? void 0 : _b.call(this, err);\n          } catch (err1) {\n            throwUnhandledRejection(err1);\n          }\n          void this._ctx.dispose();\n        }\n      });\n      if (producerCleanup) {\n        this._producerCleanup = producerCleanup;\n      }\n    } catch (err) {\n      this._ctx.raise(err);\n    }\n  }\n  static consume(stream) {\n    return new Promise((resolve) => {\n      const items = [];\n      stream.onReady(() => {\n        items.push({\n          ready: true\n        });\n      });\n      stream.subscribe((data) => {\n        items.push({\n          data\n        });\n      }, (error) => {\n        if (error) {\n          items.push({\n            closed: true,\n            error\n          });\n        } else {\n          items.push({\n            closed: true\n          });\n        }\n        resolve(items);\n      });\n    });\n  }\n  static map(source, map) {\n    return new Stream(({ ready, next, close }) => {\n      source.onReady(ready);\n      source.subscribe((data) => next(map(data)), close);\n      return () => source.close();\n    });\n  }\n  static unwrapPromise(streamPromise) {\n    if (streamPromise instanceof Stream) {\n      return streamPromise;\n    }\n    return new Stream(({ ready, next, close }) => {\n      streamPromise.then((stream) => {\n        stream.onReady(ready);\n        stream.subscribe(next, close);\n      }, (err) => {\n        close(err);\n      });\n      return () => {\n        streamPromise.then(\n          (stream) => stream.close(),\n          (err) => {\n          }\n        );\n      };\n    });\n  }\n  _markAsReady() {\n    var _a;\n    if (!this._isReady) {\n      this._isReady = true;\n      (_a = this._readyHandler) == null ? void 0 : _a.call(this);\n      this._resolveReadyPromise();\n    }\n  }\n  subscribe(onMessage, onClose) {\n    assert3(!this._messageHandler, \"Stream is already subscribed to.\");\n    assert3(!this._closeHandler, \"Stream is already subscribed to.\");\n    assert3(this._buffer);\n    for (const message of this._buffer) {\n      try {\n        onMessage(message);\n      } catch (err) {\n        throwUnhandledRejection(err);\n      }\n    }\n    this._buffer = null;\n    if (this._isClosed) {\n      onClose == null ? void 0 : onClose(this._closeError);\n      return;\n    }\n    this._messageHandler = onMessage;\n    this._closeHandler = onClose;\n  }\n  waitUntilReady() {\n    return this._readyPromise;\n  }\n  onReady(onReady) {\n    assert3(!this._readyHandler, \"Stream already has a handler for the ready event.\");\n    this._readyHandler = onReady;\n    if (this._isReady) {\n      onReady();\n    }\n  }\n  close() {\n    var _a, _b;\n    if (this._isClosed) {\n      return;\n    }\n    this._isClosed = true;\n    (_a = this._producerCleanup) == null ? void 0 : _a.call(this);\n    (_b = this._closeHandler) == null ? void 0 : _b.call(this, void 0);\n    void this._ctx.dispose();\n    this._messageHandler = void 0;\n    this._closeHandler = void 0;\n    this._producerCleanup = void 0;\n  }\n};\nvar throwUnhandledRejection = (error) => {\n  setTimeout(() => {\n    throw error;\n  });\n};\n\n// packages/common/codec-protobuf/src/service.ts\nvar ServiceDescriptor = class {\n  constructor(_service, _schema) {\n    this._service = _service;\n    this._schema = _schema;\n  }\n  get serviceProto() {\n    return this._service;\n  }\n  createClient(backend, encodingOptions) {\n    return new Service(backend, this._service, this._schema, encodingOptions);\n  }\n  createServer(handlers, encodingOptions) {\n    return new ServiceHandler(this._service, this._schema, handlers, encodingOptions);\n  }\n};\nvar Service = class {\n  constructor(backend, service, schema, encodingOptions) {\n    for (const method of service.methodsArray) {\n      method.resolve();\n      assert4(method.resolvedRequestType);\n      assert4(method.resolvedResponseType);\n      assert4(!method.requestStream, \"Streaming RPC requests are not supported.\");\n      const requestCodec = schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n      const responseCodec = schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n      const methodName = mapRpcMethodName(method.name);\n      if (method.responseStream) {\n        this[methodName] = (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const stream = backend.callStream(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return Stream.map(stream, (data) => responseCodec.decode(data.value, encodingOptions));\n        };\n      } else {\n        this[methodName] = async (request) => {\n          const encoded = requestCodec.encode(request, encodingOptions);\n          const response = await backend.call(method.name, {\n            value: encoded,\n            type_url: method.resolvedRequestType.fullName\n          });\n          return responseCodec.decode(response.value, encodingOptions);\n        };\n      }\n      Object.defineProperty(this[methodName], \"name\", {\n        value: methodName\n      });\n    }\n  }\n};\nvar ServiceHandler = class {\n  constructor(_serviceDefinition, _schema, _serviceProvider, _encodingOptions) {\n    this._serviceDefinition = _serviceDefinition;\n    this._schema = _schema;\n    this._serviceProvider = _serviceProvider;\n    this._encodingOptions = _encodingOptions;\n  }\n  async call(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(!method.responseStream, `Invalid RPC method call: response streaming mismatch. ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handler = await this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const response = await handler(requestDecoded);\n    const responseEncoded = responseCodec.encode(response, this._encodingOptions);\n    return {\n      value: responseEncoded,\n      type_url: method.resolvedResponseType.fullName\n    };\n  }\n  callStream(methodName, request) {\n    const { method, requestCodec, responseCodec } = this._getMethodInfo(methodName);\n    assert4(!method.requestStream, \"Invalid RPC method call: request streaming mismatch.\");\n    assert4(method.responseStream, `Invalid RPC method call: response streaming mismatch., ${methodName}`);\n    const mappedMethodName = mapRpcMethodName(methodName);\n    const handlerPromise = this._getHandler(mappedMethodName);\n    const requestDecoded = requestCodec.decode(request.value, this._encodingOptions);\n    const responseStream = Stream.unwrapPromise(handlerPromise.then((handler) => handler(requestDecoded)));\n    return Stream.map(responseStream, (data) => ({\n      value: responseCodec.encode(data, this._encodingOptions),\n      type_url: method.resolvedResponseType.fullName\n    }));\n  }\n  async _getHandler(method) {\n    const service = await getAsyncValue(this._serviceProvider);\n    const handler = service[method];\n    assert4(handler, `Handler is missing: ${method}`);\n    return handler.bind(service);\n  }\n  _getMethodInfo(methodName) {\n    const method = this._serviceDefinition.methods[methodName];\n    assert4(!!method, `Method not found: ${methodName}`);\n    method.resolve();\n    assert4(method.resolvedRequestType);\n    assert4(method.resolvedResponseType);\n    const requestCodec = this._schema.tryGetCodecForType(method.resolvedRequestType.fullName);\n    const responseCodec = this._schema.tryGetCodecForType(method.resolvedResponseType.fullName);\n    return {\n      method,\n      requestCodec,\n      responseCodec\n    };\n  }\n};\nvar mapRpcMethodName = (name) => name[0].toLocaleLowerCase() + name.substring(1);\n\n// packages/common/codec-protobuf/src/schema.ts\nvar Schema = class {\n  static fromJson(schema, substitutions = {}) {\n    const root = protobufjs2.Root.fromJSON(schema);\n    return new Schema(root, substitutions);\n  }\n  constructor(_typesRoot, substitutions) {\n    this._typesRoot = _typesRoot;\n    this._codecCache = {};\n    this._mapping = createMappingDescriptors(substitutions);\n  }\n  getCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  hasType(typeName) {\n    if (typeName === \"\") {\n      return false;\n    }\n    try {\n      this._typesRoot.lookupType(typeName);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  tryGetCodecForType(typeName) {\n    var _a, _b, _c;\n    if (typeName === \"\") {\n      throw new Error(`Type not found: \"${typeName}\"`);\n    }\n    if (typeof typeName !== \"string\") {\n      throw new TypeError(\"Expected `typeName` argument to be a string\");\n    }\n    const type = this._typesRoot.lookupType(typeName);\n    (_c = (_a = this._codecCache)[_b = type.fullName]) != null ? _c : _a[_b] = new ProtoCodec(type, this._mapping, this);\n    return this._codecCache[type.fullName];\n  }\n  getService(name) {\n    if (typeof name !== \"string\") {\n      throw new TypeError(\"Expected `name` argument to be a string\");\n    }\n    const service = this._typesRoot.lookupService(name);\n    return new ServiceDescriptor(service, this);\n  }\n  addJson(schema) {\n    if (!schema.nested) {\n      throw new Error(\"Invalid schema: missing nested object\");\n    }\n    this._typesRoot = Root2.fromJSON(merge(this._typesRoot.toJSON(), schema));\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/any.ts\nvar anySubstitutions = {\n  \"google.protobuf.Any\": {\n    encode: (value, schema, options) => {\n      if (options.preserveAny) {\n        if (value[\"@type\"] && value[\"@type\"] !== \"google.protobuf.Any\") {\n          throw new Error(\"Can only encode google.protobuf.Any with @type set to google.protobuf.Any in preserveAny mode.\");\n        }\n        return value;\n      }\n      if (typeof value[\"@type\"] !== \"string\") {\n        throw new Error(\"Cannot encode google.protobuf.Any without @type string field\");\n      }\n      if (value[\"@type\"] === \"google.protobuf.Any\") {\n        const { type_url, value: payload } = value;\n        return {\n          type_url,\n          value: payload\n        };\n      }\n      const codec = schema.tryGetCodecForType(value[\"@type\"]);\n      const data = codec.encode(value);\n      return {\n        type_url: value[\"@type\"],\n        value: data\n      };\n    },\n    decode: (value, schema, options) => {\n      var _a, _b;\n      if (options.preserveAny) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          type_url: (_a = value.type_url) != null ? _a : \"\",\n          value: (_b = value.value) != null ? _b : new Uint8Array()\n        };\n      }\n      if (!schema.hasType(value.type_url)) {\n        return {\n          \"@type\": \"google.protobuf.Any\",\n          ...value\n        };\n      }\n      const codec = schema.tryGetCodecForType(value.type_url);\n      const data = codec.decode(value.value);\n      return {\n        ...data,\n        \"@type\": value.type_url\n      };\n    }\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/struct.ts\nvar encodeStructValue = (structValue) => {\n  const valueType = typeof structValue;\n  switch (valueType) {\n    case \"undefined\": {\n      return {\n        nullValue: 0\n      };\n    }\n    case \"number\": {\n      return {\n        numberValue: structValue\n      };\n    }\n    case \"string\": {\n      return {\n        stringValue: structValue\n      };\n    }\n    case \"boolean\": {\n      return {\n        boolValue: structValue\n      };\n    }\n    case \"object\": {\n      if (structValue === null) {\n        return {\n          nullValue: 0\n        };\n      }\n      if (Array.isArray(structValue)) {\n        return {\n          listValue: {\n            values: structValue.map(encodeStructValue)\n          }\n        };\n      }\n      return {\n        structValue: encodeStruct(structValue)\n      };\n    }\n    default: {\n      throw new Error(`Unsupported type: ${valueType}`);\n    }\n  }\n};\nvar encodeStruct = (struct) => ({\n  fields: Object.fromEntries(Object.entries(struct).map(([key, value]) => [\n    key,\n    encodeStructValue(value)\n  ]))\n});\nvar decodeStructValue = (structValue) => {\n  const [key, v] = Object.entries(structValue)[0];\n  switch (key) {\n    case \"nullValue\": {\n      return null;\n    }\n    case \"numberValue\": {\n      return v;\n    }\n    case \"stringValue\": {\n      return v;\n    }\n    case \"boolValue\": {\n      return v;\n    }\n    case \"structValue\": {\n      return decodeStruct(v);\n    }\n    case \"listValue\": {\n      return v.values.map(decodeStructValue);\n    }\n    default:\n      throw new Error(`Unsupported type: ${key}`);\n  }\n};\nvar decodeStruct = (struct) => Object.fromEntries(Object.entries(struct.fields || {}).map(([key, value]) => [\n  key,\n  decodeStructValue(value)\n]));\nvar structSubstitutions = {\n  \"google.protobuf.Struct\": {\n    encode: (value) => encodeStruct(value),\n    decode: (value) => decodeStruct(value)\n  }\n};\n\n// packages/common/codec-protobuf/src/substitutions/timestamp.ts\nvar timestampSubstitutions = {\n  \"google.protobuf.Timestamp\": {\n    encode: (value) => {\n      const unixMilliseconds = value.getTime();\n      return {\n        seconds: Math.floor(unixMilliseconds / 1e3).toString(),\n        nanos: unixMilliseconds % 1e3 * 1e6\n      };\n    },\n    decode: (value) => {\n      var _a, _b;\n      return new Date(parseInt((_a = value.seconds) != null ? _a : \"0\") * 1e3 + ((_b = value.nanos) != null ? _b : 0) / 1e6);\n    }\n  }\n};\nexport {\n  OBJECT_CONVERSION_OPTIONS,\n  ProtoCodec,\n  Schema,\n  Service,\n  ServiceDescriptor,\n  ServiceHandler,\n  Stream,\n  anySubstitutions,\n  createMappingDescriptors,\n  decodeProtobuf,\n  encodeProtobuf,\n  mapMessage,\n  patchBufferCodec,\n  sanitize,\n  structSubstitutions,\n  timestampSubstitutions\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466442,"end":1670465466449,"order":"normal"}]}
