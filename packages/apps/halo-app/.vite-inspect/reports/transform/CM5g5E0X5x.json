{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/index.js","transforms":[{"name":"vite:load-fallback","result":"var low = require('last-one-wins')\nvar remove = require('unordered-array-remove')\nvar set = require('unordered-set')\nvar MerkleGenerator = require('merkle-tree-stream/generator')\nvar flat = require('flat-tree')\nvar codecs = require('codecs')\nvar batcher = require('atomic-batcher')\nvar inherits = require('inherits')\nvar bitfield = require('./lib/bitfield')\nvar sparseBitfield = require('sparse-bitfield')\nvar treeIndex = require('./lib/tree-index')\nvar storage = require('./lib/storage')\nvar crypto = require('hypercore-crypto')\nvar inspect = require('inspect-custom-symbol')\nvar pretty = require('pretty-hash')\nvar Nanoguard = require('nanoguard')\nvar safeBufferEquals = require('./lib/safe-buffer-equals')\nvar replicate = require('./lib/replicate')\nvar Protocol = require('hypercore-protocol')\nvar Message = require('abstract-extension')\nvar Nanoresource = require('nanoresource/emitter')\nvar defaultStorage = require('hypercore-default-storage')\nvar { WriteStream, ReadStream } = require('hypercore-streams')\n\nclass Extension extends Message {\n  broadcast (message) {\n    const feed = this.local.handlers\n    const buf = this.encoding.encode(message)\n    let broadcasted = false\n    for (const peer of feed.peers) {\n      broadcasted = true\n      peer.extension(this.id, buf)\n    }\n    return broadcasted\n  }\n\n  send (message, peer) {\n    peer.extension(this.id, this.encode(message))\n  }\n}\n\nvar defaultCrypto = {\n  sign (data, sk, cb) {\n    return cb(null, crypto.sign(data, sk))\n  },\n  verify (sig, data, pk, cb) {\n    return cb(null, crypto.verify(sig, data, pk))\n  }\n}\n\nmodule.exports = Feed\n\nfunction Feed (createStorage, key, opts) {\n  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts)\n  Nanoresource.call(this)\n\n  if (typeof createStorage === 'string') createStorage = defaultStorageDir(createStorage)\n  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string')\n\n  if (typeof key === 'string') key = Buffer.from(key, 'hex')\n\n  if (!Buffer.isBuffer(key) && !opts) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  var self = this\n\n  var secretKey = opts.secretKey || null\n  if (typeof secretKey === 'string') secretKey = Buffer.from(secretKey, 'hex')\n\n  this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair()\n  this.live = opts.live !== false\n  this.sparse = !!opts.sparse\n  this.length = 0\n  this.byteLength = 0\n  this.maxRequests = opts.maxRequests || 16\n  this.key = key || opts.key || null\n  this.discoveryKey = this.key && crypto.discoveryKey(this.key)\n  this.secretKey = secretKey\n  this.bitfield = null\n  this.tree = null\n  this.writable = !!opts.writable\n  this.readable = true\n  this.downloading = opts.downloading !== false\n  this.uploading = opts.uploading !== false\n  this.allowPush = !!opts.allowPush\n  this.peers = []\n  this.ifAvailable = new Nanoguard()\n  this.extensions = Extension.createLocal(this) // set Feed as the handlers\n\n  this.crypto = opts.crypto || defaultCrypto\n\n  // hooks\n  this._onwrite = opts.onwrite || null\n\n  this._force = !!opts.force\n  this._expectedLength = -1\n  this._indexing = !!opts.indexing\n  this._createIfMissing = opts.createIfMissing !== false\n  this._overwrite = !!opts.overwrite\n  this._storeSecretKey = opts.storeSecretKey !== false\n  this._alwaysIfAvailable = !!opts.ifAvailable\n  this._merkle = null\n  this._storage = storage(createStorage, opts)\n  this._batch = batcher(this._onwrite ? workHook : work)\n\n  this.timeouts = opts.timeouts || {\n    get (cb) {\n      cb(null)\n    },\n    update (cb) {\n      cb(null)\n    }\n  }\n\n  this._seq = 0\n  this._waiting = []\n  this._selections = []\n  this._reserved = sparseBitfield()\n  this._synced = null\n  this._downloadingSet = typeof opts.downloading === 'boolean'\n\n  this._stats = (typeof opts.stats !== 'undefined' && !opts.stats) ? null : {\n    downloadedBlocks: 0,\n    downloadedBytes: 0,\n    uploadedBlocks: 0,\n    uploadedBytes: 0\n  }\n\n  this._codec = toCodec(opts.valueEncoding)\n  this._sync = low(sync)\n  if (!this.sparse) this.download({ start: 0, end: -1 })\n\n  if (this.sparse && opts.eagerUpdate) {\n    this.update(function loop (err) {\n      if (err) self.emit('update-error', err)\n      self.update(loop)\n    })\n  }\n\n  // open it right away\n  this.open(onerror)\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function workHook (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb)\n    self._appendHook(values, cb)\n  }\n\n  function work (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb)\n    self._append(values, cb)\n  }\n\n  function sync (_, cb) {\n    self._syncBitfield(cb)\n  }\n}\n\ninherits(Feed, Nanoresource)\n\nFeed.discoveryKey = crypto.discoveryKey\n\nFeed.prototype[inspect] = function (depth, opts) {\n  var indent = ''\n  if (typeof opts.indentationLvl === 'number') {\n    while (indent.length < opts.indentationLvl) indent += ' '\n  }\n  return 'Hypercore(\\n' +\n    indent + '  key: ' + opts.stylize((this.key && pretty(this.key)), 'string') + '\\n' +\n    indent + '  discoveryKey: ' + opts.stylize((this.discoveryKey && pretty(this.discoveryKey)), 'string') + '\\n' +\n    indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n    indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\\n' +\n    indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n    indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n    indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\\n' +\n    indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\\n' +\n    indent + ')'\n}\n\n// TODO: instead of using a getter, update on remote-update/add/remove\nObject.defineProperty(Feed.prototype, 'remoteLength', {\n  enumerable: true,\n  get: function () {\n    var len = 0\n    for (var i = 0; i < this.peers.length; i++) {\n      var remoteLength = this.peers[i].remoteLength\n      if (remoteLength > len) len = remoteLength\n    }\n    return len\n  }\n})\n\nObject.defineProperty(Feed.prototype, 'stats', {\n  enumerable: true,\n  get: function () {\n    if (!this._stats) return null\n    var peerStats = []\n    for (var i = 0; i < this.peers.length; i++) {\n      var peer = this.peers[i]\n      peerStats[i] = peer.stats\n    }\n    return {\n      peers: peerStats,\n      totals: this._stats\n    }\n  }\n})\n\nFeed.prototype.replicate = function (initiator, opts) {\n  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection\n    this.download({ start: 0, end: -1 })\n  }\n\n  if (isOptions(initiator) && !opts) {\n    opts = initiator\n    initiator = opts.initiator\n  }\n\n  opts = opts || {}\n  opts.stats = !!this._stats\n  opts.noise = !(opts.noise === false && opts.encrypted === false)\n\n  return replicate(this, initiator, opts)\n}\n\nFeed.prototype.registerExtension = function (name, handlers) {\n  return this.extensions.add(name, handlers)\n}\n\nFeed.prototype.onextensionupdate = function () {\n  for (const peer of this.peers) peer._updateOptions()\n}\n\nFeed.prototype.setDownloading = function (downloading) {\n  if (this.downloading === downloading && this._downloadingSet) return\n  this.downloading = downloading\n  this._downloadingSet = true\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setDownloading(this.downloading)\n  })\n}\n\nFeed.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setUploading(this.uploading)\n  })\n}\n\n// Alias the nanoresource open method\nFeed.prototype.ready = Feed.prototype.open\n\nFeed.prototype.update = function (opts, cb) {\n  if (typeof opts === 'function') return this.update(-1, opts)\n  if (typeof opts === 'number') opts = { minLength: opts }\n  if (!opts) opts = {}\n  if (!cb) cb = noop\n\n  var self = this\n  var len = typeof opts.minLength === 'number' ? opts.minLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (len === -1) len = self.length + 1\n    if (self.length >= len) return cb(null)\n\n    const ifAvailable = typeof opts.ifAvailable === 'boolean'\n      ? opts.ifAvailable\n      : self._alwaysIfAvailable\n\n    if (ifAvailable && self.writable && !opts.force) return cb(new Error('No update available from peers'))\n    if (self.writable) cb = self._writeStateReloader(cb)\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: 0,\n      index: len - 1,\n      options: opts,\n      update: true,\n      callback: cb\n    }\n\n    self._waiting.push(w)\n    if (ifAvailable) self._ifAvailable(w, len)\n    self._updatePeers()\n  })\n}\n\n// Used to hint to the update guard if it can bail early\nFeed.prototype.setExpectedLength = function (len) {\n  this._expectedLength = len\n  this.ready((err) => {\n    if (err) return\n\n    this.ifAvailable.ready(() => {\n      this._expectedLength = -1\n    })\n\n    if (this._expectedLength === -1 || this._expectedLength > this.length) return\n\n    for (const w of this._waiting) {\n      if (w.update && w.ifAvailable) w.callback(new Error('Expected length is less than current length'))\n    }\n  })\n}\n\n// Beware! This might break your core if you share forks with other people through replication\nFeed.prototype.truncate = function (newLength, cb) {\n  if (!cb) cb = noop\n  const self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    self._roots(newLength, function (err, roots) {\n      if (err) return cb(err)\n\n      const oldLength = self.length\n      if (oldLength <= newLength) return cb(null)\n\n      let byteLength = 0\n      for (const { size } of roots) byteLength += size\n\n      for (let i = oldLength; i < newLength; i++) self.data.set(i, false)\n      self.byteLength = byteLength\n      self.length = newLength\n      self.tree.truncate(2 * newLength)\n      self._merkle = new MerkleGenerator(crypto, roots)\n\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        self._storage.deleteSignatures(newLength, oldLength, cb)\n      })\n    })\n  })\n}\n\nFeed.prototype._ifAvailable = function (w, minLength) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n  w.ifAvailable = true\n\n  if (this._expectedLength > -1 && this._expectedLength <= this.length) {\n    return process.nextTick(w.callback, new Error('Expected length is less than current length'))\n  }\n\n  this.timeouts.update(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n      if (self.length >= minLength || self.remoteLength >= minLength) return\n      done(new Error('No update available from peers'))\n    })\n  })\n\n  function done (err) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err)\n  }\n}\n\nFeed.prototype._ifAvailableGet = function (w) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      for (var i = 0; i < self.peers.length; i++) {\n        var peer = self.peers[i]\n        if (peer.remoteBitfield.get(w.index)) return\n      }\n      done(new Error('Block not available from peers'))\n    })\n  })\n\n  function done (err, data) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err, data)\n  }\n}\n\n// will reload the writable state. used by .update on a writable peer\nFeed.prototype._writeStateReloader = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._reloadMerkleState(cb)\n  }\n}\n\nFeed.prototype._reloadMerkleState = function (cb) {\n  var self = this\n\n  this._roots(self.length, function (err, roots) {\n    if (err) return cb(err)\n    self._merkle = new MerkleGenerator(crypto, roots)\n    cb(null)\n  })\n}\n\nFeed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {\n  this._reloadMerkleState(function (err) {\n    if (err) return cb(err)\n    work(values, cb)\n  })\n}\n\nFeed.prototype._open = function (cb) {\n  var self = this\n  var generatedKey = false\n  var retryOpen = true\n\n  // TODO: clean up the duplicate code below ...\n\n  this._storage.openKey(function (_, key) {\n    if (key && !self._overwrite && !self.key) self.key = key\n\n    if (!self.key && self.live) {\n      var keyPair = crypto.keyPair()\n      self.secretKey = keyPair.secretKey\n      self.key = keyPair.publicKey\n      generatedKey = true\n    }\n\n    self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n    self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen)\n  })\n\n  function onopen (err, state) {\n    if (err) return cb(err)\n\n    // if no key but we have data do a bitfield reset since we cannot verify the data.\n    if (!state.key && state.bitfield.length) {\n      self._overwrite = true\n    }\n\n    if (self._force && state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      self._overwrite = true\n    }\n\n    if (self._overwrite) {\n      state.bitfield = []\n      state.key = state.secretKey = null\n    }\n\n    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield)\n    self.tree = treeIndex(self.bitfield.tree)\n    self.length = self.tree.blocks()\n    self._seq = self.length\n\n    if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      return self._forceClose(cb, new Error('Another hypercore is stored here'))\n    }\n\n    if (state.key) self.key = state.key\n    if (state.secretKey) self.secretKey = state.secretKey\n\n    if (!self.length) return onsignature(null, null)\n    self._storage.getSignature(self.length - 1, onsignature)\n\n    function onsignature (_, sig) {\n      if (self.length) self.live = !!sig\n\n      if ((generatedKey || !self.key) && !self._createIfMissing) {\n        return self._forceClose(cb, new Error('No hypercore is stored here'))\n      }\n\n      if (!self.key && self.live) {\n        var keyPair = crypto.keyPair()\n        self.secretKey = keyPair.secretKey\n        self.key = keyPair.publicKey\n      }\n\n      var writable = !!self.secretKey || self.key === null\n\n      if (!writable && self.writable) return self._forceClose(cb, new Error('Feed is not writable'))\n      self.writable = writable\n      if (!self._downloadingSet) self.downloading = !writable\n      self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n\n      if (self._storeSecretKey && !self.secretKey) {\n        self._storeSecretKey = false\n      }\n\n      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key)\n      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey))\n\n      var missing = 1 +\n        (shouldWriteKey ? 1 : 0) +\n        (shouldWriteSecretKey ? 1 : 0) +\n        (self._overwrite ? 1 : 0)\n      var error = null\n\n      if (shouldWriteKey) self._storage.key.write(0, self.key, done)\n      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done)\n\n      if (self._overwrite) {\n        self._storage.bitfield.del(32, Infinity, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return self._forceClose(cb, error)\n        self._roots(self.length, onroots)\n      }\n\n      function onroots (err, roots) {\n        if (err && retryOpen) {\n          retryOpen = false\n          self.length--\n          self._storage.getSignature(self.length - 1, onsignature)\n          return\n        }\n\n        if (err) return self._forceClose(cb, err)\n\n        self._merkle = new MerkleGenerator(crypto, roots)\n        self.byteLength = roots.reduce(addSize, 0)\n        self.emit('ready')\n\n        cb(null)\n      }\n    }\n  }\n}\n\nFeed.prototype.download = function (range, cb) {\n  if (typeof range === 'function') return this.download(null, range)\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (Array.isArray(range)) range = { blocks: range }\n  if (!range) range = {}\n  if (!cb) cb = noop\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so\n  // this._updatePeers does this for us when there is a peer though, so not critical\n\n  // We need range.start, end for the want messages so make sure to infer these\n  // when blocks are passed and start,end is not set\n  if (range.blocks && typeof range.start !== 'number') {\n    var min = -1\n    var max = 0\n\n    for (var i = 0; i < range.blocks.length; i++) {\n      const blk = range.blocks[i]\n      if (min === -1 || blk < min) min = blk\n      if (blk >= max) max = blk + 1\n    }\n\n    range.start = min === -1 ? 0 : min\n    range.end = max\n  }\n\n  var sel = {\n    _index: this._selections.length,\n    hash: !!range.hash,\n    iterator: null,\n    start: range.start || 0,\n    end: range.end || -1,\n    want: 0,\n    linear: !!range.linear,\n    blocks: range.blocks || null,\n    blocksDownloaded: 0,\n    requested: 0,\n    callback: cb\n  }\n\n  sel.want = toWantRange(sel.start)\n\n  this._selections.push(sel)\n  this._updatePeers()\n\n  return sel\n}\n\nFeed.prototype.undownload = function (range) {\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (!range) range = {}\n\n  if (range.callback && range._index > -1) {\n    set.remove(this._selections, range)\n    process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n    return\n  }\n\n  var start = range.start || 0\n  var end = range.end || -1\n  var hash = !!range.hash\n  var linear = !!range.linear\n\n  for (var i = 0; i < this._selections.length; i++) {\n    var s = this._selections[i]\n\n    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n      set.remove(this._selections, s)\n      process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n      return\n    }\n  }\n}\n\nFeed.prototype.digest = function (index) {\n  return this.tree.digest(2 * index)\n}\n\nFeed.prototype.proof = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.proof(index, null, opts)\n  if (!this.opened) return this._readyAndProof(index, opts, cb)\n  if (!opts) opts = {}\n\n  var proof = this.tree.proof(2 * index, opts)\n  if (!proof) return cb(new Error('No proof available for this index'))\n\n  var needsSig = this.live && !!proof.verifiedBy\n  var pending = proof.nodes.length + (needsSig ? 1 : 0)\n  var error = null\n  var signature = null\n  var nodes = new Array(proof.nodes.length)\n\n  if (!pending) return cb(null, { nodes: nodes, signature: null })\n\n  for (var i = 0; i < proof.nodes.length; i++) {\n    this._storage.getNode(proof.nodes[i], onnode)\n  }\n  if (needsSig) {\n    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)\n  }\n\n  function onsignature (err, sig) {\n    if (sig) signature = sig\n    onnode(err, null)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n\n    if (node) {\n      nodes[proof.nodes.indexOf(node.index)] = node\n    }\n\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, { nodes: nodes, signature: signature })\n  }\n}\n\nFeed.prototype._readyAndProof = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.proof(index, opts, cb)\n  })\n}\n\nFeed.prototype.put = function (index, data, proof, cb) {\n  if (!this.opened) return this._readyAndPut(index, data, proof, cb)\n  this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb)\n}\n\nFeed.prototype.cancel = function (start, end) { // TODO: use same argument scheme as download\n  if (typeof start !== 'symbol') {\n    if (!end) end = start + 1\n\n    // cancel these right away as .download does not wait for ready\n    for (var i = this._selections.length - 1; i >= 0; i--) {\n      var sel = this._selections[i]\n      if (start <= sel.start && sel.end <= end) {\n        this.undownload(sel)\n      }\n    }\n  }\n\n  // defer the last part until after ready as .get does that as well\n  if (this.opened) this._cancel(start, end)\n  else this._readyAndCancel(start, end)\n}\n\nFeed.prototype._cancel = function (start, end) {\n  var i = 0\n\n  if (typeof start === 'symbol') {\n    for (i = this._waiting.length - 1; i >= 0; i--) {\n      const w = this._waiting[i]\n      if (w.options.cancel === start) {\n        remove(this._waiting, i)\n        this._reserved.set(w.index, false)\n        if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n        this._updatePeers()\n        return\n      }\n    }\n    return\n  }\n\n  for (i = start; i < end; i++) {\n    this._reserved.set(i, false) // TODO: send cancel message if set returns true\n  }\n\n  for (i = this._waiting.length - 1; i >= 0; i--) {\n    var w = this._waiting[i]\n    if ((start <= w.start && w.end <= end) || (start <= w.index && w.index < end)) {\n      remove(this._waiting, i)\n      if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n    }\n  }\n}\n\nFeed.prototype.clear = function (start, end, opts, cb) { // TODO: use same argument scheme as download\n  if (typeof end === 'function') return this.clear(start, start + 1, null, end)\n  if (typeof opts === 'function') return this.clear(start, end, null, opts)\n  if (!opts) opts = {}\n  if (!end) end = start + 1\n  if (!cb) cb = noop\n\n  // TODO: this needs some work. fx we can only calc byte offset for blocks we know about\n  // so internally we should make sure to only do that. We should use the merkle tree for this\n\n  var self = this\n  var byteOffset = start === 0 ? 0 : (typeof opts.byteOffset === 'number' ? opts.byteOffset : -1)\n  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var modified = false\n\n    // TODO: use a buffer.fill thing here to speed this up!\n\n    for (var i = start; i < end; i++) {\n      if (self.bitfield.set(i, false)) modified = true\n    }\n\n    if (!modified) return process.nextTick(cb)\n\n    // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing\n\n    self._unannounce({ start: start, length: end - start })\n    if (opts.delete === false || self._indexing) return sync()\n    if (byteOffset > -1) return onstartbytes(null, byteOffset)\n    self._storage.dataOffset(start, [], onstartbytes)\n\n    function sync () {\n      self.emit('clear', start, end)\n      self._sync(null, cb)\n    }\n\n    function onstartbytes (err, offset) {\n      if (err) return cb(err)\n      byteOffset = offset\n      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset)\n      if (end === self.length) return onendbytes(null, self.byteLength)\n      self._storage.dataOffset(end, [], onendbytes)\n    }\n\n    function onendbytes (err, end) {\n      if (err) return cb(err)\n      if (!self._storage.data.del) return sync() // Not all data storage impls del\n      self._storage.data.del(byteOffset, end - byteOffset, sync)\n    }\n  })\n}\n\nFeed.prototype.signature = function (index, cb) {\n  if (typeof index === 'function') return this.signature(this.length - 1, index)\n\n  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'))\n\n  this._storage.nextSignature(index, cb)\n}\n\nFeed.prototype.verify = function (index, signature, cb) {\n  var self = this\n\n  this.rootHashes(index, function (err, roots) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, index + 1)\n\n    verifyCompat(self, checksum, signature, function (err, valid) {\n      if (err) return cb(err)\n\n      if (!valid) return cb(new Error('Signature verification failed'))\n\n      return cb(null, true)\n    })\n  })\n}\n\nFeed.prototype.rootHashes = function (index, cb) {\n  this._getRootsToVerify(index * 2 + 2, {}, [], cb)\n}\n\nFeed.prototype.seek = function (bytes, opts, cb) {\n  if (typeof opts === 'function') return this.seek(bytes, null, opts)\n  if (!opts) opts = {}\n  if (!this.opened) return this._readyAndSeek(bytes, opts, cb)\n\n  var self = this\n\n  if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0)\n\n  this._seek(bytes, function (err, index, offset) {\n    if (!err && isBlock(index)) return done(index / 2, offset)\n    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'))\n\n    var start = opts.start || 0\n    var end = opts.end || -1\n\n    if (!err) {\n      var left = flat.leftSpan(index) / 2\n      var right = flat.rightSpan(index) / 2 + 1\n\n      if (left > start) start = left\n      if (right < end || end === -1) end = right\n    }\n\n    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'))\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: bytes,\n      index: -1,\n      ifAvailable: opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable,\n      start: start,\n      end: end,\n      want: toWantRange(start),\n      requested: 0,\n      callback: cb || noop\n    }\n\n    self._waiting.push(w)\n    self._updatePeers()\n    if (w.ifAvailable) self._ifAvailableSeek(w)\n  })\n\n  function done (index, offset) {\n    for (var i = 0; i < self.peers.length; i++) {\n      self.peers[i].haveBytes(bytes)\n    }\n    cb(null, index, offset)\n  }\n}\n\nFeed.prototype._ifAvailableSeek = function (w) {\n  var self = this\n  var cb = w.callback\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      let available = false\n      for (const peer of self.peers) {\n        const ite = peer._iterator\n        let i = ite.seek(w.start).next(true)\n        while (self.tree.get(i * 2) && i > -1) i = ite.next(true)\n        if (i > -1 && (w.end === -1 || i < w.end)) {\n          available = true\n          break\n        }\n      }\n\n      if (!available) done(new Error('Seek not available from peers'))\n    })\n  })\n\n  function done (err) {\n    var i = self._waiting.indexOf(w)\n    if (i > -1) {\n      remove(self._waiting, i)\n      w.callback = noop\n      cb(err)\n    }\n  }\n}\n\nFeed.prototype._seek = function (offset, cb) {\n  if (offset === 0) return cb(null, 0, 0)\n\n  var self = this\n  var roots = flat.fullRoots(this.length * 2)\n  var nearestRoot = 0\n\n  loop(null, null)\n\n  function onroot (top) {\n    if (isBlock(top)) return cb(null, nearestRoot, offset)\n\n    var left = flat.leftChild(top)\n    while (!self.tree.get(left)) {\n      if (isBlock(left)) return cb(null, nearestRoot, offset)\n      left = flat.leftChild(left)\n    }\n\n    self._storage.getNode(left, onleftchild)\n  }\n\n  function onleftchild (err, node) {\n    if (err) return cb(err)\n\n    if (node.size > offset) {\n      nearestRoot = node.index\n      onroot(node.index)\n    } else {\n      offset -= node.size\n      if (flat.parent(node.index) === nearestRoot) {\n        nearestRoot = flat.sibling(node.index)\n        onroot(nearestRoot)\n      } else {\n        onroot(flat.sibling(node.index))\n      }\n    }\n  }\n\n  function loop (err, node) {\n    if (err) return cb(err)\n\n    if (node) {\n      if (node.size > offset) {\n        nearestRoot = node.index\n        return onroot(node.index)\n      }\n      offset -= node.size\n    }\n\n    if (!roots.length) return cb(new Error('Out of bounds'))\n    self._storage.getNode(roots.shift(), loop)\n  }\n}\n\nFeed.prototype._readyAndSeek = function (bytes, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.seek(bytes, opts, cb)\n  })\n}\n\nFeed.prototype._getBuffer = function (index, cb) {\n  this._storage.getData(index, cb)\n}\n\nFeed.prototype._putBuffer = function (index, data, proof, from, cb) {\n  // TODO: this nodes in proof are not instances of our Node prototype\n  // but just similar. Check if this has any v8 perf implications.\n\n  // TODO: if the proof contains a valid signature BUT fails, emit a critical error\n  // --> feed should be considered dead\n\n  var self = this\n  var trusted = -1\n  var missing = []\n  var next = 2 * index\n  var i = data ? 0 : 1\n\n  while (true) {\n    if (this.tree.get(next)) {\n      trusted = next\n      break\n    }\n\n    var sib = flat.sibling(next)\n    next = flat.parent(next)\n\n    if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n      i++\n      continue\n    }\n\n    if (!this.tree.get(sib)) break\n    missing.push(sib)\n  }\n\n  if (trusted === -1 && this.tree.get(next)) trusted = next\n\n  var error = null\n  var trustedNode = null\n  var missingNodes = new Array(missing.length)\n  var pending = missing.length + (trusted > -1 ? 1 : 0)\n\n  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing)\n  if (trusted > -1) this._storage.getNode(trusted, ontrusted)\n  if (!missing.length && trusted === -1) onmissingloaded(null)\n\n  function ontrusted (err, node) {\n    if (err) error = err\n    if (node) trustedNode = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissing (err, node) {\n    if (err) error = err\n    if (node) missingNodes[missing.indexOf(node.index)] = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissingloaded (err) {\n    if (err) return cb(err)\n    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb)\n  }\n}\n\nFeed.prototype._readyAndPut = function (index, data, proof, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.put(index, data, proof, cb)\n  })\n}\n\nFeed.prototype._write = function (index, data, nodes, sig, from, cb) {\n  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb)\n  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb))\n}\n\nfunction writeHookDone (self, index, data, nodes, sig, from, cb) {\n  return function (err) {\n    if (err) return cb(err)\n    self._writeAfterHook(index, data, nodes, sig, from, cb)\n  }\n}\n\nFeed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {\n  var self = this\n  var pending = nodes.length + 1 + (sig ? 1 : 0)\n  var error = null\n\n  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone)\n  if (data) this._storage.putData(index, data, nodes, ondone)\n  else ondone()\n  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone)\n\n  function ondone (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n    self._writeDone(index, data, nodes, from, cb)\n  }\n}\n\nFeed.prototype._writeDone = function (index, data, nodes, from, cb) {\n  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)\n  this.tree.set(2 * index)\n\n  if (data) {\n    if (this.bitfield.set(index, true)) {\n      if (this._stats) {\n        this._stats.downloadedBlocks += 1\n        this._stats.downloadedBytes += data.length\n      }\n      this.emit('download', index, data, from)\n    }\n    if (this.peers.length) this._announce({ start: index }, from)\n\n    if (!this.writable) {\n      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length)\n      if (this._synced.next() === -1) {\n        this._synced.range(0, this.length)\n        this._synced.seek(0)\n        if (this._synced.next() === -1) {\n          this.emit('sync')\n        }\n      }\n    }\n  }\n\n  this._sync(null, cb)\n}\n\nFeed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {\n  var visited = []\n  var remoteNodes = proof.nodes\n  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift()\n\n  // check if we already have the hash for this node\n  if (verifyNode(trustedNode, top)) {\n    this._write(index, data, visited, null, from, cb)\n    return\n  }\n\n  // keep hashing with siblings until we reach or trusted node\n  while (true) {\n    var node = null\n    var next = flat.sibling(top.index)\n\n    if (remoteNodes.length && remoteNodes[0].index === next) {\n      node = remoteNodes.shift()\n      visited.push(node)\n    } else if (localNodes.length && localNodes[0].index === next) {\n      node = localNodes.shift()\n    } else {\n      // we cannot create another parent, i.e. these nodes must be roots in the tree\n      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb)\n      return\n    }\n\n    visited.push(top)\n    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size)\n\n    // the tree checks out, write the data and the visited nodes\n    if (verifyNode(trustedNode, top)) {\n      this._write(index, data, visited, null, from, cb)\n      return\n    }\n  }\n}\n\nFeed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {\n  var remoteNodes = proof.nodes\n  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index\n  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2\n  var length = verifiedBy / 2\n  var self = this\n\n  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, length)\n    var signature = null\n\n    if (self.length && self.live && !proof.signature) {\n      return cb(new Error('Remote did not include a signature'))\n    }\n\n    if (proof.signature) { // check signatures\n      verifyCompat(self, checksum, proof.signature, function (err, valid) {\n        if (err) return cb(err)\n        if (!valid) return cb(new Error('Remote signature could not be verified'))\n\n        signature = { index: verifiedBy / 2 - 1, signature: proof.signature }\n        write()\n      })\n    } else { // check tree root\n      if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {\n        return cb(new Error('Remote checksum failed'))\n      }\n\n      write()\n    }\n\n    function write () {\n      self.live = !!signature\n\n      if (length > self.length) {\n        // TODO: only emit this after the info has been flushed to storage\n        if (self.writable) self._merkle = null // We need to reload merkle state now\n        self.length = length\n        self._seq = length\n        self.byteLength = roots.reduce(addSize, 0)\n        if (self._synced) self._synced.seek(0, self.length)\n        self.emit('append')\n      }\n\n      self._write(index, data, nodes.concat(extraNodes), signature, from, cb)\n    }\n  })\n}\n\nFeed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {\n  var indexes = flat.fullRoots(verifiedBy)\n  var roots = new Array(indexes.length)\n  var nodes = []\n  var error = null\n  var pending = roots.length\n\n  for (var i = 0; i < indexes.length; i++) {\n    if (indexes[i] === top.index) {\n      nodes.push(top)\n      onnode(null, top)\n    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n      nodes.push(remoteNodes[0])\n      onnode(null, remoteNodes.shift())\n    } else if (this.tree.get(indexes[i])) {\n      this._storage.getNode(indexes[i], onnode)\n    } else {\n      onnode(new Error('Missing tree roots needed for verify'))\n    }\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) roots[indexes.indexOf(node.index)] = node\n    if (!--pending) done(error)\n  }\n\n  function done (err) {\n    if (err) return cb(err)\n\n    cb(null, roots, nodes)\n  }\n}\n\nFeed.prototype._announce = function (message, from) {\n  for (var i = 0; i < this.peers.length; i++) {\n    var peer = this.peers[i]\n    if (peer !== from) peer.have(message)\n  }\n}\n\nFeed.prototype._unannounce = function (message) {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message)\n}\n\nFeed.prototype.downloaded = function (start, end, cb) {\n  const count = this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, count) // prepare async interface for this\n  return count\n}\n\nFeed.prototype.has = function (start, end, cb) {\n  if (typeof end === 'function') return this.has(start, undefined, end)\n  if (end === undefined) {\n    const res = this.bitfield.get(start)\n    if (cb) process.nextTick(cb, null, res)\n    return res\n  }\n  const total = end - start\n  const res = total === this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, res)\n  return res\n}\n\nFeed.prototype.getBlockInfo = function (index, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._storage.getNode(2 * index, cb)\n  })\n}\n\nFeed.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head({}, opts)\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (opts && opts.update) self.update(opts, onupdate)\n    else process.nextTick(onupdate)\n  })\n\n  function onupdate () {\n    if (self.length === 0) cb(new Error('feed is empty'))\n    else self.get(self.length - 1, opts, cb)\n  }\n}\n\nFeed.prototype.get = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.get(index, null, opts)\n\n  opts = { ...opts }\n  if (!opts.cancel) opts.cancel = Symbol('hypercore-get')\n\n  if (!this.opened) return this._readyAndGet(index, opts, cb)\n\n  if (!this.readable) {\n    process.nextTick(cb, new Error('Feed is closed'))\n    return opts.cancel\n  }\n\n  if (opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  if (!this.bitfield.get(index)) {\n    if (opts && opts.wait === false) return process.nextTick(cb, new Error('Block not downloaded'))\n\n    var w = { bytes: 0, hash: false, index: index, options: opts, requested: 0, callback: cb }\n    this._waiting.push(w)\n\n    if (opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w)\n\n    this._updatePeers()\n    if (opts.onwait) {\n      const onwait = opts.onwait\n      opts.onwait = null\n      onwait(index)\n    }\n    return opts.cancel\n  }\n\n  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb)\n  else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb)\n\n  this._getBuffer(index, cb)\n  return opts.cancel\n}\n\nFeed.prototype._readyAndGet = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.get(index, opts, cb)\n  })\n  return opts.cancel\n}\n\nFeed.prototype.getBatch = function (start, end, opts, cb) {\n  if (typeof opts === 'function') return this.getBatch(start, end, null, opts)\n  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb)\n\n  var self = this\n  var wait = !opts || opts.wait !== false\n\n  if (this.has(start, end)) return this._getBatch(start, end, opts, cb)\n  if (!wait) return process.nextTick(cb, new Error('Block not downloaded'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  this.download({ start: start, end: end }, function (err) {\n    if (err) return cb(err)\n    self._getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._getBatch = function (start, end, opts, cb) {\n  var enc = opts && opts.valueEncoding\n  var codec = enc ? toCodec(enc) : this._codec\n\n  this._storage.getDataBatch(start, end - start, onbatch)\n\n  function onbatch (err, buffers) {\n    if (err) return cb(err)\n\n    var batch = new Array(buffers.length)\n\n    for (var i = 0; i < buffers.length; i++) {\n      try {\n        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i]\n      } catch (err) {\n        return cb(err)\n      }\n    }\n\n    cb(null, batch)\n  }\n}\n\nFeed.prototype._readyAndGetBatch = function (start, end, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._updatePeers = function () {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].update()\n}\n\nFeed.prototype.createWriteStream = function (opts) {\n  return new WriteStream(this, opts)\n}\n\nFeed.prototype.createReadStream = function (opts) {\n  return new ReadStream(this, opts)\n}\n\n// TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)\nFeed.prototype.finalize = function (cb) {\n  if (!this.key) {\n    this.key = crypto.tree(this._merkle.roots)\n    this.discoveryKey = crypto.discoveryKey(this.key)\n  }\n  this._storage.key.write(0, this.key, cb)\n}\n\nFeed.prototype.append = function (batch, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var list = Array.isArray(batch) ? batch : [batch]\n  this._batch(list, onappend)\n\n  function onappend (err) {\n    if (err) return cb(err)\n    var seq = self._seq\n    self._seq += list.length\n    cb(null, seq)\n  }\n}\n\nFeed.prototype.flush = function (cb) {\n  this.append([], cb)\n}\n\nFeed.prototype.destroyStorage = function (cb) {\n  const self = this\n\n  this.close(function (err) {\n    if (err) cb(err)\n    else self._storage.destroy(cb)\n  })\n}\n\nFeed.prototype._close = function (cb) {\n  const self = this\n\n  for (const peer of this.peers) {\n    if (!peer._destroyed) peer._close()\n  }\n\n  this._forceClose(onclose, null)\n\n  function onclose (err) {\n    if (!err) self.emit('close')\n    cb(err)\n  }\n}\n\nFeed.prototype._forceClose = function (cb, error) {\n  var self = this\n\n  this.writable = false\n  this.readable = false\n\n  this._storage.close(function (err) {\n    if (!err) err = error\n    self._destroy(err || new Error('Feed is closed'))\n    cb(err)\n  })\n}\n\nFeed.prototype._destroy = function (err) {\n  this.ifAvailable.destroy()\n\n  while (this._waiting.length) {\n    this._waiting.pop().callback(err)\n  }\n  while (this._selections.length) {\n    this._selections.pop().callback(err)\n  }\n}\n\nFeed.prototype._appendHook = function (batch, cb) {\n  var self = this\n  var missing = batch.length\n  var error = null\n\n  if (!missing) return this._append(batch, cb)\n  for (var i = 0; i < batch.length; i++) {\n    this._onwrite(i + this.length, batch[i], null, done)\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) return cb(error)\n    self._append(batch, cb)\n  }\n}\n\nFeed.prototype._append = function (batch, cb) {\n  if (!this.opened) return this._readyAndAppend(batch, cb)\n  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'))\n\n  var self = this\n  var pending = 1\n  var offset = 0\n  var error = null\n  var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0)\n  var nodeOffset = this.length * 2\n  var dataBatch = new Array(batch.length)\n\n  if (!pending) return cb()\n\n  for (var i = 0; i < batch.length; i++) {\n    var data = this._codec.encode(batch[i])\n    var nodes = this._merkle.next(data)\n\n    // the replication stream rejects frames >8MB for DOS defense. Is configurable there, so\n    // we could bubble that up here. For now just hardcode it so you can't accidentally \"brick\" your core\n    // note: this is *only* for individual blocks and is just a sanity check. most blocks are <1MB\n    if (data.length > 8388608) return cb(new Error('Individual blocks has be less than 8MB'))\n\n    offset += data.length\n    dataBatch[i] = data\n\n    for (var j = 0; j < nodes.length; j++) {\n      var node = nodes[j]\n      if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {\n        nodeBatch[node.index - nodeOffset] = node\n      } else {\n        pending++\n        this._storage.putNode(node.index, node, done)\n      }\n    }\n  }\n\n  if (this.live && batch.length) {\n    pending++\n    this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function (err, sig) {\n      if (err) return done(err)\n      self._storage.putSignature(self.length + batch.length - 1, sig, done)\n    })\n  }\n\n  if (!this._indexing) {\n    pending++\n    if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done)\n    else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done)\n  }\n\n  this._storage.putNodeBatch(nodeOffset, nodeBatch, done)\n\n  function done (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n\n    var start = self.length\n\n    // TODO: only emit append and update length / byteLength after the info has been flushed to storage\n    self.byteLength += offset\n    for (var i = 0; i < batch.length; i++) {\n      self.bitfield.set(self.length, true)\n      self.tree.set(2 * self.length++)\n    }\n    self.emit('append')\n\n    var message = self.length - start > 1 ? { start: start, length: self.length - start } : { start: start }\n    if (self.peers.length) self._announce(message)\n\n    self._sync(null, cb)\n  }\n}\n\nFeed.prototype._readyAndAppend = function (batch, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._append(batch, cb)\n  })\n}\n\nFeed.prototype._readyAndCancel = function (start, end) {\n  var self = this\n  this.ready(function () {\n    self._cancel(start, end)\n  })\n}\n\nFeed.prototype._pollWaiting = function () {\n  var len = this._waiting.length\n\n  for (var i = 0; i < len; i++) {\n    var next = this._waiting[i]\n    if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {\n      continue\n    }\n\n    remove(this._waiting, i--)\n    len--\n\n    if (next.bytes) this.seek(next.bytes, next, next.callback)\n    else if (next.update) this.update(next.index + 1, next.callback)\n    else this.get(next.index, next.options, next.callback)\n  }\n}\n\nFeed.prototype._syncBitfield = function (cb) {\n  var missing = this.bitfield.pages.updates.length\n  var next = null\n  var error = null\n\n  // All data / nodes have been written now. We still need to update the bitfields though\n\n  // TODO 1: if the program fails during this write the bitfield might not have been fully written\n  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists\n  // on disk. So if a get fails, it should try and recover once.\n\n  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf\n  // Added benefit is that if the program exits while flushing the bitfield the feed will only get\n  // truncated and not have missing chunks which is what you expect.\n\n  if (!missing) {\n    this._pollWaiting()\n    return cb(null)\n  }\n\n  while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n    this._storage.putBitfield(next.offset, next.buffer, ondone)\n  }\n\n  this._pollWaiting()\n\n  function ondone (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nFeed.prototype._roots = function (index, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var result = new Array(roots.length)\n  var pending = roots.length\n  var error = null\n\n  if (!pending) return cb(null, result)\n\n  for (var i = 0; i < roots.length; i++) {\n    this._storage.getNode(roots[i], onnode)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) result[roots.indexOf(node.index)] = node\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, result)\n  }\n}\n\nFeed.prototype.audit = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var report = {\n    valid: 0,\n    invalid: 0\n  }\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var block = 0\n    var max = self.length\n\n    next()\n\n    function onnode (err, node) {\n      if (err) return ondata(null, null)\n      self._storage.getData(block, ondata)\n\n      function ondata (_, data) {\n        var verified = data && crypto.data(data).equals(node.hash)\n        if (verified) report.valid++\n        else report.invalid++\n        self.bitfield.set(block, verified)\n        block++\n        next()\n      }\n    }\n\n    function next () {\n      while (block < max && !self.bitfield.get(block)) block++\n      if (block >= max) return done()\n      self._storage.getNode(2 * block, onnode)\n    }\n\n    function done () {\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        cb(null, report)\n      })\n    }\n  })\n}\n\nFeed.prototype.extension = function (name, message) {\n  var peers = this.peers\n\n  for (var i = 0; i < peers.length; i++) {\n    peers[i].extension(name, message)\n  }\n}\n\nfunction noop () {}\n\nfunction verifyNode (trusted, node) {\n  return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0\n}\n\nfunction addSize (size, node) {\n  return size + node.size\n}\n\nfunction isBlock (index) {\n  return (index & 1) === 0\n}\n\nfunction toCodec (enc) {\n  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \\o/\n  return codecs(enc === 'json' ? 'ndjson' : enc)\n}\n\nfunction wrapCodec (enc, cb) {\n  return function (err, buf) {\n    if (err) return cb(err)\n    try {\n      buf = enc.decode(buf)\n    } catch (err) {\n      return cb(err)\n    }\n    cb(null, buf)\n  }\n}\n\nfunction timeoutCallback (cb, timeout) {\n  var failed = false\n  var id = setTimeout(ontimeout, timeout)\n  return done\n\n  function ontimeout () {\n    failed = true\n    // TODO: make libs/errors for all this stuff\n    var err = new Error('ETIMEDOUT')\n    err.code = 'ETIMEDOUT'\n    cb(err)\n  }\n\n  function done (err, val) {\n    if (failed) return\n    clearTimeout(id)\n    cb(err, val)\n  }\n}\n\nfunction toWantRange (i) {\n  return Math.floor(i / 1024 / 1024) * 1024 * 1024\n}\n\nfunction createError (code, errno, msg) {\n  var err = new Error(msg)\n  err.code = code\n  err.errno = errno\n  return err\n}\n\nfunction defaultStorageDir (directory) {\n  return function (name) {\n    return defaultStorage(name, { directory })\n  }\n}\n\nfunction isOptions (initiator) {\n  return !Protocol.isProtocolStream(initiator) &&\n    typeof initiator === 'object' &&\n    !!initiator &&\n    typeof initiator.initiator === 'boolean'\n}\n\nfunction readyNT (ifAvailable, fn) {\n  ifAvailable.ready(fn)\n}\n\nfunction verifyCompat (self, checksum, signature, cb) {\n  self.crypto.verify(checksum, signature, self.key, function (err, valid) {\n    if (err || valid) return cb(err, valid)\n    // compat mode, will be removed in a later version\n    self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb)\n  })\n}\n","start":1670465468180,"end":1670465468234},{"name":"vite:react-babel","result":"var low = require('last-one-wins')\nvar remove = require('unordered-array-remove')\nvar set = require('unordered-set')\nvar MerkleGenerator = require('merkle-tree-stream/generator')\nvar flat = require('flat-tree')\nvar codecs = require('codecs')\nvar batcher = require('atomic-batcher')\nvar inherits = require('inherits')\nvar bitfield = require('./lib/bitfield')\nvar sparseBitfield = require('sparse-bitfield')\nvar treeIndex = require('./lib/tree-index')\nvar storage = require('./lib/storage')\nvar crypto = require('hypercore-crypto')\nvar inspect = require('inspect-custom-symbol')\nvar pretty = require('pretty-hash')\nvar Nanoguard = require('nanoguard')\nvar safeBufferEquals = require('./lib/safe-buffer-equals')\nvar replicate = require('./lib/replicate')\nvar Protocol = require('hypercore-protocol')\nvar Message = require('abstract-extension')\nvar Nanoresource = require('nanoresource/emitter')\nvar defaultStorage = require('hypercore-default-storage')\nvar { WriteStream, ReadStream } = require('hypercore-streams')\n\nclass Extension extends Message {\n  broadcast (message) {\n    const feed = this.local.handlers\n    const buf = this.encoding.encode(message)\n    let broadcasted = false\n    for (const peer of feed.peers) {\n      broadcasted = true\n      peer.extension(this.id, buf)\n    }\n    return broadcasted\n  }\n\n  send (message, peer) {\n    peer.extension(this.id, this.encode(message))\n  }\n}\n\nvar defaultCrypto = {\n  sign (data, sk, cb) {\n    return cb(null, crypto.sign(data, sk))\n  },\n  verify (sig, data, pk, cb) {\n    return cb(null, crypto.verify(sig, data, pk))\n  }\n}\n\nmodule.exports = Feed\n\nfunction Feed (createStorage, key, opts) {\n  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts)\n  Nanoresource.call(this)\n\n  if (typeof createStorage === 'string') createStorage = defaultStorageDir(createStorage)\n  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string')\n\n  if (typeof key === 'string') key = Buffer.from(key, 'hex')\n\n  if (!Buffer.isBuffer(key) && !opts) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  var self = this\n\n  var secretKey = opts.secretKey || null\n  if (typeof secretKey === 'string') secretKey = Buffer.from(secretKey, 'hex')\n\n  this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair()\n  this.live = opts.live !== false\n  this.sparse = !!opts.sparse\n  this.length = 0\n  this.byteLength = 0\n  this.maxRequests = opts.maxRequests || 16\n  this.key = key || opts.key || null\n  this.discoveryKey = this.key && crypto.discoveryKey(this.key)\n  this.secretKey = secretKey\n  this.bitfield = null\n  this.tree = null\n  this.writable = !!opts.writable\n  this.readable = true\n  this.downloading = opts.downloading !== false\n  this.uploading = opts.uploading !== false\n  this.allowPush = !!opts.allowPush\n  this.peers = []\n  this.ifAvailable = new Nanoguard()\n  this.extensions = Extension.createLocal(this) // set Feed as the handlers\n\n  this.crypto = opts.crypto || defaultCrypto\n\n  // hooks\n  this._onwrite = opts.onwrite || null\n\n  this._force = !!opts.force\n  this._expectedLength = -1\n  this._indexing = !!opts.indexing\n  this._createIfMissing = opts.createIfMissing !== false\n  this._overwrite = !!opts.overwrite\n  this._storeSecretKey = opts.storeSecretKey !== false\n  this._alwaysIfAvailable = !!opts.ifAvailable\n  this._merkle = null\n  this._storage = storage(createStorage, opts)\n  this._batch = batcher(this._onwrite ? workHook : work)\n\n  this.timeouts = opts.timeouts || {\n    get (cb) {\n      cb(null)\n    },\n    update (cb) {\n      cb(null)\n    }\n  }\n\n  this._seq = 0\n  this._waiting = []\n  this._selections = []\n  this._reserved = sparseBitfield()\n  this._synced = null\n  this._downloadingSet = typeof opts.downloading === 'boolean'\n\n  this._stats = (typeof opts.stats !== 'undefined' && !opts.stats) ? null : {\n    downloadedBlocks: 0,\n    downloadedBytes: 0,\n    uploadedBlocks: 0,\n    uploadedBytes: 0\n  }\n\n  this._codec = toCodec(opts.valueEncoding)\n  this._sync = low(sync)\n  if (!this.sparse) this.download({ start: 0, end: -1 })\n\n  if (this.sparse && opts.eagerUpdate) {\n    this.update(function loop (err) {\n      if (err) self.emit('update-error', err)\n      self.update(loop)\n    })\n  }\n\n  // open it right away\n  this.open(onerror)\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function workHook (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb)\n    self._appendHook(values, cb)\n  }\n\n  function work (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb)\n    self._append(values, cb)\n  }\n\n  function sync (_, cb) {\n    self._syncBitfield(cb)\n  }\n}\n\ninherits(Feed, Nanoresource)\n\nFeed.discoveryKey = crypto.discoveryKey\n\nFeed.prototype[inspect] = function (depth, opts) {\n  var indent = ''\n  if (typeof opts.indentationLvl === 'number') {\n    while (indent.length < opts.indentationLvl) indent += ' '\n  }\n  return 'Hypercore(\\n' +\n    indent + '  key: ' + opts.stylize((this.key && pretty(this.key)), 'string') + '\\n' +\n    indent + '  discoveryKey: ' + opts.stylize((this.discoveryKey && pretty(this.discoveryKey)), 'string') + '\\n' +\n    indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n    indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\\n' +\n    indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n    indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n    indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\\n' +\n    indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\\n' +\n    indent + ')'\n}\n\n// TODO: instead of using a getter, update on remote-update/add/remove\nObject.defineProperty(Feed.prototype, 'remoteLength', {\n  enumerable: true,\n  get: function () {\n    var len = 0\n    for (var i = 0; i < this.peers.length; i++) {\n      var remoteLength = this.peers[i].remoteLength\n      if (remoteLength > len) len = remoteLength\n    }\n    return len\n  }\n})\n\nObject.defineProperty(Feed.prototype, 'stats', {\n  enumerable: true,\n  get: function () {\n    if (!this._stats) return null\n    var peerStats = []\n    for (var i = 0; i < this.peers.length; i++) {\n      var peer = this.peers[i]\n      peerStats[i] = peer.stats\n    }\n    return {\n      peers: peerStats,\n      totals: this._stats\n    }\n  }\n})\n\nFeed.prototype.replicate = function (initiator, opts) {\n  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection\n    this.download({ start: 0, end: -1 })\n  }\n\n  if (isOptions(initiator) && !opts) {\n    opts = initiator\n    initiator = opts.initiator\n  }\n\n  opts = opts || {}\n  opts.stats = !!this._stats\n  opts.noise = !(opts.noise === false && opts.encrypted === false)\n\n  return replicate(this, initiator, opts)\n}\n\nFeed.prototype.registerExtension = function (name, handlers) {\n  return this.extensions.add(name, handlers)\n}\n\nFeed.prototype.onextensionupdate = function () {\n  for (const peer of this.peers) peer._updateOptions()\n}\n\nFeed.prototype.setDownloading = function (downloading) {\n  if (this.downloading === downloading && this._downloadingSet) return\n  this.downloading = downloading\n  this._downloadingSet = true\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setDownloading(this.downloading)\n  })\n}\n\nFeed.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setUploading(this.uploading)\n  })\n}\n\n// Alias the nanoresource open method\nFeed.prototype.ready = Feed.prototype.open\n\nFeed.prototype.update = function (opts, cb) {\n  if (typeof opts === 'function') return this.update(-1, opts)\n  if (typeof opts === 'number') opts = { minLength: opts }\n  if (!opts) opts = {}\n  if (!cb) cb = noop\n\n  var self = this\n  var len = typeof opts.minLength === 'number' ? opts.minLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (len === -1) len = self.length + 1\n    if (self.length >= len) return cb(null)\n\n    const ifAvailable = typeof opts.ifAvailable === 'boolean'\n      ? opts.ifAvailable\n      : self._alwaysIfAvailable\n\n    if (ifAvailable && self.writable && !opts.force) return cb(new Error('No update available from peers'))\n    if (self.writable) cb = self._writeStateReloader(cb)\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: 0,\n      index: len - 1,\n      options: opts,\n      update: true,\n      callback: cb\n    }\n\n    self._waiting.push(w)\n    if (ifAvailable) self._ifAvailable(w, len)\n    self._updatePeers()\n  })\n}\n\n// Used to hint to the update guard if it can bail early\nFeed.prototype.setExpectedLength = function (len) {\n  this._expectedLength = len\n  this.ready((err) => {\n    if (err) return\n\n    this.ifAvailable.ready(() => {\n      this._expectedLength = -1\n    })\n\n    if (this._expectedLength === -1 || this._expectedLength > this.length) return\n\n    for (const w of this._waiting) {\n      if (w.update && w.ifAvailable) w.callback(new Error('Expected length is less than current length'))\n    }\n  })\n}\n\n// Beware! This might break your core if you share forks with other people through replication\nFeed.prototype.truncate = function (newLength, cb) {\n  if (!cb) cb = noop\n  const self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    self._roots(newLength, function (err, roots) {\n      if (err) return cb(err)\n\n      const oldLength = self.length\n      if (oldLength <= newLength) return cb(null)\n\n      let byteLength = 0\n      for (const { size } of roots) byteLength += size\n\n      for (let i = oldLength; i < newLength; i++) self.data.set(i, false)\n      self.byteLength = byteLength\n      self.length = newLength\n      self.tree.truncate(2 * newLength)\n      self._merkle = new MerkleGenerator(crypto, roots)\n\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        self._storage.deleteSignatures(newLength, oldLength, cb)\n      })\n    })\n  })\n}\n\nFeed.prototype._ifAvailable = function (w, minLength) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n  w.ifAvailable = true\n\n  if (this._expectedLength > -1 && this._expectedLength <= this.length) {\n    return process.nextTick(w.callback, new Error('Expected length is less than current length'))\n  }\n\n  this.timeouts.update(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n      if (self.length >= minLength || self.remoteLength >= minLength) return\n      done(new Error('No update available from peers'))\n    })\n  })\n\n  function done (err) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err)\n  }\n}\n\nFeed.prototype._ifAvailableGet = function (w) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      for (var i = 0; i < self.peers.length; i++) {\n        var peer = self.peers[i]\n        if (peer.remoteBitfield.get(w.index)) return\n      }\n      done(new Error('Block not available from peers'))\n    })\n  })\n\n  function done (err, data) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err, data)\n  }\n}\n\n// will reload the writable state. used by .update on a writable peer\nFeed.prototype._writeStateReloader = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._reloadMerkleState(cb)\n  }\n}\n\nFeed.prototype._reloadMerkleState = function (cb) {\n  var self = this\n\n  this._roots(self.length, function (err, roots) {\n    if (err) return cb(err)\n    self._merkle = new MerkleGenerator(crypto, roots)\n    cb(null)\n  })\n}\n\nFeed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {\n  this._reloadMerkleState(function (err) {\n    if (err) return cb(err)\n    work(values, cb)\n  })\n}\n\nFeed.prototype._open = function (cb) {\n  var self = this\n  var generatedKey = false\n  var retryOpen = true\n\n  // TODO: clean up the duplicate code below ...\n\n  this._storage.openKey(function (_, key) {\n    if (key && !self._overwrite && !self.key) self.key = key\n\n    if (!self.key && self.live) {\n      var keyPair = crypto.keyPair()\n      self.secretKey = keyPair.secretKey\n      self.key = keyPair.publicKey\n      generatedKey = true\n    }\n\n    self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n    self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen)\n  })\n\n  function onopen (err, state) {\n    if (err) return cb(err)\n\n    // if no key but we have data do a bitfield reset since we cannot verify the data.\n    if (!state.key && state.bitfield.length) {\n      self._overwrite = true\n    }\n\n    if (self._force && state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      self._overwrite = true\n    }\n\n    if (self._overwrite) {\n      state.bitfield = []\n      state.key = state.secretKey = null\n    }\n\n    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield)\n    self.tree = treeIndex(self.bitfield.tree)\n    self.length = self.tree.blocks()\n    self._seq = self.length\n\n    if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      return self._forceClose(cb, new Error('Another hypercore is stored here'))\n    }\n\n    if (state.key) self.key = state.key\n    if (state.secretKey) self.secretKey = state.secretKey\n\n    if (!self.length) return onsignature(null, null)\n    self._storage.getSignature(self.length - 1, onsignature)\n\n    function onsignature (_, sig) {\n      if (self.length) self.live = !!sig\n\n      if ((generatedKey || !self.key) && !self._createIfMissing) {\n        return self._forceClose(cb, new Error('No hypercore is stored here'))\n      }\n\n      if (!self.key && self.live) {\n        var keyPair = crypto.keyPair()\n        self.secretKey = keyPair.secretKey\n        self.key = keyPair.publicKey\n      }\n\n      var writable = !!self.secretKey || self.key === null\n\n      if (!writable && self.writable) return self._forceClose(cb, new Error('Feed is not writable'))\n      self.writable = writable\n      if (!self._downloadingSet) self.downloading = !writable\n      self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n\n      if (self._storeSecretKey && !self.secretKey) {\n        self._storeSecretKey = false\n      }\n\n      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key)\n      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey))\n\n      var missing = 1 +\n        (shouldWriteKey ? 1 : 0) +\n        (shouldWriteSecretKey ? 1 : 0) +\n        (self._overwrite ? 1 : 0)\n      var error = null\n\n      if (shouldWriteKey) self._storage.key.write(0, self.key, done)\n      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done)\n\n      if (self._overwrite) {\n        self._storage.bitfield.del(32, Infinity, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return self._forceClose(cb, error)\n        self._roots(self.length, onroots)\n      }\n\n      function onroots (err, roots) {\n        if (err && retryOpen) {\n          retryOpen = false\n          self.length--\n          self._storage.getSignature(self.length - 1, onsignature)\n          return\n        }\n\n        if (err) return self._forceClose(cb, err)\n\n        self._merkle = new MerkleGenerator(crypto, roots)\n        self.byteLength = roots.reduce(addSize, 0)\n        self.emit('ready')\n\n        cb(null)\n      }\n    }\n  }\n}\n\nFeed.prototype.download = function (range, cb) {\n  if (typeof range === 'function') return this.download(null, range)\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (Array.isArray(range)) range = { blocks: range }\n  if (!range) range = {}\n  if (!cb) cb = noop\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so\n  // this._updatePeers does this for us when there is a peer though, so not critical\n\n  // We need range.start, end for the want messages so make sure to infer these\n  // when blocks are passed and start,end is not set\n  if (range.blocks && typeof range.start !== 'number') {\n    var min = -1\n    var max = 0\n\n    for (var i = 0; i < range.blocks.length; i++) {\n      const blk = range.blocks[i]\n      if (min === -1 || blk < min) min = blk\n      if (blk >= max) max = blk + 1\n    }\n\n    range.start = min === -1 ? 0 : min\n    range.end = max\n  }\n\n  var sel = {\n    _index: this._selections.length,\n    hash: !!range.hash,\n    iterator: null,\n    start: range.start || 0,\n    end: range.end || -1,\n    want: 0,\n    linear: !!range.linear,\n    blocks: range.blocks || null,\n    blocksDownloaded: 0,\n    requested: 0,\n    callback: cb\n  }\n\n  sel.want = toWantRange(sel.start)\n\n  this._selections.push(sel)\n  this._updatePeers()\n\n  return sel\n}\n\nFeed.prototype.undownload = function (range) {\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (!range) range = {}\n\n  if (range.callback && range._index > -1) {\n    set.remove(this._selections, range)\n    process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n    return\n  }\n\n  var start = range.start || 0\n  var end = range.end || -1\n  var hash = !!range.hash\n  var linear = !!range.linear\n\n  for (var i = 0; i < this._selections.length; i++) {\n    var s = this._selections[i]\n\n    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n      set.remove(this._selections, s)\n      process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n      return\n    }\n  }\n}\n\nFeed.prototype.digest = function (index) {\n  return this.tree.digest(2 * index)\n}\n\nFeed.prototype.proof = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.proof(index, null, opts)\n  if (!this.opened) return this._readyAndProof(index, opts, cb)\n  if (!opts) opts = {}\n\n  var proof = this.tree.proof(2 * index, opts)\n  if (!proof) return cb(new Error('No proof available for this index'))\n\n  var needsSig = this.live && !!proof.verifiedBy\n  var pending = proof.nodes.length + (needsSig ? 1 : 0)\n  var error = null\n  var signature = null\n  var nodes = new Array(proof.nodes.length)\n\n  if (!pending) return cb(null, { nodes: nodes, signature: null })\n\n  for (var i = 0; i < proof.nodes.length; i++) {\n    this._storage.getNode(proof.nodes[i], onnode)\n  }\n  if (needsSig) {\n    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)\n  }\n\n  function onsignature (err, sig) {\n    if (sig) signature = sig\n    onnode(err, null)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n\n    if (node) {\n      nodes[proof.nodes.indexOf(node.index)] = node\n    }\n\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, { nodes: nodes, signature: signature })\n  }\n}\n\nFeed.prototype._readyAndProof = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.proof(index, opts, cb)\n  })\n}\n\nFeed.prototype.put = function (index, data, proof, cb) {\n  if (!this.opened) return this._readyAndPut(index, data, proof, cb)\n  this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb)\n}\n\nFeed.prototype.cancel = function (start, end) { // TODO: use same argument scheme as download\n  if (typeof start !== 'symbol') {\n    if (!end) end = start + 1\n\n    // cancel these right away as .download does not wait for ready\n    for (var i = this._selections.length - 1; i >= 0; i--) {\n      var sel = this._selections[i]\n      if (start <= sel.start && sel.end <= end) {\n        this.undownload(sel)\n      }\n    }\n  }\n\n  // defer the last part until after ready as .get does that as well\n  if (this.opened) this._cancel(start, end)\n  else this._readyAndCancel(start, end)\n}\n\nFeed.prototype._cancel = function (start, end) {\n  var i = 0\n\n  if (typeof start === 'symbol') {\n    for (i = this._waiting.length - 1; i >= 0; i--) {\n      const w = this._waiting[i]\n      if (w.options.cancel === start) {\n        remove(this._waiting, i)\n        this._reserved.set(w.index, false)\n        if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n        this._updatePeers()\n        return\n      }\n    }\n    return\n  }\n\n  for (i = start; i < end; i++) {\n    this._reserved.set(i, false) // TODO: send cancel message if set returns true\n  }\n\n  for (i = this._waiting.length - 1; i >= 0; i--) {\n    var w = this._waiting[i]\n    if ((start <= w.start && w.end <= end) || (start <= w.index && w.index < end)) {\n      remove(this._waiting, i)\n      if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n    }\n  }\n}\n\nFeed.prototype.clear = function (start, end, opts, cb) { // TODO: use same argument scheme as download\n  if (typeof end === 'function') return this.clear(start, start + 1, null, end)\n  if (typeof opts === 'function') return this.clear(start, end, null, opts)\n  if (!opts) opts = {}\n  if (!end) end = start + 1\n  if (!cb) cb = noop\n\n  // TODO: this needs some work. fx we can only calc byte offset for blocks we know about\n  // so internally we should make sure to only do that. We should use the merkle tree for this\n\n  var self = this\n  var byteOffset = start === 0 ? 0 : (typeof opts.byteOffset === 'number' ? opts.byteOffset : -1)\n  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var modified = false\n\n    // TODO: use a buffer.fill thing here to speed this up!\n\n    for (var i = start; i < end; i++) {\n      if (self.bitfield.set(i, false)) modified = true\n    }\n\n    if (!modified) return process.nextTick(cb)\n\n    // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing\n\n    self._unannounce({ start: start, length: end - start })\n    if (opts.delete === false || self._indexing) return sync()\n    if (byteOffset > -1) return onstartbytes(null, byteOffset)\n    self._storage.dataOffset(start, [], onstartbytes)\n\n    function sync () {\n      self.emit('clear', start, end)\n      self._sync(null, cb)\n    }\n\n    function onstartbytes (err, offset) {\n      if (err) return cb(err)\n      byteOffset = offset\n      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset)\n      if (end === self.length) return onendbytes(null, self.byteLength)\n      self._storage.dataOffset(end, [], onendbytes)\n    }\n\n    function onendbytes (err, end) {\n      if (err) return cb(err)\n      if (!self._storage.data.del) return sync() // Not all data storage impls del\n      self._storage.data.del(byteOffset, end - byteOffset, sync)\n    }\n  })\n}\n\nFeed.prototype.signature = function (index, cb) {\n  if (typeof index === 'function') return this.signature(this.length - 1, index)\n\n  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'))\n\n  this._storage.nextSignature(index, cb)\n}\n\nFeed.prototype.verify = function (index, signature, cb) {\n  var self = this\n\n  this.rootHashes(index, function (err, roots) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, index + 1)\n\n    verifyCompat(self, checksum, signature, function (err, valid) {\n      if (err) return cb(err)\n\n      if (!valid) return cb(new Error('Signature verification failed'))\n\n      return cb(null, true)\n    })\n  })\n}\n\nFeed.prototype.rootHashes = function (index, cb) {\n  this._getRootsToVerify(index * 2 + 2, {}, [], cb)\n}\n\nFeed.prototype.seek = function (bytes, opts, cb) {\n  if (typeof opts === 'function') return this.seek(bytes, null, opts)\n  if (!opts) opts = {}\n  if (!this.opened) return this._readyAndSeek(bytes, opts, cb)\n\n  var self = this\n\n  if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0)\n\n  this._seek(bytes, function (err, index, offset) {\n    if (!err && isBlock(index)) return done(index / 2, offset)\n    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'))\n\n    var start = opts.start || 0\n    var end = opts.end || -1\n\n    if (!err) {\n      var left = flat.leftSpan(index) / 2\n      var right = flat.rightSpan(index) / 2 + 1\n\n      if (left > start) start = left\n      if (right < end || end === -1) end = right\n    }\n\n    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'))\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: bytes,\n      index: -1,\n      ifAvailable: opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable,\n      start: start,\n      end: end,\n      want: toWantRange(start),\n      requested: 0,\n      callback: cb || noop\n    }\n\n    self._waiting.push(w)\n    self._updatePeers()\n    if (w.ifAvailable) self._ifAvailableSeek(w)\n  })\n\n  function done (index, offset) {\n    for (var i = 0; i < self.peers.length; i++) {\n      self.peers[i].haveBytes(bytes)\n    }\n    cb(null, index, offset)\n  }\n}\n\nFeed.prototype._ifAvailableSeek = function (w) {\n  var self = this\n  var cb = w.callback\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      let available = false\n      for (const peer of self.peers) {\n        const ite = peer._iterator\n        let i = ite.seek(w.start).next(true)\n        while (self.tree.get(i * 2) && i > -1) i = ite.next(true)\n        if (i > -1 && (w.end === -1 || i < w.end)) {\n          available = true\n          break\n        }\n      }\n\n      if (!available) done(new Error('Seek not available from peers'))\n    })\n  })\n\n  function done (err) {\n    var i = self._waiting.indexOf(w)\n    if (i > -1) {\n      remove(self._waiting, i)\n      w.callback = noop\n      cb(err)\n    }\n  }\n}\n\nFeed.prototype._seek = function (offset, cb) {\n  if (offset === 0) return cb(null, 0, 0)\n\n  var self = this\n  var roots = flat.fullRoots(this.length * 2)\n  var nearestRoot = 0\n\n  loop(null, null)\n\n  function onroot (top) {\n    if (isBlock(top)) return cb(null, nearestRoot, offset)\n\n    var left = flat.leftChild(top)\n    while (!self.tree.get(left)) {\n      if (isBlock(left)) return cb(null, nearestRoot, offset)\n      left = flat.leftChild(left)\n    }\n\n    self._storage.getNode(left, onleftchild)\n  }\n\n  function onleftchild (err, node) {\n    if (err) return cb(err)\n\n    if (node.size > offset) {\n      nearestRoot = node.index\n      onroot(node.index)\n    } else {\n      offset -= node.size\n      if (flat.parent(node.index) === nearestRoot) {\n        nearestRoot = flat.sibling(node.index)\n        onroot(nearestRoot)\n      } else {\n        onroot(flat.sibling(node.index))\n      }\n    }\n  }\n\n  function loop (err, node) {\n    if (err) return cb(err)\n\n    if (node) {\n      if (node.size > offset) {\n        nearestRoot = node.index\n        return onroot(node.index)\n      }\n      offset -= node.size\n    }\n\n    if (!roots.length) return cb(new Error('Out of bounds'))\n    self._storage.getNode(roots.shift(), loop)\n  }\n}\n\nFeed.prototype._readyAndSeek = function (bytes, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.seek(bytes, opts, cb)\n  })\n}\n\nFeed.prototype._getBuffer = function (index, cb) {\n  this._storage.getData(index, cb)\n}\n\nFeed.prototype._putBuffer = function (index, data, proof, from, cb) {\n  // TODO: this nodes in proof are not instances of our Node prototype\n  // but just similar. Check if this has any v8 perf implications.\n\n  // TODO: if the proof contains a valid signature BUT fails, emit a critical error\n  // --> feed should be considered dead\n\n  var self = this\n  var trusted = -1\n  var missing = []\n  var next = 2 * index\n  var i = data ? 0 : 1\n\n  while (true) {\n    if (this.tree.get(next)) {\n      trusted = next\n      break\n    }\n\n    var sib = flat.sibling(next)\n    next = flat.parent(next)\n\n    if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n      i++\n      continue\n    }\n\n    if (!this.tree.get(sib)) break\n    missing.push(sib)\n  }\n\n  if (trusted === -1 && this.tree.get(next)) trusted = next\n\n  var error = null\n  var trustedNode = null\n  var missingNodes = new Array(missing.length)\n  var pending = missing.length + (trusted > -1 ? 1 : 0)\n\n  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing)\n  if (trusted > -1) this._storage.getNode(trusted, ontrusted)\n  if (!missing.length && trusted === -1) onmissingloaded(null)\n\n  function ontrusted (err, node) {\n    if (err) error = err\n    if (node) trustedNode = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissing (err, node) {\n    if (err) error = err\n    if (node) missingNodes[missing.indexOf(node.index)] = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissingloaded (err) {\n    if (err) return cb(err)\n    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb)\n  }\n}\n\nFeed.prototype._readyAndPut = function (index, data, proof, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.put(index, data, proof, cb)\n  })\n}\n\nFeed.prototype._write = function (index, data, nodes, sig, from, cb) {\n  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb)\n  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb))\n}\n\nfunction writeHookDone (self, index, data, nodes, sig, from, cb) {\n  return function (err) {\n    if (err) return cb(err)\n    self._writeAfterHook(index, data, nodes, sig, from, cb)\n  }\n}\n\nFeed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {\n  var self = this\n  var pending = nodes.length + 1 + (sig ? 1 : 0)\n  var error = null\n\n  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone)\n  if (data) this._storage.putData(index, data, nodes, ondone)\n  else ondone()\n  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone)\n\n  function ondone (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n    self._writeDone(index, data, nodes, from, cb)\n  }\n}\n\nFeed.prototype._writeDone = function (index, data, nodes, from, cb) {\n  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)\n  this.tree.set(2 * index)\n\n  if (data) {\n    if (this.bitfield.set(index, true)) {\n      if (this._stats) {\n        this._stats.downloadedBlocks += 1\n        this._stats.downloadedBytes += data.length\n      }\n      this.emit('download', index, data, from)\n    }\n    if (this.peers.length) this._announce({ start: index }, from)\n\n    if (!this.writable) {\n      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length)\n      if (this._synced.next() === -1) {\n        this._synced.range(0, this.length)\n        this._synced.seek(0)\n        if (this._synced.next() === -1) {\n          this.emit('sync')\n        }\n      }\n    }\n  }\n\n  this._sync(null, cb)\n}\n\nFeed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {\n  var visited = []\n  var remoteNodes = proof.nodes\n  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift()\n\n  // check if we already have the hash for this node\n  if (verifyNode(trustedNode, top)) {\n    this._write(index, data, visited, null, from, cb)\n    return\n  }\n\n  // keep hashing with siblings until we reach or trusted node\n  while (true) {\n    var node = null\n    var next = flat.sibling(top.index)\n\n    if (remoteNodes.length && remoteNodes[0].index === next) {\n      node = remoteNodes.shift()\n      visited.push(node)\n    } else if (localNodes.length && localNodes[0].index === next) {\n      node = localNodes.shift()\n    } else {\n      // we cannot create another parent, i.e. these nodes must be roots in the tree\n      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb)\n      return\n    }\n\n    visited.push(top)\n    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size)\n\n    // the tree checks out, write the data and the visited nodes\n    if (verifyNode(trustedNode, top)) {\n      this._write(index, data, visited, null, from, cb)\n      return\n    }\n  }\n}\n\nFeed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {\n  var remoteNodes = proof.nodes\n  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index\n  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2\n  var length = verifiedBy / 2\n  var self = this\n\n  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, length)\n    var signature = null\n\n    if (self.length && self.live && !proof.signature) {\n      return cb(new Error('Remote did not include a signature'))\n    }\n\n    if (proof.signature) { // check signatures\n      verifyCompat(self, checksum, proof.signature, function (err, valid) {\n        if (err) return cb(err)\n        if (!valid) return cb(new Error('Remote signature could not be verified'))\n\n        signature = { index: verifiedBy / 2 - 1, signature: proof.signature }\n        write()\n      })\n    } else { // check tree root\n      if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {\n        return cb(new Error('Remote checksum failed'))\n      }\n\n      write()\n    }\n\n    function write () {\n      self.live = !!signature\n\n      if (length > self.length) {\n        // TODO: only emit this after the info has been flushed to storage\n        if (self.writable) self._merkle = null // We need to reload merkle state now\n        self.length = length\n        self._seq = length\n        self.byteLength = roots.reduce(addSize, 0)\n        if (self._synced) self._synced.seek(0, self.length)\n        self.emit('append')\n      }\n\n      self._write(index, data, nodes.concat(extraNodes), signature, from, cb)\n    }\n  })\n}\n\nFeed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {\n  var indexes = flat.fullRoots(verifiedBy)\n  var roots = new Array(indexes.length)\n  var nodes = []\n  var error = null\n  var pending = roots.length\n\n  for (var i = 0; i < indexes.length; i++) {\n    if (indexes[i] === top.index) {\n      nodes.push(top)\n      onnode(null, top)\n    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n      nodes.push(remoteNodes[0])\n      onnode(null, remoteNodes.shift())\n    } else if (this.tree.get(indexes[i])) {\n      this._storage.getNode(indexes[i], onnode)\n    } else {\n      onnode(new Error('Missing tree roots needed for verify'))\n    }\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) roots[indexes.indexOf(node.index)] = node\n    if (!--pending) done(error)\n  }\n\n  function done (err) {\n    if (err) return cb(err)\n\n    cb(null, roots, nodes)\n  }\n}\n\nFeed.prototype._announce = function (message, from) {\n  for (var i = 0; i < this.peers.length; i++) {\n    var peer = this.peers[i]\n    if (peer !== from) peer.have(message)\n  }\n}\n\nFeed.prototype._unannounce = function (message) {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message)\n}\n\nFeed.prototype.downloaded = function (start, end, cb) {\n  const count = this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, count) // prepare async interface for this\n  return count\n}\n\nFeed.prototype.has = function (start, end, cb) {\n  if (typeof end === 'function') return this.has(start, undefined, end)\n  if (end === undefined) {\n    const res = this.bitfield.get(start)\n    if (cb) process.nextTick(cb, null, res)\n    return res\n  }\n  const total = end - start\n  const res = total === this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, res)\n  return res\n}\n\nFeed.prototype.getBlockInfo = function (index, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._storage.getNode(2 * index, cb)\n  })\n}\n\nFeed.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head({}, opts)\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (opts && opts.update) self.update(opts, onupdate)\n    else process.nextTick(onupdate)\n  })\n\n  function onupdate () {\n    if (self.length === 0) cb(new Error('feed is empty'))\n    else self.get(self.length - 1, opts, cb)\n  }\n}\n\nFeed.prototype.get = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.get(index, null, opts)\n\n  opts = { ...opts }\n  if (!opts.cancel) opts.cancel = Symbol('hypercore-get')\n\n  if (!this.opened) return this._readyAndGet(index, opts, cb)\n\n  if (!this.readable) {\n    process.nextTick(cb, new Error('Feed is closed'))\n    return opts.cancel\n  }\n\n  if (opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  if (!this.bitfield.get(index)) {\n    if (opts && opts.wait === false) return process.nextTick(cb, new Error('Block not downloaded'))\n\n    var w = { bytes: 0, hash: false, index: index, options: opts, requested: 0, callback: cb }\n    this._waiting.push(w)\n\n    if (opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w)\n\n    this._updatePeers()\n    if (opts.onwait) {\n      const onwait = opts.onwait\n      opts.onwait = null\n      onwait(index)\n    }\n    return opts.cancel\n  }\n\n  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb)\n  else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb)\n\n  this._getBuffer(index, cb)\n  return opts.cancel\n}\n\nFeed.prototype._readyAndGet = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.get(index, opts, cb)\n  })\n  return opts.cancel\n}\n\nFeed.prototype.getBatch = function (start, end, opts, cb) {\n  if (typeof opts === 'function') return this.getBatch(start, end, null, opts)\n  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb)\n\n  var self = this\n  var wait = !opts || opts.wait !== false\n\n  if (this.has(start, end)) return this._getBatch(start, end, opts, cb)\n  if (!wait) return process.nextTick(cb, new Error('Block not downloaded'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  this.download({ start: start, end: end }, function (err) {\n    if (err) return cb(err)\n    self._getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._getBatch = function (start, end, opts, cb) {\n  var enc = opts && opts.valueEncoding\n  var codec = enc ? toCodec(enc) : this._codec\n\n  this._storage.getDataBatch(start, end - start, onbatch)\n\n  function onbatch (err, buffers) {\n    if (err) return cb(err)\n\n    var batch = new Array(buffers.length)\n\n    for (var i = 0; i < buffers.length; i++) {\n      try {\n        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i]\n      } catch (err) {\n        return cb(err)\n      }\n    }\n\n    cb(null, batch)\n  }\n}\n\nFeed.prototype._readyAndGetBatch = function (start, end, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._updatePeers = function () {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].update()\n}\n\nFeed.prototype.createWriteStream = function (opts) {\n  return new WriteStream(this, opts)\n}\n\nFeed.prototype.createReadStream = function (opts) {\n  return new ReadStream(this, opts)\n}\n\n// TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)\nFeed.prototype.finalize = function (cb) {\n  if (!this.key) {\n    this.key = crypto.tree(this._merkle.roots)\n    this.discoveryKey = crypto.discoveryKey(this.key)\n  }\n  this._storage.key.write(0, this.key, cb)\n}\n\nFeed.prototype.append = function (batch, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var list = Array.isArray(batch) ? batch : [batch]\n  this._batch(list, onappend)\n\n  function onappend (err) {\n    if (err) return cb(err)\n    var seq = self._seq\n    self._seq += list.length\n    cb(null, seq)\n  }\n}\n\nFeed.prototype.flush = function (cb) {\n  this.append([], cb)\n}\n\nFeed.prototype.destroyStorage = function (cb) {\n  const self = this\n\n  this.close(function (err) {\n    if (err) cb(err)\n    else self._storage.destroy(cb)\n  })\n}\n\nFeed.prototype._close = function (cb) {\n  const self = this\n\n  for (const peer of this.peers) {\n    if (!peer._destroyed) peer._close()\n  }\n\n  this._forceClose(onclose, null)\n\n  function onclose (err) {\n    if (!err) self.emit('close')\n    cb(err)\n  }\n}\n\nFeed.prototype._forceClose = function (cb, error) {\n  var self = this\n\n  this.writable = false\n  this.readable = false\n\n  this._storage.close(function (err) {\n    if (!err) err = error\n    self._destroy(err || new Error('Feed is closed'))\n    cb(err)\n  })\n}\n\nFeed.prototype._destroy = function (err) {\n  this.ifAvailable.destroy()\n\n  while (this._waiting.length) {\n    this._waiting.pop().callback(err)\n  }\n  while (this._selections.length) {\n    this._selections.pop().callback(err)\n  }\n}\n\nFeed.prototype._appendHook = function (batch, cb) {\n  var self = this\n  var missing = batch.length\n  var error = null\n\n  if (!missing) return this._append(batch, cb)\n  for (var i = 0; i < batch.length; i++) {\n    this._onwrite(i + this.length, batch[i], null, done)\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) return cb(error)\n    self._append(batch, cb)\n  }\n}\n\nFeed.prototype._append = function (batch, cb) {\n  if (!this.opened) return this._readyAndAppend(batch, cb)\n  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'))\n\n  var self = this\n  var pending = 1\n  var offset = 0\n  var error = null\n  var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0)\n  var nodeOffset = this.length * 2\n  var dataBatch = new Array(batch.length)\n\n  if (!pending) return cb()\n\n  for (var i = 0; i < batch.length; i++) {\n    var data = this._codec.encode(batch[i])\n    var nodes = this._merkle.next(data)\n\n    // the replication stream rejects frames >8MB for DOS defense. Is configurable there, so\n    // we could bubble that up here. For now just hardcode it so you can't accidentally \"brick\" your core\n    // note: this is *only* for individual blocks and is just a sanity check. most blocks are <1MB\n    if (data.length > 8388608) return cb(new Error('Individual blocks has be less than 8MB'))\n\n    offset += data.length\n    dataBatch[i] = data\n\n    for (var j = 0; j < nodes.length; j++) {\n      var node = nodes[j]\n      if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {\n        nodeBatch[node.index - nodeOffset] = node\n      } else {\n        pending++\n        this._storage.putNode(node.index, node, done)\n      }\n    }\n  }\n\n  if (this.live && batch.length) {\n    pending++\n    this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function (err, sig) {\n      if (err) return done(err)\n      self._storage.putSignature(self.length + batch.length - 1, sig, done)\n    })\n  }\n\n  if (!this._indexing) {\n    pending++\n    if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done)\n    else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done)\n  }\n\n  this._storage.putNodeBatch(nodeOffset, nodeBatch, done)\n\n  function done (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n\n    var start = self.length\n\n    // TODO: only emit append and update length / byteLength after the info has been flushed to storage\n    self.byteLength += offset\n    for (var i = 0; i < batch.length; i++) {\n      self.bitfield.set(self.length, true)\n      self.tree.set(2 * self.length++)\n    }\n    self.emit('append')\n\n    var message = self.length - start > 1 ? { start: start, length: self.length - start } : { start: start }\n    if (self.peers.length) self._announce(message)\n\n    self._sync(null, cb)\n  }\n}\n\nFeed.prototype._readyAndAppend = function (batch, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._append(batch, cb)\n  })\n}\n\nFeed.prototype._readyAndCancel = function (start, end) {\n  var self = this\n  this.ready(function () {\n    self._cancel(start, end)\n  })\n}\n\nFeed.prototype._pollWaiting = function () {\n  var len = this._waiting.length\n\n  for (var i = 0; i < len; i++) {\n    var next = this._waiting[i]\n    if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {\n      continue\n    }\n\n    remove(this._waiting, i--)\n    len--\n\n    if (next.bytes) this.seek(next.bytes, next, next.callback)\n    else if (next.update) this.update(next.index + 1, next.callback)\n    else this.get(next.index, next.options, next.callback)\n  }\n}\n\nFeed.prototype._syncBitfield = function (cb) {\n  var missing = this.bitfield.pages.updates.length\n  var next = null\n  var error = null\n\n  // All data / nodes have been written now. We still need to update the bitfields though\n\n  // TODO 1: if the program fails during this write the bitfield might not have been fully written\n  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists\n  // on disk. So if a get fails, it should try and recover once.\n\n  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf\n  // Added benefit is that if the program exits while flushing the bitfield the feed will only get\n  // truncated and not have missing chunks which is what you expect.\n\n  if (!missing) {\n    this._pollWaiting()\n    return cb(null)\n  }\n\n  while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n    this._storage.putBitfield(next.offset, next.buffer, ondone)\n  }\n\n  this._pollWaiting()\n\n  function ondone (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nFeed.prototype._roots = function (index, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var result = new Array(roots.length)\n  var pending = roots.length\n  var error = null\n\n  if (!pending) return cb(null, result)\n\n  for (var i = 0; i < roots.length; i++) {\n    this._storage.getNode(roots[i], onnode)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) result[roots.indexOf(node.index)] = node\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, result)\n  }\n}\n\nFeed.prototype.audit = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var report = {\n    valid: 0,\n    invalid: 0\n  }\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var block = 0\n    var max = self.length\n\n    next()\n\n    function onnode (err, node) {\n      if (err) return ondata(null, null)\n      self._storage.getData(block, ondata)\n\n      function ondata (_, data) {\n        var verified = data && crypto.data(data).equals(node.hash)\n        if (verified) report.valid++\n        else report.invalid++\n        self.bitfield.set(block, verified)\n        block++\n        next()\n      }\n    }\n\n    function next () {\n      while (block < max && !self.bitfield.get(block)) block++\n      if (block >= max) return done()\n      self._storage.getNode(2 * block, onnode)\n    }\n\n    function done () {\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        cb(null, report)\n      })\n    }\n  })\n}\n\nFeed.prototype.extension = function (name, message) {\n  var peers = this.peers\n\n  for (var i = 0; i < peers.length; i++) {\n    peers[i].extension(name, message)\n  }\n}\n\nfunction noop () {}\n\nfunction verifyNode (trusted, node) {\n  return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0\n}\n\nfunction addSize (size, node) {\n  return size + node.size\n}\n\nfunction isBlock (index) {\n  return (index & 1) === 0\n}\n\nfunction toCodec (enc) {\n  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \\o/\n  return codecs(enc === 'json' ? 'ndjson' : enc)\n}\n\nfunction wrapCodec (enc, cb) {\n  return function (err, buf) {\n    if (err) return cb(err)\n    try {\n      buf = enc.decode(buf)\n    } catch (err) {\n      return cb(err)\n    }\n    cb(null, buf)\n  }\n}\n\nfunction timeoutCallback (cb, timeout) {\n  var failed = false\n  var id = setTimeout(ontimeout, timeout)\n  return done\n\n  function ontimeout () {\n    failed = true\n    // TODO: make libs/errors for all this stuff\n    var err = new Error('ETIMEDOUT')\n    err.code = 'ETIMEDOUT'\n    cb(err)\n  }\n\n  function done (err, val) {\n    if (failed) return\n    clearTimeout(id)\n    cb(err, val)\n  }\n}\n\nfunction toWantRange (i) {\n  return Math.floor(i / 1024 / 1024) * 1024 * 1024\n}\n\nfunction createError (code, errno, msg) {\n  var err = new Error(msg)\n  err.code = code\n  err.errno = errno\n  return err\n}\n\nfunction defaultStorageDir (directory) {\n  return function (name) {\n    return defaultStorage(name, { directory })\n  }\n}\n\nfunction isOptions (initiator) {\n  return !Protocol.isProtocolStream(initiator) &&\n    typeof initiator === 'object' &&\n    !!initiator &&\n    typeof initiator.initiator === 'boolean'\n}\n\nfunction readyNT (ifAvailable, fn) {\n  ifAvailable.ready(fn)\n}\n\nfunction verifyCompat (self, checksum, signature, cb) {\n  self.crypto.verify(checksum, signature, self.key, function (err, valid) {\n    if (err || valid) return cb(err, valid)\n    // compat mode, will be removed in a later version\n    self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb)\n  })\n}\n","start":1670465468234,"end":1670465468234,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js?commonjs-proxy\";\nimport require$$8 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js?commonjs-proxy\";\nimport require$$9 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js?commonjs-proxy\";\nimport require$$10 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js?commonjs-proxy\";\nimport require$$11 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js?commonjs-proxy\";\nimport require$$12 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$13 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js?commonjs-proxy\";\nimport require$$14 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js?commonjs-proxy\";\nimport require$$15 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js?commonjs-proxy\";\nimport require$$16 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js?commonjs-proxy\";\nimport require$$17 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js?commonjs-proxy\";\nimport require$$18 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js?commonjs-proxy\";\nimport require$$19 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js?commonjs-proxy\";\nimport require$$20 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js?commonjs-proxy\";\nimport require$$21 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-default-storage@1.1.1/node_modules/hypercore-default-storage/index.js?commonjs-proxy\";\nimport require$$22 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js?commonjs-proxy\";\n\nvar low = require$$0\nvar remove = require$$1\nvar set = require$$2\nvar MerkleGenerator = require$$3\nvar flat = require$$4\nvar codecs = require$$5\nvar batcher = require$$6\nvar inherits = require$$7\nvar bitfield = require$$8\nvar sparseBitfield = require$$9\nvar treeIndex = require$$10\nvar storage = require$$11\nvar crypto = require$$12\nvar inspect = require$$13\nvar pretty = require$$14\nvar Nanoguard = require$$15\nvar safeBufferEquals = require$$16\nvar replicate = require$$17\nvar Protocol = require$$18\nvar Message = require$$19\nvar Nanoresource = require$$20\nvar defaultStorage = require$$21\nvar { WriteStream, ReadStream } = require$$22\n\nclass Extension extends Message {\n  broadcast (message) {\n    const feed = this.local.handlers\n    const buf = this.encoding.encode(message)\n    let broadcasted = false\n    for (const peer of feed.peers) {\n      broadcasted = true\n      peer.extension(this.id, buf)\n    }\n    return broadcasted\n  }\n\n  send (message, peer) {\n    peer.extension(this.id, this.encode(message))\n  }\n}\n\nvar defaultCrypto = {\n  sign (data, sk, cb) {\n    return cb(null, crypto.sign(data, sk))\n  },\n  verify (sig, data, pk, cb) {\n    return cb(null, crypto.verify(sig, data, pk))\n  }\n}\n\nvar hypercore = Feed\n\nfunction Feed (createStorage, key, opts) {\n  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts)\n  Nanoresource.call(this)\n\n  if (typeof createStorage === 'string') createStorage = defaultStorageDir(createStorage)\n  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string')\n\n  if (typeof key === 'string') key = Buffer.from(key, 'hex')\n\n  if (!Buffer.isBuffer(key) && !opts) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  var self = this\n\n  var secretKey = opts.secretKey || null\n  if (typeof secretKey === 'string') secretKey = Buffer.from(secretKey, 'hex')\n\n  this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair()\n  this.live = opts.live !== false\n  this.sparse = !!opts.sparse\n  this.length = 0\n  this.byteLength = 0\n  this.maxRequests = opts.maxRequests || 16\n  this.key = key || opts.key || null\n  this.discoveryKey = this.key && crypto.discoveryKey(this.key)\n  this.secretKey = secretKey\n  this.bitfield = null\n  this.tree = null\n  this.writable = !!opts.writable\n  this.readable = true\n  this.downloading = opts.downloading !== false\n  this.uploading = opts.uploading !== false\n  this.allowPush = !!opts.allowPush\n  this.peers = []\n  this.ifAvailable = new Nanoguard()\n  this.extensions = Extension.createLocal(this) // set Feed as the handlers\n\n  this.crypto = opts.crypto || defaultCrypto\n\n  // hooks\n  this._onwrite = opts.onwrite || null\n\n  this._force = !!opts.force\n  this._expectedLength = -1\n  this._indexing = !!opts.indexing\n  this._createIfMissing = opts.createIfMissing !== false\n  this._overwrite = !!opts.overwrite\n  this._storeSecretKey = opts.storeSecretKey !== false\n  this._alwaysIfAvailable = !!opts.ifAvailable\n  this._merkle = null\n  this._storage = storage(createStorage, opts)\n  this._batch = batcher(this._onwrite ? workHook : work)\n\n  this.timeouts = opts.timeouts || {\n    get (cb) {\n      cb(null)\n    },\n    update (cb) {\n      cb(null)\n    }\n  }\n\n  this._seq = 0\n  this._waiting = []\n  this._selections = []\n  this._reserved = sparseBitfield()\n  this._synced = null\n  this._downloadingSet = typeof opts.downloading === 'boolean'\n\n  this._stats = (typeof opts.stats !== 'undefined' && !opts.stats) ? null : {\n    downloadedBlocks: 0,\n    downloadedBytes: 0,\n    uploadedBlocks: 0,\n    uploadedBytes: 0\n  }\n\n  this._codec = toCodec(opts.valueEncoding)\n  this._sync = low(sync)\n  if (!this.sparse) this.download({ start: 0, end: -1 })\n\n  if (this.sparse && opts.eagerUpdate) {\n    this.update(function loop (err) {\n      if (err) self.emit('update-error', err)\n      self.update(loop)\n    })\n  }\n\n  // open it right away\n  this.open(onerror)\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function workHook (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb)\n    self._appendHook(values, cb)\n  }\n\n  function work (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb)\n    self._append(values, cb)\n  }\n\n  function sync (_, cb) {\n    self._syncBitfield(cb)\n  }\n}\n\ninherits(Feed, Nanoresource)\n\nFeed.discoveryKey = crypto.discoveryKey\n\nFeed.prototype[inspect] = function (depth, opts) {\n  var indent = ''\n  if (typeof opts.indentationLvl === 'number') {\n    while (indent.length < opts.indentationLvl) indent += ' '\n  }\n  return 'Hypercore(\\n' +\n    indent + '  key: ' + opts.stylize((this.key && pretty(this.key)), 'string') + '\\n' +\n    indent + '  discoveryKey: ' + opts.stylize((this.discoveryKey && pretty(this.discoveryKey)), 'string') + '\\n' +\n    indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n    indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\\n' +\n    indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n    indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n    indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\\n' +\n    indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\\n' +\n    indent + ')'\n}\n\n// TODO: instead of using a getter, update on remote-update/add/remove\nObject.defineProperty(Feed.prototype, 'remoteLength', {\n  enumerable: true,\n  get: function () {\n    var len = 0\n    for (var i = 0; i < this.peers.length; i++) {\n      var remoteLength = this.peers[i].remoteLength\n      if (remoteLength > len) len = remoteLength\n    }\n    return len\n  }\n})\n\nObject.defineProperty(Feed.prototype, 'stats', {\n  enumerable: true,\n  get: function () {\n    if (!this._stats) return null\n    var peerStats = []\n    for (var i = 0; i < this.peers.length; i++) {\n      var peer = this.peers[i]\n      peerStats[i] = peer.stats\n    }\n    return {\n      peers: peerStats,\n      totals: this._stats\n    }\n  }\n})\n\nFeed.prototype.replicate = function (initiator, opts) {\n  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection\n    this.download({ start: 0, end: -1 })\n  }\n\n  if (isOptions(initiator) && !opts) {\n    opts = initiator\n    initiator = opts.initiator\n  }\n\n  opts = opts || {}\n  opts.stats = !!this._stats\n  opts.noise = !(opts.noise === false && opts.encrypted === false)\n\n  return replicate(this, initiator, opts)\n}\n\nFeed.prototype.registerExtension = function (name, handlers) {\n  return this.extensions.add(name, handlers)\n}\n\nFeed.prototype.onextensionupdate = function () {\n  for (const peer of this.peers) peer._updateOptions()\n}\n\nFeed.prototype.setDownloading = function (downloading) {\n  if (this.downloading === downloading && this._downloadingSet) return\n  this.downloading = downloading\n  this._downloadingSet = true\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setDownloading(this.downloading)\n  })\n}\n\nFeed.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setUploading(this.uploading)\n  })\n}\n\n// Alias the nanoresource open method\nFeed.prototype.ready = Feed.prototype.open\n\nFeed.prototype.update = function (opts, cb) {\n  if (typeof opts === 'function') return this.update(-1, opts)\n  if (typeof opts === 'number') opts = { minLength: opts }\n  if (!opts) opts = {}\n  if (!cb) cb = noop\n\n  var self = this\n  var len = typeof opts.minLength === 'number' ? opts.minLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (len === -1) len = self.length + 1\n    if (self.length >= len) return cb(null)\n\n    const ifAvailable = typeof opts.ifAvailable === 'boolean'\n      ? opts.ifAvailable\n      : self._alwaysIfAvailable\n\n    if (ifAvailable && self.writable && !opts.force) return cb(new Error('No update available from peers'))\n    if (self.writable) cb = self._writeStateReloader(cb)\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: 0,\n      index: len - 1,\n      options: opts,\n      update: true,\n      callback: cb\n    }\n\n    self._waiting.push(w)\n    if (ifAvailable) self._ifAvailable(w, len)\n    self._updatePeers()\n  })\n}\n\n// Used to hint to the update guard if it can bail early\nFeed.prototype.setExpectedLength = function (len) {\n  this._expectedLength = len\n  this.ready((err) => {\n    if (err) return\n\n    this.ifAvailable.ready(() => {\n      this._expectedLength = -1\n    })\n\n    if (this._expectedLength === -1 || this._expectedLength > this.length) return\n\n    for (const w of this._waiting) {\n      if (w.update && w.ifAvailable) w.callback(new Error('Expected length is less than current length'))\n    }\n  })\n}\n\n// Beware! This might break your core if you share forks with other people through replication\nFeed.prototype.truncate = function (newLength, cb) {\n  if (!cb) cb = noop\n  const self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    self._roots(newLength, function (err, roots) {\n      if (err) return cb(err)\n\n      const oldLength = self.length\n      if (oldLength <= newLength) return cb(null)\n\n      let byteLength = 0\n      for (const { size } of roots) byteLength += size\n\n      for (let i = oldLength; i < newLength; i++) self.data.set(i, false)\n      self.byteLength = byteLength\n      self.length = newLength\n      self.tree.truncate(2 * newLength)\n      self._merkle = new MerkleGenerator(crypto, roots)\n\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        self._storage.deleteSignatures(newLength, oldLength, cb)\n      })\n    })\n  })\n}\n\nFeed.prototype._ifAvailable = function (w, minLength) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n  w.ifAvailable = true\n\n  if (this._expectedLength > -1 && this._expectedLength <= this.length) {\n    return process.nextTick(w.callback, new Error('Expected length is less than current length'))\n  }\n\n  this.timeouts.update(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n      if (self.length >= minLength || self.remoteLength >= minLength) return\n      done(new Error('No update available from peers'))\n    })\n  })\n\n  function done (err) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err)\n  }\n}\n\nFeed.prototype._ifAvailableGet = function (w) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      for (var i = 0; i < self.peers.length; i++) {\n        var peer = self.peers[i]\n        if (peer.remoteBitfield.get(w.index)) return\n      }\n      done(new Error('Block not available from peers'))\n    })\n  })\n\n  function done (err, data) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err, data)\n  }\n}\n\n// will reload the writable state. used by .update on a writable peer\nFeed.prototype._writeStateReloader = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._reloadMerkleState(cb)\n  }\n}\n\nFeed.prototype._reloadMerkleState = function (cb) {\n  var self = this\n\n  this._roots(self.length, function (err, roots) {\n    if (err) return cb(err)\n    self._merkle = new MerkleGenerator(crypto, roots)\n    cb(null)\n  })\n}\n\nFeed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {\n  this._reloadMerkleState(function (err) {\n    if (err) return cb(err)\n    work(values, cb)\n  })\n}\n\nFeed.prototype._open = function (cb) {\n  var self = this\n  var generatedKey = false\n  var retryOpen = true\n\n  // TODO: clean up the duplicate code below ...\n\n  this._storage.openKey(function (_, key) {\n    if (key && !self._overwrite && !self.key) self.key = key\n\n    if (!self.key && self.live) {\n      var keyPair = crypto.keyPair()\n      self.secretKey = keyPair.secretKey\n      self.key = keyPair.publicKey\n      generatedKey = true\n    }\n\n    self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n    self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen)\n  })\n\n  function onopen (err, state) {\n    if (err) return cb(err)\n\n    // if no key but we have data do a bitfield reset since we cannot verify the data.\n    if (!state.key && state.bitfield.length) {\n      self._overwrite = true\n    }\n\n    if (self._force && state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      self._overwrite = true\n    }\n\n    if (self._overwrite) {\n      state.bitfield = []\n      state.key = state.secretKey = null\n    }\n\n    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield)\n    self.tree = treeIndex(self.bitfield.tree)\n    self.length = self.tree.blocks()\n    self._seq = self.length\n\n    if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      return self._forceClose(cb, new Error('Another hypercore is stored here'))\n    }\n\n    if (state.key) self.key = state.key\n    if (state.secretKey) self.secretKey = state.secretKey\n\n    if (!self.length) return onsignature(null, null)\n    self._storage.getSignature(self.length - 1, onsignature)\n\n    function onsignature (_, sig) {\n      if (self.length) self.live = !!sig\n\n      if ((generatedKey || !self.key) && !self._createIfMissing) {\n        return self._forceClose(cb, new Error('No hypercore is stored here'))\n      }\n\n      if (!self.key && self.live) {\n        var keyPair = crypto.keyPair()\n        self.secretKey = keyPair.secretKey\n        self.key = keyPair.publicKey\n      }\n\n      var writable = !!self.secretKey || self.key === null\n\n      if (!writable && self.writable) return self._forceClose(cb, new Error('Feed is not writable'))\n      self.writable = writable\n      if (!self._downloadingSet) self.downloading = !writable\n      self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n\n      if (self._storeSecretKey && !self.secretKey) {\n        self._storeSecretKey = false\n      }\n\n      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key)\n      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey))\n\n      var missing = 1 +\n        (shouldWriteKey ? 1 : 0) +\n        (shouldWriteSecretKey ? 1 : 0) +\n        (self._overwrite ? 1 : 0)\n      var error = null\n\n      if (shouldWriteKey) self._storage.key.write(0, self.key, done)\n      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done)\n\n      if (self._overwrite) {\n        self._storage.bitfield.del(32, Infinity, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return self._forceClose(cb, error)\n        self._roots(self.length, onroots)\n      }\n\n      function onroots (err, roots) {\n        if (err && retryOpen) {\n          retryOpen = false\n          self.length--\n          self._storage.getSignature(self.length - 1, onsignature)\n          return\n        }\n\n        if (err) return self._forceClose(cb, err)\n\n        self._merkle = new MerkleGenerator(crypto, roots)\n        self.byteLength = roots.reduce(addSize, 0)\n        self.emit('ready')\n\n        cb(null)\n      }\n    }\n  }\n}\n\nFeed.prototype.download = function (range, cb) {\n  if (typeof range === 'function') return this.download(null, range)\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (Array.isArray(range)) range = { blocks: range }\n  if (!range) range = {}\n  if (!cb) cb = noop\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so\n  // this._updatePeers does this for us when there is a peer though, so not critical\n\n  // We need range.start, end for the want messages so make sure to infer these\n  // when blocks are passed and start,end is not set\n  if (range.blocks && typeof range.start !== 'number') {\n    var min = -1\n    var max = 0\n\n    for (var i = 0; i < range.blocks.length; i++) {\n      const blk = range.blocks[i]\n      if (min === -1 || blk < min) min = blk\n      if (blk >= max) max = blk + 1\n    }\n\n    range.start = min === -1 ? 0 : min\n    range.end = max\n  }\n\n  var sel = {\n    _index: this._selections.length,\n    hash: !!range.hash,\n    iterator: null,\n    start: range.start || 0,\n    end: range.end || -1,\n    want: 0,\n    linear: !!range.linear,\n    blocks: range.blocks || null,\n    blocksDownloaded: 0,\n    requested: 0,\n    callback: cb\n  }\n\n  sel.want = toWantRange(sel.start)\n\n  this._selections.push(sel)\n  this._updatePeers()\n\n  return sel\n}\n\nFeed.prototype.undownload = function (range) {\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (!range) range = {}\n\n  if (range.callback && range._index > -1) {\n    set.remove(this._selections, range)\n    process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n    return\n  }\n\n  var start = range.start || 0\n  var end = range.end || -1\n  var hash = !!range.hash\n  var linear = !!range.linear\n\n  for (var i = 0; i < this._selections.length; i++) {\n    var s = this._selections[i]\n\n    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n      set.remove(this._selections, s)\n      process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n      return\n    }\n  }\n}\n\nFeed.prototype.digest = function (index) {\n  return this.tree.digest(2 * index)\n}\n\nFeed.prototype.proof = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.proof(index, null, opts)\n  if (!this.opened) return this._readyAndProof(index, opts, cb)\n  if (!opts) opts = {}\n\n  var proof = this.tree.proof(2 * index, opts)\n  if (!proof) return cb(new Error('No proof available for this index'))\n\n  var needsSig = this.live && !!proof.verifiedBy\n  var pending = proof.nodes.length + (needsSig ? 1 : 0)\n  var error = null\n  var signature = null\n  var nodes = new Array(proof.nodes.length)\n\n  if (!pending) return cb(null, { nodes: nodes, signature: null })\n\n  for (var i = 0; i < proof.nodes.length; i++) {\n    this._storage.getNode(proof.nodes[i], onnode)\n  }\n  if (needsSig) {\n    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)\n  }\n\n  function onsignature (err, sig) {\n    if (sig) signature = sig\n    onnode(err, null)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n\n    if (node) {\n      nodes[proof.nodes.indexOf(node.index)] = node\n    }\n\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, { nodes: nodes, signature: signature })\n  }\n}\n\nFeed.prototype._readyAndProof = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.proof(index, opts, cb)\n  })\n}\n\nFeed.prototype.put = function (index, data, proof, cb) {\n  if (!this.opened) return this._readyAndPut(index, data, proof, cb)\n  this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb)\n}\n\nFeed.prototype.cancel = function (start, end) { // TODO: use same argument scheme as download\n  if (typeof start !== 'symbol') {\n    if (!end) end = start + 1\n\n    // cancel these right away as .download does not wait for ready\n    for (var i = this._selections.length - 1; i >= 0; i--) {\n      var sel = this._selections[i]\n      if (start <= sel.start && sel.end <= end) {\n        this.undownload(sel)\n      }\n    }\n  }\n\n  // defer the last part until after ready as .get does that as well\n  if (this.opened) this._cancel(start, end)\n  else this._readyAndCancel(start, end)\n}\n\nFeed.prototype._cancel = function (start, end) {\n  var i = 0\n\n  if (typeof start === 'symbol') {\n    for (i = this._waiting.length - 1; i >= 0; i--) {\n      const w = this._waiting[i]\n      if (w.options.cancel === start) {\n        remove(this._waiting, i)\n        this._reserved.set(w.index, false)\n        if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n        this._updatePeers()\n        return\n      }\n    }\n    return\n  }\n\n  for (i = start; i < end; i++) {\n    this._reserved.set(i, false) // TODO: send cancel message if set returns true\n  }\n\n  for (i = this._waiting.length - 1; i >= 0; i--) {\n    var w = this._waiting[i]\n    if ((start <= w.start && w.end <= end) || (start <= w.index && w.index < end)) {\n      remove(this._waiting, i)\n      if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n    }\n  }\n}\n\nFeed.prototype.clear = function (start, end, opts, cb) { // TODO: use same argument scheme as download\n  if (typeof end === 'function') return this.clear(start, start + 1, null, end)\n  if (typeof opts === 'function') return this.clear(start, end, null, opts)\n  if (!opts) opts = {}\n  if (!end) end = start + 1\n  if (!cb) cb = noop\n\n  // TODO: this needs some work. fx we can only calc byte offset for blocks we know about\n  // so internally we should make sure to only do that. We should use the merkle tree for this\n\n  var self = this\n  var byteOffset = start === 0 ? 0 : (typeof opts.byteOffset === 'number' ? opts.byteOffset : -1)\n  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var modified = false\n\n    // TODO: use a buffer.fill thing here to speed this up!\n\n    for (var i = start; i < end; i++) {\n      if (self.bitfield.set(i, false)) modified = true\n    }\n\n    if (!modified) return process.nextTick(cb)\n\n    // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing\n\n    self._unannounce({ start: start, length: end - start })\n    if (opts.delete === false || self._indexing) return sync()\n    if (byteOffset > -1) return onstartbytes(null, byteOffset)\n    self._storage.dataOffset(start, [], onstartbytes)\n\n    function sync () {\n      self.emit('clear', start, end)\n      self._sync(null, cb)\n    }\n\n    function onstartbytes (err, offset) {\n      if (err) return cb(err)\n      byteOffset = offset\n      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset)\n      if (end === self.length) return onendbytes(null, self.byteLength)\n      self._storage.dataOffset(end, [], onendbytes)\n    }\n\n    function onendbytes (err, end) {\n      if (err) return cb(err)\n      if (!self._storage.data.del) return sync() // Not all data storage impls del\n      self._storage.data.del(byteOffset, end - byteOffset, sync)\n    }\n  })\n}\n\nFeed.prototype.signature = function (index, cb) {\n  if (typeof index === 'function') return this.signature(this.length - 1, index)\n\n  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'))\n\n  this._storage.nextSignature(index, cb)\n}\n\nFeed.prototype.verify = function (index, signature, cb) {\n  var self = this\n\n  this.rootHashes(index, function (err, roots) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, index + 1)\n\n    verifyCompat(self, checksum, signature, function (err, valid) {\n      if (err) return cb(err)\n\n      if (!valid) return cb(new Error('Signature verification failed'))\n\n      return cb(null, true)\n    })\n  })\n}\n\nFeed.prototype.rootHashes = function (index, cb) {\n  this._getRootsToVerify(index * 2 + 2, {}, [], cb)\n}\n\nFeed.prototype.seek = function (bytes, opts, cb) {\n  if (typeof opts === 'function') return this.seek(bytes, null, opts)\n  if (!opts) opts = {}\n  if (!this.opened) return this._readyAndSeek(bytes, opts, cb)\n\n  var self = this\n\n  if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0)\n\n  this._seek(bytes, function (err, index, offset) {\n    if (!err && isBlock(index)) return done(index / 2, offset)\n    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'))\n\n    var start = opts.start || 0\n    var end = opts.end || -1\n\n    if (!err) {\n      var left = flat.leftSpan(index) / 2\n      var right = flat.rightSpan(index) / 2 + 1\n\n      if (left > start) start = left\n      if (right < end || end === -1) end = right\n    }\n\n    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'))\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: bytes,\n      index: -1,\n      ifAvailable: opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable,\n      start: start,\n      end: end,\n      want: toWantRange(start),\n      requested: 0,\n      callback: cb || noop\n    }\n\n    self._waiting.push(w)\n    self._updatePeers()\n    if (w.ifAvailable) self._ifAvailableSeek(w)\n  })\n\n  function done (index, offset) {\n    for (var i = 0; i < self.peers.length; i++) {\n      self.peers[i].haveBytes(bytes)\n    }\n    cb(null, index, offset)\n  }\n}\n\nFeed.prototype._ifAvailableSeek = function (w) {\n  var self = this\n  var cb = w.callback\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      let available = false\n      for (const peer of self.peers) {\n        const ite = peer._iterator\n        let i = ite.seek(w.start).next(true)\n        while (self.tree.get(i * 2) && i > -1) i = ite.next(true)\n        if (i > -1 && (w.end === -1 || i < w.end)) {\n          available = true\n          break\n        }\n      }\n\n      if (!available) done(new Error('Seek not available from peers'))\n    })\n  })\n\n  function done (err) {\n    var i = self._waiting.indexOf(w)\n    if (i > -1) {\n      remove(self._waiting, i)\n      w.callback = noop\n      cb(err)\n    }\n  }\n}\n\nFeed.prototype._seek = function (offset, cb) {\n  if (offset === 0) return cb(null, 0, 0)\n\n  var self = this\n  var roots = flat.fullRoots(this.length * 2)\n  var nearestRoot = 0\n\n  loop(null, null)\n\n  function onroot (top) {\n    if (isBlock(top)) return cb(null, nearestRoot, offset)\n\n    var left = flat.leftChild(top)\n    while (!self.tree.get(left)) {\n      if (isBlock(left)) return cb(null, nearestRoot, offset)\n      left = flat.leftChild(left)\n    }\n\n    self._storage.getNode(left, onleftchild)\n  }\n\n  function onleftchild (err, node) {\n    if (err) return cb(err)\n\n    if (node.size > offset) {\n      nearestRoot = node.index\n      onroot(node.index)\n    } else {\n      offset -= node.size\n      if (flat.parent(node.index) === nearestRoot) {\n        nearestRoot = flat.sibling(node.index)\n        onroot(nearestRoot)\n      } else {\n        onroot(flat.sibling(node.index))\n      }\n    }\n  }\n\n  function loop (err, node) {\n    if (err) return cb(err)\n\n    if (node) {\n      if (node.size > offset) {\n        nearestRoot = node.index\n        return onroot(node.index)\n      }\n      offset -= node.size\n    }\n\n    if (!roots.length) return cb(new Error('Out of bounds'))\n    self._storage.getNode(roots.shift(), loop)\n  }\n}\n\nFeed.prototype._readyAndSeek = function (bytes, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.seek(bytes, opts, cb)\n  })\n}\n\nFeed.prototype._getBuffer = function (index, cb) {\n  this._storage.getData(index, cb)\n}\n\nFeed.prototype._putBuffer = function (index, data, proof, from, cb) {\n  // TODO: this nodes in proof are not instances of our Node prototype\n  // but just similar. Check if this has any v8 perf implications.\n\n  // TODO: if the proof contains a valid signature BUT fails, emit a critical error\n  // --> feed should be considered dead\n\n  var self = this\n  var trusted = -1\n  var missing = []\n  var next = 2 * index\n  var i = data ? 0 : 1\n\n  while (true) {\n    if (this.tree.get(next)) {\n      trusted = next\n      break\n    }\n\n    var sib = flat.sibling(next)\n    next = flat.parent(next)\n\n    if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n      i++\n      continue\n    }\n\n    if (!this.tree.get(sib)) break\n    missing.push(sib)\n  }\n\n  if (trusted === -1 && this.tree.get(next)) trusted = next\n\n  var error = null\n  var trustedNode = null\n  var missingNodes = new Array(missing.length)\n  var pending = missing.length + (trusted > -1 ? 1 : 0)\n\n  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing)\n  if (trusted > -1) this._storage.getNode(trusted, ontrusted)\n  if (!missing.length && trusted === -1) onmissingloaded(null)\n\n  function ontrusted (err, node) {\n    if (err) error = err\n    if (node) trustedNode = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissing (err, node) {\n    if (err) error = err\n    if (node) missingNodes[missing.indexOf(node.index)] = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissingloaded (err) {\n    if (err) return cb(err)\n    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb)\n  }\n}\n\nFeed.prototype._readyAndPut = function (index, data, proof, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.put(index, data, proof, cb)\n  })\n}\n\nFeed.prototype._write = function (index, data, nodes, sig, from, cb) {\n  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb)\n  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb))\n}\n\nfunction writeHookDone (self, index, data, nodes, sig, from, cb) {\n  return function (err) {\n    if (err) return cb(err)\n    self._writeAfterHook(index, data, nodes, sig, from, cb)\n  }\n}\n\nFeed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {\n  var self = this\n  var pending = nodes.length + 1 + (sig ? 1 : 0)\n  var error = null\n\n  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone)\n  if (data) this._storage.putData(index, data, nodes, ondone)\n  else ondone()\n  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone)\n\n  function ondone (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n    self._writeDone(index, data, nodes, from, cb)\n  }\n}\n\nFeed.prototype._writeDone = function (index, data, nodes, from, cb) {\n  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)\n  this.tree.set(2 * index)\n\n  if (data) {\n    if (this.bitfield.set(index, true)) {\n      if (this._stats) {\n        this._stats.downloadedBlocks += 1\n        this._stats.downloadedBytes += data.length\n      }\n      this.emit('download', index, data, from)\n    }\n    if (this.peers.length) this._announce({ start: index }, from)\n\n    if (!this.writable) {\n      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length)\n      if (this._synced.next() === -1) {\n        this._synced.range(0, this.length)\n        this._synced.seek(0)\n        if (this._synced.next() === -1) {\n          this.emit('sync')\n        }\n      }\n    }\n  }\n\n  this._sync(null, cb)\n}\n\nFeed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {\n  var visited = []\n  var remoteNodes = proof.nodes\n  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift()\n\n  // check if we already have the hash for this node\n  if (verifyNode(trustedNode, top)) {\n    this._write(index, data, visited, null, from, cb)\n    return\n  }\n\n  // keep hashing with siblings until we reach or trusted node\n  while (true) {\n    var node = null\n    var next = flat.sibling(top.index)\n\n    if (remoteNodes.length && remoteNodes[0].index === next) {\n      node = remoteNodes.shift()\n      visited.push(node)\n    } else if (localNodes.length && localNodes[0].index === next) {\n      node = localNodes.shift()\n    } else {\n      // we cannot create another parent, i.e. these nodes must be roots in the tree\n      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb)\n      return\n    }\n\n    visited.push(top)\n    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size)\n\n    // the tree checks out, write the data and the visited nodes\n    if (verifyNode(trustedNode, top)) {\n      this._write(index, data, visited, null, from, cb)\n      return\n    }\n  }\n}\n\nFeed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {\n  var remoteNodes = proof.nodes\n  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index\n  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2\n  var length = verifiedBy / 2\n  var self = this\n\n  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, length)\n    var signature = null\n\n    if (self.length && self.live && !proof.signature) {\n      return cb(new Error('Remote did not include a signature'))\n    }\n\n    if (proof.signature) { // check signatures\n      verifyCompat(self, checksum, proof.signature, function (err, valid) {\n        if (err) return cb(err)\n        if (!valid) return cb(new Error('Remote signature could not be verified'))\n\n        signature = { index: verifiedBy / 2 - 1, signature: proof.signature }\n        write()\n      })\n    } else { // check tree root\n      if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {\n        return cb(new Error('Remote checksum failed'))\n      }\n\n      write()\n    }\n\n    function write () {\n      self.live = !!signature\n\n      if (length > self.length) {\n        // TODO: only emit this after the info has been flushed to storage\n        if (self.writable) self._merkle = null // We need to reload merkle state now\n        self.length = length\n        self._seq = length\n        self.byteLength = roots.reduce(addSize, 0)\n        if (self._synced) self._synced.seek(0, self.length)\n        self.emit('append')\n      }\n\n      self._write(index, data, nodes.concat(extraNodes), signature, from, cb)\n    }\n  })\n}\n\nFeed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {\n  var indexes = flat.fullRoots(verifiedBy)\n  var roots = new Array(indexes.length)\n  var nodes = []\n  var error = null\n  var pending = roots.length\n\n  for (var i = 0; i < indexes.length; i++) {\n    if (indexes[i] === top.index) {\n      nodes.push(top)\n      onnode(null, top)\n    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n      nodes.push(remoteNodes[0])\n      onnode(null, remoteNodes.shift())\n    } else if (this.tree.get(indexes[i])) {\n      this._storage.getNode(indexes[i], onnode)\n    } else {\n      onnode(new Error('Missing tree roots needed for verify'))\n    }\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) roots[indexes.indexOf(node.index)] = node\n    if (!--pending) done(error)\n  }\n\n  function done (err) {\n    if (err) return cb(err)\n\n    cb(null, roots, nodes)\n  }\n}\n\nFeed.prototype._announce = function (message, from) {\n  for (var i = 0; i < this.peers.length; i++) {\n    var peer = this.peers[i]\n    if (peer !== from) peer.have(message)\n  }\n}\n\nFeed.prototype._unannounce = function (message) {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message)\n}\n\nFeed.prototype.downloaded = function (start, end, cb) {\n  const count = this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, count) // prepare async interface for this\n  return count\n}\n\nFeed.prototype.has = function (start, end, cb) {\n  if (typeof end === 'function') return this.has(start, undefined, end)\n  if (end === undefined) {\n    const res = this.bitfield.get(start)\n    if (cb) process.nextTick(cb, null, res)\n    return res\n  }\n  const total = end - start\n  const res = total === this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, res)\n  return res\n}\n\nFeed.prototype.getBlockInfo = function (index, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._storage.getNode(2 * index, cb)\n  })\n}\n\nFeed.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head({}, opts)\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (opts && opts.update) self.update(opts, onupdate)\n    else process.nextTick(onupdate)\n  })\n\n  function onupdate () {\n    if (self.length === 0) cb(new Error('feed is empty'))\n    else self.get(self.length - 1, opts, cb)\n  }\n}\n\nFeed.prototype.get = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.get(index, null, opts)\n\n  opts = { ...opts }\n  if (!opts.cancel) opts.cancel = Symbol('hypercore-get')\n\n  if (!this.opened) return this._readyAndGet(index, opts, cb)\n\n  if (!this.readable) {\n    process.nextTick(cb, new Error('Feed is closed'))\n    return opts.cancel\n  }\n\n  if (opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  if (!this.bitfield.get(index)) {\n    if (opts && opts.wait === false) return process.nextTick(cb, new Error('Block not downloaded'))\n\n    var w = { bytes: 0, hash: false, index: index, options: opts, requested: 0, callback: cb }\n    this._waiting.push(w)\n\n    if (opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w)\n\n    this._updatePeers()\n    if (opts.onwait) {\n      const onwait = opts.onwait\n      opts.onwait = null\n      onwait(index)\n    }\n    return opts.cancel\n  }\n\n  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb)\n  else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb)\n\n  this._getBuffer(index, cb)\n  return opts.cancel\n}\n\nFeed.prototype._readyAndGet = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.get(index, opts, cb)\n  })\n  return opts.cancel\n}\n\nFeed.prototype.getBatch = function (start, end, opts, cb) {\n  if (typeof opts === 'function') return this.getBatch(start, end, null, opts)\n  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb)\n\n  var self = this\n  var wait = !opts || opts.wait !== false\n\n  if (this.has(start, end)) return this._getBatch(start, end, opts, cb)\n  if (!wait) return process.nextTick(cb, new Error('Block not downloaded'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  this.download({ start: start, end: end }, function (err) {\n    if (err) return cb(err)\n    self._getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._getBatch = function (start, end, opts, cb) {\n  var enc = opts && opts.valueEncoding\n  var codec = enc ? toCodec(enc) : this._codec\n\n  this._storage.getDataBatch(start, end - start, onbatch)\n\n  function onbatch (err, buffers) {\n    if (err) return cb(err)\n\n    var batch = new Array(buffers.length)\n\n    for (var i = 0; i < buffers.length; i++) {\n      try {\n        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i]\n      } catch (err) {\n        return cb(err)\n      }\n    }\n\n    cb(null, batch)\n  }\n}\n\nFeed.prototype._readyAndGetBatch = function (start, end, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._updatePeers = function () {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].update()\n}\n\nFeed.prototype.createWriteStream = function (opts) {\n  return new WriteStream(this, opts)\n}\n\nFeed.prototype.createReadStream = function (opts) {\n  return new ReadStream(this, opts)\n}\n\n// TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)\nFeed.prototype.finalize = function (cb) {\n  if (!this.key) {\n    this.key = crypto.tree(this._merkle.roots)\n    this.discoveryKey = crypto.discoveryKey(this.key)\n  }\n  this._storage.key.write(0, this.key, cb)\n}\n\nFeed.prototype.append = function (batch, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var list = Array.isArray(batch) ? batch : [batch]\n  this._batch(list, onappend)\n\n  function onappend (err) {\n    if (err) return cb(err)\n    var seq = self._seq\n    self._seq += list.length\n    cb(null, seq)\n  }\n}\n\nFeed.prototype.flush = function (cb) {\n  this.append([], cb)\n}\n\nFeed.prototype.destroyStorage = function (cb) {\n  const self = this\n\n  this.close(function (err) {\n    if (err) cb(err)\n    else self._storage.destroy(cb)\n  })\n}\n\nFeed.prototype._close = function (cb) {\n  const self = this\n\n  for (const peer of this.peers) {\n    if (!peer._destroyed) peer._close()\n  }\n\n  this._forceClose(onclose, null)\n\n  function onclose (err) {\n    if (!err) self.emit('close')\n    cb(err)\n  }\n}\n\nFeed.prototype._forceClose = function (cb, error) {\n  var self = this\n\n  this.writable = false\n  this.readable = false\n\n  this._storage.close(function (err) {\n    if (!err) err = error\n    self._destroy(err || new Error('Feed is closed'))\n    cb(err)\n  })\n}\n\nFeed.prototype._destroy = function (err) {\n  this.ifAvailable.destroy()\n\n  while (this._waiting.length) {\n    this._waiting.pop().callback(err)\n  }\n  while (this._selections.length) {\n    this._selections.pop().callback(err)\n  }\n}\n\nFeed.prototype._appendHook = function (batch, cb) {\n  var self = this\n  var missing = batch.length\n  var error = null\n\n  if (!missing) return this._append(batch, cb)\n  for (var i = 0; i < batch.length; i++) {\n    this._onwrite(i + this.length, batch[i], null, done)\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) return cb(error)\n    self._append(batch, cb)\n  }\n}\n\nFeed.prototype._append = function (batch, cb) {\n  if (!this.opened) return this._readyAndAppend(batch, cb)\n  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'))\n\n  var self = this\n  var pending = 1\n  var offset = 0\n  var error = null\n  var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0)\n  var nodeOffset = this.length * 2\n  var dataBatch = new Array(batch.length)\n\n  if (!pending) return cb()\n\n  for (var i = 0; i < batch.length; i++) {\n    var data = this._codec.encode(batch[i])\n    var nodes = this._merkle.next(data)\n\n    // the replication stream rejects frames >8MB for DOS defense. Is configurable there, so\n    // we could bubble that up here. For now just hardcode it so you can't accidentally \"brick\" your core\n    // note: this is *only* for individual blocks and is just a sanity check. most blocks are <1MB\n    if (data.length > 8388608) return cb(new Error('Individual blocks has be less than 8MB'))\n\n    offset += data.length\n    dataBatch[i] = data\n\n    for (var j = 0; j < nodes.length; j++) {\n      var node = nodes[j]\n      if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {\n        nodeBatch[node.index - nodeOffset] = node\n      } else {\n        pending++\n        this._storage.putNode(node.index, node, done)\n      }\n    }\n  }\n\n  if (this.live && batch.length) {\n    pending++\n    this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function (err, sig) {\n      if (err) return done(err)\n      self._storage.putSignature(self.length + batch.length - 1, sig, done)\n    })\n  }\n\n  if (!this._indexing) {\n    pending++\n    if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done)\n    else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done)\n  }\n\n  this._storage.putNodeBatch(nodeOffset, nodeBatch, done)\n\n  function done (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n\n    var start = self.length\n\n    // TODO: only emit append and update length / byteLength after the info has been flushed to storage\n    self.byteLength += offset\n    for (var i = 0; i < batch.length; i++) {\n      self.bitfield.set(self.length, true)\n      self.tree.set(2 * self.length++)\n    }\n    self.emit('append')\n\n    var message = self.length - start > 1 ? { start: start, length: self.length - start } : { start: start }\n    if (self.peers.length) self._announce(message)\n\n    self._sync(null, cb)\n  }\n}\n\nFeed.prototype._readyAndAppend = function (batch, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._append(batch, cb)\n  })\n}\n\nFeed.prototype._readyAndCancel = function (start, end) {\n  var self = this\n  this.ready(function () {\n    self._cancel(start, end)\n  })\n}\n\nFeed.prototype._pollWaiting = function () {\n  var len = this._waiting.length\n\n  for (var i = 0; i < len; i++) {\n    var next = this._waiting[i]\n    if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {\n      continue\n    }\n\n    remove(this._waiting, i--)\n    len--\n\n    if (next.bytes) this.seek(next.bytes, next, next.callback)\n    else if (next.update) this.update(next.index + 1, next.callback)\n    else this.get(next.index, next.options, next.callback)\n  }\n}\n\nFeed.prototype._syncBitfield = function (cb) {\n  var missing = this.bitfield.pages.updates.length\n  var next = null\n  var error = null\n\n  // All data / nodes have been written now. We still need to update the bitfields though\n\n  // TODO 1: if the program fails during this write the bitfield might not have been fully written\n  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists\n  // on disk. So if a get fails, it should try and recover once.\n\n  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf\n  // Added benefit is that if the program exits while flushing the bitfield the feed will only get\n  // truncated and not have missing chunks which is what you expect.\n\n  if (!missing) {\n    this._pollWaiting()\n    return cb(null)\n  }\n\n  while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n    this._storage.putBitfield(next.offset, next.buffer, ondone)\n  }\n\n  this._pollWaiting()\n\n  function ondone (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nFeed.prototype._roots = function (index, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var result = new Array(roots.length)\n  var pending = roots.length\n  var error = null\n\n  if (!pending) return cb(null, result)\n\n  for (var i = 0; i < roots.length; i++) {\n    this._storage.getNode(roots[i], onnode)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) result[roots.indexOf(node.index)] = node\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, result)\n  }\n}\n\nFeed.prototype.audit = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var report = {\n    valid: 0,\n    invalid: 0\n  }\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var block = 0\n    var max = self.length\n\n    next()\n\n    function onnode (err, node) {\n      if (err) return ondata(null, null)\n      self._storage.getData(block, ondata)\n\n      function ondata (_, data) {\n        var verified = data && crypto.data(data).equals(node.hash)\n        if (verified) report.valid++\n        else report.invalid++\n        self.bitfield.set(block, verified)\n        block++\n        next()\n      }\n    }\n\n    function next () {\n      while (block < max && !self.bitfield.get(block)) block++\n      if (block >= max) return done()\n      self._storage.getNode(2 * block, onnode)\n    }\n\n    function done () {\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        cb(null, report)\n      })\n    }\n  })\n}\n\nFeed.prototype.extension = function (name, message) {\n  var peers = this.peers\n\n  for (var i = 0; i < peers.length; i++) {\n    peers[i].extension(name, message)\n  }\n}\n\nfunction noop () {}\n\nfunction verifyNode (trusted, node) {\n  return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0\n}\n\nfunction addSize (size, node) {\n  return size + node.size\n}\n\nfunction isBlock (index) {\n  return (index & 1) === 0\n}\n\nfunction toCodec (enc) {\n  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \\o/\n  return codecs(enc === 'json' ? 'ndjson' : enc)\n}\n\nfunction wrapCodec (enc, cb) {\n  return function (err, buf) {\n    if (err) return cb(err)\n    try {\n      buf = enc.decode(buf)\n    } catch (err) {\n      return cb(err)\n    }\n    cb(null, buf)\n  }\n}\n\nfunction timeoutCallback (cb, timeout) {\n  var failed = false\n  var id = setTimeout(ontimeout, timeout)\n  return done\n\n  function ontimeout () {\n    failed = true\n    // TODO: make libs/errors for all this stuff\n    var err = new Error('ETIMEDOUT')\n    err.code = 'ETIMEDOUT'\n    cb(err)\n  }\n\n  function done (err, val) {\n    if (failed) return\n    clearTimeout(id)\n    cb(err, val)\n  }\n}\n\nfunction toWantRange (i) {\n  return Math.floor(i / 1024 / 1024) * 1024 * 1024\n}\n\nfunction createError (code, errno, msg) {\n  var err = new Error(msg)\n  err.code = code\n  err.errno = errno\n  return err\n}\n\nfunction defaultStorageDir (directory) {\n  return function (name) {\n    return defaultStorage(name, { directory })\n  }\n}\n\nfunction isOptions (initiator) {\n  return !Protocol.isProtocolStream(initiator) &&\n    typeof initiator === 'object' &&\n    !!initiator &&\n    typeof initiator.initiator === 'boolean'\n}\n\nfunction readyNT (ifAvailable, fn) {\n  ifAvailable.ready(fn)\n}\n\nfunction verifyCompat (self, checksum, signature, cb) {\n  self.crypto.verify(checksum, signature, self.key, function (err, valid) {\n    if (err || valid) return cb(err, valid)\n    // compat mode, will be removed in a later version\n    self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb)\n  })\n}\n\nexport default hypercore;\nexport { hypercore as __moduleExports };","start":1670465468235,"end":1670465471863,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport { default as process } from '\u0000polyfill-node.process';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/last-one-wins@1.0.4/node_modules/last-one-wins/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-array-remove@1.0.2/node_modules/unordered-array-remove/index.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/atomic-batcher@1.0.2/node_modules/atomic-batcher/index.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js?commonjs-proxy\";\nimport require$$8 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/bitfield.js?commonjs-proxy\";\nimport require$$9 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sparse-bitfield@3.0.3/node_modules/sparse-bitfield/index.js?commonjs-proxy\";\nimport require$$10 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js?commonjs-proxy\";\nimport require$$11 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/storage.js?commonjs-proxy\";\nimport require$$12 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$13 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js?commonjs-proxy\";\nimport require$$14 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js?commonjs-proxy\";\nimport require$$15 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js?commonjs-proxy\";\nimport require$$16 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/safe-buffer-equals.js?commonjs-proxy\";\nimport require$$17 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js?commonjs-proxy\";\nimport require$$18 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js?commonjs-proxy\";\nimport require$$19 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js?commonjs-proxy\";\nimport require$$20 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoresource@1.3.0/node_modules/nanoresource/emitter.js?commonjs-proxy\";\nimport require$$21 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-default-storage@1.1.1/node_modules/hypercore-default-storage/index.js?commonjs-proxy\";\nimport require$$22 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js?commonjs-proxy\";\n\nvar low = require$$0\nvar remove = require$$1\nvar set = require$$2\nvar MerkleGenerator = require$$3\nvar flat = require$$4\nvar codecs = require$$5\nvar batcher = require$$6\nvar inherits = require$$7\nvar bitfield = require$$8\nvar sparseBitfield = require$$9\nvar treeIndex = require$$10\nvar storage = require$$11\nvar crypto = require$$12\nvar inspect = require$$13\nvar pretty = require$$14\nvar Nanoguard = require$$15\nvar safeBufferEquals = require$$16\nvar replicate = require$$17\nvar Protocol = require$$18\nvar Message = require$$19\nvar Nanoresource = require$$20\nvar defaultStorage = require$$21\nvar { WriteStream, ReadStream } = require$$22\n\nclass Extension extends Message {\n  broadcast (message) {\n    const feed = this.local.handlers\n    const buf = this.encoding.encode(message)\n    let broadcasted = false\n    for (const peer of feed.peers) {\n      broadcasted = true\n      peer.extension(this.id, buf)\n    }\n    return broadcasted\n  }\n\n  send (message, peer) {\n    peer.extension(this.id, this.encode(message))\n  }\n}\n\nvar defaultCrypto = {\n  sign (data, sk, cb) {\n    return cb(null, crypto.sign(data, sk))\n  },\n  verify (sig, data, pk, cb) {\n    return cb(null, crypto.verify(sig, data, pk))\n  }\n}\n\nvar hypercore = Feed\n\nfunction Feed (createStorage, key, opts) {\n  if (!(this instanceof Feed)) return new Feed(createStorage, key, opts)\n  Nanoresource.call(this)\n\n  if (typeof createStorage === 'string') createStorage = defaultStorageDir(createStorage)\n  if (typeof createStorage !== 'function') throw new Error('Storage should be a function or string')\n\n  if (typeof key === 'string') key = Buffer.from(key, 'hex')\n\n  if (!Buffer.isBuffer(key) && !opts) {\n    opts = key\n    key = null\n  }\n\n  if (!opts) opts = {}\n\n  var self = this\n\n  var secretKey = opts.secretKey || null\n  if (typeof secretKey === 'string') secretKey = Buffer.from(secretKey, 'hex')\n\n  this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair()\n  this.live = opts.live !== false\n  this.sparse = !!opts.sparse\n  this.length = 0\n  this.byteLength = 0\n  this.maxRequests = opts.maxRequests || 16\n  this.key = key || opts.key || null\n  this.discoveryKey = this.key && crypto.discoveryKey(this.key)\n  this.secretKey = secretKey\n  this.bitfield = null\n  this.tree = null\n  this.writable = !!opts.writable\n  this.readable = true\n  this.downloading = opts.downloading !== false\n  this.uploading = opts.uploading !== false\n  this.allowPush = !!opts.allowPush\n  this.peers = []\n  this.ifAvailable = new Nanoguard()\n  this.extensions = Extension.createLocal(this) // set Feed as the handlers\n\n  this.crypto = opts.crypto || defaultCrypto\n\n  // hooks\n  this._onwrite = opts.onwrite || null\n\n  this._force = !!opts.force\n  this._expectedLength = -1\n  this._indexing = !!opts.indexing\n  this._createIfMissing = opts.createIfMissing !== false\n  this._overwrite = !!opts.overwrite\n  this._storeSecretKey = opts.storeSecretKey !== false\n  this._alwaysIfAvailable = !!opts.ifAvailable\n  this._merkle = null\n  this._storage = storage(createStorage, opts)\n  this._batch = batcher(this._onwrite ? workHook : work)\n\n  this.timeouts = opts.timeouts || {\n    get (cb) {\n      cb(null)\n    },\n    update (cb) {\n      cb(null)\n    }\n  }\n\n  this._seq = 0\n  this._waiting = []\n  this._selections = []\n  this._reserved = sparseBitfield()\n  this._synced = null\n  this._downloadingSet = typeof opts.downloading === 'boolean'\n\n  this._stats = (typeof opts.stats !== 'undefined' && !opts.stats) ? null : {\n    downloadedBlocks: 0,\n    downloadedBytes: 0,\n    uploadedBlocks: 0,\n    uploadedBytes: 0\n  }\n\n  this._codec = toCodec(opts.valueEncoding)\n  this._sync = low(sync)\n  if (!this.sparse) this.download({ start: 0, end: -1 })\n\n  if (this.sparse && opts.eagerUpdate) {\n    this.update(function loop (err) {\n      if (err) self.emit('update-error', err)\n      self.update(loop)\n    })\n  }\n\n  // open it right away\n  this.open(onerror)\n\n  function onerror (err) {\n    if (err) self.emit('error', err)\n  }\n\n  function workHook (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(workHook, values, cb)\n    self._appendHook(values, cb)\n  }\n\n  function work (values, cb) {\n    if (!self._merkle) return self._reloadMerkleStateBeforeAppend(work, values, cb)\n    self._append(values, cb)\n  }\n\n  function sync (_, cb) {\n    self._syncBitfield(cb)\n  }\n}\n\ninherits(Feed, Nanoresource)\n\nFeed.discoveryKey = crypto.discoveryKey\n\nFeed.prototype[inspect] = function (depth, opts) {\n  var indent = ''\n  if (typeof opts.indentationLvl === 'number') {\n    while (indent.length < opts.indentationLvl) indent += ' '\n  }\n  return 'Hypercore(\\n' +\n    indent + '  key: ' + opts.stylize((this.key && pretty(this.key)), 'string') + '\\n' +\n    indent + '  discoveryKey: ' + opts.stylize((this.discoveryKey && pretty(this.discoveryKey)), 'string') + '\\n' +\n    indent + '  opened: ' + opts.stylize(this.opened, 'boolean') + '\\n' +\n    indent + '  sparse: ' + opts.stylize(this.sparse, 'boolean') + '\\n' +\n    indent + '  writable: ' + opts.stylize(this.writable, 'boolean') + '\\n' +\n    indent + '  length: ' + opts.stylize(this.length, 'number') + '\\n' +\n    indent + '  byteLength: ' + opts.stylize(this.byteLength, 'number') + '\\n' +\n    indent + '  peers: ' + opts.stylize(this.peers.length, 'number') + '\\n' +\n    indent + ')'\n}\n\n// TODO: instead of using a getter, update on remote-update/add/remove\nObject.defineProperty(Feed.prototype, 'remoteLength', {\n  enumerable: true,\n  get: function () {\n    var len = 0\n    for (var i = 0; i < this.peers.length; i++) {\n      var remoteLength = this.peers[i].remoteLength\n      if (remoteLength > len) len = remoteLength\n    }\n    return len\n  }\n})\n\nObject.defineProperty(Feed.prototype, 'stats', {\n  enumerable: true,\n  get: function () {\n    if (!this._stats) return null\n    var peerStats = []\n    for (var i = 0; i < this.peers.length; i++) {\n      var peer = this.peers[i]\n      peerStats[i] = peer.stats\n    }\n    return {\n      peers: peerStats,\n      totals: this._stats\n    }\n  }\n})\n\nFeed.prototype.replicate = function (initiator, opts) {\n  if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {\n    // hack!! proper fix is to refactor ./replicate to *not* clear our non-sparse selection\n    this.download({ start: 0, end: -1 })\n  }\n\n  if (isOptions(initiator) && !opts) {\n    opts = initiator\n    initiator = opts.initiator\n  }\n\n  opts = opts || {}\n  opts.stats = !!this._stats\n  opts.noise = !(opts.noise === false && opts.encrypted === false)\n\n  return replicate(this, initiator, opts)\n}\n\nFeed.prototype.registerExtension = function (name, handlers) {\n  return this.extensions.add(name, handlers)\n}\n\nFeed.prototype.onextensionupdate = function () {\n  for (const peer of this.peers) peer._updateOptions()\n}\n\nFeed.prototype.setDownloading = function (downloading) {\n  if (this.downloading === downloading && this._downloadingSet) return\n  this.downloading = downloading\n  this._downloadingSet = true\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setDownloading(this.downloading)\n  })\n}\n\nFeed.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.ready((err) => {\n    if (err) return\n    for (const peer of this.peers) peer.setUploading(this.uploading)\n  })\n}\n\n// Alias the nanoresource open method\nFeed.prototype.ready = Feed.prototype.open\n\nFeed.prototype.update = function (opts, cb) {\n  if (typeof opts === 'function') return this.update(-1, opts)\n  if (typeof opts === 'number') opts = { minLength: opts }\n  if (!opts) opts = {}\n  if (!cb) cb = noop\n\n  var self = this\n  var len = typeof opts.minLength === 'number' ? opts.minLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (len === -1) len = self.length + 1\n    if (self.length >= len) return cb(null)\n\n    const ifAvailable = typeof opts.ifAvailable === 'boolean'\n      ? opts.ifAvailable\n      : self._alwaysIfAvailable\n\n    if (ifAvailable && self.writable && !opts.force) return cb(new Error('No update available from peers'))\n    if (self.writable) cb = self._writeStateReloader(cb)\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: 0,\n      index: len - 1,\n      options: opts,\n      update: true,\n      callback: cb\n    }\n\n    self._waiting.push(w)\n    if (ifAvailable) self._ifAvailable(w, len)\n    self._updatePeers()\n  })\n}\n\n// Used to hint to the update guard if it can bail early\nFeed.prototype.setExpectedLength = function (len) {\n  this._expectedLength = len\n  this.ready((err) => {\n    if (err) return\n\n    this.ifAvailable.ready(() => {\n      this._expectedLength = -1\n    })\n\n    if (this._expectedLength === -1 || this._expectedLength > this.length) return\n\n    for (const w of this._waiting) {\n      if (w.update && w.ifAvailable) w.callback(new Error('Expected length is less than current length'))\n    }\n  })\n}\n\n// Beware! This might break your core if you share forks with other people through replication\nFeed.prototype.truncate = function (newLength, cb) {\n  if (!cb) cb = noop\n  const self = this\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    self._roots(newLength, function (err, roots) {\n      if (err) return cb(err)\n\n      const oldLength = self.length\n      if (oldLength <= newLength) return cb(null)\n\n      let byteLength = 0\n      for (const { size } of roots) byteLength += size\n\n      for (let i = oldLength; i < newLength; i++) self.data.set(i, false)\n      self.byteLength = byteLength\n      self.length = newLength\n      self.tree.truncate(2 * newLength)\n      self._merkle = new MerkleGenerator(crypto, roots)\n\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        self._storage.deleteSignatures(newLength, oldLength, cb)\n      })\n    })\n  })\n}\n\nFeed.prototype._ifAvailable = function (w, minLength) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n  w.ifAvailable = true\n\n  if (this._expectedLength > -1 && this._expectedLength <= this.length) {\n    return process.nextTick(w.callback, new Error('Expected length is less than current length'))\n  }\n\n  this.timeouts.update(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n      if (self.length >= minLength || self.remoteLength >= minLength) return\n      done(new Error('No update available from peers'))\n    })\n  })\n\n  function done (err) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err)\n  }\n}\n\nFeed.prototype._ifAvailableGet = function (w) {\n  var cb = w.callback\n  var called = false\n  var self = this\n\n  w.callback = done\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      for (var i = 0; i < self.peers.length; i++) {\n        var peer = self.peers[i]\n        if (peer.remoteBitfield.get(w.index)) return\n      }\n      done(new Error('Block not available from peers'))\n    })\n  })\n\n  function done (err, data) {\n    if (called) return\n    called = true\n\n    var i = self._waiting.indexOf(w)\n    if (i > -1) remove(self._waiting, i)\n    cb(err, data)\n  }\n}\n\n// will reload the writable state. used by .update on a writable peer\nFeed.prototype._writeStateReloader = function (cb) {\n  var self = this\n  return function (err) {\n    if (err) return cb(err)\n    self._reloadMerkleState(cb)\n  }\n}\n\nFeed.prototype._reloadMerkleState = function (cb) {\n  var self = this\n\n  this._roots(self.length, function (err, roots) {\n    if (err) return cb(err)\n    self._merkle = new MerkleGenerator(crypto, roots)\n    cb(null)\n  })\n}\n\nFeed.prototype._reloadMerkleStateBeforeAppend = function (work, values, cb) {\n  this._reloadMerkleState(function (err) {\n    if (err) return cb(err)\n    work(values, cb)\n  })\n}\n\nFeed.prototype._open = function (cb) {\n  var self = this\n  var generatedKey = false\n  var retryOpen = true\n\n  // TODO: clean up the duplicate code below ...\n\n  this._storage.openKey(function (_, key) {\n    if (key && !self._overwrite && !self.key) self.key = key\n\n    if (!self.key && self.live) {\n      var keyPair = crypto.keyPair()\n      self.secretKey = keyPair.secretKey\n      self.key = keyPair.publicKey\n      generatedKey = true\n    }\n\n    self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n    self._storage.open({ key: self.key, discoveryKey: self.discoveryKey }, onopen)\n  })\n\n  function onopen (err, state) {\n    if (err) return cb(err)\n\n    // if no key but we have data do a bitfield reset since we cannot verify the data.\n    if (!state.key && state.bitfield.length) {\n      self._overwrite = true\n    }\n\n    if (self._force && state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      self._overwrite = true\n    }\n\n    if (self._overwrite) {\n      state.bitfield = []\n      state.key = state.secretKey = null\n    }\n\n    self.bitfield = bitfield(state.bitfieldPageSize, state.bitfield)\n    self.tree = treeIndex(self.bitfield.tree)\n    self.length = self.tree.blocks()\n    self._seq = self.length\n\n    if (state.key && self.key && Buffer.compare(state.key, self.key) !== 0) {\n      return self._forceClose(cb, new Error('Another hypercore is stored here'))\n    }\n\n    if (state.key) self.key = state.key\n    if (state.secretKey) self.secretKey = state.secretKey\n\n    if (!self.length) return onsignature(null, null)\n    self._storage.getSignature(self.length - 1, onsignature)\n\n    function onsignature (_, sig) {\n      if (self.length) self.live = !!sig\n\n      if ((generatedKey || !self.key) && !self._createIfMissing) {\n        return self._forceClose(cb, new Error('No hypercore is stored here'))\n      }\n\n      if (!self.key && self.live) {\n        var keyPair = crypto.keyPair()\n        self.secretKey = keyPair.secretKey\n        self.key = keyPair.publicKey\n      }\n\n      var writable = !!self.secretKey || self.key === null\n\n      if (!writable && self.writable) return self._forceClose(cb, new Error('Feed is not writable'))\n      self.writable = writable\n      if (!self._downloadingSet) self.downloading = !writable\n      self.discoveryKey = self.key && crypto.discoveryKey(self.key)\n\n      if (self._storeSecretKey && !self.secretKey) {\n        self._storeSecretKey = false\n      }\n\n      var shouldWriteKey = generatedKey || !safeBufferEquals(self.key, state.key)\n      var shouldWriteSecretKey = self._storeSecretKey && (generatedKey || !safeBufferEquals(self.secretKey, state.secretKey))\n\n      var missing = 1 +\n        (shouldWriteKey ? 1 : 0) +\n        (shouldWriteSecretKey ? 1 : 0) +\n        (self._overwrite ? 1 : 0)\n      var error = null\n\n      if (shouldWriteKey) self._storage.key.write(0, self.key, done)\n      if (shouldWriteSecretKey) self._storage.secretKey.write(0, self.secretKey, done)\n\n      if (self._overwrite) {\n        self._storage.bitfield.del(32, Infinity, done)\n      }\n\n      done(null)\n\n      function done (err) {\n        if (err) error = err\n        if (--missing) return\n        if (error) return self._forceClose(cb, error)\n        self._roots(self.length, onroots)\n      }\n\n      function onroots (err, roots) {\n        if (err && retryOpen) {\n          retryOpen = false\n          self.length--\n          self._storage.getSignature(self.length - 1, onsignature)\n          return\n        }\n\n        if (err) return self._forceClose(cb, err)\n\n        self._merkle = new MerkleGenerator(crypto, roots)\n        self.byteLength = roots.reduce(addSize, 0)\n        self.emit('ready')\n\n        cb(null)\n      }\n    }\n  }\n}\n\nFeed.prototype.download = function (range, cb) {\n  if (typeof range === 'function') return this.download(null, range)\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (Array.isArray(range)) range = { blocks: range }\n  if (!range) range = {}\n  if (!cb) cb = noop\n  if (!this.readable) return cb(new Error('Feed is closed'))\n\n  // TODO: if no peers, check if range is already satisfied and nextTick(cb) if so\n  // this._updatePeers does this for us when there is a peer though, so not critical\n\n  // We need range.start, end for the want messages so make sure to infer these\n  // when blocks are passed and start,end is not set\n  if (range.blocks && typeof range.start !== 'number') {\n    var min = -1\n    var max = 0\n\n    for (var i = 0; i < range.blocks.length; i++) {\n      const blk = range.blocks[i]\n      if (min === -1 || blk < min) min = blk\n      if (blk >= max) max = blk + 1\n    }\n\n    range.start = min === -1 ? 0 : min\n    range.end = max\n  }\n\n  var sel = {\n    _index: this._selections.length,\n    hash: !!range.hash,\n    iterator: null,\n    start: range.start || 0,\n    end: range.end || -1,\n    want: 0,\n    linear: !!range.linear,\n    blocks: range.blocks || null,\n    blocksDownloaded: 0,\n    requested: 0,\n    callback: cb\n  }\n\n  sel.want = toWantRange(sel.start)\n\n  this._selections.push(sel)\n  this._updatePeers()\n\n  return sel\n}\n\nFeed.prototype.undownload = function (range) {\n  if (typeof range === 'number') range = { start: range, end: range + 1 }\n  if (!range) range = {}\n\n  if (range.callback && range._index > -1) {\n    set.remove(this._selections, range)\n    process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n    return\n  }\n\n  var start = range.start || 0\n  var end = range.end || -1\n  var hash = !!range.hash\n  var linear = !!range.linear\n\n  for (var i = 0; i < this._selections.length; i++) {\n    var s = this._selections[i]\n\n    if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {\n      set.remove(this._selections, s)\n      process.nextTick(range.callback, createError('ECANCELED', -11, 'Download was cancelled'))\n      return\n    }\n  }\n}\n\nFeed.prototype.digest = function (index) {\n  return this.tree.digest(2 * index)\n}\n\nFeed.prototype.proof = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.proof(index, null, opts)\n  if (!this.opened) return this._readyAndProof(index, opts, cb)\n  if (!opts) opts = {}\n\n  var proof = this.tree.proof(2 * index, opts)\n  if (!proof) return cb(new Error('No proof available for this index'))\n\n  var needsSig = this.live && !!proof.verifiedBy\n  var pending = proof.nodes.length + (needsSig ? 1 : 0)\n  var error = null\n  var signature = null\n  var nodes = new Array(proof.nodes.length)\n\n  if (!pending) return cb(null, { nodes: nodes, signature: null })\n\n  for (var i = 0; i < proof.nodes.length; i++) {\n    this._storage.getNode(proof.nodes[i], onnode)\n  }\n  if (needsSig) {\n    this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature)\n  }\n\n  function onsignature (err, sig) {\n    if (sig) signature = sig\n    onnode(err, null)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n\n    if (node) {\n      nodes[proof.nodes.indexOf(node.index)] = node\n    }\n\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, { nodes: nodes, signature: signature })\n  }\n}\n\nFeed.prototype._readyAndProof = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.proof(index, opts, cb)\n  })\n}\n\nFeed.prototype.put = function (index, data, proof, cb) {\n  if (!this.opened) return this._readyAndPut(index, data, proof, cb)\n  this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb)\n}\n\nFeed.prototype.cancel = function (start, end) { // TODO: use same argument scheme as download\n  if (typeof start !== 'symbol') {\n    if (!end) end = start + 1\n\n    // cancel these right away as .download does not wait for ready\n    for (var i = this._selections.length - 1; i >= 0; i--) {\n      var sel = this._selections[i]\n      if (start <= sel.start && sel.end <= end) {\n        this.undownload(sel)\n      }\n    }\n  }\n\n  // defer the last part until after ready as .get does that as well\n  if (this.opened) this._cancel(start, end)\n  else this._readyAndCancel(start, end)\n}\n\nFeed.prototype._cancel = function (start, end) {\n  var i = 0\n\n  if (typeof start === 'symbol') {\n    for (i = this._waiting.length - 1; i >= 0; i--) {\n      const w = this._waiting[i]\n      if (w.options.cancel === start) {\n        remove(this._waiting, i)\n        this._reserved.set(w.index, false)\n        if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n        this._updatePeers()\n        return\n      }\n    }\n    return\n  }\n\n  for (i = start; i < end; i++) {\n    this._reserved.set(i, false) // TODO: send cancel message if set returns true\n  }\n\n  for (i = this._waiting.length - 1; i >= 0; i--) {\n    var w = this._waiting[i]\n    if ((start <= w.start && w.end <= end) || (start <= w.index && w.index < end)) {\n      remove(this._waiting, i)\n      if (w.callback) process.nextTick(w.callback, new Error('Request cancelled'))\n    }\n  }\n}\n\nFeed.prototype.clear = function (start, end, opts, cb) { // TODO: use same argument scheme as download\n  if (typeof end === 'function') return this.clear(start, start + 1, null, end)\n  if (typeof opts === 'function') return this.clear(start, end, null, opts)\n  if (!opts) opts = {}\n  if (!end) end = start + 1\n  if (!cb) cb = noop\n\n  // TODO: this needs some work. fx we can only calc byte offset for blocks we know about\n  // so internally we should make sure to only do that. We should use the merkle tree for this\n\n  var self = this\n  var byteOffset = start === 0 ? 0 : (typeof opts.byteOffset === 'number' ? opts.byteOffset : -1)\n  var byteLength = typeof opts.byteLength === 'number' ? opts.byteLength : -1\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var modified = false\n\n    // TODO: use a buffer.fill thing here to speed this up!\n\n    for (var i = start; i < end; i++) {\n      if (self.bitfield.set(i, false)) modified = true\n    }\n\n    if (!modified) return process.nextTick(cb)\n\n    // TODO: write to a tmp/update file that we want to del this incase it crashes will del'ing\n\n    self._unannounce({ start: start, length: end - start })\n    if (opts.delete === false || self._indexing) return sync()\n    if (byteOffset > -1) return onstartbytes(null, byteOffset)\n    self._storage.dataOffset(start, [], onstartbytes)\n\n    function sync () {\n      self.emit('clear', start, end)\n      self._sync(null, cb)\n    }\n\n    function onstartbytes (err, offset) {\n      if (err) return cb(err)\n      byteOffset = offset\n      if (byteLength > -1) return onendbytes(null, byteLength + byteOffset)\n      if (end === self.length) return onendbytes(null, self.byteLength)\n      self._storage.dataOffset(end, [], onendbytes)\n    }\n\n    function onendbytes (err, end) {\n      if (err) return cb(err)\n      if (!self._storage.data.del) return sync() // Not all data storage impls del\n      self._storage.data.del(byteOffset, end - byteOffset, sync)\n    }\n  })\n}\n\nFeed.prototype.signature = function (index, cb) {\n  if (typeof index === 'function') return this.signature(this.length - 1, index)\n\n  if (index < 0 || index >= this.length) return cb(new Error('No signature available for this index'))\n\n  this._storage.nextSignature(index, cb)\n}\n\nFeed.prototype.verify = function (index, signature, cb) {\n  var self = this\n\n  this.rootHashes(index, function (err, roots) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, index + 1)\n\n    verifyCompat(self, checksum, signature, function (err, valid) {\n      if (err) return cb(err)\n\n      if (!valid) return cb(new Error('Signature verification failed'))\n\n      return cb(null, true)\n    })\n  })\n}\n\nFeed.prototype.rootHashes = function (index, cb) {\n  this._getRootsToVerify(index * 2 + 2, {}, [], cb)\n}\n\nFeed.prototype.seek = function (bytes, opts, cb) {\n  if (typeof opts === 'function') return this.seek(bytes, null, opts)\n  if (!opts) opts = {}\n  if (!this.opened) return this._readyAndSeek(bytes, opts, cb)\n\n  var self = this\n\n  if (bytes === this.byteLength) return process.nextTick(cb, null, this.length, 0)\n\n  this._seek(bytes, function (err, index, offset) {\n    if (!err && isBlock(index)) return done(index / 2, offset)\n    if (opts.wait === false) return cb(err || new Error('Unable to seek to this offset'))\n\n    var start = opts.start || 0\n    var end = opts.end || -1\n\n    if (!err) {\n      var left = flat.leftSpan(index) / 2\n      var right = flat.rightSpan(index) / 2 + 1\n\n      if (left > start) start = left\n      if (right < end || end === -1) end = right\n    }\n\n    if (end > -1 && end <= start) return cb(new Error('Unable to seek to this offset'))\n\n    var w = {\n      hash: opts.hash !== false,\n      bytes: bytes,\n      index: -1,\n      ifAvailable: opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : self._alwaysIfAvailable,\n      start: start,\n      end: end,\n      want: toWantRange(start),\n      requested: 0,\n      callback: cb || noop\n    }\n\n    self._waiting.push(w)\n    self._updatePeers()\n    if (w.ifAvailable) self._ifAvailableSeek(w)\n  })\n\n  function done (index, offset) {\n    for (var i = 0; i < self.peers.length; i++) {\n      self.peers[i].haveBytes(bytes)\n    }\n    cb(null, index, offset)\n  }\n}\n\nFeed.prototype._ifAvailableSeek = function (w) {\n  var self = this\n  var cb = w.callback\n\n  self.timeouts.get(function () {\n    if (self.closed) return done(new Error('Closed'))\n\n    process.nextTick(readyNT, self.ifAvailable, function () {\n      if (self.closed) return done(new Error('Closed'))\n\n      let available = false\n      for (const peer of self.peers) {\n        const ite = peer._iterator\n        let i = ite.seek(w.start).next(true)\n        while (self.tree.get(i * 2) && i > -1) i = ite.next(true)\n        if (i > -1 && (w.end === -1 || i < w.end)) {\n          available = true\n          break\n        }\n      }\n\n      if (!available) done(new Error('Seek not available from peers'))\n    })\n  })\n\n  function done (err) {\n    var i = self._waiting.indexOf(w)\n    if (i > -1) {\n      remove(self._waiting, i)\n      w.callback = noop\n      cb(err)\n    }\n  }\n}\n\nFeed.prototype._seek = function (offset, cb) {\n  if (offset === 0) return cb(null, 0, 0)\n\n  var self = this\n  var roots = flat.fullRoots(this.length * 2)\n  var nearestRoot = 0\n\n  loop(null, null)\n\n  function onroot (top) {\n    if (isBlock(top)) return cb(null, nearestRoot, offset)\n\n    var left = flat.leftChild(top)\n    while (!self.tree.get(left)) {\n      if (isBlock(left)) return cb(null, nearestRoot, offset)\n      left = flat.leftChild(left)\n    }\n\n    self._storage.getNode(left, onleftchild)\n  }\n\n  function onleftchild (err, node) {\n    if (err) return cb(err)\n\n    if (node.size > offset) {\n      nearestRoot = node.index\n      onroot(node.index)\n    } else {\n      offset -= node.size\n      if (flat.parent(node.index) === nearestRoot) {\n        nearestRoot = flat.sibling(node.index)\n        onroot(nearestRoot)\n      } else {\n        onroot(flat.sibling(node.index))\n      }\n    }\n  }\n\n  function loop (err, node) {\n    if (err) return cb(err)\n\n    if (node) {\n      if (node.size > offset) {\n        nearestRoot = node.index\n        return onroot(node.index)\n      }\n      offset -= node.size\n    }\n\n    if (!roots.length) return cb(new Error('Out of bounds'))\n    self._storage.getNode(roots.shift(), loop)\n  }\n}\n\nFeed.prototype._readyAndSeek = function (bytes, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.seek(bytes, opts, cb)\n  })\n}\n\nFeed.prototype._getBuffer = function (index, cb) {\n  this._storage.getData(index, cb)\n}\n\nFeed.prototype._putBuffer = function (index, data, proof, from, cb) {\n  // TODO: this nodes in proof are not instances of our Node prototype\n  // but just similar. Check if this has any v8 perf implications.\n\n  // TODO: if the proof contains a valid signature BUT fails, emit a critical error\n  // --> feed should be considered dead\n\n  var self = this\n  var trusted = -1\n  var missing = []\n  var next = 2 * index\n  var i = data ? 0 : 1\n\n  while (true) {\n    if (this.tree.get(next)) {\n      trusted = next\n      break\n    }\n\n    var sib = flat.sibling(next)\n    next = flat.parent(next)\n\n    if (i < proof.nodes.length && proof.nodes[i].index === sib) {\n      i++\n      continue\n    }\n\n    if (!this.tree.get(sib)) break\n    missing.push(sib)\n  }\n\n  if (trusted === -1 && this.tree.get(next)) trusted = next\n\n  var error = null\n  var trustedNode = null\n  var missingNodes = new Array(missing.length)\n  var pending = missing.length + (trusted > -1 ? 1 : 0)\n\n  for (i = 0; i < missing.length; i++) this._storage.getNode(missing[i], onmissing)\n  if (trusted > -1) this._storage.getNode(trusted, ontrusted)\n  if (!missing.length && trusted === -1) onmissingloaded(null)\n\n  function ontrusted (err, node) {\n    if (err) error = err\n    if (node) trustedNode = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissing (err, node) {\n    if (err) error = err\n    if (node) missingNodes[missing.indexOf(node.index)] = node\n    if (!--pending) onmissingloaded(error)\n  }\n\n  function onmissingloaded (err) {\n    if (err) return cb(err)\n    self._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb)\n  }\n}\n\nFeed.prototype._readyAndPut = function (index, data, proof, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.put(index, data, proof, cb)\n  })\n}\n\nFeed.prototype._write = function (index, data, nodes, sig, from, cb) {\n  if (!this._onwrite) return this._writeAfterHook(index, data, nodes, sig, from, cb)\n  this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb))\n}\n\nfunction writeHookDone (self, index, data, nodes, sig, from, cb) {\n  return function (err) {\n    if (err) return cb(err)\n    self._writeAfterHook(index, data, nodes, sig, from, cb)\n  }\n}\n\nFeed.prototype._writeAfterHook = function (index, data, nodes, sig, from, cb) {\n  var self = this\n  var pending = nodes.length + 1 + (sig ? 1 : 0)\n  var error = null\n\n  for (var i = 0; i < nodes.length; i++) this._storage.putNode(nodes[i].index, nodes[i], ondone)\n  if (data) this._storage.putData(index, data, nodes, ondone)\n  else ondone()\n  if (sig) this._storage.putSignature(sig.index, sig.signature, ondone)\n\n  function ondone (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n    self._writeDone(index, data, nodes, from, cb)\n  }\n}\n\nFeed.prototype._writeDone = function (index, data, nodes, from, cb) {\n  for (var i = 0; i < nodes.length; i++) this.tree.set(nodes[i].index)\n  this.tree.set(2 * index)\n\n  if (data) {\n    if (this.bitfield.set(index, true)) {\n      if (this._stats) {\n        this._stats.downloadedBlocks += 1\n        this._stats.downloadedBytes += data.length\n      }\n      this.emit('download', index, data, from)\n    }\n    if (this.peers.length) this._announce({ start: index }, from)\n\n    if (!this.writable) {\n      if (!this._synced) this._synced = this.bitfield.iterator(0, this.length)\n      if (this._synced.next() === -1) {\n        this._synced.range(0, this.length)\n        this._synced.seek(0)\n        if (this._synced.next() === -1) {\n          this.emit('sync')\n        }\n      }\n    }\n  }\n\n  this._sync(null, cb)\n}\n\nFeed.prototype._verifyAndWrite = function (index, data, proof, localNodes, trustedNode, from, cb) {\n  var visited = []\n  var remoteNodes = proof.nodes\n  var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift()\n\n  // check if we already have the hash for this node\n  if (verifyNode(trustedNode, top)) {\n    this._write(index, data, visited, null, from, cb)\n    return\n  }\n\n  // keep hashing with siblings until we reach or trusted node\n  while (true) {\n    var node = null\n    var next = flat.sibling(top.index)\n\n    if (remoteNodes.length && remoteNodes[0].index === next) {\n      node = remoteNodes.shift()\n      visited.push(node)\n    } else if (localNodes.length && localNodes[0].index === next) {\n      node = localNodes.shift()\n    } else {\n      // we cannot create another parent, i.e. these nodes must be roots in the tree\n      this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb)\n      return\n    }\n\n    visited.push(top)\n    top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size)\n\n    // the tree checks out, write the data and the visited nodes\n    if (verifyNode(trustedNode, top)) {\n      this._write(index, data, visited, null, from, cb)\n      return\n    }\n  }\n}\n\nFeed.prototype._verifyRootsAndWrite = function (index, data, top, proof, nodes, from, cb) {\n  var remoteNodes = proof.nodes\n  var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index\n  var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2\n  var length = verifiedBy / 2\n  var self = this\n\n  this._getRootsToVerify(verifiedBy, top, remoteNodes, function (err, roots, extraNodes) {\n    if (err) return cb(err)\n\n    var checksum = crypto.signable(roots, length)\n    var signature = null\n\n    if (self.length && self.live && !proof.signature) {\n      return cb(new Error('Remote did not include a signature'))\n    }\n\n    if (proof.signature) { // check signatures\n      verifyCompat(self, checksum, proof.signature, function (err, valid) {\n        if (err) return cb(err)\n        if (!valid) return cb(new Error('Remote signature could not be verified'))\n\n        signature = { index: verifiedBy / 2 - 1, signature: proof.signature }\n        write()\n      })\n    } else { // check tree root\n      if (Buffer.compare(checksum.slice(0, 32), self.key) !== 0) {\n        return cb(new Error('Remote checksum failed'))\n      }\n\n      write()\n    }\n\n    function write () {\n      self.live = !!signature\n\n      if (length > self.length) {\n        // TODO: only emit this after the info has been flushed to storage\n        if (self.writable) self._merkle = null // We need to reload merkle state now\n        self.length = length\n        self._seq = length\n        self.byteLength = roots.reduce(addSize, 0)\n        if (self._synced) self._synced.seek(0, self.length)\n        self.emit('append')\n      }\n\n      self._write(index, data, nodes.concat(extraNodes), signature, from, cb)\n    }\n  })\n}\n\nFeed.prototype._getRootsToVerify = function (verifiedBy, top, remoteNodes, cb) {\n  var indexes = flat.fullRoots(verifiedBy)\n  var roots = new Array(indexes.length)\n  var nodes = []\n  var error = null\n  var pending = roots.length\n\n  for (var i = 0; i < indexes.length; i++) {\n    if (indexes[i] === top.index) {\n      nodes.push(top)\n      onnode(null, top)\n    } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {\n      nodes.push(remoteNodes[0])\n      onnode(null, remoteNodes.shift())\n    } else if (this.tree.get(indexes[i])) {\n      this._storage.getNode(indexes[i], onnode)\n    } else {\n      onnode(new Error('Missing tree roots needed for verify'))\n    }\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) roots[indexes.indexOf(node.index)] = node\n    if (!--pending) done(error)\n  }\n\n  function done (err) {\n    if (err) return cb(err)\n\n    cb(null, roots, nodes)\n  }\n}\n\nFeed.prototype._announce = function (message, from) {\n  for (var i = 0; i < this.peers.length; i++) {\n    var peer = this.peers[i]\n    if (peer !== from) peer.have(message)\n  }\n}\n\nFeed.prototype._unannounce = function (message) {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].unhave(message)\n}\n\nFeed.prototype.downloaded = function (start, end, cb) {\n  const count = this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, count) // prepare async interface for this\n  return count\n}\n\nFeed.prototype.has = function (start, end, cb) {\n  if (typeof end === 'function') return this.has(start, undefined, end)\n  if (end === undefined) {\n    const res = this.bitfield.get(start)\n    if (cb) process.nextTick(cb, null, res)\n    return res\n  }\n  const total = end - start\n  const res = total === this.bitfield.total(start, end)\n  if (cb) process.nextTick(cb, null, res)\n  return res\n}\n\nFeed.prototype.getBlockInfo = function (index, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._storage.getNode(2 * index, cb)\n  })\n}\n\nFeed.prototype.head = function (opts, cb) {\n  if (typeof opts === 'function') return this.head({}, opts)\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    if (opts && opts.update) self.update(opts, onupdate)\n    else process.nextTick(onupdate)\n  })\n\n  function onupdate () {\n    if (self.length === 0) cb(new Error('feed is empty'))\n    else self.get(self.length - 1, opts, cb)\n  }\n}\n\nFeed.prototype.get = function (index, opts, cb) {\n  if (typeof opts === 'function') return this.get(index, null, opts)\n\n  opts = { ...opts }\n  if (!opts.cancel) opts.cancel = Symbol('hypercore-get')\n\n  if (!this.opened) return this._readyAndGet(index, opts, cb)\n\n  if (!this.readable) {\n    process.nextTick(cb, new Error('Feed is closed'))\n    return opts.cancel\n  }\n\n  if (opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  if (!this.bitfield.get(index)) {\n    if (opts && opts.wait === false) return process.nextTick(cb, new Error('Block not downloaded'))\n\n    var w = { bytes: 0, hash: false, index: index, options: opts, requested: 0, callback: cb }\n    this._waiting.push(w)\n\n    if (opts && typeof opts.ifAvailable === 'boolean' ? opts.ifAvailable : this._alwaysIfAvailable) this._ifAvailableGet(w)\n\n    this._updatePeers()\n    if (opts.onwait) {\n      const onwait = opts.onwait\n      opts.onwait = null\n      onwait(index)\n    }\n    return opts.cancel\n  }\n\n  if (opts && opts.valueEncoding) cb = wrapCodec(toCodec(opts.valueEncoding), cb)\n  else if (this._codec !== codecs.binary) cb = wrapCodec(this._codec, cb)\n\n  this._getBuffer(index, cb)\n  return opts.cancel\n}\n\nFeed.prototype._readyAndGet = function (index, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.get(index, opts, cb)\n  })\n  return opts.cancel\n}\n\nFeed.prototype.getBatch = function (start, end, opts, cb) {\n  if (typeof opts === 'function') return this.getBatch(start, end, null, opts)\n  if (!this.opened) return this._readyAndGetBatch(start, end, opts, cb)\n\n  var self = this\n  var wait = !opts || opts.wait !== false\n\n  if (this.has(start, end)) return this._getBatch(start, end, opts, cb)\n  if (!wait) return process.nextTick(cb, new Error('Block not downloaded'))\n\n  if (opts && opts.timeout) cb = timeoutCallback(cb, opts.timeout)\n\n  this.download({ start: start, end: end }, function (err) {\n    if (err) return cb(err)\n    self._getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._getBatch = function (start, end, opts, cb) {\n  var enc = opts && opts.valueEncoding\n  var codec = enc ? toCodec(enc) : this._codec\n\n  this._storage.getDataBatch(start, end - start, onbatch)\n\n  function onbatch (err, buffers) {\n    if (err) return cb(err)\n\n    var batch = new Array(buffers.length)\n\n    for (var i = 0; i < buffers.length; i++) {\n      try {\n        batch[i] = codec ? codec.decode(buffers[i]) : buffers[i]\n      } catch (err) {\n        return cb(err)\n      }\n    }\n\n    cb(null, batch)\n  }\n}\n\nFeed.prototype._readyAndGetBatch = function (start, end, opts, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self.getBatch(start, end, opts, cb)\n  })\n}\n\nFeed.prototype._updatePeers = function () {\n  for (var i = 0; i < this.peers.length; i++) this.peers[i].update()\n}\n\nFeed.prototype.createWriteStream = function (opts) {\n  return new WriteStream(this, opts)\n}\n\nFeed.prototype.createReadStream = function (opts) {\n  return new ReadStream(this, opts)\n}\n\n// TODO: when calling finalize on a live feed write an END_OF_FEED block (length === 0?)\nFeed.prototype.finalize = function (cb) {\n  if (!this.key) {\n    this.key = crypto.tree(this._merkle.roots)\n    this.discoveryKey = crypto.discoveryKey(this.key)\n  }\n  this._storage.key.write(0, this.key, cb)\n}\n\nFeed.prototype.append = function (batch, cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var list = Array.isArray(batch) ? batch : [batch]\n  this._batch(list, onappend)\n\n  function onappend (err) {\n    if (err) return cb(err)\n    var seq = self._seq\n    self._seq += list.length\n    cb(null, seq)\n  }\n}\n\nFeed.prototype.flush = function (cb) {\n  this.append([], cb)\n}\n\nFeed.prototype.destroyStorage = function (cb) {\n  const self = this\n\n  this.close(function (err) {\n    if (err) cb(err)\n    else self._storage.destroy(cb)\n  })\n}\n\nFeed.prototype._close = function (cb) {\n  const self = this\n\n  for (const peer of this.peers) {\n    if (!peer._destroyed) peer._close()\n  }\n\n  this._forceClose(onclose, null)\n\n  function onclose (err) {\n    if (!err) self.emit('close')\n    cb(err)\n  }\n}\n\nFeed.prototype._forceClose = function (cb, error) {\n  var self = this\n\n  this.writable = false\n  this.readable = false\n\n  this._storage.close(function (err) {\n    if (!err) err = error\n    self._destroy(err || new Error('Feed is closed'))\n    cb(err)\n  })\n}\n\nFeed.prototype._destroy = function (err) {\n  this.ifAvailable.destroy()\n\n  while (this._waiting.length) {\n    this._waiting.pop().callback(err)\n  }\n  while (this._selections.length) {\n    this._selections.pop().callback(err)\n  }\n}\n\nFeed.prototype._appendHook = function (batch, cb) {\n  var self = this\n  var missing = batch.length\n  var error = null\n\n  if (!missing) return this._append(batch, cb)\n  for (var i = 0; i < batch.length; i++) {\n    this._onwrite(i + this.length, batch[i], null, done)\n  }\n\n  function done (err) {\n    if (err) error = err\n    if (--missing) return\n    if (error) return cb(error)\n    self._append(batch, cb)\n  }\n}\n\nFeed.prototype._append = function (batch, cb) {\n  if (!this.opened) return this._readyAndAppend(batch, cb)\n  if (!this.writable) return cb(new Error('This feed is not writable. Did you create it?'))\n\n  var self = this\n  var pending = 1\n  var offset = 0\n  var error = null\n  var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0)\n  var nodeOffset = this.length * 2\n  var dataBatch = new Array(batch.length)\n\n  if (!pending) return cb()\n\n  for (var i = 0; i < batch.length; i++) {\n    var data = this._codec.encode(batch[i])\n    var nodes = this._merkle.next(data)\n\n    // the replication stream rejects frames >8MB for DOS defense. Is configurable there, so\n    // we could bubble that up here. For now just hardcode it so you can't accidentally \"brick\" your core\n    // note: this is *only* for individual blocks and is just a sanity check. most blocks are <1MB\n    if (data.length > 8388608) return cb(new Error('Individual blocks has be less than 8MB'))\n\n    offset += data.length\n    dataBatch[i] = data\n\n    for (var j = 0; j < nodes.length; j++) {\n      var node = nodes[j]\n      if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {\n        nodeBatch[node.index - nodeOffset] = node\n      } else {\n        pending++\n        this._storage.putNode(node.index, node, done)\n      }\n    }\n  }\n\n  if (this.live && batch.length) {\n    pending++\n    this.crypto.sign(crypto.signable(this._merkle.roots, self.length + batch.length), this.secretKey, function (err, sig) {\n      if (err) return done(err)\n      self._storage.putSignature(self.length + batch.length - 1, sig, done)\n    })\n  }\n\n  if (!this._indexing) {\n    pending++\n    if (dataBatch.length === 1) this._storage.data.write(this.byteLength, dataBatch[0], done)\n    else this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done)\n  }\n\n  this._storage.putNodeBatch(nodeOffset, nodeBatch, done)\n\n  function done (err) {\n    if (err) error = err\n    if (--pending) return\n    if (error) return cb(error)\n\n    var start = self.length\n\n    // TODO: only emit append and update length / byteLength after the info has been flushed to storage\n    self.byteLength += offset\n    for (var i = 0; i < batch.length; i++) {\n      self.bitfield.set(self.length, true)\n      self.tree.set(2 * self.length++)\n    }\n    self.emit('append')\n\n    var message = self.length - start > 1 ? { start: start, length: self.length - start } : { start: start }\n    if (self.peers.length) self._announce(message)\n\n    self._sync(null, cb)\n  }\n}\n\nFeed.prototype._readyAndAppend = function (batch, cb) {\n  var self = this\n  this.ready(function (err) {\n    if (err) return cb(err)\n    self._append(batch, cb)\n  })\n}\n\nFeed.prototype._readyAndCancel = function (start, end) {\n  var self = this\n  this.ready(function () {\n    self._cancel(start, end)\n  })\n}\n\nFeed.prototype._pollWaiting = function () {\n  var len = this._waiting.length\n\n  for (var i = 0; i < len; i++) {\n    var next = this._waiting[i]\n    if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {\n      continue\n    }\n\n    remove(this._waiting, i--)\n    len--\n\n    if (next.bytes) this.seek(next.bytes, next, next.callback)\n    else if (next.update) this.update(next.index + 1, next.callback)\n    else this.get(next.index, next.options, next.callback)\n  }\n}\n\nFeed.prototype._syncBitfield = function (cb) {\n  var missing = this.bitfield.pages.updates.length\n  var next = null\n  var error = null\n\n  // All data / nodes have been written now. We still need to update the bitfields though\n\n  // TODO 1: if the program fails during this write the bitfield might not have been fully written\n  // HOWEVER, we can easily recover from this by traversing the tree and checking if the nodes exists\n  // on disk. So if a get fails, it should try and recover once.\n\n  // TODO 2: if .writable append bitfield updates into a single buffer for extra perf\n  // Added benefit is that if the program exits while flushing the bitfield the feed will only get\n  // truncated and not have missing chunks which is what you expect.\n\n  if (!missing) {\n    this._pollWaiting()\n    return cb(null)\n  }\n\n  while ((next = this.bitfield.pages.lastUpdate()) !== null) {\n    this._storage.putBitfield(next.offset, next.buffer, ondone)\n  }\n\n  this._pollWaiting()\n\n  function ondone (err) {\n    if (err) error = err\n    if (--missing) return\n    cb(error)\n  }\n}\n\nFeed.prototype._roots = function (index, cb) {\n  var roots = flat.fullRoots(2 * index)\n  var result = new Array(roots.length)\n  var pending = roots.length\n  var error = null\n\n  if (!pending) return cb(null, result)\n\n  for (var i = 0; i < roots.length; i++) {\n    this._storage.getNode(roots[i], onnode)\n  }\n\n  function onnode (err, node) {\n    if (err) error = err\n    if (node) result[roots.indexOf(node.index)] = node\n    if (--pending) return\n    if (error) return cb(error)\n    cb(null, result)\n  }\n}\n\nFeed.prototype.audit = function (cb) {\n  if (!cb) cb = noop\n\n  var self = this\n  var report = {\n    valid: 0,\n    invalid: 0\n  }\n\n  this.ready(function (err) {\n    if (err) return cb(err)\n\n    var block = 0\n    var max = self.length\n\n    next()\n\n    function onnode (err, node) {\n      if (err) return ondata(null, null)\n      self._storage.getData(block, ondata)\n\n      function ondata (_, data) {\n        var verified = data && crypto.data(data).equals(node.hash)\n        if (verified) report.valid++\n        else report.invalid++\n        self.bitfield.set(block, verified)\n        block++\n        next()\n      }\n    }\n\n    function next () {\n      while (block < max && !self.bitfield.get(block)) block++\n      if (block >= max) return done()\n      self._storage.getNode(2 * block, onnode)\n    }\n\n    function done () {\n      self._sync(null, function (err) {\n        if (err) return cb(err)\n        cb(null, report)\n      })\n    }\n  })\n}\n\nFeed.prototype.extension = function (name, message) {\n  var peers = this.peers\n\n  for (var i = 0; i < peers.length; i++) {\n    peers[i].extension(name, message)\n  }\n}\n\nfunction noop () {}\n\nfunction verifyNode (trusted, node) {\n  return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0\n}\n\nfunction addSize (size, node) {\n  return size + node.size\n}\n\nfunction isBlock (index) {\n  return (index & 1) === 0\n}\n\nfunction toCodec (enc) {\n  // Switch to ndjson encoding if JSON is used. That way data files parse like ndjson \\o/\n  return codecs(enc === 'json' ? 'ndjson' : enc)\n}\n\nfunction wrapCodec (enc, cb) {\n  return function (err, buf) {\n    if (err) return cb(err)\n    try {\n      buf = enc.decode(buf)\n    } catch (err) {\n      return cb(err)\n    }\n    cb(null, buf)\n  }\n}\n\nfunction timeoutCallback (cb, timeout) {\n  var failed = false\n  var id = setTimeout(ontimeout, timeout)\n  return done\n\n  function ontimeout () {\n    failed = true\n    // TODO: make libs/errors for all this stuff\n    var err = new Error('ETIMEDOUT')\n    err.code = 'ETIMEDOUT'\n    cb(err)\n  }\n\n  function done (err, val) {\n    if (failed) return\n    clearTimeout(id)\n    cb(err, val)\n  }\n}\n\nfunction toWantRange (i) {\n  return Math.floor(i / 1024 / 1024) * 1024 * 1024\n}\n\nfunction createError (code, errno, msg) {\n  var err = new Error(msg)\n  err.code = code\n  err.errno = errno\n  return err\n}\n\nfunction defaultStorageDir (directory) {\n  return function (name) {\n    return defaultStorage(name, { directory })\n  }\n}\n\nfunction isOptions (initiator) {\n  return !Protocol.isProtocolStream(initiator) &&\n    typeof initiator === 'object' &&\n    !!initiator &&\n    typeof initiator.initiator === 'boolean'\n}\n\nfunction readyNT (ifAvailable, fn) {\n  ifAvailable.ready(fn)\n}\n\nfunction verifyCompat (self, checksum, signature, cb) {\n  self.crypto.verify(checksum, signature, self.key, function (err, valid) {\n    if (err || valid) return cb(err, valid)\n    // compat mode, will be removed in a later version\n    self.crypto.verify(checksum.slice(0, 32), signature, self.key, cb)\n  })\n}\n\nexport default hypercore;\nexport { hypercore as __moduleExports };","start":1670465471870,"end":1670465471902,"order":"normal"}]}
