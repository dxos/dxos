{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/decoder.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(\"./enum\"),\n    types   = require(\"./types\"),\n    util    = require(\"./util\");\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i:\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\");\n    // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","start":1670465470524,"end":1670465470622},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(\"./enum\"),\n    types   = require(\"./types\"),\n    util    = require(\"./util\");\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i:\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\");\n    // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","start":1670465470622,"end":1670465470622,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/types.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar decoder_1;\nvar hasRequiredDecoder;\n\nfunction requireDecoder () {\n\tif (hasRequiredDecoder) return decoder_1;\n\thasRequiredDecoder = 1;\n\t\"use strict\";\n\tdecoder_1 = decoder;\n\n\tvar Enum    = require$$0(),\n\t    types   = require$$1(),\n\t    util    = require$$2();\n\n\tfunction missing(field) {\n\t    return \"missing required '\" + field.name + \"'\";\n\t}\n\n\t/**\n\t * Generates a decoder specific to the specified message type.\n\t * @param {Type} mtype Message type\n\t * @returns {Codegen} Codegen instance\n\t */\n\tfunction decoder(mtype) {\n\t    /* eslint-disable no-unexpected-multiline */\n\t    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n\t    (\"if(!(r instanceof Reader))\")\n\t        (\"r=Reader.create(r)\")\n\t    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n\t    (\"while(r.pos<c){\")\n\t        (\"var t=r.uint32()\");\n\t    if (mtype.group) gen\n\t        (\"if((t&7)===4)\")\n\t            (\"break\");\n\t    gen\n\t        (\"switch(t>>>3){\");\n\n\t    var i = 0;\n\t    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n\t        var field = mtype._fieldsArray[i].resolve(),\n\t            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n\t            ref   = \"m\" + util.safeProp(field.name); gen\n\t            (\"case %i:\", field.id);\n\n\t        // Map fields\n\t        if (field.map) { gen\n\t                (\"if(%s===util.emptyObject)\", ref)\n\t                    (\"%s={}\", ref)\n\t                (\"var c2 = r.uint32()+r.pos\");\n\n\t            if (types.defaults[field.keyType] !== undefined) gen\n\t                (\"k=%j\", types.defaults[field.keyType]);\n\t            else gen\n\t                (\"k=null\");\n\n\t            if (types.defaults[type] !== undefined) gen\n\t                (\"value=%j\", types.defaults[type]);\n\t            else gen\n\t                (\"value=null\");\n\n\t            gen\n\t                (\"while(r.pos<c2){\")\n\t                    (\"var tag2=r.uint32()\")\n\t                    (\"switch(tag2>>>3){\")\n\t                        (\"case 1: k=r.%s(); break\", field.keyType)\n\t                        (\"case 2:\");\n\n\t            if (types.basic[type] === undefined) gen\n\t                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n\t            else gen\n\t                            (\"value=r.%s()\", type);\n\n\t            gen\n\t                            (\"break\")\n\t                        (\"default:\")\n\t                            (\"r.skipType(tag2&7)\")\n\t                            (\"break\")\n\t                    (\"}\")\n\t                (\"}\");\n\n\t            if (types.long[field.keyType] !== undefined) gen\n\t                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n\t            else gen\n\t                (\"%s[k]=value\", ref);\n\n\t        // Repeated fields\n\t        } else if (field.repeated) { gen\n\n\t                (\"if(!(%s&&%s.length))\", ref, ref)\n\t                    (\"%s=[]\", ref);\n\n\t            // Packable (always check for forward and backward compatiblity)\n\t            if (types.packed[type] !== undefined) gen\n\t                (\"if((t&7)===2){\")\n\t                    (\"var c2=r.uint32()+r.pos\")\n\t                    (\"while(r.pos<c2)\")\n\t                        (\"%s.push(r.%s())\", ref, type)\n\t                (\"}else\");\n\n\t            // Non-packed\n\t            if (types.basic[type] === undefined) gen(field.resolvedType.group\n\t                    ? \"%s.push(types[%i].decode(r))\"\n\t                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n\t            else gen\n\t                    (\"%s.push(r.%s())\", ref, type);\n\n\t        // Non-repeated\n\t        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n\t                ? \"%s=types[%i].decode(r)\"\n\t                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n\t        else gen\n\t                (\"%s=r.%s()\", ref, type);\n\t        gen\n\t                (\"break\");\n\t    // Unknown fields\n\t    } gen\n\t            (\"default:\")\n\t                (\"r.skipType(t&7)\")\n\t                (\"break\")\n\n\t        (\"}\")\n\t    (\"}\");\n\n\t    // Field presence\n\t    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n\t        var rfield = mtype._fieldsArray[i];\n\t        if (rfield.required) gen\n\t    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n\t        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n\t    }\n\n\t    return gen\n\t    (\"return m\");\n\t    /* eslint-enable no-unexpected-multiline */\n\t}\n\treturn decoder_1;\n}\n\nexport { requireDecoder as __require };","start":1670465470623,"end":1670465471407,"order":"normal"}]}
