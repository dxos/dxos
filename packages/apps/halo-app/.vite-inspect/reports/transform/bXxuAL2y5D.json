{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/buffer-json.js","transforms":[{"name":"vite:load-fallback","result":"function iterate (x, decode) {\n  if (typeof x !== 'object') {\n    if (decode && Object.prototype.toString.call(x) === '[object String]' && x.startsWith('base64:')) {\n      return Buffer.from(x.slice('base64:'.length), 'base64')\n    }\n    return x\n  }\n\n  let k\n  let tmp\n  const type = Object.prototype.toString.call(x)\n\n  if (!decode && type === '[object Uint8Array]' && Buffer.isBuffer(x)) {\n    return 'base64:' + Buffer.from(x).toString('base64')\n  }\n\n  if (type === '[object Object]') {\n    tmp = {}\n    for (k in x) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  if (type === '[object Array]') {\n    k = x.length\n    for (tmp = Array(k); k--;) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  return x\n}\n\nmodule.exports = {\n  _lastObj: null,\n  _lastStr: null,\n  _lastLength: null,\n  encode (obj, buf, offset) {\n    let str\n    let length\n\n    if (this._lastObj === obj) {\n      str = this._lastStr\n      length = this._lastLength\n    } else {\n      str = JSON.stringify(iterate({ data: obj }))\n      length = Buffer.byteLength(str, 'utf8')\n    }\n\n    buf.write(str, offset, length, 'utf8')\n    this._lastObj = null\n    this._lastStr = null\n    this._lastLength = null\n    return buf.slice(offset, offset + length)\n  },\n  decode (buf, start, end) {\n    start = start || 0\n    end = end || buf.length\n    return iterate(JSON.parse(buf.slice(start, end)), true).data\n  },\n  encodingLength (obj) {\n    this._lastObj = obj\n    this._lastStr = JSON.stringify(iterate({ data: obj }))\n    this._lastLength = Buffer.byteLength(this._lastStr, 'utf8')\n    return this._lastLength\n  }\n}\n","start":1670465469293,"end":1670465469542},{"name":"vite:react-babel","result":"function iterate (x, decode) {\n  if (typeof x !== 'object') {\n    if (decode && Object.prototype.toString.call(x) === '[object String]' && x.startsWith('base64:')) {\n      return Buffer.from(x.slice('base64:'.length), 'base64')\n    }\n    return x\n  }\n\n  let k\n  let tmp\n  const type = Object.prototype.toString.call(x)\n\n  if (!decode && type === '[object Uint8Array]' && Buffer.isBuffer(x)) {\n    return 'base64:' + Buffer.from(x).toString('base64')\n  }\n\n  if (type === '[object Object]') {\n    tmp = {}\n    for (k in x) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  if (type === '[object Array]') {\n    k = x.length\n    for (tmp = Array(k); k--;) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  return x\n}\n\nmodule.exports = {\n  _lastObj: null,\n  _lastStr: null,\n  _lastLength: null,\n  encode (obj, buf, offset) {\n    let str\n    let length\n\n    if (this._lastObj === obj) {\n      str = this._lastStr\n      length = this._lastLength\n    } else {\n      str = JSON.stringify(iterate({ data: obj }))\n      length = Buffer.byteLength(str, 'utf8')\n    }\n\n    buf.write(str, offset, length, 'utf8')\n    this._lastObj = null\n    this._lastStr = null\n    this._lastLength = null\n    return buf.slice(offset, offset + length)\n  },\n  decode (buf, start, end) {\n    start = start || 0\n    end = end || buf.length\n    return iterate(JSON.parse(buf.slice(start, end)), true).data\n  },\n  encodingLength (obj) {\n    this._lastObj = obj\n    this._lastStr = JSON.stringify(iterate({ data: obj }))\n    this._lastLength = Buffer.byteLength(this._lastStr, 'utf8')\n    return this._lastLength\n  }\n}\n","start":1670465469542,"end":1670465469542,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nfunction iterate (x, decode) {\n  if (typeof x !== 'object') {\n    if (decode && Object.prototype.toString.call(x) === '[object String]' && x.startsWith('base64:')) {\n      return Buffer.from(x.slice('base64:'.length), 'base64')\n    }\n    return x\n  }\n\n  let k\n  let tmp\n  const type = Object.prototype.toString.call(x)\n\n  if (!decode && type === '[object Uint8Array]' && Buffer.isBuffer(x)) {\n    return 'base64:' + Buffer.from(x).toString('base64')\n  }\n\n  if (type === '[object Object]') {\n    tmp = {}\n    for (k in x) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  if (type === '[object Array]') {\n    k = x.length\n    for (tmp = Array(k); k--;) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  return x\n}\n\nvar bufferJson = {\n  _lastObj: null,\n  _lastStr: null,\n  _lastLength: null,\n  encode (obj, buf, offset) {\n    let str\n    let length\n\n    if (this._lastObj === obj) {\n      str = this._lastStr\n      length = this._lastLength\n    } else {\n      str = JSON.stringify(iterate({ data: obj }))\n      length = Buffer.byteLength(str, 'utf8')\n    }\n\n    buf.write(str, offset, length, 'utf8')\n    this._lastObj = null\n    this._lastStr = null\n    this._lastLength = null\n    return buf.slice(offset, offset + length)\n  },\n  decode (buf, start, end) {\n    start = start || 0\n    end = end || buf.length\n    return iterate(JSON.parse(buf.slice(start, end)), true).data\n  },\n  encodingLength (obj) {\n    this._lastObj = obj\n    this._lastStr = JSON.stringify(iterate({ data: obj }))\n    this._lastLength = Buffer.byteLength(this._lastStr, 'utf8')\n    return this._lastLength\n  }\n}\n\nexport default bufferJson;\nexport { bufferJson as __moduleExports };","start":1670465469542,"end":1670465469545,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nfunction iterate (x, decode) {\n  if (typeof x !== 'object') {\n    if (decode && Object.prototype.toString.call(x) === '[object String]' && x.startsWith('base64:')) {\n      return Buffer.from(x.slice('base64:'.length), 'base64')\n    }\n    return x\n  }\n\n  let k\n  let tmp\n  const type = Object.prototype.toString.call(x)\n\n  if (!decode && type === '[object Uint8Array]' && Buffer.isBuffer(x)) {\n    return 'base64:' + Buffer.from(x).toString('base64')\n  }\n\n  if (type === '[object Object]') {\n    tmp = {}\n    for (k in x) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  if (type === '[object Array]') {\n    k = x.length\n    for (tmp = Array(k); k--;) {\n      tmp[k] = iterate(x[k], decode)\n    }\n    return tmp\n  }\n\n  return x\n}\n\nvar bufferJson = {\n  _lastObj: null,\n  _lastStr: null,\n  _lastLength: null,\n  encode (obj, buf, offset) {\n    let str\n    let length\n\n    if (this._lastObj === obj) {\n      str = this._lastStr\n      length = this._lastLength\n    } else {\n      str = JSON.stringify(iterate({ data: obj }))\n      length = Buffer.byteLength(str, 'utf8')\n    }\n\n    buf.write(str, offset, length, 'utf8')\n    this._lastObj = null\n    this._lastStr = null\n    this._lastLength = null\n    return buf.slice(offset, offset + length)\n  },\n  decode (buf, start, end) {\n    start = start || 0\n    end = end || buf.length\n    return iterate(JSON.parse(buf.slice(start, end)), true).data\n  },\n  encodingLength (obj) {\n    this._lastObj = obj\n    this._lastStr = JSON.stringify(iterate({ data: obj }))\n    this._lastLength = Buffer.byteLength(this._lastStr, 'utf8')\n    return this._lastLength\n  }\n}\n\nexport default bufferJson;\nexport { bufferJson as __moduleExports };","start":1670465469545,"end":1670465469548,"order":"normal"}]}
