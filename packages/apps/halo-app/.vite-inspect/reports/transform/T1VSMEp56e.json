{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/util/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/util/src/binder.ts\nimport util from \"@dxos/node-std/util\";\nvar createBinder = (obj) => ({\n  fn: (fn) => fn.bind(obj),\n  async: (fn) => util.promisify(fn.bind(obj))\n});\n\n// packages/common/util/src/callback.ts\nimport assert from \"@dxos/node-std/assert\";\nvar Callback = class {\n  call(...args) {\n    assert(this._callback, \"Callback not set\");\n    return this._callback(...args);\n  }\n  callIfSet(...args) {\n    var _a;\n    return (_a = this._callback) == null ? void 0 : _a.call(this, ...args);\n  }\n  set(callback) {\n    assert(!this._callback, \"Callback already set\");\n    this._callback = callback;\n  }\n  isSet() {\n    return !!this._callback;\n  }\n};\nvar createSetDispatch = ({ handlers }) => {\n  return new Proxy({\n    handlers\n  }, {\n    get: (target, prop) => {\n      return (...args) => {\n        handlers.forEach((handler) => {\n          const method = handler[prop];\n          if (method) {\n            method.apply(handler, args);\n          }\n        });\n      };\n    }\n  });\n};\n\n// packages/common/util/src/complex.ts\nimport { raise } from \"@dxos/debug\";\nvar ComplexSet = class {\n  constructor(_projection, values) {\n    this._projection = _projection;\n    this._values = /* @__PURE__ */ new Map();\n    if (values) {\n      for (const value of values) {\n        this.add(value);\n      }\n    }\n  }\n  add(value) {\n    this._values.set(this._projection(value), value);\n    return this;\n  }\n  clear() {\n    this._values.clear();\n  }\n  delete(value) {\n    return this._values.delete(this._projection(value));\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._values.forEach((value) => callbackfn(value, value, this));\n  }\n  has(value) {\n    return this._values.has(this._projection(value));\n  }\n  get size() {\n    return this._values.size;\n  }\n  [Symbol.iterator]() {\n    return this._values.values();\n  }\n  *entries() {\n    for (const value of this._values.values()) {\n      yield [\n        value,\n        value\n      ];\n    }\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexSet\";\n  }\n};\nvar makeSet = (projection) => class BoundComplexSet extends ComplexSet {\n  constructor(values) {\n    super(projection, values);\n  }\n};\nvar ComplexMap = class {\n  constructor(_keyProjection, entries) {\n    this._keyProjection = _keyProjection;\n    this._keys = /* @__PURE__ */ new Map();\n    this._values = /* @__PURE__ */ new Map();\n    if (entries) {\n      for (const [key, value] of entries) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this._keys.clear();\n    this._values.clear();\n  }\n  delete(key) {\n    const keyDeleted = this._keys.delete(this._keyProjection(key));\n    const valueDeleted = this._values.delete(this._keyProjection(key));\n    return keyDeleted || valueDeleted;\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._keys.forEach((key, primitive) => {\n      var _a;\n      return callbackfn((_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\")), key, this);\n    });\n  }\n  get(key) {\n    return this._values.get(this._keyProjection(key));\n  }\n  has(key) {\n    return this._keys.has(this._keyProjection(key));\n  }\n  set(key, value) {\n    const primitive = this._keyProjection(key);\n    this._keys.set(primitive, key);\n    this._values.set(primitive, value);\n    return this;\n  }\n  get size() {\n    return this._keys.size;\n  }\n  *[Symbol.iterator]() {\n    var _a;\n    for (const [primitive, key] of this._keys) {\n      const value = (_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\"));\n      yield [\n        key,\n        value\n      ];\n    }\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  keys() {\n    return this._keys.values();\n  }\n  values() {\n    return this._values.values();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexMap\";\n  }\n};\nvar makeMap = (keyProjection) => class BoundComplexMap extends ComplexMap {\n  constructor(entries) {\n    super(keyProjection, entries);\n  }\n};\n\n// packages/common/util/src/default-map.ts\nvar defaultMap = (map, def) => (key) => {\n  let value = map.get(key);\n  if (value === void 0) {\n    value = def();\n    map.set(key, value);\n  }\n  return value;\n};\n\n// packages/common/util/src/human-hash.ts\nimport { PublicKey } from \"@dxos/keys\";\nvar DEFAULT_WORDLIST = [\n  \"ack\",\n  \"alabama\",\n  \"alanine\",\n  \"alaska\",\n  \"alpha\",\n  \"angel\",\n  \"apart\",\n  \"april\",\n  \"arizona\",\n  \"arkansas\",\n  \"artist\",\n  \"asparagus\",\n  \"aspen\",\n  \"august\",\n  \"autumn\",\n  \"avocado\",\n  \"bacon\",\n  \"bakerloo\",\n  \"batman\",\n  \"beer\",\n  \"berlin\",\n  \"beryllium\",\n  \"black\",\n  \"blossom\",\n  \"blue\",\n  \"bluebird\",\n  \"bravo\",\n  \"bulldog\",\n  \"burger\",\n  \"butter\",\n  \"california\",\n  \"carbon\",\n  \"cardinal\",\n  \"carolina\",\n  \"carpet\",\n  \"cat\",\n  \"ceiling\",\n  \"charlie\",\n  \"chicken\",\n  \"coffee\",\n  \"cola\",\n  \"cold\",\n  \"colorado\",\n  \"comet\",\n  \"connecticut\",\n  \"crazy\",\n  \"cup\",\n  \"dakota\",\n  \"december\",\n  \"delaware\",\n  \"delta\",\n  \"diet\",\n  \"don\",\n  \"double\",\n  \"early\",\n  \"earth\",\n  \"east\",\n  \"echo\",\n  \"edward\",\n  \"eight\",\n  \"eighteen\",\n  \"eleven\",\n  \"emma\",\n  \"enemy\",\n  \"equal\",\n  \"failed\",\n  \"fanta\",\n  \"fifteen\",\n  \"fillet\",\n  \"finch\",\n  \"fish\",\n  \"five\",\n  \"fix\",\n  \"floor\",\n  \"florida\",\n  \"football\",\n  \"four\",\n  \"fourteen\",\n  \"foxtrot\",\n  \"freddie\",\n  \"friend\",\n  \"fruit\",\n  \"gee\",\n  \"georgia\",\n  \"glucose\",\n  \"golf\",\n  \"green\",\n  \"grey\",\n  \"hamper\",\n  \"happy\",\n  \"harry\",\n  \"hawaii\",\n  \"helium\",\n  \"high\",\n  \"hot\",\n  \"hotel\",\n  \"hydrogen\",\n  \"idaho\",\n  \"illinois\",\n  \"india\",\n  \"indigo\",\n  \"ink\",\n  \"iowa\",\n  \"island\",\n  \"item\",\n  \"jersey\",\n  \"jig\",\n  \"johnny\",\n  \"juliet\",\n  \"july\",\n  \"jupiter\",\n  \"kansas\",\n  \"kentucky\",\n  \"kilo\",\n  \"king\",\n  \"kitten\",\n  \"lactose\",\n  \"lake\",\n  \"lamp\",\n  \"lemon\",\n  \"leopard\",\n  \"lima\",\n  \"lion\",\n  \"lithium\",\n  \"london\",\n  \"louisiana\",\n  \"low\",\n  \"magazine\",\n  \"magnesium\",\n  \"maine\",\n  \"mango\",\n  \"march\",\n  \"mars\",\n  \"maryland\",\n  \"massachusetts\",\n  \"may\",\n  \"mexico\",\n  \"michigan\",\n  \"mike\",\n  \"minnesota\",\n  \"mirror\",\n  \"mississippi\",\n  \"missouri\",\n  \"mobile\",\n  \"mockingbird\",\n  \"monkey\",\n  \"montana\",\n  \"moon\",\n  \"mountain\",\n  \"muppet\",\n  \"music\",\n  \"nebraska\",\n  \"neptune\",\n  \"network\",\n  \"nevada\",\n  \"nine\",\n  \"nineteen\",\n  \"nitrogen\",\n  \"north\",\n  \"november\",\n  \"nuts\",\n  \"october\",\n  \"ohio\",\n  \"oklahoma\",\n  \"one\",\n  \"orange\",\n  \"oranges\",\n  \"oregon\",\n  \"oscar\",\n  \"oven\",\n  \"oxygen\",\n  \"papa\",\n  \"paris\",\n  \"pasta\",\n  \"pennsylvania\",\n  \"pip\",\n  \"pizza\",\n  \"pluto\",\n  \"potato\",\n  \"princess\",\n  \"purple\",\n  \"quebec\",\n  \"queen\",\n  \"quiet\",\n  \"red\",\n  \"river\",\n  \"robert\",\n  \"robin\",\n  \"romeo\",\n  \"rugby\",\n  \"sad\",\n  \"salami\",\n  \"saturn\",\n  \"september\",\n  \"seven\",\n  \"seventeen\",\n  \"shade\",\n  \"sierra\",\n  \"single\",\n  \"sink\",\n  \"six\",\n  \"sixteen\",\n  \"skylark\",\n  \"snake\",\n  \"social\",\n  \"sodium\",\n  \"solar\",\n  \"south\",\n  \"spaghetti\",\n  \"speaker\",\n  \"spring\",\n  \"stairway\",\n  \"steak\",\n  \"stream\",\n  \"summer\",\n  \"sweet\",\n  \"table\",\n  \"tango\",\n  \"ten\",\n  \"tennessee\",\n  \"tennis\",\n  \"texas\",\n  \"thirteen\",\n  \"three\",\n  \"timing\",\n  \"triple\",\n  \"twelve\",\n  \"twenty\",\n  \"two\",\n  \"uncle\",\n  \"undress\",\n  \"uniform\",\n  \"uranus\",\n  \"utah\",\n  \"vegan\",\n  \"venus\",\n  \"vermont\",\n  \"victor\",\n  \"video\",\n  \"violet\",\n  \"virginia\",\n  \"washington\",\n  \"west\",\n  \"whiskey\",\n  \"white\",\n  \"william\",\n  \"winner\",\n  \"winter\",\n  \"wisconsin\",\n  \"wolfram\",\n  \"wyoming\",\n  \"xray\",\n  \"yankee\",\n  \"yellow\",\n  \"zebra\",\n  \"zulu\"\n];\nvar HumanHasher = class {\n  constructor(wordlist = DEFAULT_WORDLIST) {\n    this.wordlist = wordlist;\n    if (wordlist.length !== 256) {\n      throw new Error(\"Wordlist must have exactly 256 items\");\n    }\n    this.wordlist = wordlist;\n  }\n  humanize(hexdigest, words = 4, separator = \"-\") {\n    const pairs = hexdigest.match(/(..?)/g);\n    if (!pairs) {\n      throw new Error(\"\");\n    }\n    const bytes = pairs.map((x) => parseInt(x, 16));\n    const compressed = this._compress(bytes, words);\n    return compressed.map((x) => this.wordlist[x]).join(separator);\n  }\n  _compress(bytes, target) {\n    const length = bytes.length;\n    if (target > length) {\n      throw new Error(\"Fewer input bytes than requested output\");\n    }\n    const segSize = length / target >> 0;\n    const segments = [];\n    for (let i = 0; i < segSize * target; i += segSize) {\n      segments.push(bytes.slice(i, i + segSize));\n    }\n    segments[segments.length - 1] = segments[segments.length - 1].concat(bytes.slice(target * segSize));\n    const checksums = segments.map((x) => x.reduce((acc, curr) => acc ^ curr));\n    return checksums;\n  }\n};\nvar hasher = new HumanHasher();\nvar humanize = (value) => {\n  if (value instanceof Buffer || value instanceof Uint8Array) {\n    value = PublicKey.stringify(value);\n  } else if (value instanceof PublicKey) {\n    value = value.toHex();\n  }\n  return hasher.humanize(value);\n};\n\n// packages/common/util/src/interval.ts\nvar exponentialBackoffInterval = (cb, initialInterval) => {\n  let interval = initialInterval;\n  const repeat = () => {\n    cb();\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n  let timeoutId = setTimeout(repeat, interval);\n  return () => clearTimeout(timeoutId);\n};\n\n// packages/common/util/src/json.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nfunction jsonReplacer(key, value) {\n  if (value !== null && typeof value === \"object\" && typeof value[inspect.custom] === \"function\") {\n    return value[inspect.custom]();\n  }\n  if (value !== null && typeof value === \"object\" && value.type === \"Buffer\" && Array.isArray(value.data)) {\n    if (value.data.length === 32) {\n      const key1 = Buffer.from(value.data);\n      return `[${humanize(key1)}]:[${PublicKey2.stringify(key1)}]`;\n    } else {\n      return Buffer.from(value.data).toString(\"hex\");\n    }\n  }\n  return value;\n}\n\n// packages/common/util/src/map.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar LazyMap = class extends Map {\n  constructor(_initFn) {\n    super();\n    this._initFn = _initFn;\n  }\n  getOrInit(key) {\n    assert2(key);\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      const value = this._initFn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// packages/common/util/src/platform.ts\nvar isNode = () => typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n\n// packages/common/util/src/random.ts\nvar randomInt = (max, min) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n// packages/common/util/src/range.ts\nvar range = (n) => Array.from(Array(n).keys());\n\n// packages/common/util/src/types.ts\nvar boolGuard = (value) => Boolean(value);\nvar isNotNullOrUndefined = (x) => x != null;\nvar getAsyncValue = async (value) => {\n  if (typeof value === \"function\") {\n    return value();\n  } else {\n    return value;\n  }\n};\n\n// packages/common/util/src/uint8array.ts\nvar arraysEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// packages/common/util/src/safe-instanceof.ts\nvar instanceTag = Symbol(\"instanceTag\");\nvar safeInstanceof = (tag) => (target) => {\n  target.prototype[instanceTag] = tag;\n  Object.defineProperty(target.prototype, Symbol.hasInstance, {\n    value: (instance) => instance[instanceTag] === tag\n  });\n};\nexport {\n  Callback,\n  ComplexMap,\n  ComplexSet,\n  HumanHasher,\n  LazyMap,\n  arraysEqual,\n  boolGuard,\n  createBinder,\n  createSetDispatch,\n  defaultMap,\n  exponentialBackoffInterval,\n  getAsyncValue,\n  humanize,\n  isNode,\n  isNotNullOrUndefined,\n  jsonReplacer,\n  makeMap,\n  makeSet,\n  randomInt,\n  range,\n  safeInstanceof\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465438903,"end":1670465440537},{"name":"vite:react-babel","result":"// packages/common/util/src/binder.ts\nimport util from \"@dxos/node-std/util\";\nvar createBinder = (obj) => ({\n  fn: (fn) => fn.bind(obj),\n  async: (fn) => util.promisify(fn.bind(obj))\n});\n\n// packages/common/util/src/callback.ts\nimport assert from \"@dxos/node-std/assert\";\nvar Callback = class {\n  call(...args) {\n    assert(this._callback, \"Callback not set\");\n    return this._callback(...args);\n  }\n  callIfSet(...args) {\n    var _a;\n    return (_a = this._callback) == null ? void 0 : _a.call(this, ...args);\n  }\n  set(callback) {\n    assert(!this._callback, \"Callback already set\");\n    this._callback = callback;\n  }\n  isSet() {\n    return !!this._callback;\n  }\n};\nvar createSetDispatch = ({ handlers }) => {\n  return new Proxy({\n    handlers\n  }, {\n    get: (target, prop) => {\n      return (...args) => {\n        handlers.forEach((handler) => {\n          const method = handler[prop];\n          if (method) {\n            method.apply(handler, args);\n          }\n        });\n      };\n    }\n  });\n};\n\n// packages/common/util/src/complex.ts\nimport { raise } from \"@dxos/debug\";\nvar ComplexSet = class {\n  constructor(_projection, values) {\n    this._projection = _projection;\n    this._values = /* @__PURE__ */ new Map();\n    if (values) {\n      for (const value of values) {\n        this.add(value);\n      }\n    }\n  }\n  add(value) {\n    this._values.set(this._projection(value), value);\n    return this;\n  }\n  clear() {\n    this._values.clear();\n  }\n  delete(value) {\n    return this._values.delete(this._projection(value));\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._values.forEach((value) => callbackfn(value, value, this));\n  }\n  has(value) {\n    return this._values.has(this._projection(value));\n  }\n  get size() {\n    return this._values.size;\n  }\n  [Symbol.iterator]() {\n    return this._values.values();\n  }\n  *entries() {\n    for (const value of this._values.values()) {\n      yield [\n        value,\n        value\n      ];\n    }\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexSet\";\n  }\n};\nvar makeSet = (projection) => class BoundComplexSet extends ComplexSet {\n  constructor(values) {\n    super(projection, values);\n  }\n};\nvar ComplexMap = class {\n  constructor(_keyProjection, entries) {\n    this._keyProjection = _keyProjection;\n    this._keys = /* @__PURE__ */ new Map();\n    this._values = /* @__PURE__ */ new Map();\n    if (entries) {\n      for (const [key, value] of entries) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this._keys.clear();\n    this._values.clear();\n  }\n  delete(key) {\n    const keyDeleted = this._keys.delete(this._keyProjection(key));\n    const valueDeleted = this._values.delete(this._keyProjection(key));\n    return keyDeleted || valueDeleted;\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._keys.forEach((key, primitive) => {\n      var _a;\n      return callbackfn((_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\")), key, this);\n    });\n  }\n  get(key) {\n    return this._values.get(this._keyProjection(key));\n  }\n  has(key) {\n    return this._keys.has(this._keyProjection(key));\n  }\n  set(key, value) {\n    const primitive = this._keyProjection(key);\n    this._keys.set(primitive, key);\n    this._values.set(primitive, value);\n    return this;\n  }\n  get size() {\n    return this._keys.size;\n  }\n  *[Symbol.iterator]() {\n    var _a;\n    for (const [primitive, key] of this._keys) {\n      const value = (_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\"));\n      yield [\n        key,\n        value\n      ];\n    }\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  keys() {\n    return this._keys.values();\n  }\n  values() {\n    return this._values.values();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexMap\";\n  }\n};\nvar makeMap = (keyProjection) => class BoundComplexMap extends ComplexMap {\n  constructor(entries) {\n    super(keyProjection, entries);\n  }\n};\n\n// packages/common/util/src/default-map.ts\nvar defaultMap = (map, def) => (key) => {\n  let value = map.get(key);\n  if (value === void 0) {\n    value = def();\n    map.set(key, value);\n  }\n  return value;\n};\n\n// packages/common/util/src/human-hash.ts\nimport { PublicKey } from \"@dxos/keys\";\nvar DEFAULT_WORDLIST = [\n  \"ack\",\n  \"alabama\",\n  \"alanine\",\n  \"alaska\",\n  \"alpha\",\n  \"angel\",\n  \"apart\",\n  \"april\",\n  \"arizona\",\n  \"arkansas\",\n  \"artist\",\n  \"asparagus\",\n  \"aspen\",\n  \"august\",\n  \"autumn\",\n  \"avocado\",\n  \"bacon\",\n  \"bakerloo\",\n  \"batman\",\n  \"beer\",\n  \"berlin\",\n  \"beryllium\",\n  \"black\",\n  \"blossom\",\n  \"blue\",\n  \"bluebird\",\n  \"bravo\",\n  \"bulldog\",\n  \"burger\",\n  \"butter\",\n  \"california\",\n  \"carbon\",\n  \"cardinal\",\n  \"carolina\",\n  \"carpet\",\n  \"cat\",\n  \"ceiling\",\n  \"charlie\",\n  \"chicken\",\n  \"coffee\",\n  \"cola\",\n  \"cold\",\n  \"colorado\",\n  \"comet\",\n  \"connecticut\",\n  \"crazy\",\n  \"cup\",\n  \"dakota\",\n  \"december\",\n  \"delaware\",\n  \"delta\",\n  \"diet\",\n  \"don\",\n  \"double\",\n  \"early\",\n  \"earth\",\n  \"east\",\n  \"echo\",\n  \"edward\",\n  \"eight\",\n  \"eighteen\",\n  \"eleven\",\n  \"emma\",\n  \"enemy\",\n  \"equal\",\n  \"failed\",\n  \"fanta\",\n  \"fifteen\",\n  \"fillet\",\n  \"finch\",\n  \"fish\",\n  \"five\",\n  \"fix\",\n  \"floor\",\n  \"florida\",\n  \"football\",\n  \"four\",\n  \"fourteen\",\n  \"foxtrot\",\n  \"freddie\",\n  \"friend\",\n  \"fruit\",\n  \"gee\",\n  \"georgia\",\n  \"glucose\",\n  \"golf\",\n  \"green\",\n  \"grey\",\n  \"hamper\",\n  \"happy\",\n  \"harry\",\n  \"hawaii\",\n  \"helium\",\n  \"high\",\n  \"hot\",\n  \"hotel\",\n  \"hydrogen\",\n  \"idaho\",\n  \"illinois\",\n  \"india\",\n  \"indigo\",\n  \"ink\",\n  \"iowa\",\n  \"island\",\n  \"item\",\n  \"jersey\",\n  \"jig\",\n  \"johnny\",\n  \"juliet\",\n  \"july\",\n  \"jupiter\",\n  \"kansas\",\n  \"kentucky\",\n  \"kilo\",\n  \"king\",\n  \"kitten\",\n  \"lactose\",\n  \"lake\",\n  \"lamp\",\n  \"lemon\",\n  \"leopard\",\n  \"lima\",\n  \"lion\",\n  \"lithium\",\n  \"london\",\n  \"louisiana\",\n  \"low\",\n  \"magazine\",\n  \"magnesium\",\n  \"maine\",\n  \"mango\",\n  \"march\",\n  \"mars\",\n  \"maryland\",\n  \"massachusetts\",\n  \"may\",\n  \"mexico\",\n  \"michigan\",\n  \"mike\",\n  \"minnesota\",\n  \"mirror\",\n  \"mississippi\",\n  \"missouri\",\n  \"mobile\",\n  \"mockingbird\",\n  \"monkey\",\n  \"montana\",\n  \"moon\",\n  \"mountain\",\n  \"muppet\",\n  \"music\",\n  \"nebraska\",\n  \"neptune\",\n  \"network\",\n  \"nevada\",\n  \"nine\",\n  \"nineteen\",\n  \"nitrogen\",\n  \"north\",\n  \"november\",\n  \"nuts\",\n  \"october\",\n  \"ohio\",\n  \"oklahoma\",\n  \"one\",\n  \"orange\",\n  \"oranges\",\n  \"oregon\",\n  \"oscar\",\n  \"oven\",\n  \"oxygen\",\n  \"papa\",\n  \"paris\",\n  \"pasta\",\n  \"pennsylvania\",\n  \"pip\",\n  \"pizza\",\n  \"pluto\",\n  \"potato\",\n  \"princess\",\n  \"purple\",\n  \"quebec\",\n  \"queen\",\n  \"quiet\",\n  \"red\",\n  \"river\",\n  \"robert\",\n  \"robin\",\n  \"romeo\",\n  \"rugby\",\n  \"sad\",\n  \"salami\",\n  \"saturn\",\n  \"september\",\n  \"seven\",\n  \"seventeen\",\n  \"shade\",\n  \"sierra\",\n  \"single\",\n  \"sink\",\n  \"six\",\n  \"sixteen\",\n  \"skylark\",\n  \"snake\",\n  \"social\",\n  \"sodium\",\n  \"solar\",\n  \"south\",\n  \"spaghetti\",\n  \"speaker\",\n  \"spring\",\n  \"stairway\",\n  \"steak\",\n  \"stream\",\n  \"summer\",\n  \"sweet\",\n  \"table\",\n  \"tango\",\n  \"ten\",\n  \"tennessee\",\n  \"tennis\",\n  \"texas\",\n  \"thirteen\",\n  \"three\",\n  \"timing\",\n  \"triple\",\n  \"twelve\",\n  \"twenty\",\n  \"two\",\n  \"uncle\",\n  \"undress\",\n  \"uniform\",\n  \"uranus\",\n  \"utah\",\n  \"vegan\",\n  \"venus\",\n  \"vermont\",\n  \"victor\",\n  \"video\",\n  \"violet\",\n  \"virginia\",\n  \"washington\",\n  \"west\",\n  \"whiskey\",\n  \"white\",\n  \"william\",\n  \"winner\",\n  \"winter\",\n  \"wisconsin\",\n  \"wolfram\",\n  \"wyoming\",\n  \"xray\",\n  \"yankee\",\n  \"yellow\",\n  \"zebra\",\n  \"zulu\"\n];\nvar HumanHasher = class {\n  constructor(wordlist = DEFAULT_WORDLIST) {\n    this.wordlist = wordlist;\n    if (wordlist.length !== 256) {\n      throw new Error(\"Wordlist must have exactly 256 items\");\n    }\n    this.wordlist = wordlist;\n  }\n  humanize(hexdigest, words = 4, separator = \"-\") {\n    const pairs = hexdigest.match(/(..?)/g);\n    if (!pairs) {\n      throw new Error(\"\");\n    }\n    const bytes = pairs.map((x) => parseInt(x, 16));\n    const compressed = this._compress(bytes, words);\n    return compressed.map((x) => this.wordlist[x]).join(separator);\n  }\n  _compress(bytes, target) {\n    const length = bytes.length;\n    if (target > length) {\n      throw new Error(\"Fewer input bytes than requested output\");\n    }\n    const segSize = length / target >> 0;\n    const segments = [];\n    for (let i = 0; i < segSize * target; i += segSize) {\n      segments.push(bytes.slice(i, i + segSize));\n    }\n    segments[segments.length - 1] = segments[segments.length - 1].concat(bytes.slice(target * segSize));\n    const checksums = segments.map((x) => x.reduce((acc, curr) => acc ^ curr));\n    return checksums;\n  }\n};\nvar hasher = new HumanHasher();\nvar humanize = (value) => {\n  if (value instanceof Buffer || value instanceof Uint8Array) {\n    value = PublicKey.stringify(value);\n  } else if (value instanceof PublicKey) {\n    value = value.toHex();\n  }\n  return hasher.humanize(value);\n};\n\n// packages/common/util/src/interval.ts\nvar exponentialBackoffInterval = (cb, initialInterval) => {\n  let interval = initialInterval;\n  const repeat = () => {\n    cb();\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n  let timeoutId = setTimeout(repeat, interval);\n  return () => clearTimeout(timeoutId);\n};\n\n// packages/common/util/src/json.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nfunction jsonReplacer(key, value) {\n  if (value !== null && typeof value === \"object\" && typeof value[inspect.custom] === \"function\") {\n    return value[inspect.custom]();\n  }\n  if (value !== null && typeof value === \"object\" && value.type === \"Buffer\" && Array.isArray(value.data)) {\n    if (value.data.length === 32) {\n      const key1 = Buffer.from(value.data);\n      return `[${humanize(key1)}]:[${PublicKey2.stringify(key1)}]`;\n    } else {\n      return Buffer.from(value.data).toString(\"hex\");\n    }\n  }\n  return value;\n}\n\n// packages/common/util/src/map.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar LazyMap = class extends Map {\n  constructor(_initFn) {\n    super();\n    this._initFn = _initFn;\n  }\n  getOrInit(key) {\n    assert2(key);\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      const value = this._initFn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// packages/common/util/src/platform.ts\nvar isNode = () => typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n\n// packages/common/util/src/random.ts\nvar randomInt = (max, min) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n// packages/common/util/src/range.ts\nvar range = (n) => Array.from(Array(n).keys());\n\n// packages/common/util/src/types.ts\nvar boolGuard = (value) => Boolean(value);\nvar isNotNullOrUndefined = (x) => x != null;\nvar getAsyncValue = async (value) => {\n  if (typeof value === \"function\") {\n    return value();\n  } else {\n    return value;\n  }\n};\n\n// packages/common/util/src/uint8array.ts\nvar arraysEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// packages/common/util/src/safe-instanceof.ts\nvar instanceTag = Symbol(\"instanceTag\");\nvar safeInstanceof = (tag) => (target) => {\n  target.prototype[instanceTag] = tag;\n  Object.defineProperty(target.prototype, Symbol.hasInstance, {\n    value: (instance) => instance[instanceTag] === tag\n  });\n};\nexport {\n  Callback,\n  ComplexMap,\n  ComplexSet,\n  HumanHasher,\n  LazyMap,\n  arraysEqual,\n  boolGuard,\n  createBinder,\n  createSetDispatch,\n  defaultMap,\n  exponentialBackoffInterval,\n  getAsyncValue,\n  humanize,\n  isNode,\n  isNotNullOrUndefined,\n  jsonReplacer,\n  makeMap,\n  makeSet,\n  randomInt,\n  range,\n  safeInstanceof\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440537,"end":1670465440537,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport { default as process } from '\u0000polyfill-node.process';\n\n// packages/common/util/src/binder.ts\nimport util from \"@dxos/node-std/util\";\nvar createBinder = (obj) => ({\n  fn: (fn) => fn.bind(obj),\n  async: (fn) => util.promisify(fn.bind(obj))\n});\n\n// packages/common/util/src/callback.ts\nimport assert from \"@dxos/node-std/assert\";\nvar Callback = class {\n  call(...args) {\n    assert(this._callback, \"Callback not set\");\n    return this._callback(...args);\n  }\n  callIfSet(...args) {\n    var _a;\n    return (_a = this._callback) == null ? void 0 : _a.call(this, ...args);\n  }\n  set(callback) {\n    assert(!this._callback, \"Callback already set\");\n    this._callback = callback;\n  }\n  isSet() {\n    return !!this._callback;\n  }\n};\nvar createSetDispatch = ({ handlers }) => {\n  return new Proxy({\n    handlers\n  }, {\n    get: (target, prop) => {\n      return (...args) => {\n        handlers.forEach((handler) => {\n          const method = handler[prop];\n          if (method) {\n            method.apply(handler, args);\n          }\n        });\n      };\n    }\n  });\n};\n\n// packages/common/util/src/complex.ts\nimport { raise } from \"@dxos/debug\";\nvar ComplexSet = class {\n  constructor(_projection, values) {\n    this._projection = _projection;\n    this._values = /* @__PURE__ */ new Map();\n    if (values) {\n      for (const value of values) {\n        this.add(value);\n      }\n    }\n  }\n  add(value) {\n    this._values.set(this._projection(value), value);\n    return this;\n  }\n  clear() {\n    this._values.clear();\n  }\n  delete(value) {\n    return this._values.delete(this._projection(value));\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._values.forEach((value) => callbackfn(value, value, this));\n  }\n  has(value) {\n    return this._values.has(this._projection(value));\n  }\n  get size() {\n    return this._values.size;\n  }\n  [Symbol.iterator]() {\n    return this._values.values();\n  }\n  *entries() {\n    for (const value of this._values.values()) {\n      yield [\n        value,\n        value\n      ];\n    }\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexSet\";\n  }\n};\nvar makeSet = (projection) => class BoundComplexSet extends ComplexSet {\n  constructor(values) {\n    super(projection, values);\n  }\n};\nvar ComplexMap = class {\n  constructor(_keyProjection, entries) {\n    this._keyProjection = _keyProjection;\n    this._keys = /* @__PURE__ */ new Map();\n    this._values = /* @__PURE__ */ new Map();\n    if (entries) {\n      for (const [key, value] of entries) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this._keys.clear();\n    this._values.clear();\n  }\n  delete(key) {\n    const keyDeleted = this._keys.delete(this._keyProjection(key));\n    const valueDeleted = this._values.delete(this._keyProjection(key));\n    return keyDeleted || valueDeleted;\n  }\n  forEach(callbackfn, thisArg) {\n    if (thisArg) {\n      callbackfn = callbackfn.bind(thisArg);\n    }\n    this._keys.forEach((key, primitive) => {\n      var _a;\n      return callbackfn((_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\")), key, this);\n    });\n  }\n  get(key) {\n    return this._values.get(this._keyProjection(key));\n  }\n  has(key) {\n    return this._keys.has(this._keyProjection(key));\n  }\n  set(key, value) {\n    const primitive = this._keyProjection(key);\n    this._keys.set(primitive, key);\n    this._values.set(primitive, value);\n    return this;\n  }\n  get size() {\n    return this._keys.size;\n  }\n  *[Symbol.iterator]() {\n    var _a;\n    for (const [primitive, key] of this._keys) {\n      const value = (_a = this._values.get(primitive)) != null ? _a : raise(new Error(\"Map corrupted.\"));\n      yield [\n        key,\n        value\n      ];\n    }\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  keys() {\n    return this._keys.values();\n  }\n  values() {\n    return this._values.values();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ComplexMap\";\n  }\n};\nvar makeMap = (keyProjection) => class BoundComplexMap extends ComplexMap {\n  constructor(entries) {\n    super(keyProjection, entries);\n  }\n};\n\n// packages/common/util/src/default-map.ts\nvar defaultMap = (map, def) => (key) => {\n  let value = map.get(key);\n  if (value === void 0) {\n    value = def();\n    map.set(key, value);\n  }\n  return value;\n};\n\n// packages/common/util/src/human-hash.ts\nimport { PublicKey } from \"@dxos/keys\";\nvar DEFAULT_WORDLIST = [\n  \"ack\",\n  \"alabama\",\n  \"alanine\",\n  \"alaska\",\n  \"alpha\",\n  \"angel\",\n  \"apart\",\n  \"april\",\n  \"arizona\",\n  \"arkansas\",\n  \"artist\",\n  \"asparagus\",\n  \"aspen\",\n  \"august\",\n  \"autumn\",\n  \"avocado\",\n  \"bacon\",\n  \"bakerloo\",\n  \"batman\",\n  \"beer\",\n  \"berlin\",\n  \"beryllium\",\n  \"black\",\n  \"blossom\",\n  \"blue\",\n  \"bluebird\",\n  \"bravo\",\n  \"bulldog\",\n  \"burger\",\n  \"butter\",\n  \"california\",\n  \"carbon\",\n  \"cardinal\",\n  \"carolina\",\n  \"carpet\",\n  \"cat\",\n  \"ceiling\",\n  \"charlie\",\n  \"chicken\",\n  \"coffee\",\n  \"cola\",\n  \"cold\",\n  \"colorado\",\n  \"comet\",\n  \"connecticut\",\n  \"crazy\",\n  \"cup\",\n  \"dakota\",\n  \"december\",\n  \"delaware\",\n  \"delta\",\n  \"diet\",\n  \"don\",\n  \"double\",\n  \"early\",\n  \"earth\",\n  \"east\",\n  \"echo\",\n  \"edward\",\n  \"eight\",\n  \"eighteen\",\n  \"eleven\",\n  \"emma\",\n  \"enemy\",\n  \"equal\",\n  \"failed\",\n  \"fanta\",\n  \"fifteen\",\n  \"fillet\",\n  \"finch\",\n  \"fish\",\n  \"five\",\n  \"fix\",\n  \"floor\",\n  \"florida\",\n  \"football\",\n  \"four\",\n  \"fourteen\",\n  \"foxtrot\",\n  \"freddie\",\n  \"friend\",\n  \"fruit\",\n  \"gee\",\n  \"georgia\",\n  \"glucose\",\n  \"golf\",\n  \"green\",\n  \"grey\",\n  \"hamper\",\n  \"happy\",\n  \"harry\",\n  \"hawaii\",\n  \"helium\",\n  \"high\",\n  \"hot\",\n  \"hotel\",\n  \"hydrogen\",\n  \"idaho\",\n  \"illinois\",\n  \"india\",\n  \"indigo\",\n  \"ink\",\n  \"iowa\",\n  \"island\",\n  \"item\",\n  \"jersey\",\n  \"jig\",\n  \"johnny\",\n  \"juliet\",\n  \"july\",\n  \"jupiter\",\n  \"kansas\",\n  \"kentucky\",\n  \"kilo\",\n  \"king\",\n  \"kitten\",\n  \"lactose\",\n  \"lake\",\n  \"lamp\",\n  \"lemon\",\n  \"leopard\",\n  \"lima\",\n  \"lion\",\n  \"lithium\",\n  \"london\",\n  \"louisiana\",\n  \"low\",\n  \"magazine\",\n  \"magnesium\",\n  \"maine\",\n  \"mango\",\n  \"march\",\n  \"mars\",\n  \"maryland\",\n  \"massachusetts\",\n  \"may\",\n  \"mexico\",\n  \"michigan\",\n  \"mike\",\n  \"minnesota\",\n  \"mirror\",\n  \"mississippi\",\n  \"missouri\",\n  \"mobile\",\n  \"mockingbird\",\n  \"monkey\",\n  \"montana\",\n  \"moon\",\n  \"mountain\",\n  \"muppet\",\n  \"music\",\n  \"nebraska\",\n  \"neptune\",\n  \"network\",\n  \"nevada\",\n  \"nine\",\n  \"nineteen\",\n  \"nitrogen\",\n  \"north\",\n  \"november\",\n  \"nuts\",\n  \"october\",\n  \"ohio\",\n  \"oklahoma\",\n  \"one\",\n  \"orange\",\n  \"oranges\",\n  \"oregon\",\n  \"oscar\",\n  \"oven\",\n  \"oxygen\",\n  \"papa\",\n  \"paris\",\n  \"pasta\",\n  \"pennsylvania\",\n  \"pip\",\n  \"pizza\",\n  \"pluto\",\n  \"potato\",\n  \"princess\",\n  \"purple\",\n  \"quebec\",\n  \"queen\",\n  \"quiet\",\n  \"red\",\n  \"river\",\n  \"robert\",\n  \"robin\",\n  \"romeo\",\n  \"rugby\",\n  \"sad\",\n  \"salami\",\n  \"saturn\",\n  \"september\",\n  \"seven\",\n  \"seventeen\",\n  \"shade\",\n  \"sierra\",\n  \"single\",\n  \"sink\",\n  \"six\",\n  \"sixteen\",\n  \"skylark\",\n  \"snake\",\n  \"social\",\n  \"sodium\",\n  \"solar\",\n  \"south\",\n  \"spaghetti\",\n  \"speaker\",\n  \"spring\",\n  \"stairway\",\n  \"steak\",\n  \"stream\",\n  \"summer\",\n  \"sweet\",\n  \"table\",\n  \"tango\",\n  \"ten\",\n  \"tennessee\",\n  \"tennis\",\n  \"texas\",\n  \"thirteen\",\n  \"three\",\n  \"timing\",\n  \"triple\",\n  \"twelve\",\n  \"twenty\",\n  \"two\",\n  \"uncle\",\n  \"undress\",\n  \"uniform\",\n  \"uranus\",\n  \"utah\",\n  \"vegan\",\n  \"venus\",\n  \"vermont\",\n  \"victor\",\n  \"video\",\n  \"violet\",\n  \"virginia\",\n  \"washington\",\n  \"west\",\n  \"whiskey\",\n  \"white\",\n  \"william\",\n  \"winner\",\n  \"winter\",\n  \"wisconsin\",\n  \"wolfram\",\n  \"wyoming\",\n  \"xray\",\n  \"yankee\",\n  \"yellow\",\n  \"zebra\",\n  \"zulu\"\n];\nvar HumanHasher = class {\n  constructor(wordlist = DEFAULT_WORDLIST) {\n    this.wordlist = wordlist;\n    if (wordlist.length !== 256) {\n      throw new Error(\"Wordlist must have exactly 256 items\");\n    }\n    this.wordlist = wordlist;\n  }\n  humanize(hexdigest, words = 4, separator = \"-\") {\n    const pairs = hexdigest.match(/(..?)/g);\n    if (!pairs) {\n      throw new Error(\"\");\n    }\n    const bytes = pairs.map((x) => parseInt(x, 16));\n    const compressed = this._compress(bytes, words);\n    return compressed.map((x) => this.wordlist[x]).join(separator);\n  }\n  _compress(bytes, target) {\n    const length = bytes.length;\n    if (target > length) {\n      throw new Error(\"Fewer input bytes than requested output\");\n    }\n    const segSize = length / target >> 0;\n    const segments = [];\n    for (let i = 0; i < segSize * target; i += segSize) {\n      segments.push(bytes.slice(i, i + segSize));\n    }\n    segments[segments.length - 1] = segments[segments.length - 1].concat(bytes.slice(target * segSize));\n    const checksums = segments.map((x) => x.reduce((acc, curr) => acc ^ curr));\n    return checksums;\n  }\n};\nvar hasher = new HumanHasher();\nvar humanize = (value) => {\n  if (value instanceof Buffer || value instanceof Uint8Array) {\n    value = PublicKey.stringify(value);\n  } else if (value instanceof PublicKey) {\n    value = value.toHex();\n  }\n  return hasher.humanize(value);\n};\n\n// packages/common/util/src/interval.ts\nvar exponentialBackoffInterval = (cb, initialInterval) => {\n  let interval = initialInterval;\n  const repeat = () => {\n    cb();\n    interval *= 2;\n    timeoutId = setTimeout(repeat, interval);\n  };\n  let timeoutId = setTimeout(repeat, interval);\n  return () => clearTimeout(timeoutId);\n};\n\n// packages/common/util/src/json.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nfunction jsonReplacer(key, value) {\n  if (value !== null && typeof value === \"object\" && typeof value[inspect.custom] === \"function\") {\n    return value[inspect.custom]();\n  }\n  if (value !== null && typeof value === \"object\" && value.type === \"Buffer\" && Array.isArray(value.data)) {\n    if (value.data.length === 32) {\n      const key1 = Buffer.from(value.data);\n      return `[${humanize(key1)}]:[${PublicKey2.stringify(key1)}]`;\n    } else {\n      return Buffer.from(value.data).toString(\"hex\");\n    }\n  }\n  return value;\n}\n\n// packages/common/util/src/map.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar LazyMap = class extends Map {\n  constructor(_initFn) {\n    super();\n    this._initFn = _initFn;\n  }\n  getOrInit(key) {\n    assert2(key);\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      const value = this._initFn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// packages/common/util/src/platform.ts\nvar isNode = () => typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n\n// packages/common/util/src/random.ts\nvar randomInt = (max, min) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n// packages/common/util/src/range.ts\nvar range = (n) => Array.from(Array(n).keys());\n\n// packages/common/util/src/types.ts\nvar boolGuard = (value) => Boolean(value);\nvar isNotNullOrUndefined = (x) => x != null;\nvar getAsyncValue = async (value) => {\n  if (typeof value === \"function\") {\n    return value();\n  } else {\n    return value;\n  }\n};\n\n// packages/common/util/src/uint8array.ts\nvar arraysEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// packages/common/util/src/safe-instanceof.ts\nvar instanceTag = Symbol(\"instanceTag\");\nvar safeInstanceof = (tag) => (target) => {\n  target.prototype[instanceTag] = tag;\n  Object.defineProperty(target.prototype, Symbol.hasInstance, {\n    value: (instance) => instance[instanceTag] === tag\n  });\n};\nexport {\n  Callback,\n  ComplexMap,\n  ComplexSet,\n  HumanHasher,\n  LazyMap,\n  arraysEqual,\n  boolGuard,\n  createBinder,\n  createSetDispatch,\n  defaultMap,\n  exponentialBackoffInterval,\n  getAsyncValue,\n  humanize,\n  isNode,\n  isNotNullOrUndefined,\n  jsonReplacer,\n  makeMap,\n  makeSet,\n  randomInt,\n  range,\n  safeInstanceof\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440537,"end":1670465440545,"order":"normal"}]}
