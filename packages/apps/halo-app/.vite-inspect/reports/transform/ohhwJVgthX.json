{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js","transforms":[{"name":"vite:load-fallback","result":"const SH = require('simple-handshake')\nconst DH = require('noise-protocol/dh')\nconst crypto = require('hypercore-crypto')\nconst varint = require('varint')\n\nmodule.exports = class ProtocolHandshake {\n  constructor (initiator, payload, opts, done) {\n    this.options = opts\n    this.ondone = done\n    this.buffer = null\n    this.length = 0\n    this.remotePayload = null\n    this.payload = payload\n    this.keyPair = opts.keyPair || ProtocolHandshake.keyPair()\n    this.remotePublicKey = null\n    this.onrecv = onrecv.bind(this)\n    this.onsend = onsend.bind(this)\n    this.destroyed = false\n    this.noise = SH(initiator, {\n      pattern: 'XX',\n      onhandshake,\n      staticKeyPair: this.keyPair,\n      onstatickey: onstatickey.bind(this)\n    })\n\n    const self = this\n    if (this.noise.waiting === false) process.nextTick(start, this)\n\n    function onhandshake (state, cb) {\n      process.nextTick(finish, self)\n      cb(null)\n    }\n  }\n\n  recv (data) {\n    if (this.destroyed) return\n\n    if (this.buffer) this.buffer = Buffer.concat([this.buffer, data])\n    else this.buffer = data\n\n    while (!this.destroyed && !this.noise.finished) {\n      if (!this.buffer || this.buffer.length < 3) return\n      if (this.length) {\n        if (this.buffer.length < this.length) return\n        const message = this.buffer.slice(0, this.length)\n        this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null\n        this.length = 0\n        this.noise.recv(message, this.onrecv)\n      } else {\n        this.length = varint.decode(this.buffer, 0)\n        this.buffer = this.buffer.slice(varint.decode.bytes)\n      }\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (!this.noise.finished) this.noise.destroy()\n    this.ondone(err)\n  }\n\n  static keyPair (seed) {\n    const obj = {\n      // suboptimal but to reduce secure memory overhead on linux with default settings\n      // better fix is to batch mallocs in noise-protocol\n      publicKey: Buffer.alloc(DH.PKLEN),\n      secretKey: Buffer.alloc(DH.SKLEN)\n    }\n\n    if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed)\n    else DH.generateKeypair(obj.publicKey, obj.secretKey)\n\n    return obj\n  }\n}\n\nfunction finish (self) {\n  if (self.destroyed) return\n  self.destroyed = true\n  // suboptimal but to reduce secure memory overhead on linux with default settings\n  // better fix is to batch mallocs in noise-protocol\n  const split = { rx: Buffer.from(self.noise.split.rx), tx: Buffer.from(self.noise.split.tx) }\n  crypto.free(self.noise.split.rx)\n  crypto.free(self.noise.split.tx)\n  self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash)\n}\n\nfunction start (self) {\n  if (self.destroyed) return\n  self.noise.send(self.payload, self.onsend)\n}\n\nfunction onsend (err, data) {\n  if (err) return this.destroy(err)\n  const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length)\n  varint.encode(data.length, buf, 0)\n  data.copy(buf, varint.encode.bytes)\n  this.options.send(buf)\n}\n\nfunction onrecv (err, data) { // data is reused so we need to copy it if we use it\n  if (err) return this.destroy(err)\n  if (data && data.length) this.remotePayload = Buffer.from(data)\n  if (this.destroyed || this.noise.finished) return\n\n  if (this.noise.waiting === false) {\n    this.noise.send(this.payload, this.onsend)\n  }\n}\n\nfunction onstatickey (remoteKey, done) {\n  this.remotePublicKey = Buffer.from(remoteKey)\n  if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done)\n  else done(null)\n}\n","start":1670465470106,"end":1670465470285},{"name":"vite:react-babel","result":"const SH = require('simple-handshake')\nconst DH = require('noise-protocol/dh')\nconst crypto = require('hypercore-crypto')\nconst varint = require('varint')\n\nmodule.exports = class ProtocolHandshake {\n  constructor (initiator, payload, opts, done) {\n    this.options = opts\n    this.ondone = done\n    this.buffer = null\n    this.length = 0\n    this.remotePayload = null\n    this.payload = payload\n    this.keyPair = opts.keyPair || ProtocolHandshake.keyPair()\n    this.remotePublicKey = null\n    this.onrecv = onrecv.bind(this)\n    this.onsend = onsend.bind(this)\n    this.destroyed = false\n    this.noise = SH(initiator, {\n      pattern: 'XX',\n      onhandshake,\n      staticKeyPair: this.keyPair,\n      onstatickey: onstatickey.bind(this)\n    })\n\n    const self = this\n    if (this.noise.waiting === false) process.nextTick(start, this)\n\n    function onhandshake (state, cb) {\n      process.nextTick(finish, self)\n      cb(null)\n    }\n  }\n\n  recv (data) {\n    if (this.destroyed) return\n\n    if (this.buffer) this.buffer = Buffer.concat([this.buffer, data])\n    else this.buffer = data\n\n    while (!this.destroyed && !this.noise.finished) {\n      if (!this.buffer || this.buffer.length < 3) return\n      if (this.length) {\n        if (this.buffer.length < this.length) return\n        const message = this.buffer.slice(0, this.length)\n        this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null\n        this.length = 0\n        this.noise.recv(message, this.onrecv)\n      } else {\n        this.length = varint.decode(this.buffer, 0)\n        this.buffer = this.buffer.slice(varint.decode.bytes)\n      }\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (!this.noise.finished) this.noise.destroy()\n    this.ondone(err)\n  }\n\n  static keyPair (seed) {\n    const obj = {\n      // suboptimal but to reduce secure memory overhead on linux with default settings\n      // better fix is to batch mallocs in noise-protocol\n      publicKey: Buffer.alloc(DH.PKLEN),\n      secretKey: Buffer.alloc(DH.SKLEN)\n    }\n\n    if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed)\n    else DH.generateKeypair(obj.publicKey, obj.secretKey)\n\n    return obj\n  }\n}\n\nfunction finish (self) {\n  if (self.destroyed) return\n  self.destroyed = true\n  // suboptimal but to reduce secure memory overhead on linux with default settings\n  // better fix is to batch mallocs in noise-protocol\n  const split = { rx: Buffer.from(self.noise.split.rx), tx: Buffer.from(self.noise.split.tx) }\n  crypto.free(self.noise.split.rx)\n  crypto.free(self.noise.split.tx)\n  self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash)\n}\n\nfunction start (self) {\n  if (self.destroyed) return\n  self.noise.send(self.payload, self.onsend)\n}\n\nfunction onsend (err, data) {\n  if (err) return this.destroy(err)\n  const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length)\n  varint.encode(data.length, buf, 0)\n  data.copy(buf, varint.encode.bytes)\n  this.options.send(buf)\n}\n\nfunction onrecv (err, data) { // data is reused so we need to copy it if we use it\n  if (err) return this.destroy(err)\n  if (data && data.length) this.remotePayload = Buffer.from(data)\n  if (this.destroyed || this.noise.finished) return\n\n  if (this.noise.waiting === false) {\n    this.noise.send(this.payload, this.onsend)\n  }\n}\n\nfunction onstatickey (remoteKey, done) {\n  this.remotePublicKey = Buffer.from(remoteKey)\n  if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done)\n  else done(null)\n}\n","start":1670465470285,"end":1670465470285,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst SH = require$$0\nconst DH = require$$1\nconst crypto = require$$2\nconst varint = require$$3\n\nvar handshake = class ProtocolHandshake {\n  constructor (initiator, payload, opts, done) {\n    this.options = opts\n    this.ondone = done\n    this.buffer = null\n    this.length = 0\n    this.remotePayload = null\n    this.payload = payload\n    this.keyPair = opts.keyPair || ProtocolHandshake.keyPair()\n    this.remotePublicKey = null\n    this.onrecv = onrecv.bind(this)\n    this.onsend = onsend.bind(this)\n    this.destroyed = false\n    this.noise = SH(initiator, {\n      pattern: 'XX',\n      onhandshake,\n      staticKeyPair: this.keyPair,\n      onstatickey: onstatickey.bind(this)\n    })\n\n    const self = this\n    if (this.noise.waiting === false) process.nextTick(start, this)\n\n    function onhandshake (state, cb) {\n      process.nextTick(finish, self)\n      cb(null)\n    }\n  }\n\n  recv (data) {\n    if (this.destroyed) return\n\n    if (this.buffer) this.buffer = Buffer.concat([this.buffer, data])\n    else this.buffer = data\n\n    while (!this.destroyed && !this.noise.finished) {\n      if (!this.buffer || this.buffer.length < 3) return\n      if (this.length) {\n        if (this.buffer.length < this.length) return\n        const message = this.buffer.slice(0, this.length)\n        this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null\n        this.length = 0\n        this.noise.recv(message, this.onrecv)\n      } else {\n        this.length = varint.decode(this.buffer, 0)\n        this.buffer = this.buffer.slice(varint.decode.bytes)\n      }\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (!this.noise.finished) this.noise.destroy()\n    this.ondone(err)\n  }\n\n  static keyPair (seed) {\n    const obj = {\n      // suboptimal but to reduce secure memory overhead on linux with default settings\n      // better fix is to batch mallocs in noise-protocol\n      publicKey: Buffer.alloc(DH.PKLEN),\n      secretKey: Buffer.alloc(DH.SKLEN)\n    }\n\n    if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed)\n    else DH.generateKeypair(obj.publicKey, obj.secretKey)\n\n    return obj\n  }\n}\n\nfunction finish (self) {\n  if (self.destroyed) return\n  self.destroyed = true\n  // suboptimal but to reduce secure memory overhead on linux with default settings\n  // better fix is to batch mallocs in noise-protocol\n  const split = { rx: Buffer.from(self.noise.split.rx), tx: Buffer.from(self.noise.split.tx) }\n  crypto.free(self.noise.split.rx)\n  crypto.free(self.noise.split.tx)\n  self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash)\n}\n\nfunction start (self) {\n  if (self.destroyed) return\n  self.noise.send(self.payload, self.onsend)\n}\n\nfunction onsend (err, data) {\n  if (err) return this.destroy(err)\n  const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length)\n  varint.encode(data.length, buf, 0)\n  data.copy(buf, varint.encode.bytes)\n  this.options.send(buf)\n}\n\nfunction onrecv (err, data) { // data is reused so we need to copy it if we use it\n  if (err) return this.destroy(err)\n  if (data && data.length) this.remotePayload = Buffer.from(data)\n  if (this.destroyed || this.noise.finished) return\n\n  if (this.noise.waiting === false) {\n    this.noise.send(this.payload, this.onsend)\n  }\n}\n\nfunction onstatickey (remoteKey, done) {\n  this.remotePublicKey = Buffer.from(remoteKey)\n  if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done)\n  else done(null)\n}\n\nexport default handshake;\nexport { handshake as __moduleExports };","start":1670465470285,"end":1670465471817,"order":"normal"},{"name":"polyfill-node","result":"import { default as process } from '\u0000polyfill-node.process';\n\nimport { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst SH = require$$0\nconst DH = require$$1\nconst crypto = require$$2\nconst varint = require$$3\n\nvar handshake = class ProtocolHandshake {\n  constructor (initiator, payload, opts, done) {\n    this.options = opts\n    this.ondone = done\n    this.buffer = null\n    this.length = 0\n    this.remotePayload = null\n    this.payload = payload\n    this.keyPair = opts.keyPair || ProtocolHandshake.keyPair()\n    this.remotePublicKey = null\n    this.onrecv = onrecv.bind(this)\n    this.onsend = onsend.bind(this)\n    this.destroyed = false\n    this.noise = SH(initiator, {\n      pattern: 'XX',\n      onhandshake,\n      staticKeyPair: this.keyPair,\n      onstatickey: onstatickey.bind(this)\n    })\n\n    const self = this\n    if (this.noise.waiting === false) process.nextTick(start, this)\n\n    function onhandshake (state, cb) {\n      process.nextTick(finish, self)\n      cb(null)\n    }\n  }\n\n  recv (data) {\n    if (this.destroyed) return\n\n    if (this.buffer) this.buffer = Buffer.concat([this.buffer, data])\n    else this.buffer = data\n\n    while (!this.destroyed && !this.noise.finished) {\n      if (!this.buffer || this.buffer.length < 3) return\n      if (this.length) {\n        if (this.buffer.length < this.length) return\n        const message = this.buffer.slice(0, this.length)\n        this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null\n        this.length = 0\n        this.noise.recv(message, this.onrecv)\n      } else {\n        this.length = varint.decode(this.buffer, 0)\n        this.buffer = this.buffer.slice(varint.decode.bytes)\n      }\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (!this.noise.finished) this.noise.destroy()\n    this.ondone(err)\n  }\n\n  static keyPair (seed) {\n    const obj = {\n      // suboptimal but to reduce secure memory overhead on linux with default settings\n      // better fix is to batch mallocs in noise-protocol\n      publicKey: Buffer.alloc(DH.PKLEN),\n      secretKey: Buffer.alloc(DH.SKLEN)\n    }\n\n    if (seed) DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed)\n    else DH.generateKeypair(obj.publicKey, obj.secretKey)\n\n    return obj\n  }\n}\n\nfunction finish (self) {\n  if (self.destroyed) return\n  self.destroyed = true\n  // suboptimal but to reduce secure memory overhead on linux with default settings\n  // better fix is to batch mallocs in noise-protocol\n  const split = { rx: Buffer.from(self.noise.split.rx), tx: Buffer.from(self.noise.split.tx) }\n  crypto.free(self.noise.split.rx)\n  crypto.free(self.noise.split.tx)\n  self.ondone(null, self.remotePayload, split, self.buffer, self.remotePublicKey, self.noise.handshakeHash)\n}\n\nfunction start (self) {\n  if (self.destroyed) return\n  self.noise.send(self.payload, self.onsend)\n}\n\nfunction onsend (err, data) {\n  if (err) return this.destroy(err)\n  const buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length)\n  varint.encode(data.length, buf, 0)\n  data.copy(buf, varint.encode.bytes)\n  this.options.send(buf)\n}\n\nfunction onrecv (err, data) { // data is reused so we need to copy it if we use it\n  if (err) return this.destroy(err)\n  if (data && data.length) this.remotePayload = Buffer.from(data)\n  if (this.destroyed || this.noise.finished) return\n\n  if (this.noise.waiting === false) {\n    this.noise.send(this.payload, this.onsend)\n  }\n}\n\nfunction onstatickey (remoteKey, done) {\n  this.remotePublicKey = Buffer.from(remoteKey)\n  if (this.options.onauthenticate) this.options.onauthenticate(this.remotePublicKey, done)\n  else done(null)\n}\n\nexport default handshake;\nexport { handshake as __moduleExports };","start":1670465471817,"end":1670465471819,"order":"normal"}]}
