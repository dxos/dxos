{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/protocol-plugin-replicator/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/protocol-plugin-replicator/src/replicator-plugin.ts\nimport debug2 from \"debug\";\nimport assert from \"@dxos/node-std/assert\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nimport { schemaJson } from \"@dxos/protocols\";\n\n// packages/core/mesh/protocol-plugin-replicator/src/peer.ts\nimport debug from \"debug\";\nimport { Event } from \"@dxos/async\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar log = debug(\"dxos.replicator.peer\");\nvar Peer = class {\n  constructor(_protocol, _extension) {\n    this._protocol = _protocol;\n    this._extension = _extension;\n    this._feeds = new ComplexMap(PublicKey.hash);\n    this.closed = new Event();\n  }\n  async share(feeds = []) {\n    log(\"share\", feeds);\n    if (!Array.isArray(feeds)) {\n      feeds = [\n        feeds\n      ];\n    }\n    if (feeds.length === 0) {\n      return;\n    }\n    const message = {\n      \"@type\": \"dxos.mesh.protocol.replicator.Container\",\n      type: \"share-feeds\",\n      data: feeds.map(({ key, discoveryKey }) => ({\n        \"@type\": \"dxos.mesh.protocol.replicator.Feed\",\n        key,\n        discoveryKey\n      }))\n    };\n    await this._extension.send(message, {\n      oneway: true\n    });\n  }\n  replicate(feeds = []) {\n    feeds.forEach((feed) => this._replicate(feed));\n  }\n  close() {\n    const { stream } = this._protocol;\n    if (!stream.destroyed) {\n      stream.destroy();\n    }\n    this.closed.emit();\n  }\n  _replicate(feed) {\n    const { stream } = this._protocol;\n    if (stream.destroyed) {\n      log(\"stream destroyed; cannot replicate.\");\n      return false;\n    }\n    if (this._feeds.has(feed.key)) {\n      return true;\n    }\n    feed.replicate(this._protocol.initiator, {\n      stream,\n      live: true\n    });\n    this._feeds.set(feed.key, feed);\n    log(\"stream replicated\", {\n      feedKey: feed.key\n    });\n    return true;\n  }\n};\n\n// packages/core/mesh/protocol-plugin-replicator/src/replicator-plugin.ts\nvar log2 = debug2(\"dxos:protocol-plugin-replicator\");\nvar defaultSubscribe = () => () => {\n};\nvar defaultReplicate = async () => [];\nvar _ReplicatorPlugin = class {\n  constructor({ load, subscribe, replicate }, options) {\n    this._peers = /* @__PURE__ */ new Map();\n    this._options = options != null ? options : {\n      timeout: 1e4\n    };\n    this._load = load;\n    this._subscribe = subscribe != null ? subscribe : defaultSubscribe;\n    this._replicate = replicate != null ? replicate : defaultReplicate;\n  }\n  createExtension() {\n    return new Extension(_ReplicatorPlugin.EXTENSION, {\n      schema: schemaJson,\n      timeout: this._options.timeout\n    }).setInitHandler(this._initHandler.bind(this)).setHandshakeHandler(this._handshakeHandler.bind(this)).setMessageHandler(this._messageHandler.bind(this)).setCloseHandler(this._closeHandler.bind(this)).setFeedHandler(this._feedHandler.bind(this));\n  }\n  async _initHandler(protocol) {\n    const extension = protocol.getExtension(_ReplicatorPlugin.EXTENSION);\n    assert(extension, `Missing '${_ReplicatorPlugin.EXTENSION}' extension in protocol.`);\n    const peer = new Peer(protocol, extension);\n    this._peers.set(protocol, peer);\n  }\n  async _handshakeHandler(protocol) {\n    var _a;\n    const peer = this._peers.get(protocol);\n    const context = protocol.getContext();\n    const { peerId: session } = (_a = protocol.getSession()) != null ? _a : {};\n    const info = {\n      context,\n      session\n    };\n    try {\n      const share = async (feeds2) => {\n        try {\n          await (peer == null ? void 0 : peer.share(feeds2));\n          await this._replicateHandler(protocol, []);\n        } catch (err) {\n          log2(err);\n        }\n      };\n      const unsubscribe = this._subscribe(share, info);\n      peer == null ? void 0 : peer.closed.on(unsubscribe);\n      const feeds = await this._load(info) || [];\n      await share(feeds);\n      await this._replicateHandler(protocol, []);\n    } catch (err) {\n      console.warn(\"Load error: \", err);\n    }\n  }\n  async _messageHandler(protocol, message) {\n    try {\n      const { type, data } = message;\n      switch (type) {\n        case \"share-feeds\": {\n          await this._replicateHandler(protocol, data || []);\n          break;\n        }\n        default: {\n          console.warn(`Invalid type: ${type}`);\n        }\n      }\n    } catch (err) {\n      console.warn(\"Message handler error\", err);\n    }\n  }\n  async _replicateHandler(protocol, data) {\n    var _a;\n    const peer = this._peers.get(protocol);\n    const context = protocol.getContext();\n    const { peerId: session } = (_a = protocol.getSession()) != null ? _a : {};\n    assert(typeof session === \"string\");\n    try {\n      const info = {\n        context,\n        session\n      };\n      const feeds = await this._replicate(data, info);\n      peer == null ? void 0 : peer.replicate(feeds != null ? feeds : []);\n    } catch (err) {\n      console.warn(\"Replicate feeds error\", err);\n    }\n  }\n  async _feedHandler(protocol, discoveryKey) {\n    await this._replicateHandler(protocol, [\n      {\n        discoveryKey\n      }\n    ]);\n  }\n  _closeHandler(protocol) {\n    const peer = this._peers.get(protocol);\n    peer == null ? void 0 : peer.close();\n    this._peers.delete(protocol);\n  }\n};\nvar ReplicatorPlugin = _ReplicatorPlugin;\nReplicatorPlugin.EXTENSION = \"dxos.mesh.protocol.replicator\";\nexport {\n  ReplicatorPlugin\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466967,"end":1670465467032},{"name":"vite:react-babel","result":"// packages/core/mesh/protocol-plugin-replicator/src/replicator-plugin.ts\nimport debug2 from \"debug\";\nimport assert from \"@dxos/node-std/assert\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nimport { schemaJson } from \"@dxos/protocols\";\n\n// packages/core/mesh/protocol-plugin-replicator/src/peer.ts\nimport debug from \"debug\";\nimport { Event } from \"@dxos/async\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar log = debug(\"dxos.replicator.peer\");\nvar Peer = class {\n  constructor(_protocol, _extension) {\n    this._protocol = _protocol;\n    this._extension = _extension;\n    this._feeds = new ComplexMap(PublicKey.hash);\n    this.closed = new Event();\n  }\n  async share(feeds = []) {\n    log(\"share\", feeds);\n    if (!Array.isArray(feeds)) {\n      feeds = [\n        feeds\n      ];\n    }\n    if (feeds.length === 0) {\n      return;\n    }\n    const message = {\n      \"@type\": \"dxos.mesh.protocol.replicator.Container\",\n      type: \"share-feeds\",\n      data: feeds.map(({ key, discoveryKey }) => ({\n        \"@type\": \"dxos.mesh.protocol.replicator.Feed\",\n        key,\n        discoveryKey\n      }))\n    };\n    await this._extension.send(message, {\n      oneway: true\n    });\n  }\n  replicate(feeds = []) {\n    feeds.forEach((feed) => this._replicate(feed));\n  }\n  close() {\n    const { stream } = this._protocol;\n    if (!stream.destroyed) {\n      stream.destroy();\n    }\n    this.closed.emit();\n  }\n  _replicate(feed) {\n    const { stream } = this._protocol;\n    if (stream.destroyed) {\n      log(\"stream destroyed; cannot replicate.\");\n      return false;\n    }\n    if (this._feeds.has(feed.key)) {\n      return true;\n    }\n    feed.replicate(this._protocol.initiator, {\n      stream,\n      live: true\n    });\n    this._feeds.set(feed.key, feed);\n    log(\"stream replicated\", {\n      feedKey: feed.key\n    });\n    return true;\n  }\n};\n\n// packages/core/mesh/protocol-plugin-replicator/src/replicator-plugin.ts\nvar log2 = debug2(\"dxos:protocol-plugin-replicator\");\nvar defaultSubscribe = () => () => {\n};\nvar defaultReplicate = async () => [];\nvar _ReplicatorPlugin = class {\n  constructor({ load, subscribe, replicate }, options) {\n    this._peers = /* @__PURE__ */ new Map();\n    this._options = options != null ? options : {\n      timeout: 1e4\n    };\n    this._load = load;\n    this._subscribe = subscribe != null ? subscribe : defaultSubscribe;\n    this._replicate = replicate != null ? replicate : defaultReplicate;\n  }\n  createExtension() {\n    return new Extension(_ReplicatorPlugin.EXTENSION, {\n      schema: schemaJson,\n      timeout: this._options.timeout\n    }).setInitHandler(this._initHandler.bind(this)).setHandshakeHandler(this._handshakeHandler.bind(this)).setMessageHandler(this._messageHandler.bind(this)).setCloseHandler(this._closeHandler.bind(this)).setFeedHandler(this._feedHandler.bind(this));\n  }\n  async _initHandler(protocol) {\n    const extension = protocol.getExtension(_ReplicatorPlugin.EXTENSION);\n    assert(extension, `Missing '${_ReplicatorPlugin.EXTENSION}' extension in protocol.`);\n    const peer = new Peer(protocol, extension);\n    this._peers.set(protocol, peer);\n  }\n  async _handshakeHandler(protocol) {\n    var _a;\n    const peer = this._peers.get(protocol);\n    const context = protocol.getContext();\n    const { peerId: session } = (_a = protocol.getSession()) != null ? _a : {};\n    const info = {\n      context,\n      session\n    };\n    try {\n      const share = async (feeds2) => {\n        try {\n          await (peer == null ? void 0 : peer.share(feeds2));\n          await this._replicateHandler(protocol, []);\n        } catch (err) {\n          log2(err);\n        }\n      };\n      const unsubscribe = this._subscribe(share, info);\n      peer == null ? void 0 : peer.closed.on(unsubscribe);\n      const feeds = await this._load(info) || [];\n      await share(feeds);\n      await this._replicateHandler(protocol, []);\n    } catch (err) {\n      console.warn(\"Load error: \", err);\n    }\n  }\n  async _messageHandler(protocol, message) {\n    try {\n      const { type, data } = message;\n      switch (type) {\n        case \"share-feeds\": {\n          await this._replicateHandler(protocol, data || []);\n          break;\n        }\n        default: {\n          console.warn(`Invalid type: ${type}`);\n        }\n      }\n    } catch (err) {\n      console.warn(\"Message handler error\", err);\n    }\n  }\n  async _replicateHandler(protocol, data) {\n    var _a;\n    const peer = this._peers.get(protocol);\n    const context = protocol.getContext();\n    const { peerId: session } = (_a = protocol.getSession()) != null ? _a : {};\n    assert(typeof session === \"string\");\n    try {\n      const info = {\n        context,\n        session\n      };\n      const feeds = await this._replicate(data, info);\n      peer == null ? void 0 : peer.replicate(feeds != null ? feeds : []);\n    } catch (err) {\n      console.warn(\"Replicate feeds error\", err);\n    }\n  }\n  async _feedHandler(protocol, discoveryKey) {\n    await this._replicateHandler(protocol, [\n      {\n        discoveryKey\n      }\n    ]);\n  }\n  _closeHandler(protocol) {\n    const peer = this._peers.get(protocol);\n    peer == null ? void 0 : peer.close();\n    this._peers.delete(protocol);\n  }\n};\nvar ReplicatorPlugin = _ReplicatorPlugin;\nReplicatorPlugin.EXTENSION = \"dxos.mesh.protocol.replicator\";\nexport {\n  ReplicatorPlugin\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467033,"end":1670465467033,"order":"pre"}]}
