{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/codec.js","transforms":[{"name":"vite:load-fallback","result":"const varint = require('varint')\nconst BJSON = require('./buffer-json')\nconst { NMSG_ERR_ENCODE, NMSG_ERR_DECODE } = require('./errors')\n\nconst ATTR_RESPONSE = 1\n\nmodule.exports = function createCodec (valueEncoding = BJSON) {\n  return {\n    encode (info) {\n      try {\n        let header = info.id << 1\n        if (info.response) header = header | ATTR_RESPONSE\n        const dataLength = valueEncoding.encodingLength(info.data)\n        const buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength)\n        let offset = 0\n        varint.encode(header, buf, offset)\n        offset += varint.encode.bytes\n        varint.encode(dataLength, buf, offset)\n        offset += varint.encode.bytes\n        valueEncoding.encode(info.data, buf, offset)\n        return buf\n      } catch (err) {\n        throw new NMSG_ERR_ENCODE(err.message)\n      }\n    },\n\n    decode (buf) {\n      try {\n        const request = {}\n        let offset = 0\n        const header = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        const dataLength = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        request.data = valueEncoding.decode(buf, offset, offset + dataLength)\n        request.response = !!(header & ATTR_RESPONSE)\n        request.id = header >> 1\n        return request\n      } catch (err) {\n        throw new NMSG_ERR_DECODE(err.message)\n      }\n    }\n  }\n}\n","start":1670465470124,"end":1670465470318},{"name":"vite:react-babel","result":"const varint = require('varint')\nconst BJSON = require('./buffer-json')\nconst { NMSG_ERR_ENCODE, NMSG_ERR_DECODE } = require('./errors')\n\nconst ATTR_RESPONSE = 1\n\nmodule.exports = function createCodec (valueEncoding = BJSON) {\n  return {\n    encode (info) {\n      try {\n        let header = info.id << 1\n        if (info.response) header = header | ATTR_RESPONSE\n        const dataLength = valueEncoding.encodingLength(info.data)\n        const buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength)\n        let offset = 0\n        varint.encode(header, buf, offset)\n        offset += varint.encode.bytes\n        varint.encode(dataLength, buf, offset)\n        offset += varint.encode.bytes\n        valueEncoding.encode(info.data, buf, offset)\n        return buf\n      } catch (err) {\n        throw new NMSG_ERR_ENCODE(err.message)\n      }\n    },\n\n    decode (buf) {\n      try {\n        const request = {}\n        let offset = 0\n        const header = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        const dataLength = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        request.data = valueEncoding.decode(buf, offset, offset + dataLength)\n        request.response = !!(header & ATTR_RESPONSE)\n        request.id = header >> 1\n        return request\n      } catch (err) {\n        throw new NMSG_ERR_DECODE(err.message)\n      }\n    }\n  }\n}\n","start":1670465470318,"end":1670465470318,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/buffer-json.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/errors.js?commonjs-proxy\";\n\nconst varint = require$$0\nconst BJSON = require$$1\nconst { NMSG_ERR_ENCODE, NMSG_ERR_DECODE } = require$$2\n\nconst ATTR_RESPONSE = 1\n\nvar codec = function createCodec (valueEncoding = BJSON) {\n  return {\n    encode (info) {\n      try {\n        let header = info.id << 1\n        if (info.response) header = header | ATTR_RESPONSE\n        const dataLength = valueEncoding.encodingLength(info.data)\n        const buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength)\n        let offset = 0\n        varint.encode(header, buf, offset)\n        offset += varint.encode.bytes\n        varint.encode(dataLength, buf, offset)\n        offset += varint.encode.bytes\n        valueEncoding.encode(info.data, buf, offset)\n        return buf\n      } catch (err) {\n        throw new NMSG_ERR_ENCODE(err.message)\n      }\n    },\n\n    decode (buf) {\n      try {\n        const request = {}\n        let offset = 0\n        const header = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        const dataLength = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        request.data = valueEncoding.decode(buf, offset, offset + dataLength)\n        request.response = !!(header & ATTR_RESPONSE)\n        request.id = header >> 1\n        return request\n      } catch (err) {\n        throw new NMSG_ERR_DECODE(err.message)\n      }\n    }\n  }\n}\n\nexport default codec;\nexport { codec as __moduleExports };","start":1670465470319,"end":1670465470934,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/buffer-json.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanomessage@8.4.0/node_modules/nanomessage/src/errors.js?commonjs-proxy\";\n\nconst varint = require$$0\nconst BJSON = require$$1\nconst { NMSG_ERR_ENCODE, NMSG_ERR_DECODE } = require$$2\n\nconst ATTR_RESPONSE = 1\n\nvar codec = function createCodec (valueEncoding = BJSON) {\n  return {\n    encode (info) {\n      try {\n        let header = info.id << 1\n        if (info.response) header = header | ATTR_RESPONSE\n        const dataLength = valueEncoding.encodingLength(info.data)\n        const buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength)\n        let offset = 0\n        varint.encode(header, buf, offset)\n        offset += varint.encode.bytes\n        varint.encode(dataLength, buf, offset)\n        offset += varint.encode.bytes\n        valueEncoding.encode(info.data, buf, offset)\n        return buf\n      } catch (err) {\n        throw new NMSG_ERR_ENCODE(err.message)\n      }\n    },\n\n    decode (buf) {\n      try {\n        const request = {}\n        let offset = 0\n        const header = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        const dataLength = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        request.data = valueEncoding.decode(buf, offset, offset + dataLength)\n        request.response = !!(header & ATTR_RESPONSE)\n        request.id = header >> 1\n        return request\n      } catch (err) {\n        throw new NMSG_ERR_DECODE(err.message)\n      }\n    }\n  }\n}\n\nexport default codec;\nexport { codec as __moduleExports };","start":1670465470936,"end":1670465470937,"order":"normal"}]}
