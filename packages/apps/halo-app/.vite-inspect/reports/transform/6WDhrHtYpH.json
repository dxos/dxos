{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/echo/echo-db/src/packlets/api/result-set.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar ResultSet = class {\n  constructor(itemUpdate, getter) {\n    this._resultsUpdate = new Event();\n    this.update = this._resultsUpdate;\n    assert(itemUpdate);\n    assert(getter);\n    this._itemUpdate = itemUpdate;\n    this._getter = getter;\n    this._resultsUpdate.addEffect(() => this._itemUpdate.on(() => {\n      this._resultsUpdate.emit(this._getter());\n    }));\n  }\n  get value() {\n    return this._getter();\n  }\n  get first() {\n    const value = this._getter();\n    assert(value.length);\n    return value[0];\n  }\n  subscribe(listener) {\n    return this._resultsUpdate.on(listener);\n  }\n  waitFor(condition) {\n    if (condition(this.value)) {\n      return Promise.resolve(this.value);\n    }\n    return this._resultsUpdate.waitFor(condition);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/schema.ts\nvar TYPE_SCHEMA = \"dxos:type/schema\";\nvar Schema = class {\n  constructor(_schema) {\n    this._schema = _schema;\n  }\n  get name() {\n    return this._schema.get(\"schema\");\n  }\n  get fields() {\n    var _a;\n    return Object.values((_a = this._schema.get(\"fields\")) != null ? _a : {});\n  }\n  getField(key) {\n    return this.fields.find((field) => field.key === key);\n  }\n  validate(model) {\n    return this.fields.every((field) => {\n      const value = model.get(field.key);\n      if (!value) {\n        return !field.required;\n      }\n      if (field.type) {\n        if (typeof value !== field.type) {\n          return false;\n        }\n      }\n      if (field.ref) {\n      }\n      return true;\n    });\n  }\n  async addField(newField) {\n    const newFields = [\n      ...this.fields,\n      newField\n    ];\n    await this._schema.set(\"fields\", newFields);\n  }\n  async editField(currentKey, editedField) {\n    const newFields = this.fields.map((field) => {\n      if (field.key === currentKey) {\n        return editedField;\n      }\n      return field;\n    });\n    await this._schema.set(\"fields\", newFields);\n  }\n  async deleteField(key) {\n    const newFields = this.fields.filter((field) => field.key !== key);\n    await this._schema.set(\"fields\", newFields);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/subscription.ts\nimport { Event as Event2 } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nvar resultSetToStream = (resultSet, map) => new Stream(({ next }) => {\n  next(map(resultSet.value));\n  return resultSet.update.on(() => next(map(resultSet.value)));\n});\nvar streamToResultSet = (stream, map) => {\n  const event = new Event2();\n  let lastItem;\n  stream.subscribe((data) => {\n    lastItem = data;\n    event.emit();\n  });\n  return new ResultSet(event, () => map(lastItem));\n};\n\n// packages/core/echo/echo-db/src/packlets/common/codec.ts\nimport { createCodecEncoding } from \"@dxos/hypercore\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.echo.feed.FeedMessage\");\nvar valueEncoding = createCodecEncoding(codec);\n\n// packages/core/echo/echo-db/src/packlets/common/feeds.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createMappedFeedWriter = (mapper, writer) => {\n  assert2(mapper);\n  assert2(writer);\n  return {\n    write: async (data) => await writer.write(await mapper(data))\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-mirror.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { failUndefined } from \"@dxos/debug\";\nvar log = debug(\"dxos:echo-db:data-mirror\");\nvar DataMirror = class {\n  constructor(_itemManager, _dataService, _spaceKey) {\n    this._itemManager = _itemManager;\n    this._dataService = _dataService;\n    this._spaceKey = _spaceKey;\n  }\n  open() {\n    const entities = this._dataService.subscribeEntitySet({\n      spaceKey: this._spaceKey\n    });\n    entities.subscribe(async (diff) => {\n      var _a, _b;\n      for (const addedEntity of (_a = diff.added) != null ? _a : []) {\n        log(`Construct: ${JSON.stringify(addedEntity)}`);\n        assert3(addedEntity.itemId);\n        assert3(addedEntity.genesis);\n        assert3(addedEntity.genesis.modelType);\n        let entity;\n        if (addedEntity.genesis.link) {\n          assert3(addedEntity.genesis.link.source);\n          assert3(addedEntity.genesis.link.target);\n          entity = await this._itemManager.constructLink({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            source: addedEntity.genesis.link.source,\n            target: addedEntity.genesis.link.target,\n            snapshot: {}\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            parentId: (_b = addedEntity.itemMutation) == null ? void 0 : _b.parentId,\n            snapshot: {}\n          });\n        }\n        this._subscribeToUpdates(entity);\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n  _subscribeToUpdates(entity) {\n    const stream = this._dataService.subscribeEntityStream({\n      spaceKey: this._spaceKey,\n      itemId: entity.id\n    });\n    stream.subscribe(async (update) => {\n      var _a, _b, _c, _d, _e, _f;\n      log(`Update[${entity.id}]: ${JSON.stringify(update)}`);\n      if (update.snapshot) {\n        assert3(update.snapshot.model);\n        entity._stateManager.resetToSnapshot(update.snapshot.model);\n      } else if (update.mutation) {\n        if ((_a = update.mutation.data) == null ? void 0 : _a.mutation) {\n          assert3(update.mutation.meta);\n          await entity._stateManager.processMessage({\n            feedKey: (_b = update.mutation.meta.feedKey) != null ? _b : failUndefined(),\n            memberKey: (_c = update.mutation.meta.memberKey) != null ? _c : failUndefined(),\n            seq: (_d = update.mutation.meta.seq) != null ? _d : failUndefined(),\n            timeframe: (_e = update.mutation.meta.timeframe) != null ? _e : failUndefined()\n          }, (_f = update.mutation.data.mutation) != null ? _f : failUndefined());\n        }\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nimport debug3 from \"debug\";\nimport assert6 from \"@dxos/node-std/assert\";\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { failUndefined as failUndefined2, raise } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\n\n// packages/core/echo/echo-db/src/packlets/errors/errors.ts\nvar DBError = class extends Error {\n  constructor(code, message, context) {\n    super(message ? `${code}: ${message}` : code.toString());\n    this.code = code;\n    this.context = context;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar IdentityNotInitializedError = class extends DBError {\n  constructor() {\n    super(\"IDENTITY_NOT_INITIALIZED\", \"Identity not initialized.\");\n  }\n};\nvar InvalidInvitationError = class extends DBError {\n  constructor() {\n    super(\"INVALID_INVITATION\", \"Invitation is invalid.\");\n  }\n};\nvar InvalidStorageVersionError = class extends DBError {\n  constructor(expected, actual) {\n    super(\"INVALID_STORAGE_VERSION\", \"Invalid storage version.\", {\n      expected,\n      actual\n    });\n  }\n};\nvar SpaceNotFoundError = class extends DBError {\n  constructor(spaceKey) {\n    super(\"SPACE_NOT_FOUND\", \"Space not found.\", {\n      spaceKey\n    });\n  }\n};\nvar EntityNotFoundError = class extends DBError {\n  constructor(entityId) {\n    super(\"ENTITY_NOT_FOUND\", \"Entity not found.\", {\n      entityId\n    });\n  }\n};\nvar UnknownModelError = class extends DBError {\n  constructor(model) {\n    super(\"UNKNOWN_MODEL\", \"Unknown model.\", {\n      model\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nimport debug2 from \"debug\";\nimport { ItemMutation } from \"@dxos/protocols/proto/dxos/echo/feed\";\n\n// packages/core/echo/echo-db/src/packlets/database/entity.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nvar Entity = class {\n  constructor(_itemManager, _id, _type, stateManager) {\n    this._itemManager = _itemManager;\n    this._id = _id;\n    this._type = _type;\n    this._onUpdate = new Event3();\n    this._subscriptions = new EventSubscriptions();\n    this._stateManager = stateManager;\n    if (this._stateManager.initialized) {\n      this._subscriptions.add(this._stateManager.model.subscribe(() => this._onUpdate.emit(this)));\n    }\n  }\n  get id() {\n    return this._id;\n  }\n  get type() {\n    return this._type;\n  }\n  get modelType() {\n    return this._stateManager.modelType;\n  }\n  get modelMeta() {\n    return this._stateManager.model.modelMeta;\n  }\n  get model() {\n    if (!this._stateManager.initialized) {\n      return null;\n    }\n    return this._stateManager.model;\n  }\n  subscribe(listener) {\n    return this._onUpdate.on(listener);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/util.ts\nvar dedupe = (values) => Array.from(new Set(values));\nvar coerceToId = (item) => {\n  if (typeof item === \"string\") {\n    return item;\n  }\n  return item.id;\n};\nvar testOneOrMultiple = (expected, value) => {\n  if (Array.isArray(expected)) {\n    return expected.includes(value);\n  } else {\n    return expected === value;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/queries.ts\nvar ItemFilterDeleted;\n(function(ItemFilterDeleted2) {\n  ItemFilterDeleted2[ItemFilterDeleted2[\"HIDE_DELETED\"] = 0] = \"HIDE_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED\"] = 1] = \"SHOW_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED_ONLY\"] = 2] = \"SHOW_DELETED_ONLY\";\n})(ItemFilterDeleted || (ItemFilterDeleted = {}));\nvar filterToPredicate = (filter) => {\n  if (typeof filter === \"function\") {\n    return filter;\n  }\n  return itemFilterToPredicate(filter);\n};\nvar itemFilterToPredicate = (filter) => {\n  if (\"id\" in filter) {\n    return (item) => item.id === filter.id;\n  } else {\n    return (item) => {\n      var _a;\n      return (!filter.type || testOneOrMultiple(filter.type, item.type)) && (!filter.parent || ((_a = item.parent) == null ? void 0 : _a.id) === coerceToId(filter.parent));\n    };\n  }\n};\nvar linkFilterToPredicate = (filter) => (link) => !filter.type || testOneOrMultiple(filter.type, link.type);\nvar createQueryOptionsFilter = ({ deleted = ItemFilterDeleted.HIDE_DELETED }) => (entity) => {\n  if (entity.model === null) {\n    return false;\n  }\n  switch (deleted) {\n    case ItemFilterDeleted.HIDE_DELETED:\n      return !(entity instanceof Item) || !entity.deleted;\n    case ItemFilterDeleted.SHOW_DELETED:\n      return true;\n    case ItemFilterDeleted.SHOW_DELETED_ONLY:\n      return entity instanceof Item && entity.deleted;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/result.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4 } from \"@dxos/async\";\nvar SelectionResult = class {\n  constructor(_execute, _update, _root, _reducer) {\n    this._execute = _execute;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n    this.update = new Event4();\n    this._lastResult = [\n      []\n    ];\n    this.refresh();\n    this.update.addEffect(() => _update.on((currentEntities) => {\n      const [previousEntities] = this._lastResult;\n      this.refresh();\n      const set = /* @__PURE__ */ new Set([\n        ...previousEntities,\n        ...this._lastResult[0]\n      ]);\n      if (this._reducer || currentEntities.some((entity) => set.has(entity))) {\n        this.update.emit(this);\n      }\n    }));\n  }\n  toString() {\n    const [entities] = this._lastResult;\n    return `SelectionResult<${JSON.stringify({\n      entities: entities.length\n    })}>`;\n  }\n  refresh() {\n    const [entities, result] = this._execute();\n    this._lastResult = [\n      dedupe(entities),\n      result\n    ];\n    return this;\n  }\n  get root() {\n    return this._root;\n  }\n  get entities() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities] = this._lastResult;\n    return entities;\n  }\n  get value() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities, value] = this._lastResult;\n    return this._reducer ? value : entities;\n  }\n  expectOne() {\n    const entities = this.entities;\n    assert4(entities.length === 1, `Expected one result; got ${entities.length}`);\n    return entities[0];\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/selection.ts\nvar createSelection = (itemsProvider, updateEventProvider, root, filter, value) => {\n  const predicate = filter ? filterToPredicate(filter) : () => true;\n  const visitor = (options) => {\n    const items = itemsProvider().filter(createQueryOptionsFilter(options)).filter(predicate);\n    return [\n      items,\n      value\n    ];\n  };\n  return new Selection(visitor, updateEventProvider(), root, value !== void 0);\n};\nvar createItemSelection = (root, update, value) => new Selection(() => [\n  [\n    root\n  ],\n  value\n], update, root, value !== void 0);\nvar Selection = class {\n  constructor(_visitor, _update, _root, _reducer = false) {\n    this._visitor = _visitor;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n  }\n  _createSubSelection(map) {\n    return new Selection((options) => map(this._visitor(options), options), this._update, this._root, this._reducer);\n  }\n  exec(options = {}) {\n    return this.query(options);\n  }\n  query(options = {}) {\n    return new SelectionResult(() => this._visitor(options), this._update, this._root, this._reducer);\n  }\n  get root() {\n    return this._root;\n  }\n  call(visitor) {\n    return this._createSubSelection(([items, result]) => [\n      items,\n      visitor(items, result)\n    ]);\n  }\n  filter(filter) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([items, result]) => [\n      items.filter(predicate),\n      result\n    ]);\n  }\n  children(filter) {\n    const predicate = filter ? filterToPredicate(filter) : Boolean;\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => Array.from(item._children.values()).filter(createQueryOptionsFilter(options)).filter(predicate)),\n      result\n    ]);\n  }\n  parent() {\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.parent ? [\n        item.parent\n      ].filter(createQueryOptionsFilter(options)) : []),\n      result\n    ]);\n  }\n  links(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.links.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  refs(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.refs.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  target(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.target).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n  source(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.source).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nvar log2 = debug2(\"dxos:echo-db:item\");\nvar Item = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, _writeStream, parent) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._writeStream = _writeStream;\n    this._parent = null;\n    this._deleted = false;\n    this._children = /* @__PURE__ */ new Set();\n    this._links = /* @__PURE__ */ new Set();\n    this._refs = /* @__PURE__ */ new Set();\n    this._updateParent(parent);\n  }\n  toString() {\n    var _a;\n    return `Item(${JSON.stringify({\n      itemId: this.id,\n      parentId: (_a = this.parent) == null ? void 0 : _a.id,\n      itemType: this.type\n    })})`;\n  }\n  get readOnly() {\n    return !this._writeStream || this._deleted;\n  }\n  get deleted() {\n    return this._deleted;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return Array.from(this._children.values()).filter((item) => !item.deleted);\n  }\n  get links() {\n    return Array.from(this._links.values()).filter((link) => !link._isDangling());\n  }\n  get refs() {\n    return Array.from(this._refs.values()).filter((link) => !link._isDangling());\n  }\n  select() {\n    return createItemSelection(this, this._itemManager.debouncedUpdate, void 0);\n  }\n  async delete() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (this.deleted) {\n      return;\n    }\n    const onUpdate = this._onUpdate.waitFor(() => this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.DELETE\n      }\n    });\n    await onUpdate;\n  }\n  async restore() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (!this.deleted) {\n      throw new Error(`Item was note delted: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => !this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.RESTORE\n      }\n    });\n    await onUpdate;\n  }\n  async setParent(parentId) {\n    if (!this._writeStream || this.readOnly) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => {\n      var _a;\n      return parentId === ((_a = this._parent) == null ? void 0 : _a.id);\n    });\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        parentId\n      }\n    });\n    await onUpdate;\n  }\n  _processMutation(mutation, getItem) {\n    log2(\"_processMutation %s\", JSON.stringify(mutation));\n    const { action, parentId } = mutation;\n    switch (action) {\n      case ItemMutation.Action.DELETE: {\n        this._deleted = true;\n        break;\n      }\n      case ItemMutation.Action.RESTORE: {\n        this._deleted = false;\n        break;\n      }\n    }\n    if (parentId) {\n      const parent = getItem(parentId);\n      this._updateParent(parent);\n    }\n    this._onUpdate.emit(this);\n  }\n  _updateParent(parent) {\n    if (this._parent) {\n      this._parent._children.delete(this);\n    }\n    if (parent) {\n      this._parent = parent;\n      this._parent._children.add(this);\n    } else {\n      this._parent = null;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/link.ts\nimport assert5 from \"@dxos/node-std/assert\";\nvar Link = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, link) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._link = link;\n  }\n  get isLink() {\n    return true;\n  }\n  get sourceId() {\n    return this._link.sourceId;\n  }\n  get targetId() {\n    return this._link.targetId;\n  }\n  get source() {\n    assert5(this._link.source, \"Dangling link\");\n    return this._link.source;\n  }\n  get target() {\n    assert5(this._link.target, \"Dangling link\");\n    return this._link.target;\n  }\n  _isDangling() {\n    return !this._link.source || !this._link.target;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nvar log3 = debug3(\"dxos:echo-db:data-service-host\");\nvar DataServiceHost = class {\n  constructor(_itemManager, _itemDemuxer, _writeStream) {\n    this._itemManager = _itemManager;\n    this._itemDemuxer = _itemDemuxer;\n    this._writeStream = _writeStream;\n  }\n  subscribeEntitySet() {\n    return new Stream2(({ next }) => {\n      const trackedSet = /* @__PURE__ */ new Set();\n      const entityInfo = (id) => {\n        var _a, _b;\n        const entity = (_a = this._itemManager.entities.get(id)) != null ? _a : failUndefined2();\n        return {\n          itemId: id,\n          genesis: {\n            itemType: entity.type,\n            modelType: entity.modelType,\n            link: entity instanceof Link ? {\n              source: entity.sourceId,\n              target: entity.targetId\n            } : void 0\n          },\n          itemMutation: entity instanceof Item ? {\n            parentId: (_b = entity.parent) == null ? void 0 : _b.id\n          } : void 0\n        };\n      };\n      const update = () => {\n        const added = /* @__PURE__ */ new Set();\n        const deleted = /* @__PURE__ */ new Set();\n        for (const entity of this._itemManager.entities.keys()) {\n          if (!trackedSet.has(entity)) {\n            added.add(entity);\n            trackedSet.add(entity);\n          }\n        }\n        for (const entity1 of trackedSet) {\n          if (!this._itemManager.entities.has(entity1)) {\n            deleted.add(entity1);\n            trackedSet.delete(entity1);\n          }\n        }\n        next({\n          added: Array.from(added).map((id) => entityInfo(id)),\n          deleted: Array.from(added).map((id) => ({\n            itemId: id\n          }))\n        });\n      };\n      update();\n      return this._itemManager.debouncedUpdate.on(update);\n    });\n  }\n  subscribeEntityStream(request) {\n    return new Stream2(({ next }) => {\n      assert6(request.itemId);\n      const entityItem = this._itemManager.items.find((item) => item.id === request.itemId);\n      let snapshot;\n      if (entityItem) {\n        snapshot = this._itemDemuxer.createItemSnapshot(entityItem);\n      } else {\n        const entityLink = this._itemManager.links.find((link) => link.id === request.itemId);\n        if (entityLink) {\n          snapshot = this._itemDemuxer.createLinkSnapshot(entityLink);\n        } else {\n          raise(new EntityNotFoundError(request.itemId));\n        }\n      }\n      log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n        snapshot\n      })}`);\n      next({\n        snapshot\n      });\n      return this._itemDemuxer.mutation.on((mutation) => {\n        if (mutation.data.itemId !== request.itemId) {\n          return;\n        }\n        log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n          mutation\n        })}`);\n        next({\n          mutation: {\n            data: mutation.data,\n            meta: {\n              feedKey: PublicKey.from(mutation.meta.feedKey),\n              memberKey: PublicKey.from(mutation.meta.memberKey),\n              seq: mutation.meta.seq,\n              timeframe: mutation.meta.timeframe\n            }\n          }\n        });\n      });\n    });\n  }\n  async write(request) {\n    assert6(this._writeStream, \"Cannot write mutations in readonly mode\");\n    return this._writeStream.write(request);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { raise as raise2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar DataServiceSubscriptions = class {\n  constructor() {\n    this._spaces = new ComplexMap(PublicKey2.hash);\n  }\n  clear() {\n    this._spaces.clear();\n  }\n  registerSpace(spaceKey, host) {\n    this._spaces.set(spaceKey, host);\n  }\n  unregisterSpace(spaceKey) {\n    this._spaces.delete(spaceKey);\n  }\n  getDataService(spaceKey) {\n    return this._spaces.get(spaceKey);\n  }\n};\nvar DataServiceImpl = class {\n  constructor(_subscriptions) {\n    this._subscriptions = _subscriptions;\n  }\n  subscribeEntitySet(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntitySet();\n  }\n  subscribeEntityStream(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntityStream(request);\n  }\n  write(request) {\n    var _a;\n    assert7(request.spaceKey);\n    assert7(request.mutation);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.write(request.mutation);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nimport debug5 from \"debug\";\nimport assert9 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\n\n// packages/core/echo/echo-db/src/packlets/database/item-demuxer.ts\nimport debug4 from \"debug\";\nimport assert8 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nvar log4 = debug4(\"dxos:echo-db:item-demuxer\");\nvar ItemDemuxer = class {\n  constructor(_itemManager, _modelFactory, _options = {}) {\n    this._itemManager = _itemManager;\n    this._modelFactory = _modelFactory;\n    this._options = _options;\n    this.mutation = new Event5();\n  }\n  open() {\n    this._modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    });\n    return async (message) => {\n      var _a, _b, _c;\n      const { data: { itemId, genesis, itemMutation, mutation, snapshot }, meta } = message;\n      assert8(itemId);\n      if (genesis) {\n        const { itemType, modelType } = genesis;\n        assert8(modelType);\n        const modelOpts = {\n          itemId,\n          modelType,\n          snapshot: {\n            mutations: mutation ? [\n              {\n                mutation,\n                meta\n              }\n            ] : void 0\n          }\n        };\n        let entity;\n        if (genesis.link) {\n          entity = await this._itemManager.constructLink({\n            ...modelOpts,\n            itemType,\n            source: (_a = genesis.link.source) != null ? _a : failUndefined3(),\n            target: (_b = genesis.link.target) != null ? _b : failUndefined3()\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            ...modelOpts,\n            parentId: itemMutation == null ? void 0 : itemMutation.parentId,\n            itemType\n          });\n        }\n        assert8(entity.id === itemId);\n      }\n      if (itemMutation) {\n        const item = this._itemManager.getItem(itemId);\n        assert8(item);\n        item._processMutation(itemMutation, (itemId2) => this._itemManager.getItem(itemId2));\n      }\n      if (mutation && !genesis) {\n        assert8(message.data.mutation);\n        const modelMessage = {\n          meta,\n          mutation\n        };\n        await this._itemManager.processModelMessage(itemId, modelMessage);\n      }\n      if (snapshot) {\n        const entity1 = (_c = this._itemManager.entities.get(itemId)) != null ? _c : failUndefined3();\n        entity1._stateManager.resetToSnapshot(snapshot);\n      }\n      this.mutation.emit(message);\n    };\n  }\n  createSnapshot() {\n    assert8(this._options.snapshots, \"Snapshots are disabled\");\n    return {\n      items: this._itemManager.items.map((item) => this.createItemSnapshot(item)),\n      links: this._itemManager.links.map((link) => this.createLinkSnapshot(link))\n    };\n  }\n  createItemSnapshot(item) {\n    var _a;\n    const model = item._stateManager.createSnapshot();\n    return {\n      itemId: item.id,\n      itemType: item.type,\n      modelType: item.modelType,\n      parentId: (_a = item.parent) == null ? void 0 : _a.id,\n      model\n    };\n  }\n  createLinkSnapshot(link) {\n    const model = link._stateManager.createSnapshot();\n    return {\n      linkId: link.id,\n      linkType: link.type,\n      modelType: link.modelMeta.type,\n      source: link.source.id,\n      target: link.target.id,\n      model\n    };\n  }\n  async restoreFromSnapshot(snapshot) {\n    const { items = [], links = [] } = snapshot;\n    log4(`Restoring ${items.length} items from snapshot.`);\n    for (const item of sortItemsTopologically(items)) {\n      assert8(item.itemId);\n      assert8(item.modelType);\n      assert8(item.model);\n      await this._itemManager.constructItem({\n        itemId: item.itemId,\n        modelType: item.modelType,\n        itemType: item.itemType,\n        parentId: item.parentId,\n        snapshot: item.model\n      });\n    }\n    log4(`Restoring ${links.length} links from snapshot.`);\n    for (const link of links) {\n      assert8(link.linkId);\n      assert8(link.modelType);\n      assert8(link.model);\n      await this._itemManager.constructLink({\n        itemId: link.linkId,\n        itemType: link.linkType,\n        modelType: link.modelType,\n        source: link.source,\n        target: link.target,\n        snapshot: link.model\n      });\n    }\n  }\n};\nvar sortItemsTopologically = (items) => {\n  const snapshots = [];\n  const seenIds = /* @__PURE__ */ new Set();\n  while (snapshots.length !== items.length) {\n    const prevLength = snapshots.length;\n    for (const item of items) {\n      assert8(item.itemId);\n      if (!seenIds.has(item.itemId) && (item.parentId == null || seenIds.has(item.parentId))) {\n        snapshots.push(item);\n        seenIds.add(item.itemId);\n      }\n    }\n    if (prevLength === snapshots.length && snapshots.length !== items.length) {\n      throw new Error(\"Cannot topologically sorts items in snapshot: some parents are missing.\");\n    }\n  }\n  return snapshots;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nvar log5 = debug5(\"dxos:echo-db:database-backend\");\nvar DatabaseBackendHost = class {\n  constructor(_outboundStream, _snapshot, _options = {}) {\n    this._outboundStream = _outboundStream;\n    this._snapshot = _snapshot;\n    this._options = _options;\n  }\n  get isReadOnly() {\n    return !!this._outboundStream;\n  }\n  get echoProcessor() {\n    return this._echoProcessor;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    this._itemDemuxer = new ItemDemuxer(itemManager, modelFactory, this._options);\n    this._echoProcessor = this._itemDemuxer.open();\n    if (this._snapshot) {\n      await this._itemDemuxer.restoreFromSnapshot(this._snapshot);\n    }\n  }\n  async close() {\n  }\n  getWriteStream() {\n    return this._outboundStream;\n  }\n  createSnapshot() {\n    return this._itemDemuxer.createSnapshot();\n  }\n  createDataServiceHost() {\n    var _a;\n    return new DataServiceHost(this._itemManager, this._itemDemuxer, (_a = this._outboundStream) != null ? _a : void 0);\n  }\n};\nvar DatabaseBackendProxy = class {\n  constructor(_service, _spaceKey) {\n    this._service = _service;\n    this._spaceKey = _spaceKey;\n    this._subscriptions = new EventSubscriptions2();\n  }\n  get isReadOnly() {\n    return false;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    const dataMirror = new DataMirror(this._itemManager, this._service, this._spaceKey);\n    this._subscriptions.add(modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    }));\n    dataMirror.open();\n  }\n  async close() {\n    this._subscriptions.clear();\n  }\n  getWriteStream() {\n    return {\n      write: async (mutation) => {\n        log5(\"write\", mutation);\n        const { feedKey, seq } = await this._service.write({\n          mutation,\n          spaceKey: this._spaceKey\n        });\n        assert9(feedKey);\n        assert9(seq !== void 0);\n        return {\n          feedKey,\n          seq\n        };\n      }\n    };\n  }\n  createSnapshot() {\n    throw new Error(\"Method not supported.\");\n  }\n  createDataServiceHost() {\n    throw new Error(\"Method not supported.\");\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item-manager.ts\nimport debug6 from \"debug\";\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Event as Event6, trigger } from \"@dxos/async\";\nimport { createId } from \"@dxos/crypto\";\nimport { timed } from \"@dxos/debug\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar log6 = debug6(\"dxos:echo-db:item-manager\");\nvar ItemManager = class {\n  constructor(_modelFactory, _memberKey, _writeStream) {\n    this._modelFactory = _modelFactory;\n    this._memberKey = _memberKey;\n    this._writeStream = _writeStream;\n    this.update = new Event6();\n    this.debouncedUpdate = debounceEntityUpdateEvent(this.update);\n    this._entities = /* @__PURE__ */ new Map();\n    this._pendingItems = /* @__PURE__ */ new Map();\n  }\n  get entities() {\n    return this._entities;\n  }\n  get items() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Item);\n  }\n  get links() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Link);\n  }\n  async createItem(modelType, itemType, parentId, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Model does not support initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis\", {\n      itemId\n    });\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType\n      },\n      itemMutation: parentId ? {\n        parentId\n      } : void 0,\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const item = await waitForCreation();\n    assert10(item instanceof Item);\n    return item;\n  }\n  async createLink(modelType, itemType, source, target, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Tried to provide initialization params to a model with no initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis:\", itemId);\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType,\n        link: {\n          source,\n          target\n        }\n      },\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const link = await waitForCreation();\n    assert10(link instanceof Link);\n    return link;\n  }\n  async _constructModel({ modelType, itemId, snapshot }) {\n    const outboundTransform = this._writeStream && createMappedFeedWriter((mutation) => ({\n      itemId,\n      mutation\n    }), this._writeStream);\n    return this._modelFactory.createModel(modelType, itemId, snapshot, this._memberKey, outboundTransform);\n  }\n  _addEntity(entity, parent) {\n    var _a;\n    assert10(!this._entities.has(entity.id));\n    this._entities.set(entity.id, entity);\n    log6(\"New entity:\", String(entity));\n    this.update.emit(entity);\n    entity.subscribe(() => {\n      this.update.emit(entity);\n    });\n    (_a = this._pendingItems.get(entity.id)) == null ? void 0 : _a(entity);\n  }\n  async constructItem({ itemId, itemType, modelType, parentId, snapshot }) {\n    assert10(itemId);\n    assert10(modelType);\n    const parent = parentId ? this._entities.get(parentId) : null;\n    if (parentId && !parent) {\n      throw new Error(`Missing parent: ${parentId}`);\n    }\n    assert10(!parent || parent instanceof Item);\n    const modelStateManager = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const item = new Item(this, itemId, itemType, modelStateManager, this._writeStream, parent);\n    if (parent) {\n      this.update.emit(parent);\n    }\n    this._addEntity(item);\n    return item;\n  }\n  async constructLink({ itemId, itemType, modelType, snapshot, source, target }) {\n    assert10(itemId);\n    assert10(modelType);\n    const model = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const sourceItem = this.getItem(source);\n    const targetItem = this.getItem(target);\n    const link = new Link(this, itemId, itemType, model, {\n      sourceId: source,\n      targetId: target,\n      source: sourceItem,\n      target: targetItem\n    });\n    if (sourceItem) {\n      sourceItem._links.add(link);\n      this.update.emit(sourceItem);\n    }\n    if (targetItem) {\n      targetItem._refs.add(link);\n      this.update.emit(targetItem);\n    }\n    this._addEntity(link);\n    return link;\n  }\n  async processModelMessage(itemId, message) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    await item._stateManager.processMessage(message.meta, message.mutation);\n    this.update.emit(item);\n  }\n  getItem(itemId) {\n    const entity = this._entities.get(itemId);\n    if (entity) {\n      assert10(entity instanceof Item);\n    }\n    return entity;\n  }\n  getUninitializedEntities() {\n    return Array.from(this._entities.values()).filter((entity) => !entity._stateManager.initialized);\n  }\n  deconstructItem(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    this._entities.delete(itemId);\n    if (item instanceof Item) {\n      if (item.parent) {\n        item.parent._children.delete(item);\n      }\n      for (const child of item.children) {\n        this.deconstructItem(child.id);\n      }\n      for (const ref of item.refs) {\n        ref._link.target = void 0;\n      }\n      for (const link of item.links) {\n        link._link.source = void 0;\n      }\n    }\n  }\n  async initializeModel(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    const model = this._modelFactory.getModel(item._stateManager.modelType);\n    assert10(model, \"Model not registered\");\n    item._stateManager.initialize(model.constructor);\n    this.update.emit(item);\n  }\n};\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createLink\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructLink\", null);\nvar debounceEntityUpdateEvent = (event) => {\n  const debouncedEvent = new Event6();\n  let firing = false;\n  const emittedSinceLastFired = /* @__PURE__ */ new Set();\n  debouncedEvent.addEffect(() => event.on((arg) => {\n    emittedSinceLastFired.add(arg);\n    if (!firing) {\n      firing = true;\n      setTimeout(() => {\n        firing = false;\n        const args = Array.from(emittedSinceLastFired);\n        emittedSinceLastFired.clear();\n        debouncedEvent.emit(args);\n      }, 0);\n    }\n  }));\n  return debouncedEvent;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport { synchronized } from \"@dxos/async\";\nimport { validateModelClass } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar State;\n(function(State2) {\n  State2[\"NULL\"] = \"NULL\";\n  State2[\"INITIALIZED\"] = \"INITIALIZED\";\n  State2[\"DESTROYED\"] = \"DESTROYED\";\n})(State || (State = {}));\nvar Database = class {\n  constructor(_modelFactory, _backend, memberKey) {\n    this._modelFactory = _modelFactory;\n    this._backend = _backend;\n    this._state = State.NULL;\n    this._itemManager = new ItemManager(this._modelFactory, memberKey, this._backend.getWriteStream());\n  }\n  get state() {\n    return this._state;\n  }\n  get isReadOnly() {\n    return this._backend.isReadOnly;\n  }\n  get update() {\n    return this._itemManager.debouncedUpdate;\n  }\n  get entityUpdate() {\n    return this._itemManager.update;\n  }\n  async initialize() {\n    if (this._state !== State.NULL) {\n      throw new Error(\"Invalid state: database was already initialized.\");\n    }\n    await this._backend.open(this._itemManager, this._modelFactory);\n    this._state = State.INITIALIZED;\n  }\n  async destroy() {\n    if (this._state === State.DESTROYED || this._state === State.NULL) {\n      return;\n    }\n    await this._backend.close();\n    this._state = State.DESTROYED;\n  }\n  async createItem(options = {}) {\n    this._assertInitialized();\n    if (!options.model) {\n      options.model = ObjectModel;\n    }\n    validateModelClass(options.model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    if (options.parent && typeof options.parent !== \"string\") {\n      throw new TypeError(\"Optional parent item id must be a string id of an existing item.\");\n    }\n    return await this._itemManager.createItem(options.model.meta.type, options.type, options.parent, options.props);\n  }\n  async createLink(options) {\n    var _a;\n    this._assertInitialized();\n    const model = (_a = options.model) != null ? _a : ObjectModel;\n    if (!model) {\n      throw new TypeError(\"Missing model class.\");\n    }\n    validateModelClass(model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    return this._itemManager.createLink(model.meta.type, options.type, options.source.id, options.target.id, options.props);\n  }\n  getItem(itemId) {\n    this._assertInitialized();\n    return this._itemManager.getItem(itemId);\n  }\n  async waitForItem(filter) {\n    const result = this.select(filter).exec();\n    await result.update.waitForCondition(() => result.entities.length > 0);\n    const item = result.expectOne();\n    assert11(item, \"Possible race condition detected.\");\n    return item;\n  }\n  select(filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, void 0);\n  }\n  reduce(result, filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, result);\n  }\n  createSnapshot() {\n    this._assertInitialized();\n    return this._backend.createSnapshot();\n  }\n  createDataServiceHost() {\n    return this._backend.createDataServiceHost();\n  }\n  _assertInitialized() {\n    if (this._state !== State.INITIALIZED) {\n      throw new Error(\"Database not initialized.\");\n    }\n  }\n};\n__decorate2([\n  synchronized\n], Database.prototype, \"initialize\", null);\n__decorate2([\n  synchronized\n], Database.prototype, \"destroy\", null);\n\n// packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { log as log7 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar STORAGE_VERSION = 1;\nvar emptyEchoMetadata = () => ({\n  version: STORAGE_VERSION,\n  spaces: [],\n  created: new Date(),\n  updated: new Date()\n});\nvar MetadataStore = class {\n  constructor(_directory) {\n    this._directory = _directory;\n    this._metadata = emptyEchoMetadata();\n  }\n  get version() {\n    var _a;\n    return (_a = this._metadata.version) != null ? _a : 0;\n  }\n  get spaces() {\n    var _a;\n    return (_a = this._metadata.spaces) != null ? _a : [];\n  }\n  async load() {\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const { size: fileLength } = await file.stat();\n      if (fileLength < 4) {\n        return;\n      }\n      const dataSize = fromBytesInt32(await file.read(0, 4));\n      log7(\"loaded\", {\n        size: dataSize\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 67,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      {\n        if (fileLength < dataSize + 4) {\n          throw new Error(\"Metadata storage is corrupted\");\n        }\n      }\n      const data = await file.read(4, dataSize);\n      this._metadata = schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").decode(data);\n    } catch (err) {\n      log7.error(\"failed to load metadata\", {\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 79,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._metadata = emptyEchoMetadata();\n    } finally {\n      await file.close();\n    }\n  }\n  async _save() {\n    var _a;\n    const data = {\n      ...this._metadata,\n      version: STORAGE_VERSION,\n      created: (_a = this._metadata.created) != null ? _a : new Date(),\n      updated: new Date()\n    };\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const encoded = Buffer.from(schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").encode(data));\n      await file.write(0, toBytesInt32(encoded.length));\n      log7(\"saved\", {\n        size: encoded.length\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 102,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await file.write(4, encoded);\n    } finally {\n      await file.close();\n    }\n  }\n  async clear() {\n    log7(\"clearing all metadata\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._directory.delete();\n  }\n  getIdentityRecord() {\n    return this._metadata.identity;\n  }\n  async setIdentityRecord(record) {\n    assert12(!this._metadata.identity, \"Cannot overwrite existing identity in metadata\");\n    this._metadata.identity = record;\n    await this._save();\n  }\n  async addSpace(record) {\n    var _a, _b, _c;\n    assert12(!((_a = this._metadata.spaces) != null ? _a : []).find((space) => space.key === record.key), \"Cannot overwrite existing space in metadata\");\n    ((_c = (_b = this._metadata).spaces) != null ? _c : _b.spaces = []).push(record);\n    await this._save();\n  }\n};\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"load\", null);\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"_save\", null);\nvar toBytesInt32 = (num) => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32LE(num, 0);\n  return buf;\n};\nvar fromBytesInt32 = (buf) => buf.readInt32LE(0);\n\n// packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { log as log8 } from \"@dxos/log\";\nimport { Extension, ERR_EXTENSION_RESPONSE_FAILED } from \"@dxos/mesh-protocol\";\nvar EXTENSION_NAME = \"dxos.credentials.auth\";\nvar AuthPlugin = class {\n  constructor(_swarmIdentity, requireAuthForExtensions = []) {\n    this._swarmIdentity = _swarmIdentity;\n    this.authenticationFailed = new Event7();\n    this._requiredForExtensions = new Set(requireAuthForExtensions);\n  }\n  createExtension() {\n    return new Extension(EXTENSION_NAME, {\n      binary: true\n    }).setHandshakeHandler(this._onHandshake.bind(this));\n  }\n  async _onHandshake(protocol) {\n    var _a;\n    try {\n      assert13(protocol);\n      const { credentials, peerId: sessionPeerId } = (_a = protocol == null ? void 0 : protocol.getSession()) != null ? _a : {};\n      log8(\"Handshake\", {\n        credentials,\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 66,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!credentials) {\n        if (this._requiredForExtensions.size) {\n          let authRequired = false;\n          for (const name of protocol.stream.remoteExtensions.names) {\n            if (this._requiredForExtensions.has(name)) {\n              log8(`Auth required for extension: ${name}`, {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n                line: 74,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              authRequired = true;\n              break;\n            }\n          }\n          if (!authRequired) {\n            log8(`Unauthenticated access allowed for ${sessionPeerId}; no extensions which require authentication are active on remote Protocol.`, {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n              line: 84,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            return;\n          }\n        }\n        log8(\"No credentials provided; dropping connection\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: no credentials.\");\n      }\n      const nonce = Buffer.from(\"\");\n      const credentialsBuf = Buffer.from(credentials, \"base64\");\n      const isAuthenticated = await this._swarmIdentity.credentialAuthenticator(nonce, credentialsBuf);\n      if (!isAuthenticated) {\n        log8(\"Unauthenticated access denied\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 110,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: bad credentials.\");\n      }\n      log8(\"Authenticated access granted\", {\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 121,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log8(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 129,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw err;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\nimport { Event as Event8 } from \"@dxos/async\";\nimport { log as log9 } from \"@dxos/log\";\nimport { ReplicatorPlugin as AbstractReplicatorPlugin } from \"@dxos/protocol-plugin-replicator\";\nvar ReplicatorPlugin = class extends AbstractReplicatorPlugin {\n  constructor() {\n    super({\n      load: async () => {\n        const feeds = Array.from(this._feeds);\n        log9(\"loading feeds\", {\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 31,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds.map((feed) => ({\n          discoveryKey: feed.properties.discoveryKey\n        }));\n      },\n      subscribe: (addFeedToReplicatedSet) => this._feedAdded.on(async (feed) => {\n        log9(\"adding feed\", {\n          feedKey: feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 39,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        addFeedToReplicatedSet({\n          discoveryKey: feed.properties.discoveryKey\n        });\n      }),\n      replicate: async (remoteFeeds, info) => {\n        const feeds = Array.from(this._feeds);\n        log9(\"replicating\", {\n          peerId: info.session,\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds;\n      }\n    });\n    this._feedAdded = new Event8();\n    this._feeds = /* @__PURE__ */ new Set();\n  }\n  addFeed(feed) {\n    log9(\"adding feed\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n      line: 21,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._feeds.add(feed);\n    this._feedAdded.emit(feed);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nimport assert16 from \"@dxos/node-std/assert\";\nimport { Event as Event10, synchronized as synchronized3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined4 } from \"@dxos/debug\";\nimport { log as log14, logInfo } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { Callback as Callback2 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nimport assert15 from \"@dxos/node-std/assert\";\nimport { FeedSetIterator } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/message-selector.ts\nimport debug7 from \"debug\";\nimport assert14 from \"@dxos/node-std/assert\";\nvar log10 = debug7(\"dxos:echo-db:message-selector\");\nvar createMessageSelector = (timeframeClock) => {\n  return (messages) => {\n    for (let i = 0; i < messages.length; i++) {\n      const { data: { timeframe } } = messages[i];\n      assert14(timeframe);\n      if (!timeframeClock.hasGaps(timeframe)) {\n        return i;\n      }\n    }\n    log10(\"Skipping...\");\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\nimport { Event as Event9 } from \"@dxos/async\";\nimport { timed as timed2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar __decorate4 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar mapTimeframeToFeedIndexes = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({\n  feedKey,\n  index\n}));\nvar mapFeedIndexesToTimeframe = (indexes) => new Timeframe(indexes.map(({ feedKey, index }) => [\n  feedKey,\n  index\n]));\nvar TimeframeClock = class {\n  constructor(_timeframe = new Timeframe()) {\n    this._timeframe = _timeframe;\n    this.update = new Event9();\n  }\n  get timeframe() {\n    return this._timeframe;\n  }\n  updateTimeframe(key, seq) {\n    this._timeframe = Timeframe.merge(this._timeframe, new Timeframe([\n      [\n        key,\n        seq\n      ]\n    ]));\n    this.update.emit(this._timeframe);\n  }\n  hasGaps(timeframe) {\n    const gaps = Timeframe.dependencies(timeframe, this._timeframe);\n    return !gaps.isEmpty();\n  }\n  async waitUntilReached(target) {\n    log11.debug(\"waitUntilReached\", {\n      target,\n      current: this._timeframe\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n      line: 45,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.update.waitForCondition(() => {\n      log11(\"check if reached\", {\n        target,\n        current: this._timeframe,\n        deps: Timeframe.dependencies(target, this._timeframe)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return Timeframe.dependencies(target, this._timeframe).isEmpty();\n    });\n  }\n};\n__decorate4([\n  timed2(5e3)\n], TimeframeClock.prototype, \"waitUntilReached\", null);\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nvar PipelineState = class {\n  constructor(_iterator, _timeframeClock) {\n    this._iterator = _iterator;\n    this._timeframeClock = _timeframeClock;\n    this.timeframeUpdate = this._timeframeClock.updateTimeframe;\n  }\n  get endTimeframe() {\n    return mapFeedIndexesToTimeframe(this._iterator.feeds.filter((feed) => feed.properties.length > 0).map((feed) => ({\n      feedKey: feed.key,\n      index: feed.properties.length - 1\n    })));\n  }\n  get timeframe() {\n    return this._timeframeClock.timeframe;\n  }\n  async waitUntilTimeframe(target) {\n    await this._timeframeClock.waitUntilReached(target);\n  }\n};\nvar Pipeline = class {\n  constructor(_initialTimeframe = new Timeframe2()) {\n    this._initialTimeframe = _initialTimeframe;\n    this._timeframeClock = new TimeframeClock(this._initialTimeframe);\n    this.feedSetIterator = new FeedSetIterator(createMessageSelector(this._timeframeClock), {\n      start: mapTimeframeToFeedIndexes(this._initialTimeframe),\n      stallTimeout: 1e3\n    });\n    this._state = new PipelineState(this.feedSetIterator, this._timeframeClock);\n    this._isOpen = false;\n    this.feedSetIterator.stalled.on((iterator) => {\n      log12.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n        line: 110,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n  }\n  get state() {\n    return this._state;\n  }\n  get writer() {\n    assert15(this._writer, \"Writer not set.\");\n    return this._writer;\n  }\n  async addFeed(feed) {\n    await this.feedSetIterator.addFeed(feed);\n  }\n  setWriteFeed(feed) {\n    assert15(!this._writer, \"Writer already set.\");\n    assert15(feed.properties.writable, \"Feed must be writable.\");\n    this._writer = createMappedFeedWriter((data) => ({\n      timeframe: this._timeframeClock.timeframe,\n      payload: data\n    }), feed.createFeedWriter());\n  }\n  async start() {\n    log12(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.open();\n    log12(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 143,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log12(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.close();\n    log12(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 149,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async *consume() {\n    assert15(!this._isOpen, \"Pipeline is already being consumed.\");\n    this._isOpen = true;\n    for await (const block of this.feedSetIterator) {\n      yield block;\n      this._timeframeClock.updateTimeframe(PublicKey3.from(block.feedKey), block.seq);\n    }\n    this._isOpen = false;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\nimport { SpaceStateMachine } from \"@dxos/credentials\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback } from \"@dxos/util\";\nvar ControlPipeline = class {\n  constructor({ spaceKey, genesisFeed, feedProvider, initialTimeframe }) {\n    this.onFeedAdmitted = new Callback();\n    this._pipeline = new Pipeline(initialTimeframe);\n    void this._pipeline.addFeed(genesisFeed);\n    this._spaceStateMachine = new SpaceStateMachine(spaceKey);\n    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {\n      log13(\"feed admitted\", {\n        info\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (info.assertion.designation === AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {\n        try {\n          const feed = await feedProvider(info.key);\n          await this._pipeline.addFeed(feed);\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 48,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n      await this.onFeedAdmitted.callIfSet(info);\n    });\n    this.onMemberAdmitted = this._spaceStateMachine.onMemberAdmitted;\n    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;\n  }\n  get spaceState() {\n    return this._spaceStateMachine;\n  }\n  get pipeline() {\n    return this._pipeline;\n  }\n  setWriteFeed(feed) {\n    this._pipeline.setWriteFeed(feed);\n  }\n  async start() {\n    log13(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    setTimeout(async () => {\n      for await (const msg of this._pipeline.consume()) {\n        try {\n          log13(\"processing\", {\n            msg\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 76,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (msg.data.payload[\"@type\"] === \"dxos.echo.feed.CredentialsMessage\") {\n            const result = await this._spaceStateMachine.process(msg.data.payload.credential, PublicKey4.from(msg.feedKey));\n            if (!result) {\n              log13.warn(\"processing failed\", {\n                msg\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n                line: 83,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n            }\n          }\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 87,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this._pipeline.start();\n    log13(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log13(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._pipeline.stop();\n    log13(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 99,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nvar __decorate5 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Space = class {\n  constructor({ spaceKey, protocol, genesisFeed, controlFeed, dataFeed, feedProvider, databaseFactory, initialTimeframe }) {\n    this.onCredentialProcessed = new Callback2();\n    this.stateUpdate = new Event10();\n    this._isOpen = false;\n    assert16(spaceKey && dataFeed && feedProvider);\n    this._key = spaceKey;\n    this._controlFeed = controlFeed;\n    this._dataFeed = dataFeed;\n    this._feedProvider = feedProvider;\n    this._genesisFeedKey = genesisFeed.key;\n    this._databaseFactory = databaseFactory;\n    this._controlPipeline = new ControlPipeline({\n      spaceKey,\n      genesisFeed,\n      feedProvider,\n      initialTimeframe\n    });\n    this._controlPipeline.setWriteFeed(controlFeed);\n    this._controlPipeline.onFeedAdmitted.set(async (info) => {\n      if (info.assertion.designation === AdmittedFeed2.Designation.DATA) {\n        if (!this._dataPipeline) {\n          return;\n        }\n        await this._dataPipeline.addFeed(await feedProvider(info.key));\n      }\n      if (!info.key.equals(genesisFeed.key)) {\n        this._protocol.addFeed(await feedProvider(info.key));\n      }\n    });\n    this._controlPipeline.onCredentialProcessed.set(async (credential) => {\n      await this.onCredentialProcessed.callIfSet(credential);\n      log14(\"onCredentialProcessed\", {\n        credential\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.stateUpdate.emit();\n    });\n    this._protocol = protocol;\n    this._protocol.addFeed(genesisFeed);\n  }\n  get key() {\n    return this._key;\n  }\n  get isOpen() {\n    return this._isOpen;\n  }\n  get database() {\n    if (!this._database) {\n      throw new Error(\"Space not open.\");\n    }\n    return this._database;\n  }\n  get genesisFeedKey() {\n    return this._genesisFeedKey;\n  }\n  get controlFeedKey() {\n    return this._controlFeed.key;\n  }\n  get dataFeedKey() {\n    return this._dataFeed.key;\n  }\n  get spaceState() {\n    return this._controlPipeline.spaceState;\n  }\n  get controlPipeline() {\n    return this._controlPipeline.pipeline;\n  }\n  async open() {\n    log14(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 171,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._isOpen) {\n      return;\n    }\n    await this._controlPipeline.start();\n    await this._openDataPipeline();\n    await this._protocol.start();\n    this._isOpen = true;\n    log14(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    log14(\"closing...\", {\n      key: this._key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 187,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._isOpen) {\n      return;\n    }\n    await this._protocol.stop();\n    await this._closeDataPipeline();\n    await this._controlPipeline.stop();\n    this._isOpen = false;\n    log14(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 198,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _openDataPipeline() {\n    var _a;\n    assert16(!this._dataPipeline, \"Data pipeline already initialized.\");\n    {\n      this._dataPipeline = new Pipeline(new Timeframe3());\n      this._dataPipeline.setWriteFeed(this._dataFeed);\n      for (const feed of this._controlPipeline.spaceState.feeds.values()) {\n        await this._dataPipeline.addFeed(await this._feedProvider(feed.key));\n      }\n    }\n    {\n      const feedWriter = createMappedFeedWriter((msg) => ({\n        \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n        ...msg\n      }), (_a = this._dataPipeline.writer) != null ? _a : failUndefined4());\n      this._databaseBackend = new DatabaseBackendHost(feedWriter, {}, {\n        snapshots: true\n      });\n    }\n    {\n      this._database = await this._databaseFactory({\n        databaseBackend: this._databaseBackend\n      });\n      await this._database.initialize();\n    }\n    await this._dataPipeline.start();\n    setTimeout(async () => {\n      assert16(this._dataPipeline);\n      for await (const msg of this._dataPipeline.consume()) {\n        const { feedKey, seq, data } = msg;\n        log14(\"processing message\", {\n          msg\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n          line: 246,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          const payload = data.payload;\n          if (payload[\"@type\"] === \"dxos.echo.feed.EchoEnvelope\") {\n            const feedInfo = this._controlPipeline.spaceState.feeds.get(feedKey);\n            if (!feedInfo) {\n              log14.error(\"Could not find feed.\", {\n                feedKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n                line: 253,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              continue;\n            }\n            await this._databaseBackend.echoProcessor({\n              data: payload,\n              meta: {\n                feedKey,\n                seq,\n                timeframe: data.timeframe,\n                memberKey: feedInfo.assertion.identityKey\n              }\n            });\n          }\n        } catch (err) {\n          log14.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n            line: 268,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n  }\n  async _closeDataPipeline() {\n    var _a, _b, _c;\n    assert16(this._dataPipeline, \"Data pipeline not initialized.\");\n    await ((_a = this._dataPipeline) == null ? void 0 : _a.stop());\n    await ((_b = this._databaseBackend) == null ? void 0 : _b.close());\n    await ((_c = this._database) == null ? void 0 : _c.destroy());\n  }\n};\n__decorate5([\n  logInfo\n], Space.prototype, \"key\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"open\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"close\", null);\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nimport { Event as Event11 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log16 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed3 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\nimport { discoveryKey, sha256 } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { log as log15 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nimport { adaptProtocolProvider, MMSTTopology } from \"@dxos/network-manager\";\nimport { PresencePlugin } from \"@dxos/protocol-plugin-presence\";\nimport { Teleport } from \"@dxos/teleport\";\nimport { ReplicatorExtension as TeleportReplicatorExtension } from \"@dxos/teleport-plugin-replicator\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MOCK_AUTH_PROVIDER = async (nonce) => Buffer.from(\"mock\");\nvar MOCK_AUTH_VERIFIER = async (nonce, credential) => true;\nvar USE_TELEPORT = true;\nvar SpaceProtocol = class {\n  constructor({ topic, identity, networkManager, plugins = [] }) {\n    this._replicator = new ReplicatorPlugin();\n    this._feeds = /* @__PURE__ */ new Set();\n    this._sessions = new ComplexMap2(PublicKey5.hash);\n    this._networkManager = networkManager;\n    this._swarmIdentity = identity;\n    this._presencePlugin = new PresencePlugin(this._swarmIdentity.peerKey.asBuffer());\n    this._authPlugin = new AuthPlugin(this._swarmIdentity, []);\n    this._customPlugins = plugins;\n    this._discoveryKey = PublicKey5.from(discoveryKey(sha256(topic.toHex())));\n    this._peerId = PublicKey5.from(discoveryKey(sha256(this._swarmIdentity.peerKey.toHex())));\n    this.authenticationFailed = this._authPlugin.authenticationFailed;\n  }\n  addFeed(feed) {\n    if (USE_TELEPORT) {\n      this._feeds.add(feed);\n      for (const session of this._sessions.values()) {\n        session.replicator.addFeed(feed);\n      }\n    } else {\n      this._replicator.addFeed(feed);\n    }\n  }\n  async start() {\n    if (this._connection) {\n      return;\n    }\n    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(\"\"));\n    const topologyConfig = {\n      originateConnections: 4,\n      maxPeers: 10,\n      sampleSize: 20\n    };\n    log15(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connection = await this._networkManager.joinSwarm({\n      protocolProvider: this._createProtocolProvider(credentials),\n      peerId: this._peerId,\n      topic: this._discoveryKey,\n      presence: this._presencePlugin,\n      topology: new MMSTTopology(topologyConfig),\n      label: `Protocol swarm: ${this._discoveryKey}`\n    });\n    log15(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    if (this._connection) {\n      log15(\"stopping...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._connection.close();\n      log15(\"stopped\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 132,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  _createProtocolProvider(credentials) {\n    if (USE_TELEPORT) {\n      return (params) => {\n        const session = new SpaceProtocolSession(params);\n        this._sessions.set(params.remotePeerId, session);\n        for (const feed of this._feeds) {\n          session.replicator.addFeed(feed);\n        }\n        return session;\n      };\n    } else {\n      return adaptProtocolProvider(({ channel, initiator }) => {\n        const protocol = new Protocol({\n          streamOptions: {\n            live: true\n          },\n          discoveryKey: channel,\n          discoveryToPublicKey: (discoveryKey2) => {\n            if (!PublicKey5.from(discoveryKey2).equals(this._discoveryKey)) {\n              return void 0;\n            }\n            protocol.setContext({\n              topic: this._discoveryKey.toHex()\n            });\n            return this._discoveryKey.asBuffer();\n          },\n          userSession: {\n            peerId: this._peerId.toHex(),\n            credentials: credentials ? Buffer.from(credentials).toString(\"base64\") : void 0\n          },\n          initiator\n        });\n        const plugins = [\n          this._presencePlugin,\n          this._authPlugin,\n          this._replicator,\n          ...this._customPlugins\n        ];\n        protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n        return protocol;\n      });\n    }\n  }\n  get peers() {\n    return this._presencePlugin.peers.map((peer) => PublicKey5.from(peer));\n  }\n};\nvar SpaceProtocolSession = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this.replicator = new TeleportReplicatorExtension().setOptions({\n      upload: true\n    });\n    this._teleport = new Teleport({\n      initiator,\n      localPeerId,\n      remotePeerId\n    });\n  }\n  get stream() {\n    return this._teleport.stream;\n  }\n  async initialize() {\n    await this._teleport.open();\n    this._teleport.addExtension(\"dxos.mesh.teleport.replicator\", this.replicator);\n  }\n  async destroy() {\n    await this._teleport.close();\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nvar SpaceManager = class {\n  constructor({ metadataStore, feedStore, networkManager, keyring, dataServiceSubscriptions, modelFactory, signingContext }) {\n    this.updated = new Event11();\n    this._spaces = new ComplexMap3(PublicKey6.hash);\n    this._metadataStore = metadataStore;\n    this._feedStore = feedStore;\n    this._networkManager = networkManager;\n    this._keyring = keyring;\n    this._dataServiceSubscriptions = dataServiceSubscriptions;\n    this._modelFactory = modelFactory;\n    this._signingContext = signingContext;\n  }\n  get spaces() {\n    return this._spaces;\n  }\n  async open() {\n    await this._metadataStore.load();\n    for (const spaceMetadata of this._metadataStore.spaces) {\n      const space = await this._constructSpace(spaceMetadata);\n      await space.open();\n      this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n      this._spaces.set(spaceMetadata.key, space);\n    }\n  }\n  async close() {\n    await Promise.all([\n      ...this._spaces.values()\n    ].map((space) => space.close()));\n  }\n  async createSpace() {\n    const spaceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n    const metadata = {\n      key: spaceKey,\n      genesisFeedKey: controlFeedKey,\n      controlFeedKey,\n      dataFeedKey\n    };\n    log16(\"creating space...\", {\n      spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, this._signingContext.identityKey, this._signingContext.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(spaceKey, controlFeedKey, this._signingContext.profile),\n        await generator.createFeedAdmission(spaceKey, dataFeedKey, AdmittedFeed3.Designation.DATA)\n      ];\n      for (const credential of credentials) {\n        await space.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  async acceptSpace(opts) {\n    const metadata = {\n      key: opts.spaceKey,\n      genesisFeedKey: opts.genesisFeedKey,\n      controlFeedKey: await this._keyring.createKey(),\n      dataFeedKey: await this._keyring.createKey()\n    };\n    log16(\"accepting space...\", {\n      spaceKey: opts.spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 161,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  _insertSpace(space) {\n    this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n    this._spaces.set(space.key, space);\n    this.updated.emit();\n  }\n  async _constructSpace(metadata) {\n    var _a, _b, _c;\n    log16(\"constructing space...\", {\n      spaceKey: metadata.genesisFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 177,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeed = await this._feedStore.openFeed((_a = metadata.controlFeedKey) != null ? _a : failUndefined5(), {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed((_b = metadata.dataFeedKey) != null ? _b : failUndefined5(), {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed((_c = metadata.genesisFeedKey) != null ? _c : failUndefined5());\n    const spaceKey = metadata.key;\n    const protocol = new SpaceProtocol({\n      topic: spaceKey,\n      identity: {\n        peerKey: this._signingContext.deviceKey,\n        credentialProvider: this._signingContext.credentialProvider,\n        credentialAuthenticator: this._signingContext.credentialAuthenticator\n      },\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, this._signingContext.identityKey)\n    });\n  }\n};\nexport {\n  AuthPlugin,\n  DBError,\n  DataMirror,\n  DataServiceHost,\n  DataServiceImpl,\n  DataServiceSubscriptions,\n  Database,\n  DatabaseBackendHost,\n  DatabaseBackendProxy,\n  Entity,\n  EntityNotFoundError,\n  IdentityNotInitializedError,\n  InvalidInvitationError,\n  InvalidStorageVersionError,\n  Item,\n  ItemDemuxer,\n  ItemFilterDeleted,\n  ItemManager,\n  Link,\n  MOCK_AUTH_PROVIDER,\n  MOCK_AUTH_VERIFIER,\n  MetadataStore,\n  ReplicatorPlugin,\n  ResultSet,\n  STORAGE_VERSION,\n  Schema,\n  Selection,\n  SelectionResult,\n  Space,\n  SpaceManager,\n  SpaceNotFoundError,\n  SpaceProtocol,\n  SpaceProtocolSession,\n  State,\n  TYPE_SCHEMA,\n  USE_TELEPORT,\n  UnknownModelError,\n  codec,\n  coerceToId,\n  createItemSelection,\n  createMappedFeedWriter,\n  createQueryOptionsFilter,\n  createSelection,\n  dedupe,\n  filterToPredicate,\n  itemFilterToPredicate,\n  linkFilterToPredicate,\n  resultSetToStream,\n  sortItemsTopologically,\n  streamToResultSet,\n  testOneOrMultiple,\n  valueEncoding\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465328,"end":1670465466022},{"name":"vite:react-babel","result":"// packages/core/echo/echo-db/src/packlets/api/result-set.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar ResultSet = class {\n  constructor(itemUpdate, getter) {\n    this._resultsUpdate = new Event();\n    this.update = this._resultsUpdate;\n    assert(itemUpdate);\n    assert(getter);\n    this._itemUpdate = itemUpdate;\n    this._getter = getter;\n    this._resultsUpdate.addEffect(() => this._itemUpdate.on(() => {\n      this._resultsUpdate.emit(this._getter());\n    }));\n  }\n  get value() {\n    return this._getter();\n  }\n  get first() {\n    const value = this._getter();\n    assert(value.length);\n    return value[0];\n  }\n  subscribe(listener) {\n    return this._resultsUpdate.on(listener);\n  }\n  waitFor(condition) {\n    if (condition(this.value)) {\n      return Promise.resolve(this.value);\n    }\n    return this._resultsUpdate.waitFor(condition);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/schema.ts\nvar TYPE_SCHEMA = \"dxos:type/schema\";\nvar Schema = class {\n  constructor(_schema) {\n    this._schema = _schema;\n  }\n  get name() {\n    return this._schema.get(\"schema\");\n  }\n  get fields() {\n    var _a;\n    return Object.values((_a = this._schema.get(\"fields\")) != null ? _a : {});\n  }\n  getField(key) {\n    return this.fields.find((field) => field.key === key);\n  }\n  validate(model) {\n    return this.fields.every((field) => {\n      const value = model.get(field.key);\n      if (!value) {\n        return !field.required;\n      }\n      if (field.type) {\n        if (typeof value !== field.type) {\n          return false;\n        }\n      }\n      if (field.ref) {\n      }\n      return true;\n    });\n  }\n  async addField(newField) {\n    const newFields = [\n      ...this.fields,\n      newField\n    ];\n    await this._schema.set(\"fields\", newFields);\n  }\n  async editField(currentKey, editedField) {\n    const newFields = this.fields.map((field) => {\n      if (field.key === currentKey) {\n        return editedField;\n      }\n      return field;\n    });\n    await this._schema.set(\"fields\", newFields);\n  }\n  async deleteField(key) {\n    const newFields = this.fields.filter((field) => field.key !== key);\n    await this._schema.set(\"fields\", newFields);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/subscription.ts\nimport { Event as Event2 } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nvar resultSetToStream = (resultSet, map) => new Stream(({ next }) => {\n  next(map(resultSet.value));\n  return resultSet.update.on(() => next(map(resultSet.value)));\n});\nvar streamToResultSet = (stream, map) => {\n  const event = new Event2();\n  let lastItem;\n  stream.subscribe((data) => {\n    lastItem = data;\n    event.emit();\n  });\n  return new ResultSet(event, () => map(lastItem));\n};\n\n// packages/core/echo/echo-db/src/packlets/common/codec.ts\nimport { createCodecEncoding } from \"@dxos/hypercore\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.echo.feed.FeedMessage\");\nvar valueEncoding = createCodecEncoding(codec);\n\n// packages/core/echo/echo-db/src/packlets/common/feeds.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createMappedFeedWriter = (mapper, writer) => {\n  assert2(mapper);\n  assert2(writer);\n  return {\n    write: async (data) => await writer.write(await mapper(data))\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-mirror.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { failUndefined } from \"@dxos/debug\";\nvar log = debug(\"dxos:echo-db:data-mirror\");\nvar DataMirror = class {\n  constructor(_itemManager, _dataService, _spaceKey) {\n    this._itemManager = _itemManager;\n    this._dataService = _dataService;\n    this._spaceKey = _spaceKey;\n  }\n  open() {\n    const entities = this._dataService.subscribeEntitySet({\n      spaceKey: this._spaceKey\n    });\n    entities.subscribe(async (diff) => {\n      var _a, _b;\n      for (const addedEntity of (_a = diff.added) != null ? _a : []) {\n        log(`Construct: ${JSON.stringify(addedEntity)}`);\n        assert3(addedEntity.itemId);\n        assert3(addedEntity.genesis);\n        assert3(addedEntity.genesis.modelType);\n        let entity;\n        if (addedEntity.genesis.link) {\n          assert3(addedEntity.genesis.link.source);\n          assert3(addedEntity.genesis.link.target);\n          entity = await this._itemManager.constructLink({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            source: addedEntity.genesis.link.source,\n            target: addedEntity.genesis.link.target,\n            snapshot: {}\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            parentId: (_b = addedEntity.itemMutation) == null ? void 0 : _b.parentId,\n            snapshot: {}\n          });\n        }\n        this._subscribeToUpdates(entity);\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n  _subscribeToUpdates(entity) {\n    const stream = this._dataService.subscribeEntityStream({\n      spaceKey: this._spaceKey,\n      itemId: entity.id\n    });\n    stream.subscribe(async (update) => {\n      var _a, _b, _c, _d, _e, _f;\n      log(`Update[${entity.id}]: ${JSON.stringify(update)}`);\n      if (update.snapshot) {\n        assert3(update.snapshot.model);\n        entity._stateManager.resetToSnapshot(update.snapshot.model);\n      } else if (update.mutation) {\n        if ((_a = update.mutation.data) == null ? void 0 : _a.mutation) {\n          assert3(update.mutation.meta);\n          await entity._stateManager.processMessage({\n            feedKey: (_b = update.mutation.meta.feedKey) != null ? _b : failUndefined(),\n            memberKey: (_c = update.mutation.meta.memberKey) != null ? _c : failUndefined(),\n            seq: (_d = update.mutation.meta.seq) != null ? _d : failUndefined(),\n            timeframe: (_e = update.mutation.meta.timeframe) != null ? _e : failUndefined()\n          }, (_f = update.mutation.data.mutation) != null ? _f : failUndefined());\n        }\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nimport debug3 from \"debug\";\nimport assert6 from \"@dxos/node-std/assert\";\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { failUndefined as failUndefined2, raise } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\n\n// packages/core/echo/echo-db/src/packlets/errors/errors.ts\nvar DBError = class extends Error {\n  constructor(code, message, context) {\n    super(message ? `${code}: ${message}` : code.toString());\n    this.code = code;\n    this.context = context;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar IdentityNotInitializedError = class extends DBError {\n  constructor() {\n    super(\"IDENTITY_NOT_INITIALIZED\", \"Identity not initialized.\");\n  }\n};\nvar InvalidInvitationError = class extends DBError {\n  constructor() {\n    super(\"INVALID_INVITATION\", \"Invitation is invalid.\");\n  }\n};\nvar InvalidStorageVersionError = class extends DBError {\n  constructor(expected, actual) {\n    super(\"INVALID_STORAGE_VERSION\", \"Invalid storage version.\", {\n      expected,\n      actual\n    });\n  }\n};\nvar SpaceNotFoundError = class extends DBError {\n  constructor(spaceKey) {\n    super(\"SPACE_NOT_FOUND\", \"Space not found.\", {\n      spaceKey\n    });\n  }\n};\nvar EntityNotFoundError = class extends DBError {\n  constructor(entityId) {\n    super(\"ENTITY_NOT_FOUND\", \"Entity not found.\", {\n      entityId\n    });\n  }\n};\nvar UnknownModelError = class extends DBError {\n  constructor(model) {\n    super(\"UNKNOWN_MODEL\", \"Unknown model.\", {\n      model\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nimport debug2 from \"debug\";\nimport { ItemMutation } from \"@dxos/protocols/proto/dxos/echo/feed\";\n\n// packages/core/echo/echo-db/src/packlets/database/entity.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nvar Entity = class {\n  constructor(_itemManager, _id, _type, stateManager) {\n    this._itemManager = _itemManager;\n    this._id = _id;\n    this._type = _type;\n    this._onUpdate = new Event3();\n    this._subscriptions = new EventSubscriptions();\n    this._stateManager = stateManager;\n    if (this._stateManager.initialized) {\n      this._subscriptions.add(this._stateManager.model.subscribe(() => this._onUpdate.emit(this)));\n    }\n  }\n  get id() {\n    return this._id;\n  }\n  get type() {\n    return this._type;\n  }\n  get modelType() {\n    return this._stateManager.modelType;\n  }\n  get modelMeta() {\n    return this._stateManager.model.modelMeta;\n  }\n  get model() {\n    if (!this._stateManager.initialized) {\n      return null;\n    }\n    return this._stateManager.model;\n  }\n  subscribe(listener) {\n    return this._onUpdate.on(listener);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/util.ts\nvar dedupe = (values) => Array.from(new Set(values));\nvar coerceToId = (item) => {\n  if (typeof item === \"string\") {\n    return item;\n  }\n  return item.id;\n};\nvar testOneOrMultiple = (expected, value) => {\n  if (Array.isArray(expected)) {\n    return expected.includes(value);\n  } else {\n    return expected === value;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/queries.ts\nvar ItemFilterDeleted;\n(function(ItemFilterDeleted2) {\n  ItemFilterDeleted2[ItemFilterDeleted2[\"HIDE_DELETED\"] = 0] = \"HIDE_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED\"] = 1] = \"SHOW_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED_ONLY\"] = 2] = \"SHOW_DELETED_ONLY\";\n})(ItemFilterDeleted || (ItemFilterDeleted = {}));\nvar filterToPredicate = (filter) => {\n  if (typeof filter === \"function\") {\n    return filter;\n  }\n  return itemFilterToPredicate(filter);\n};\nvar itemFilterToPredicate = (filter) => {\n  if (\"id\" in filter) {\n    return (item) => item.id === filter.id;\n  } else {\n    return (item) => {\n      var _a;\n      return (!filter.type || testOneOrMultiple(filter.type, item.type)) && (!filter.parent || ((_a = item.parent) == null ? void 0 : _a.id) === coerceToId(filter.parent));\n    };\n  }\n};\nvar linkFilterToPredicate = (filter) => (link) => !filter.type || testOneOrMultiple(filter.type, link.type);\nvar createQueryOptionsFilter = ({ deleted = ItemFilterDeleted.HIDE_DELETED }) => (entity) => {\n  if (entity.model === null) {\n    return false;\n  }\n  switch (deleted) {\n    case ItemFilterDeleted.HIDE_DELETED:\n      return !(entity instanceof Item) || !entity.deleted;\n    case ItemFilterDeleted.SHOW_DELETED:\n      return true;\n    case ItemFilterDeleted.SHOW_DELETED_ONLY:\n      return entity instanceof Item && entity.deleted;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/result.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4 } from \"@dxos/async\";\nvar SelectionResult = class {\n  constructor(_execute, _update, _root, _reducer) {\n    this._execute = _execute;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n    this.update = new Event4();\n    this._lastResult = [\n      []\n    ];\n    this.refresh();\n    this.update.addEffect(() => _update.on((currentEntities) => {\n      const [previousEntities] = this._lastResult;\n      this.refresh();\n      const set = /* @__PURE__ */ new Set([\n        ...previousEntities,\n        ...this._lastResult[0]\n      ]);\n      if (this._reducer || currentEntities.some((entity) => set.has(entity))) {\n        this.update.emit(this);\n      }\n    }));\n  }\n  toString() {\n    const [entities] = this._lastResult;\n    return `SelectionResult<${JSON.stringify({\n      entities: entities.length\n    })}>`;\n  }\n  refresh() {\n    const [entities, result] = this._execute();\n    this._lastResult = [\n      dedupe(entities),\n      result\n    ];\n    return this;\n  }\n  get root() {\n    return this._root;\n  }\n  get entities() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities] = this._lastResult;\n    return entities;\n  }\n  get value() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities, value] = this._lastResult;\n    return this._reducer ? value : entities;\n  }\n  expectOne() {\n    const entities = this.entities;\n    assert4(entities.length === 1, `Expected one result; got ${entities.length}`);\n    return entities[0];\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/selection.ts\nvar createSelection = (itemsProvider, updateEventProvider, root, filter, value) => {\n  const predicate = filter ? filterToPredicate(filter) : () => true;\n  const visitor = (options) => {\n    const items = itemsProvider().filter(createQueryOptionsFilter(options)).filter(predicate);\n    return [\n      items,\n      value\n    ];\n  };\n  return new Selection(visitor, updateEventProvider(), root, value !== void 0);\n};\nvar createItemSelection = (root, update, value) => new Selection(() => [\n  [\n    root\n  ],\n  value\n], update, root, value !== void 0);\nvar Selection = class {\n  constructor(_visitor, _update, _root, _reducer = false) {\n    this._visitor = _visitor;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n  }\n  _createSubSelection(map) {\n    return new Selection((options) => map(this._visitor(options), options), this._update, this._root, this._reducer);\n  }\n  exec(options = {}) {\n    return this.query(options);\n  }\n  query(options = {}) {\n    return new SelectionResult(() => this._visitor(options), this._update, this._root, this._reducer);\n  }\n  get root() {\n    return this._root;\n  }\n  call(visitor) {\n    return this._createSubSelection(([items, result]) => [\n      items,\n      visitor(items, result)\n    ]);\n  }\n  filter(filter) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([items, result]) => [\n      items.filter(predicate),\n      result\n    ]);\n  }\n  children(filter) {\n    const predicate = filter ? filterToPredicate(filter) : Boolean;\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => Array.from(item._children.values()).filter(createQueryOptionsFilter(options)).filter(predicate)),\n      result\n    ]);\n  }\n  parent() {\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.parent ? [\n        item.parent\n      ].filter(createQueryOptionsFilter(options)) : []),\n      result\n    ]);\n  }\n  links(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.links.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  refs(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.refs.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  target(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.target).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n  source(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.source).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nvar log2 = debug2(\"dxos:echo-db:item\");\nvar Item = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, _writeStream, parent) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._writeStream = _writeStream;\n    this._parent = null;\n    this._deleted = false;\n    this._children = /* @__PURE__ */ new Set();\n    this._links = /* @__PURE__ */ new Set();\n    this._refs = /* @__PURE__ */ new Set();\n    this._updateParent(parent);\n  }\n  toString() {\n    var _a;\n    return `Item(${JSON.stringify({\n      itemId: this.id,\n      parentId: (_a = this.parent) == null ? void 0 : _a.id,\n      itemType: this.type\n    })})`;\n  }\n  get readOnly() {\n    return !this._writeStream || this._deleted;\n  }\n  get deleted() {\n    return this._deleted;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return Array.from(this._children.values()).filter((item) => !item.deleted);\n  }\n  get links() {\n    return Array.from(this._links.values()).filter((link) => !link._isDangling());\n  }\n  get refs() {\n    return Array.from(this._refs.values()).filter((link) => !link._isDangling());\n  }\n  select() {\n    return createItemSelection(this, this._itemManager.debouncedUpdate, void 0);\n  }\n  async delete() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (this.deleted) {\n      return;\n    }\n    const onUpdate = this._onUpdate.waitFor(() => this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.DELETE\n      }\n    });\n    await onUpdate;\n  }\n  async restore() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (!this.deleted) {\n      throw new Error(`Item was note delted: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => !this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.RESTORE\n      }\n    });\n    await onUpdate;\n  }\n  async setParent(parentId) {\n    if (!this._writeStream || this.readOnly) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => {\n      var _a;\n      return parentId === ((_a = this._parent) == null ? void 0 : _a.id);\n    });\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        parentId\n      }\n    });\n    await onUpdate;\n  }\n  _processMutation(mutation, getItem) {\n    log2(\"_processMutation %s\", JSON.stringify(mutation));\n    const { action, parentId } = mutation;\n    switch (action) {\n      case ItemMutation.Action.DELETE: {\n        this._deleted = true;\n        break;\n      }\n      case ItemMutation.Action.RESTORE: {\n        this._deleted = false;\n        break;\n      }\n    }\n    if (parentId) {\n      const parent = getItem(parentId);\n      this._updateParent(parent);\n    }\n    this._onUpdate.emit(this);\n  }\n  _updateParent(parent) {\n    if (this._parent) {\n      this._parent._children.delete(this);\n    }\n    if (parent) {\n      this._parent = parent;\n      this._parent._children.add(this);\n    } else {\n      this._parent = null;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/link.ts\nimport assert5 from \"@dxos/node-std/assert\";\nvar Link = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, link) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._link = link;\n  }\n  get isLink() {\n    return true;\n  }\n  get sourceId() {\n    return this._link.sourceId;\n  }\n  get targetId() {\n    return this._link.targetId;\n  }\n  get source() {\n    assert5(this._link.source, \"Dangling link\");\n    return this._link.source;\n  }\n  get target() {\n    assert5(this._link.target, \"Dangling link\");\n    return this._link.target;\n  }\n  _isDangling() {\n    return !this._link.source || !this._link.target;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nvar log3 = debug3(\"dxos:echo-db:data-service-host\");\nvar DataServiceHost = class {\n  constructor(_itemManager, _itemDemuxer, _writeStream) {\n    this._itemManager = _itemManager;\n    this._itemDemuxer = _itemDemuxer;\n    this._writeStream = _writeStream;\n  }\n  subscribeEntitySet() {\n    return new Stream2(({ next }) => {\n      const trackedSet = /* @__PURE__ */ new Set();\n      const entityInfo = (id) => {\n        var _a, _b;\n        const entity = (_a = this._itemManager.entities.get(id)) != null ? _a : failUndefined2();\n        return {\n          itemId: id,\n          genesis: {\n            itemType: entity.type,\n            modelType: entity.modelType,\n            link: entity instanceof Link ? {\n              source: entity.sourceId,\n              target: entity.targetId\n            } : void 0\n          },\n          itemMutation: entity instanceof Item ? {\n            parentId: (_b = entity.parent) == null ? void 0 : _b.id\n          } : void 0\n        };\n      };\n      const update = () => {\n        const added = /* @__PURE__ */ new Set();\n        const deleted = /* @__PURE__ */ new Set();\n        for (const entity of this._itemManager.entities.keys()) {\n          if (!trackedSet.has(entity)) {\n            added.add(entity);\n            trackedSet.add(entity);\n          }\n        }\n        for (const entity1 of trackedSet) {\n          if (!this._itemManager.entities.has(entity1)) {\n            deleted.add(entity1);\n            trackedSet.delete(entity1);\n          }\n        }\n        next({\n          added: Array.from(added).map((id) => entityInfo(id)),\n          deleted: Array.from(added).map((id) => ({\n            itemId: id\n          }))\n        });\n      };\n      update();\n      return this._itemManager.debouncedUpdate.on(update);\n    });\n  }\n  subscribeEntityStream(request) {\n    return new Stream2(({ next }) => {\n      assert6(request.itemId);\n      const entityItem = this._itemManager.items.find((item) => item.id === request.itemId);\n      let snapshot;\n      if (entityItem) {\n        snapshot = this._itemDemuxer.createItemSnapshot(entityItem);\n      } else {\n        const entityLink = this._itemManager.links.find((link) => link.id === request.itemId);\n        if (entityLink) {\n          snapshot = this._itemDemuxer.createLinkSnapshot(entityLink);\n        } else {\n          raise(new EntityNotFoundError(request.itemId));\n        }\n      }\n      log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n        snapshot\n      })}`);\n      next({\n        snapshot\n      });\n      return this._itemDemuxer.mutation.on((mutation) => {\n        if (mutation.data.itemId !== request.itemId) {\n          return;\n        }\n        log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n          mutation\n        })}`);\n        next({\n          mutation: {\n            data: mutation.data,\n            meta: {\n              feedKey: PublicKey.from(mutation.meta.feedKey),\n              memberKey: PublicKey.from(mutation.meta.memberKey),\n              seq: mutation.meta.seq,\n              timeframe: mutation.meta.timeframe\n            }\n          }\n        });\n      });\n    });\n  }\n  async write(request) {\n    assert6(this._writeStream, \"Cannot write mutations in readonly mode\");\n    return this._writeStream.write(request);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { raise as raise2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar DataServiceSubscriptions = class {\n  constructor() {\n    this._spaces = new ComplexMap(PublicKey2.hash);\n  }\n  clear() {\n    this._spaces.clear();\n  }\n  registerSpace(spaceKey, host) {\n    this._spaces.set(spaceKey, host);\n  }\n  unregisterSpace(spaceKey) {\n    this._spaces.delete(spaceKey);\n  }\n  getDataService(spaceKey) {\n    return this._spaces.get(spaceKey);\n  }\n};\nvar DataServiceImpl = class {\n  constructor(_subscriptions) {\n    this._subscriptions = _subscriptions;\n  }\n  subscribeEntitySet(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntitySet();\n  }\n  subscribeEntityStream(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntityStream(request);\n  }\n  write(request) {\n    var _a;\n    assert7(request.spaceKey);\n    assert7(request.mutation);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.write(request.mutation);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nimport debug5 from \"debug\";\nimport assert9 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\n\n// packages/core/echo/echo-db/src/packlets/database/item-demuxer.ts\nimport debug4 from \"debug\";\nimport assert8 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nvar log4 = debug4(\"dxos:echo-db:item-demuxer\");\nvar ItemDemuxer = class {\n  constructor(_itemManager, _modelFactory, _options = {}) {\n    this._itemManager = _itemManager;\n    this._modelFactory = _modelFactory;\n    this._options = _options;\n    this.mutation = new Event5();\n  }\n  open() {\n    this._modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    });\n    return async (message) => {\n      var _a, _b, _c;\n      const { data: { itemId, genesis, itemMutation, mutation, snapshot }, meta } = message;\n      assert8(itemId);\n      if (genesis) {\n        const { itemType, modelType } = genesis;\n        assert8(modelType);\n        const modelOpts = {\n          itemId,\n          modelType,\n          snapshot: {\n            mutations: mutation ? [\n              {\n                mutation,\n                meta\n              }\n            ] : void 0\n          }\n        };\n        let entity;\n        if (genesis.link) {\n          entity = await this._itemManager.constructLink({\n            ...modelOpts,\n            itemType,\n            source: (_a = genesis.link.source) != null ? _a : failUndefined3(),\n            target: (_b = genesis.link.target) != null ? _b : failUndefined3()\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            ...modelOpts,\n            parentId: itemMutation == null ? void 0 : itemMutation.parentId,\n            itemType\n          });\n        }\n        assert8(entity.id === itemId);\n      }\n      if (itemMutation) {\n        const item = this._itemManager.getItem(itemId);\n        assert8(item);\n        item._processMutation(itemMutation, (itemId2) => this._itemManager.getItem(itemId2));\n      }\n      if (mutation && !genesis) {\n        assert8(message.data.mutation);\n        const modelMessage = {\n          meta,\n          mutation\n        };\n        await this._itemManager.processModelMessage(itemId, modelMessage);\n      }\n      if (snapshot) {\n        const entity1 = (_c = this._itemManager.entities.get(itemId)) != null ? _c : failUndefined3();\n        entity1._stateManager.resetToSnapshot(snapshot);\n      }\n      this.mutation.emit(message);\n    };\n  }\n  createSnapshot() {\n    assert8(this._options.snapshots, \"Snapshots are disabled\");\n    return {\n      items: this._itemManager.items.map((item) => this.createItemSnapshot(item)),\n      links: this._itemManager.links.map((link) => this.createLinkSnapshot(link))\n    };\n  }\n  createItemSnapshot(item) {\n    var _a;\n    const model = item._stateManager.createSnapshot();\n    return {\n      itemId: item.id,\n      itemType: item.type,\n      modelType: item.modelType,\n      parentId: (_a = item.parent) == null ? void 0 : _a.id,\n      model\n    };\n  }\n  createLinkSnapshot(link) {\n    const model = link._stateManager.createSnapshot();\n    return {\n      linkId: link.id,\n      linkType: link.type,\n      modelType: link.modelMeta.type,\n      source: link.source.id,\n      target: link.target.id,\n      model\n    };\n  }\n  async restoreFromSnapshot(snapshot) {\n    const { items = [], links = [] } = snapshot;\n    log4(`Restoring ${items.length} items from snapshot.`);\n    for (const item of sortItemsTopologically(items)) {\n      assert8(item.itemId);\n      assert8(item.modelType);\n      assert8(item.model);\n      await this._itemManager.constructItem({\n        itemId: item.itemId,\n        modelType: item.modelType,\n        itemType: item.itemType,\n        parentId: item.parentId,\n        snapshot: item.model\n      });\n    }\n    log4(`Restoring ${links.length} links from snapshot.`);\n    for (const link of links) {\n      assert8(link.linkId);\n      assert8(link.modelType);\n      assert8(link.model);\n      await this._itemManager.constructLink({\n        itemId: link.linkId,\n        itemType: link.linkType,\n        modelType: link.modelType,\n        source: link.source,\n        target: link.target,\n        snapshot: link.model\n      });\n    }\n  }\n};\nvar sortItemsTopologically = (items) => {\n  const snapshots = [];\n  const seenIds = /* @__PURE__ */ new Set();\n  while (snapshots.length !== items.length) {\n    const prevLength = snapshots.length;\n    for (const item of items) {\n      assert8(item.itemId);\n      if (!seenIds.has(item.itemId) && (item.parentId == null || seenIds.has(item.parentId))) {\n        snapshots.push(item);\n        seenIds.add(item.itemId);\n      }\n    }\n    if (prevLength === snapshots.length && snapshots.length !== items.length) {\n      throw new Error(\"Cannot topologically sorts items in snapshot: some parents are missing.\");\n    }\n  }\n  return snapshots;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nvar log5 = debug5(\"dxos:echo-db:database-backend\");\nvar DatabaseBackendHost = class {\n  constructor(_outboundStream, _snapshot, _options = {}) {\n    this._outboundStream = _outboundStream;\n    this._snapshot = _snapshot;\n    this._options = _options;\n  }\n  get isReadOnly() {\n    return !!this._outboundStream;\n  }\n  get echoProcessor() {\n    return this._echoProcessor;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    this._itemDemuxer = new ItemDemuxer(itemManager, modelFactory, this._options);\n    this._echoProcessor = this._itemDemuxer.open();\n    if (this._snapshot) {\n      await this._itemDemuxer.restoreFromSnapshot(this._snapshot);\n    }\n  }\n  async close() {\n  }\n  getWriteStream() {\n    return this._outboundStream;\n  }\n  createSnapshot() {\n    return this._itemDemuxer.createSnapshot();\n  }\n  createDataServiceHost() {\n    var _a;\n    return new DataServiceHost(this._itemManager, this._itemDemuxer, (_a = this._outboundStream) != null ? _a : void 0);\n  }\n};\nvar DatabaseBackendProxy = class {\n  constructor(_service, _spaceKey) {\n    this._service = _service;\n    this._spaceKey = _spaceKey;\n    this._subscriptions = new EventSubscriptions2();\n  }\n  get isReadOnly() {\n    return false;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    const dataMirror = new DataMirror(this._itemManager, this._service, this._spaceKey);\n    this._subscriptions.add(modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    }));\n    dataMirror.open();\n  }\n  async close() {\n    this._subscriptions.clear();\n  }\n  getWriteStream() {\n    return {\n      write: async (mutation) => {\n        log5(\"write\", mutation);\n        const { feedKey, seq } = await this._service.write({\n          mutation,\n          spaceKey: this._spaceKey\n        });\n        assert9(feedKey);\n        assert9(seq !== void 0);\n        return {\n          feedKey,\n          seq\n        };\n      }\n    };\n  }\n  createSnapshot() {\n    throw new Error(\"Method not supported.\");\n  }\n  createDataServiceHost() {\n    throw new Error(\"Method not supported.\");\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item-manager.ts\nimport debug6 from \"debug\";\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Event as Event6, trigger } from \"@dxos/async\";\nimport { createId } from \"@dxos/crypto\";\nimport { timed } from \"@dxos/debug\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar log6 = debug6(\"dxos:echo-db:item-manager\");\nvar ItemManager = class {\n  constructor(_modelFactory, _memberKey, _writeStream) {\n    this._modelFactory = _modelFactory;\n    this._memberKey = _memberKey;\n    this._writeStream = _writeStream;\n    this.update = new Event6();\n    this.debouncedUpdate = debounceEntityUpdateEvent(this.update);\n    this._entities = /* @__PURE__ */ new Map();\n    this._pendingItems = /* @__PURE__ */ new Map();\n  }\n  get entities() {\n    return this._entities;\n  }\n  get items() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Item);\n  }\n  get links() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Link);\n  }\n  async createItem(modelType, itemType, parentId, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Model does not support initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis\", {\n      itemId\n    });\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType\n      },\n      itemMutation: parentId ? {\n        parentId\n      } : void 0,\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const item = await waitForCreation();\n    assert10(item instanceof Item);\n    return item;\n  }\n  async createLink(modelType, itemType, source, target, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Tried to provide initialization params to a model with no initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis:\", itemId);\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType,\n        link: {\n          source,\n          target\n        }\n      },\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const link = await waitForCreation();\n    assert10(link instanceof Link);\n    return link;\n  }\n  async _constructModel({ modelType, itemId, snapshot }) {\n    const outboundTransform = this._writeStream && createMappedFeedWriter((mutation) => ({\n      itemId,\n      mutation\n    }), this._writeStream);\n    return this._modelFactory.createModel(modelType, itemId, snapshot, this._memberKey, outboundTransform);\n  }\n  _addEntity(entity, parent) {\n    var _a;\n    assert10(!this._entities.has(entity.id));\n    this._entities.set(entity.id, entity);\n    log6(\"New entity:\", String(entity));\n    this.update.emit(entity);\n    entity.subscribe(() => {\n      this.update.emit(entity);\n    });\n    (_a = this._pendingItems.get(entity.id)) == null ? void 0 : _a(entity);\n  }\n  async constructItem({ itemId, itemType, modelType, parentId, snapshot }) {\n    assert10(itemId);\n    assert10(modelType);\n    const parent = parentId ? this._entities.get(parentId) : null;\n    if (parentId && !parent) {\n      throw new Error(`Missing parent: ${parentId}`);\n    }\n    assert10(!parent || parent instanceof Item);\n    const modelStateManager = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const item = new Item(this, itemId, itemType, modelStateManager, this._writeStream, parent);\n    if (parent) {\n      this.update.emit(parent);\n    }\n    this._addEntity(item);\n    return item;\n  }\n  async constructLink({ itemId, itemType, modelType, snapshot, source, target }) {\n    assert10(itemId);\n    assert10(modelType);\n    const model = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const sourceItem = this.getItem(source);\n    const targetItem = this.getItem(target);\n    const link = new Link(this, itemId, itemType, model, {\n      sourceId: source,\n      targetId: target,\n      source: sourceItem,\n      target: targetItem\n    });\n    if (sourceItem) {\n      sourceItem._links.add(link);\n      this.update.emit(sourceItem);\n    }\n    if (targetItem) {\n      targetItem._refs.add(link);\n      this.update.emit(targetItem);\n    }\n    this._addEntity(link);\n    return link;\n  }\n  async processModelMessage(itemId, message) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    await item._stateManager.processMessage(message.meta, message.mutation);\n    this.update.emit(item);\n  }\n  getItem(itemId) {\n    const entity = this._entities.get(itemId);\n    if (entity) {\n      assert10(entity instanceof Item);\n    }\n    return entity;\n  }\n  getUninitializedEntities() {\n    return Array.from(this._entities.values()).filter((entity) => !entity._stateManager.initialized);\n  }\n  deconstructItem(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    this._entities.delete(itemId);\n    if (item instanceof Item) {\n      if (item.parent) {\n        item.parent._children.delete(item);\n      }\n      for (const child of item.children) {\n        this.deconstructItem(child.id);\n      }\n      for (const ref of item.refs) {\n        ref._link.target = void 0;\n      }\n      for (const link of item.links) {\n        link._link.source = void 0;\n      }\n    }\n  }\n  async initializeModel(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    const model = this._modelFactory.getModel(item._stateManager.modelType);\n    assert10(model, \"Model not registered\");\n    item._stateManager.initialize(model.constructor);\n    this.update.emit(item);\n  }\n};\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createLink\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructLink\", null);\nvar debounceEntityUpdateEvent = (event) => {\n  const debouncedEvent = new Event6();\n  let firing = false;\n  const emittedSinceLastFired = /* @__PURE__ */ new Set();\n  debouncedEvent.addEffect(() => event.on((arg) => {\n    emittedSinceLastFired.add(arg);\n    if (!firing) {\n      firing = true;\n      setTimeout(() => {\n        firing = false;\n        const args = Array.from(emittedSinceLastFired);\n        emittedSinceLastFired.clear();\n        debouncedEvent.emit(args);\n      }, 0);\n    }\n  }));\n  return debouncedEvent;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport { synchronized } from \"@dxos/async\";\nimport { validateModelClass } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar State;\n(function(State2) {\n  State2[\"NULL\"] = \"NULL\";\n  State2[\"INITIALIZED\"] = \"INITIALIZED\";\n  State2[\"DESTROYED\"] = \"DESTROYED\";\n})(State || (State = {}));\nvar Database = class {\n  constructor(_modelFactory, _backend, memberKey) {\n    this._modelFactory = _modelFactory;\n    this._backend = _backend;\n    this._state = State.NULL;\n    this._itemManager = new ItemManager(this._modelFactory, memberKey, this._backend.getWriteStream());\n  }\n  get state() {\n    return this._state;\n  }\n  get isReadOnly() {\n    return this._backend.isReadOnly;\n  }\n  get update() {\n    return this._itemManager.debouncedUpdate;\n  }\n  get entityUpdate() {\n    return this._itemManager.update;\n  }\n  async initialize() {\n    if (this._state !== State.NULL) {\n      throw new Error(\"Invalid state: database was already initialized.\");\n    }\n    await this._backend.open(this._itemManager, this._modelFactory);\n    this._state = State.INITIALIZED;\n  }\n  async destroy() {\n    if (this._state === State.DESTROYED || this._state === State.NULL) {\n      return;\n    }\n    await this._backend.close();\n    this._state = State.DESTROYED;\n  }\n  async createItem(options = {}) {\n    this._assertInitialized();\n    if (!options.model) {\n      options.model = ObjectModel;\n    }\n    validateModelClass(options.model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    if (options.parent && typeof options.parent !== \"string\") {\n      throw new TypeError(\"Optional parent item id must be a string id of an existing item.\");\n    }\n    return await this._itemManager.createItem(options.model.meta.type, options.type, options.parent, options.props);\n  }\n  async createLink(options) {\n    var _a;\n    this._assertInitialized();\n    const model = (_a = options.model) != null ? _a : ObjectModel;\n    if (!model) {\n      throw new TypeError(\"Missing model class.\");\n    }\n    validateModelClass(model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    return this._itemManager.createLink(model.meta.type, options.type, options.source.id, options.target.id, options.props);\n  }\n  getItem(itemId) {\n    this._assertInitialized();\n    return this._itemManager.getItem(itemId);\n  }\n  async waitForItem(filter) {\n    const result = this.select(filter).exec();\n    await result.update.waitForCondition(() => result.entities.length > 0);\n    const item = result.expectOne();\n    assert11(item, \"Possible race condition detected.\");\n    return item;\n  }\n  select(filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, void 0);\n  }\n  reduce(result, filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, result);\n  }\n  createSnapshot() {\n    this._assertInitialized();\n    return this._backend.createSnapshot();\n  }\n  createDataServiceHost() {\n    return this._backend.createDataServiceHost();\n  }\n  _assertInitialized() {\n    if (this._state !== State.INITIALIZED) {\n      throw new Error(\"Database not initialized.\");\n    }\n  }\n};\n__decorate2([\n  synchronized\n], Database.prototype, \"initialize\", null);\n__decorate2([\n  synchronized\n], Database.prototype, \"destroy\", null);\n\n// packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { log as log7 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar STORAGE_VERSION = 1;\nvar emptyEchoMetadata = () => ({\n  version: STORAGE_VERSION,\n  spaces: [],\n  created: new Date(),\n  updated: new Date()\n});\nvar MetadataStore = class {\n  constructor(_directory) {\n    this._directory = _directory;\n    this._metadata = emptyEchoMetadata();\n  }\n  get version() {\n    var _a;\n    return (_a = this._metadata.version) != null ? _a : 0;\n  }\n  get spaces() {\n    var _a;\n    return (_a = this._metadata.spaces) != null ? _a : [];\n  }\n  async load() {\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const { size: fileLength } = await file.stat();\n      if (fileLength < 4) {\n        return;\n      }\n      const dataSize = fromBytesInt32(await file.read(0, 4));\n      log7(\"loaded\", {\n        size: dataSize\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 67,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      {\n        if (fileLength < dataSize + 4) {\n          throw new Error(\"Metadata storage is corrupted\");\n        }\n      }\n      const data = await file.read(4, dataSize);\n      this._metadata = schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").decode(data);\n    } catch (err) {\n      log7.error(\"failed to load metadata\", {\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 79,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._metadata = emptyEchoMetadata();\n    } finally {\n      await file.close();\n    }\n  }\n  async _save() {\n    var _a;\n    const data = {\n      ...this._metadata,\n      version: STORAGE_VERSION,\n      created: (_a = this._metadata.created) != null ? _a : new Date(),\n      updated: new Date()\n    };\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const encoded = Buffer.from(schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").encode(data));\n      await file.write(0, toBytesInt32(encoded.length));\n      log7(\"saved\", {\n        size: encoded.length\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 102,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await file.write(4, encoded);\n    } finally {\n      await file.close();\n    }\n  }\n  async clear() {\n    log7(\"clearing all metadata\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._directory.delete();\n  }\n  getIdentityRecord() {\n    return this._metadata.identity;\n  }\n  async setIdentityRecord(record) {\n    assert12(!this._metadata.identity, \"Cannot overwrite existing identity in metadata\");\n    this._metadata.identity = record;\n    await this._save();\n  }\n  async addSpace(record) {\n    var _a, _b, _c;\n    assert12(!((_a = this._metadata.spaces) != null ? _a : []).find((space) => space.key === record.key), \"Cannot overwrite existing space in metadata\");\n    ((_c = (_b = this._metadata).spaces) != null ? _c : _b.spaces = []).push(record);\n    await this._save();\n  }\n};\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"load\", null);\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"_save\", null);\nvar toBytesInt32 = (num) => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32LE(num, 0);\n  return buf;\n};\nvar fromBytesInt32 = (buf) => buf.readInt32LE(0);\n\n// packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { log as log8 } from \"@dxos/log\";\nimport { Extension, ERR_EXTENSION_RESPONSE_FAILED } from \"@dxos/mesh-protocol\";\nvar EXTENSION_NAME = \"dxos.credentials.auth\";\nvar AuthPlugin = class {\n  constructor(_swarmIdentity, requireAuthForExtensions = []) {\n    this._swarmIdentity = _swarmIdentity;\n    this.authenticationFailed = new Event7();\n    this._requiredForExtensions = new Set(requireAuthForExtensions);\n  }\n  createExtension() {\n    return new Extension(EXTENSION_NAME, {\n      binary: true\n    }).setHandshakeHandler(this._onHandshake.bind(this));\n  }\n  async _onHandshake(protocol) {\n    var _a;\n    try {\n      assert13(protocol);\n      const { credentials, peerId: sessionPeerId } = (_a = protocol == null ? void 0 : protocol.getSession()) != null ? _a : {};\n      log8(\"Handshake\", {\n        credentials,\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 66,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!credentials) {\n        if (this._requiredForExtensions.size) {\n          let authRequired = false;\n          for (const name of protocol.stream.remoteExtensions.names) {\n            if (this._requiredForExtensions.has(name)) {\n              log8(`Auth required for extension: ${name}`, {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n                line: 74,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              authRequired = true;\n              break;\n            }\n          }\n          if (!authRequired) {\n            log8(`Unauthenticated access allowed for ${sessionPeerId}; no extensions which require authentication are active on remote Protocol.`, {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n              line: 84,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            return;\n          }\n        }\n        log8(\"No credentials provided; dropping connection\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: no credentials.\");\n      }\n      const nonce = Buffer.from(\"\");\n      const credentialsBuf = Buffer.from(credentials, \"base64\");\n      const isAuthenticated = await this._swarmIdentity.credentialAuthenticator(nonce, credentialsBuf);\n      if (!isAuthenticated) {\n        log8(\"Unauthenticated access denied\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 110,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: bad credentials.\");\n      }\n      log8(\"Authenticated access granted\", {\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 121,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log8(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 129,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw err;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\nimport { Event as Event8 } from \"@dxos/async\";\nimport { log as log9 } from \"@dxos/log\";\nimport { ReplicatorPlugin as AbstractReplicatorPlugin } from \"@dxos/protocol-plugin-replicator\";\nvar ReplicatorPlugin = class extends AbstractReplicatorPlugin {\n  constructor() {\n    super({\n      load: async () => {\n        const feeds = Array.from(this._feeds);\n        log9(\"loading feeds\", {\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 31,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds.map((feed) => ({\n          discoveryKey: feed.properties.discoveryKey\n        }));\n      },\n      subscribe: (addFeedToReplicatedSet) => this._feedAdded.on(async (feed) => {\n        log9(\"adding feed\", {\n          feedKey: feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 39,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        addFeedToReplicatedSet({\n          discoveryKey: feed.properties.discoveryKey\n        });\n      }),\n      replicate: async (remoteFeeds, info) => {\n        const feeds = Array.from(this._feeds);\n        log9(\"replicating\", {\n          peerId: info.session,\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds;\n      }\n    });\n    this._feedAdded = new Event8();\n    this._feeds = /* @__PURE__ */ new Set();\n  }\n  addFeed(feed) {\n    log9(\"adding feed\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n      line: 21,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._feeds.add(feed);\n    this._feedAdded.emit(feed);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nimport assert16 from \"@dxos/node-std/assert\";\nimport { Event as Event10, synchronized as synchronized3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined4 } from \"@dxos/debug\";\nimport { log as log14, logInfo } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { Callback as Callback2 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nimport assert15 from \"@dxos/node-std/assert\";\nimport { FeedSetIterator } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/message-selector.ts\nimport debug7 from \"debug\";\nimport assert14 from \"@dxos/node-std/assert\";\nvar log10 = debug7(\"dxos:echo-db:message-selector\");\nvar createMessageSelector = (timeframeClock) => {\n  return (messages) => {\n    for (let i = 0; i < messages.length; i++) {\n      const { data: { timeframe } } = messages[i];\n      assert14(timeframe);\n      if (!timeframeClock.hasGaps(timeframe)) {\n        return i;\n      }\n    }\n    log10(\"Skipping...\");\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\nimport { Event as Event9 } from \"@dxos/async\";\nimport { timed as timed2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar __decorate4 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar mapTimeframeToFeedIndexes = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({\n  feedKey,\n  index\n}));\nvar mapFeedIndexesToTimeframe = (indexes) => new Timeframe(indexes.map(({ feedKey, index }) => [\n  feedKey,\n  index\n]));\nvar TimeframeClock = class {\n  constructor(_timeframe = new Timeframe()) {\n    this._timeframe = _timeframe;\n    this.update = new Event9();\n  }\n  get timeframe() {\n    return this._timeframe;\n  }\n  updateTimeframe(key, seq) {\n    this._timeframe = Timeframe.merge(this._timeframe, new Timeframe([\n      [\n        key,\n        seq\n      ]\n    ]));\n    this.update.emit(this._timeframe);\n  }\n  hasGaps(timeframe) {\n    const gaps = Timeframe.dependencies(timeframe, this._timeframe);\n    return !gaps.isEmpty();\n  }\n  async waitUntilReached(target) {\n    log11.debug(\"waitUntilReached\", {\n      target,\n      current: this._timeframe\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n      line: 45,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.update.waitForCondition(() => {\n      log11(\"check if reached\", {\n        target,\n        current: this._timeframe,\n        deps: Timeframe.dependencies(target, this._timeframe)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return Timeframe.dependencies(target, this._timeframe).isEmpty();\n    });\n  }\n};\n__decorate4([\n  timed2(5e3)\n], TimeframeClock.prototype, \"waitUntilReached\", null);\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nvar PipelineState = class {\n  constructor(_iterator, _timeframeClock) {\n    this._iterator = _iterator;\n    this._timeframeClock = _timeframeClock;\n    this.timeframeUpdate = this._timeframeClock.updateTimeframe;\n  }\n  get endTimeframe() {\n    return mapFeedIndexesToTimeframe(this._iterator.feeds.filter((feed) => feed.properties.length > 0).map((feed) => ({\n      feedKey: feed.key,\n      index: feed.properties.length - 1\n    })));\n  }\n  get timeframe() {\n    return this._timeframeClock.timeframe;\n  }\n  async waitUntilTimeframe(target) {\n    await this._timeframeClock.waitUntilReached(target);\n  }\n};\nvar Pipeline = class {\n  constructor(_initialTimeframe = new Timeframe2()) {\n    this._initialTimeframe = _initialTimeframe;\n    this._timeframeClock = new TimeframeClock(this._initialTimeframe);\n    this.feedSetIterator = new FeedSetIterator(createMessageSelector(this._timeframeClock), {\n      start: mapTimeframeToFeedIndexes(this._initialTimeframe),\n      stallTimeout: 1e3\n    });\n    this._state = new PipelineState(this.feedSetIterator, this._timeframeClock);\n    this._isOpen = false;\n    this.feedSetIterator.stalled.on((iterator) => {\n      log12.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n        line: 110,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n  }\n  get state() {\n    return this._state;\n  }\n  get writer() {\n    assert15(this._writer, \"Writer not set.\");\n    return this._writer;\n  }\n  async addFeed(feed) {\n    await this.feedSetIterator.addFeed(feed);\n  }\n  setWriteFeed(feed) {\n    assert15(!this._writer, \"Writer already set.\");\n    assert15(feed.properties.writable, \"Feed must be writable.\");\n    this._writer = createMappedFeedWriter((data) => ({\n      timeframe: this._timeframeClock.timeframe,\n      payload: data\n    }), feed.createFeedWriter());\n  }\n  async start() {\n    log12(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.open();\n    log12(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 143,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log12(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.close();\n    log12(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 149,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async *consume() {\n    assert15(!this._isOpen, \"Pipeline is already being consumed.\");\n    this._isOpen = true;\n    for await (const block of this.feedSetIterator) {\n      yield block;\n      this._timeframeClock.updateTimeframe(PublicKey3.from(block.feedKey), block.seq);\n    }\n    this._isOpen = false;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\nimport { SpaceStateMachine } from \"@dxos/credentials\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback } from \"@dxos/util\";\nvar ControlPipeline = class {\n  constructor({ spaceKey, genesisFeed, feedProvider, initialTimeframe }) {\n    this.onFeedAdmitted = new Callback();\n    this._pipeline = new Pipeline(initialTimeframe);\n    void this._pipeline.addFeed(genesisFeed);\n    this._spaceStateMachine = new SpaceStateMachine(spaceKey);\n    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {\n      log13(\"feed admitted\", {\n        info\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (info.assertion.designation === AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {\n        try {\n          const feed = await feedProvider(info.key);\n          await this._pipeline.addFeed(feed);\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 48,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n      await this.onFeedAdmitted.callIfSet(info);\n    });\n    this.onMemberAdmitted = this._spaceStateMachine.onMemberAdmitted;\n    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;\n  }\n  get spaceState() {\n    return this._spaceStateMachine;\n  }\n  get pipeline() {\n    return this._pipeline;\n  }\n  setWriteFeed(feed) {\n    this._pipeline.setWriteFeed(feed);\n  }\n  async start() {\n    log13(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    setTimeout(async () => {\n      for await (const msg of this._pipeline.consume()) {\n        try {\n          log13(\"processing\", {\n            msg\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 76,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (msg.data.payload[\"@type\"] === \"dxos.echo.feed.CredentialsMessage\") {\n            const result = await this._spaceStateMachine.process(msg.data.payload.credential, PublicKey4.from(msg.feedKey));\n            if (!result) {\n              log13.warn(\"processing failed\", {\n                msg\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n                line: 83,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n            }\n          }\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 87,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this._pipeline.start();\n    log13(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log13(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._pipeline.stop();\n    log13(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 99,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nvar __decorate5 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Space = class {\n  constructor({ spaceKey, protocol, genesisFeed, controlFeed, dataFeed, feedProvider, databaseFactory, initialTimeframe }) {\n    this.onCredentialProcessed = new Callback2();\n    this.stateUpdate = new Event10();\n    this._isOpen = false;\n    assert16(spaceKey && dataFeed && feedProvider);\n    this._key = spaceKey;\n    this._controlFeed = controlFeed;\n    this._dataFeed = dataFeed;\n    this._feedProvider = feedProvider;\n    this._genesisFeedKey = genesisFeed.key;\n    this._databaseFactory = databaseFactory;\n    this._controlPipeline = new ControlPipeline({\n      spaceKey,\n      genesisFeed,\n      feedProvider,\n      initialTimeframe\n    });\n    this._controlPipeline.setWriteFeed(controlFeed);\n    this._controlPipeline.onFeedAdmitted.set(async (info) => {\n      if (info.assertion.designation === AdmittedFeed2.Designation.DATA) {\n        if (!this._dataPipeline) {\n          return;\n        }\n        await this._dataPipeline.addFeed(await feedProvider(info.key));\n      }\n      if (!info.key.equals(genesisFeed.key)) {\n        this._protocol.addFeed(await feedProvider(info.key));\n      }\n    });\n    this._controlPipeline.onCredentialProcessed.set(async (credential) => {\n      await this.onCredentialProcessed.callIfSet(credential);\n      log14(\"onCredentialProcessed\", {\n        credential\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.stateUpdate.emit();\n    });\n    this._protocol = protocol;\n    this._protocol.addFeed(genesisFeed);\n  }\n  get key() {\n    return this._key;\n  }\n  get isOpen() {\n    return this._isOpen;\n  }\n  get database() {\n    if (!this._database) {\n      throw new Error(\"Space not open.\");\n    }\n    return this._database;\n  }\n  get genesisFeedKey() {\n    return this._genesisFeedKey;\n  }\n  get controlFeedKey() {\n    return this._controlFeed.key;\n  }\n  get dataFeedKey() {\n    return this._dataFeed.key;\n  }\n  get spaceState() {\n    return this._controlPipeline.spaceState;\n  }\n  get controlPipeline() {\n    return this._controlPipeline.pipeline;\n  }\n  async open() {\n    log14(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 171,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._isOpen) {\n      return;\n    }\n    await this._controlPipeline.start();\n    await this._openDataPipeline();\n    await this._protocol.start();\n    this._isOpen = true;\n    log14(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    log14(\"closing...\", {\n      key: this._key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 187,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._isOpen) {\n      return;\n    }\n    await this._protocol.stop();\n    await this._closeDataPipeline();\n    await this._controlPipeline.stop();\n    this._isOpen = false;\n    log14(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 198,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _openDataPipeline() {\n    var _a;\n    assert16(!this._dataPipeline, \"Data pipeline already initialized.\");\n    {\n      this._dataPipeline = new Pipeline(new Timeframe3());\n      this._dataPipeline.setWriteFeed(this._dataFeed);\n      for (const feed of this._controlPipeline.spaceState.feeds.values()) {\n        await this._dataPipeline.addFeed(await this._feedProvider(feed.key));\n      }\n    }\n    {\n      const feedWriter = createMappedFeedWriter((msg) => ({\n        \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n        ...msg\n      }), (_a = this._dataPipeline.writer) != null ? _a : failUndefined4());\n      this._databaseBackend = new DatabaseBackendHost(feedWriter, {}, {\n        snapshots: true\n      });\n    }\n    {\n      this._database = await this._databaseFactory({\n        databaseBackend: this._databaseBackend\n      });\n      await this._database.initialize();\n    }\n    await this._dataPipeline.start();\n    setTimeout(async () => {\n      assert16(this._dataPipeline);\n      for await (const msg of this._dataPipeline.consume()) {\n        const { feedKey, seq, data } = msg;\n        log14(\"processing message\", {\n          msg\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n          line: 246,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          const payload = data.payload;\n          if (payload[\"@type\"] === \"dxos.echo.feed.EchoEnvelope\") {\n            const feedInfo = this._controlPipeline.spaceState.feeds.get(feedKey);\n            if (!feedInfo) {\n              log14.error(\"Could not find feed.\", {\n                feedKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n                line: 253,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              continue;\n            }\n            await this._databaseBackend.echoProcessor({\n              data: payload,\n              meta: {\n                feedKey,\n                seq,\n                timeframe: data.timeframe,\n                memberKey: feedInfo.assertion.identityKey\n              }\n            });\n          }\n        } catch (err) {\n          log14.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n            line: 268,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n  }\n  async _closeDataPipeline() {\n    var _a, _b, _c;\n    assert16(this._dataPipeline, \"Data pipeline not initialized.\");\n    await ((_a = this._dataPipeline) == null ? void 0 : _a.stop());\n    await ((_b = this._databaseBackend) == null ? void 0 : _b.close());\n    await ((_c = this._database) == null ? void 0 : _c.destroy());\n  }\n};\n__decorate5([\n  logInfo\n], Space.prototype, \"key\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"open\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"close\", null);\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nimport { Event as Event11 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log16 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed3 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\nimport { discoveryKey, sha256 } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { log as log15 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nimport { adaptProtocolProvider, MMSTTopology } from \"@dxos/network-manager\";\nimport { PresencePlugin } from \"@dxos/protocol-plugin-presence\";\nimport { Teleport } from \"@dxos/teleport\";\nimport { ReplicatorExtension as TeleportReplicatorExtension } from \"@dxos/teleport-plugin-replicator\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MOCK_AUTH_PROVIDER = async (nonce) => Buffer.from(\"mock\");\nvar MOCK_AUTH_VERIFIER = async (nonce, credential) => true;\nvar USE_TELEPORT = true;\nvar SpaceProtocol = class {\n  constructor({ topic, identity, networkManager, plugins = [] }) {\n    this._replicator = new ReplicatorPlugin();\n    this._feeds = /* @__PURE__ */ new Set();\n    this._sessions = new ComplexMap2(PublicKey5.hash);\n    this._networkManager = networkManager;\n    this._swarmIdentity = identity;\n    this._presencePlugin = new PresencePlugin(this._swarmIdentity.peerKey.asBuffer());\n    this._authPlugin = new AuthPlugin(this._swarmIdentity, []);\n    this._customPlugins = plugins;\n    this._discoveryKey = PublicKey5.from(discoveryKey(sha256(topic.toHex())));\n    this._peerId = PublicKey5.from(discoveryKey(sha256(this._swarmIdentity.peerKey.toHex())));\n    this.authenticationFailed = this._authPlugin.authenticationFailed;\n  }\n  addFeed(feed) {\n    if (USE_TELEPORT) {\n      this._feeds.add(feed);\n      for (const session of this._sessions.values()) {\n        session.replicator.addFeed(feed);\n      }\n    } else {\n      this._replicator.addFeed(feed);\n    }\n  }\n  async start() {\n    if (this._connection) {\n      return;\n    }\n    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(\"\"));\n    const topologyConfig = {\n      originateConnections: 4,\n      maxPeers: 10,\n      sampleSize: 20\n    };\n    log15(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connection = await this._networkManager.joinSwarm({\n      protocolProvider: this._createProtocolProvider(credentials),\n      peerId: this._peerId,\n      topic: this._discoveryKey,\n      presence: this._presencePlugin,\n      topology: new MMSTTopology(topologyConfig),\n      label: `Protocol swarm: ${this._discoveryKey}`\n    });\n    log15(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    if (this._connection) {\n      log15(\"stopping...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._connection.close();\n      log15(\"stopped\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 132,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  _createProtocolProvider(credentials) {\n    if (USE_TELEPORT) {\n      return (params) => {\n        const session = new SpaceProtocolSession(params);\n        this._sessions.set(params.remotePeerId, session);\n        for (const feed of this._feeds) {\n          session.replicator.addFeed(feed);\n        }\n        return session;\n      };\n    } else {\n      return adaptProtocolProvider(({ channel, initiator }) => {\n        const protocol = new Protocol({\n          streamOptions: {\n            live: true\n          },\n          discoveryKey: channel,\n          discoveryToPublicKey: (discoveryKey2) => {\n            if (!PublicKey5.from(discoveryKey2).equals(this._discoveryKey)) {\n              return void 0;\n            }\n            protocol.setContext({\n              topic: this._discoveryKey.toHex()\n            });\n            return this._discoveryKey.asBuffer();\n          },\n          userSession: {\n            peerId: this._peerId.toHex(),\n            credentials: credentials ? Buffer.from(credentials).toString(\"base64\") : void 0\n          },\n          initiator\n        });\n        const plugins = [\n          this._presencePlugin,\n          this._authPlugin,\n          this._replicator,\n          ...this._customPlugins\n        ];\n        protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n        return protocol;\n      });\n    }\n  }\n  get peers() {\n    return this._presencePlugin.peers.map((peer) => PublicKey5.from(peer));\n  }\n};\nvar SpaceProtocolSession = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this.replicator = new TeleportReplicatorExtension().setOptions({\n      upload: true\n    });\n    this._teleport = new Teleport({\n      initiator,\n      localPeerId,\n      remotePeerId\n    });\n  }\n  get stream() {\n    return this._teleport.stream;\n  }\n  async initialize() {\n    await this._teleport.open();\n    this._teleport.addExtension(\"dxos.mesh.teleport.replicator\", this.replicator);\n  }\n  async destroy() {\n    await this._teleport.close();\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nvar SpaceManager = class {\n  constructor({ metadataStore, feedStore, networkManager, keyring, dataServiceSubscriptions, modelFactory, signingContext }) {\n    this.updated = new Event11();\n    this._spaces = new ComplexMap3(PublicKey6.hash);\n    this._metadataStore = metadataStore;\n    this._feedStore = feedStore;\n    this._networkManager = networkManager;\n    this._keyring = keyring;\n    this._dataServiceSubscriptions = dataServiceSubscriptions;\n    this._modelFactory = modelFactory;\n    this._signingContext = signingContext;\n  }\n  get spaces() {\n    return this._spaces;\n  }\n  async open() {\n    await this._metadataStore.load();\n    for (const spaceMetadata of this._metadataStore.spaces) {\n      const space = await this._constructSpace(spaceMetadata);\n      await space.open();\n      this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n      this._spaces.set(spaceMetadata.key, space);\n    }\n  }\n  async close() {\n    await Promise.all([\n      ...this._spaces.values()\n    ].map((space) => space.close()));\n  }\n  async createSpace() {\n    const spaceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n    const metadata = {\n      key: spaceKey,\n      genesisFeedKey: controlFeedKey,\n      controlFeedKey,\n      dataFeedKey\n    };\n    log16(\"creating space...\", {\n      spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, this._signingContext.identityKey, this._signingContext.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(spaceKey, controlFeedKey, this._signingContext.profile),\n        await generator.createFeedAdmission(spaceKey, dataFeedKey, AdmittedFeed3.Designation.DATA)\n      ];\n      for (const credential of credentials) {\n        await space.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  async acceptSpace(opts) {\n    const metadata = {\n      key: opts.spaceKey,\n      genesisFeedKey: opts.genesisFeedKey,\n      controlFeedKey: await this._keyring.createKey(),\n      dataFeedKey: await this._keyring.createKey()\n    };\n    log16(\"accepting space...\", {\n      spaceKey: opts.spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 161,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  _insertSpace(space) {\n    this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n    this._spaces.set(space.key, space);\n    this.updated.emit();\n  }\n  async _constructSpace(metadata) {\n    var _a, _b, _c;\n    log16(\"constructing space...\", {\n      spaceKey: metadata.genesisFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 177,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeed = await this._feedStore.openFeed((_a = metadata.controlFeedKey) != null ? _a : failUndefined5(), {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed((_b = metadata.dataFeedKey) != null ? _b : failUndefined5(), {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed((_c = metadata.genesisFeedKey) != null ? _c : failUndefined5());\n    const spaceKey = metadata.key;\n    const protocol = new SpaceProtocol({\n      topic: spaceKey,\n      identity: {\n        peerKey: this._signingContext.deviceKey,\n        credentialProvider: this._signingContext.credentialProvider,\n        credentialAuthenticator: this._signingContext.credentialAuthenticator\n      },\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, this._signingContext.identityKey)\n    });\n  }\n};\nexport {\n  AuthPlugin,\n  DBError,\n  DataMirror,\n  DataServiceHost,\n  DataServiceImpl,\n  DataServiceSubscriptions,\n  Database,\n  DatabaseBackendHost,\n  DatabaseBackendProxy,\n  Entity,\n  EntityNotFoundError,\n  IdentityNotInitializedError,\n  InvalidInvitationError,\n  InvalidStorageVersionError,\n  Item,\n  ItemDemuxer,\n  ItemFilterDeleted,\n  ItemManager,\n  Link,\n  MOCK_AUTH_PROVIDER,\n  MOCK_AUTH_VERIFIER,\n  MetadataStore,\n  ReplicatorPlugin,\n  ResultSet,\n  STORAGE_VERSION,\n  Schema,\n  Selection,\n  SelectionResult,\n  Space,\n  SpaceManager,\n  SpaceNotFoundError,\n  SpaceProtocol,\n  SpaceProtocolSession,\n  State,\n  TYPE_SCHEMA,\n  USE_TELEPORT,\n  UnknownModelError,\n  codec,\n  coerceToId,\n  createItemSelection,\n  createMappedFeedWriter,\n  createQueryOptionsFilter,\n  createSelection,\n  dedupe,\n  filterToPredicate,\n  itemFilterToPredicate,\n  linkFilterToPredicate,\n  resultSetToStream,\n  sortItemsTopologically,\n  streamToResultSet,\n  testOneOrMultiple,\n  valueEncoding\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466022,"end":1670465466022,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/echo/echo-db/src/packlets/api/result-set.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar ResultSet = class {\n  constructor(itemUpdate, getter) {\n    this._resultsUpdate = new Event();\n    this.update = this._resultsUpdate;\n    assert(itemUpdate);\n    assert(getter);\n    this._itemUpdate = itemUpdate;\n    this._getter = getter;\n    this._resultsUpdate.addEffect(() => this._itemUpdate.on(() => {\n      this._resultsUpdate.emit(this._getter());\n    }));\n  }\n  get value() {\n    return this._getter();\n  }\n  get first() {\n    const value = this._getter();\n    assert(value.length);\n    return value[0];\n  }\n  subscribe(listener) {\n    return this._resultsUpdate.on(listener);\n  }\n  waitFor(condition) {\n    if (condition(this.value)) {\n      return Promise.resolve(this.value);\n    }\n    return this._resultsUpdate.waitFor(condition);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/schema.ts\nvar TYPE_SCHEMA = \"dxos:type/schema\";\nvar Schema = class {\n  constructor(_schema) {\n    this._schema = _schema;\n  }\n  get name() {\n    return this._schema.get(\"schema\");\n  }\n  get fields() {\n    var _a;\n    return Object.values((_a = this._schema.get(\"fields\")) != null ? _a : {});\n  }\n  getField(key) {\n    return this.fields.find((field) => field.key === key);\n  }\n  validate(model) {\n    return this.fields.every((field) => {\n      const value = model.get(field.key);\n      if (!value) {\n        return !field.required;\n      }\n      if (field.type) {\n        if (typeof value !== field.type) {\n          return false;\n        }\n      }\n      if (field.ref) {\n      }\n      return true;\n    });\n  }\n  async addField(newField) {\n    const newFields = [\n      ...this.fields,\n      newField\n    ];\n    await this._schema.set(\"fields\", newFields);\n  }\n  async editField(currentKey, editedField) {\n    const newFields = this.fields.map((field) => {\n      if (field.key === currentKey) {\n        return editedField;\n      }\n      return field;\n    });\n    await this._schema.set(\"fields\", newFields);\n  }\n  async deleteField(key) {\n    const newFields = this.fields.filter((field) => field.key !== key);\n    await this._schema.set(\"fields\", newFields);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/api/subscription.ts\nimport { Event as Event2 } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nvar resultSetToStream = (resultSet, map) => new Stream(({ next }) => {\n  next(map(resultSet.value));\n  return resultSet.update.on(() => next(map(resultSet.value)));\n});\nvar streamToResultSet = (stream, map) => {\n  const event = new Event2();\n  let lastItem;\n  stream.subscribe((data) => {\n    lastItem = data;\n    event.emit();\n  });\n  return new ResultSet(event, () => map(lastItem));\n};\n\n// packages/core/echo/echo-db/src/packlets/common/codec.ts\nimport { createCodecEncoding } from \"@dxos/hypercore\";\nimport { schema } from \"@dxos/protocols\";\nvar codec = schema.getCodecForType(\"dxos.echo.feed.FeedMessage\");\nvar valueEncoding = createCodecEncoding(codec);\n\n// packages/core/echo/echo-db/src/packlets/common/feeds.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createMappedFeedWriter = (mapper, writer) => {\n  assert2(mapper);\n  assert2(writer);\n  return {\n    write: async (data) => await writer.write(await mapper(data))\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-mirror.ts\nimport debug from \"debug\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { failUndefined } from \"@dxos/debug\";\nvar log = debug(\"dxos:echo-db:data-mirror\");\nvar DataMirror = class {\n  constructor(_itemManager, _dataService, _spaceKey) {\n    this._itemManager = _itemManager;\n    this._dataService = _dataService;\n    this._spaceKey = _spaceKey;\n  }\n  open() {\n    const entities = this._dataService.subscribeEntitySet({\n      spaceKey: this._spaceKey\n    });\n    entities.subscribe(async (diff) => {\n      var _a, _b;\n      for (const addedEntity of (_a = diff.added) != null ? _a : []) {\n        log(`Construct: ${JSON.stringify(addedEntity)}`);\n        assert3(addedEntity.itemId);\n        assert3(addedEntity.genesis);\n        assert3(addedEntity.genesis.modelType);\n        let entity;\n        if (addedEntity.genesis.link) {\n          assert3(addedEntity.genesis.link.source);\n          assert3(addedEntity.genesis.link.target);\n          entity = await this._itemManager.constructLink({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            source: addedEntity.genesis.link.source,\n            target: addedEntity.genesis.link.target,\n            snapshot: {}\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            itemId: addedEntity.itemId,\n            itemType: addedEntity.genesis.itemType,\n            modelType: addedEntity.genesis.modelType,\n            parentId: (_b = addedEntity.itemMutation) == null ? void 0 : _b.parentId,\n            snapshot: {}\n          });\n        }\n        this._subscribeToUpdates(entity);\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n  _subscribeToUpdates(entity) {\n    const stream = this._dataService.subscribeEntityStream({\n      spaceKey: this._spaceKey,\n      itemId: entity.id\n    });\n    stream.subscribe(async (update) => {\n      var _a, _b, _c, _d, _e, _f;\n      log(`Update[${entity.id}]: ${JSON.stringify(update)}`);\n      if (update.snapshot) {\n        assert3(update.snapshot.model);\n        entity._stateManager.resetToSnapshot(update.snapshot.model);\n      } else if (update.mutation) {\n        if ((_a = update.mutation.data) == null ? void 0 : _a.mutation) {\n          assert3(update.mutation.meta);\n          await entity._stateManager.processMessage({\n            feedKey: (_b = update.mutation.meta.feedKey) != null ? _b : failUndefined(),\n            memberKey: (_c = update.mutation.meta.memberKey) != null ? _c : failUndefined(),\n            seq: (_d = update.mutation.meta.seq) != null ? _d : failUndefined(),\n            timeframe: (_e = update.mutation.meta.timeframe) != null ? _e : failUndefined()\n          }, (_f = update.mutation.data.mutation) != null ? _f : failUndefined());\n        }\n      }\n    }, (err) => {\n      log(`Connection closed: ${err}`);\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nimport debug3 from \"debug\";\nimport assert6 from \"@dxos/node-std/assert\";\nimport { Stream as Stream2 } from \"@dxos/codec-protobuf\";\nimport { failUndefined as failUndefined2, raise } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\n\n// packages/core/echo/echo-db/src/packlets/errors/errors.ts\nvar DBError = class extends Error {\n  constructor(code, message, context) {\n    super(message ? `${code}: ${message}` : code.toString());\n    this.code = code;\n    this.context = context;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar IdentityNotInitializedError = class extends DBError {\n  constructor() {\n    super(\"IDENTITY_NOT_INITIALIZED\", \"Identity not initialized.\");\n  }\n};\nvar InvalidInvitationError = class extends DBError {\n  constructor() {\n    super(\"INVALID_INVITATION\", \"Invitation is invalid.\");\n  }\n};\nvar InvalidStorageVersionError = class extends DBError {\n  constructor(expected, actual) {\n    super(\"INVALID_STORAGE_VERSION\", \"Invalid storage version.\", {\n      expected,\n      actual\n    });\n  }\n};\nvar SpaceNotFoundError = class extends DBError {\n  constructor(spaceKey) {\n    super(\"SPACE_NOT_FOUND\", \"Space not found.\", {\n      spaceKey\n    });\n  }\n};\nvar EntityNotFoundError = class extends DBError {\n  constructor(entityId) {\n    super(\"ENTITY_NOT_FOUND\", \"Entity not found.\", {\n      entityId\n    });\n  }\n};\nvar UnknownModelError = class extends DBError {\n  constructor(model) {\n    super(\"UNKNOWN_MODEL\", \"Unknown model.\", {\n      model\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nimport debug2 from \"debug\";\nimport { ItemMutation } from \"@dxos/protocols/proto/dxos/echo/feed\";\n\n// packages/core/echo/echo-db/src/packlets/database/entity.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nvar Entity = class {\n  constructor(_itemManager, _id, _type, stateManager) {\n    this._itemManager = _itemManager;\n    this._id = _id;\n    this._type = _type;\n    this._onUpdate = new Event3();\n    this._subscriptions = new EventSubscriptions();\n    this._stateManager = stateManager;\n    if (this._stateManager.initialized) {\n      this._subscriptions.add(this._stateManager.model.subscribe(() => this._onUpdate.emit(this)));\n    }\n  }\n  get id() {\n    return this._id;\n  }\n  get type() {\n    return this._type;\n  }\n  get modelType() {\n    return this._stateManager.modelType;\n  }\n  get modelMeta() {\n    return this._stateManager.model.modelMeta;\n  }\n  get model() {\n    if (!this._stateManager.initialized) {\n      return null;\n    }\n    return this._stateManager.model;\n  }\n  subscribe(listener) {\n    return this._onUpdate.on(listener);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/util.ts\nvar dedupe = (values) => Array.from(new Set(values));\nvar coerceToId = (item) => {\n  if (typeof item === \"string\") {\n    return item;\n  }\n  return item.id;\n};\nvar testOneOrMultiple = (expected, value) => {\n  if (Array.isArray(expected)) {\n    return expected.includes(value);\n  } else {\n    return expected === value;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/queries.ts\nvar ItemFilterDeleted;\n(function(ItemFilterDeleted2) {\n  ItemFilterDeleted2[ItemFilterDeleted2[\"HIDE_DELETED\"] = 0] = \"HIDE_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED\"] = 1] = \"SHOW_DELETED\";\n  ItemFilterDeleted2[ItemFilterDeleted2[\"SHOW_DELETED_ONLY\"] = 2] = \"SHOW_DELETED_ONLY\";\n})(ItemFilterDeleted || (ItemFilterDeleted = {}));\nvar filterToPredicate = (filter) => {\n  if (typeof filter === \"function\") {\n    return filter;\n  }\n  return itemFilterToPredicate(filter);\n};\nvar itemFilterToPredicate = (filter) => {\n  if (\"id\" in filter) {\n    return (item) => item.id === filter.id;\n  } else {\n    return (item) => {\n      var _a;\n      return (!filter.type || testOneOrMultiple(filter.type, item.type)) && (!filter.parent || ((_a = item.parent) == null ? void 0 : _a.id) === coerceToId(filter.parent));\n    };\n  }\n};\nvar linkFilterToPredicate = (filter) => (link) => !filter.type || testOneOrMultiple(filter.type, link.type);\nvar createQueryOptionsFilter = ({ deleted = ItemFilterDeleted.HIDE_DELETED }) => (entity) => {\n  if (entity.model === null) {\n    return false;\n  }\n  switch (deleted) {\n    case ItemFilterDeleted.HIDE_DELETED:\n      return !(entity instanceof Item) || !entity.deleted;\n    case ItemFilterDeleted.SHOW_DELETED:\n      return true;\n    case ItemFilterDeleted.SHOW_DELETED_ONLY:\n      return entity instanceof Item && entity.deleted;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/result.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4 } from \"@dxos/async\";\nvar SelectionResult = class {\n  constructor(_execute, _update, _root, _reducer) {\n    this._execute = _execute;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n    this.update = new Event4();\n    this._lastResult = [\n      []\n    ];\n    this.refresh();\n    this.update.addEffect(() => _update.on((currentEntities) => {\n      const [previousEntities] = this._lastResult;\n      this.refresh();\n      const set = /* @__PURE__ */ new Set([\n        ...previousEntities,\n        ...this._lastResult[0]\n      ]);\n      if (this._reducer || currentEntities.some((entity) => set.has(entity))) {\n        this.update.emit(this);\n      }\n    }));\n  }\n  toString() {\n    const [entities] = this._lastResult;\n    return `SelectionResult<${JSON.stringify({\n      entities: entities.length\n    })}>`;\n  }\n  refresh() {\n    const [entities, result] = this._execute();\n    this._lastResult = [\n      dedupe(entities),\n      result\n    ];\n    return this;\n  }\n  get root() {\n    return this._root;\n  }\n  get entities() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities] = this._lastResult;\n    return entities;\n  }\n  get value() {\n    if (!this._lastResult) {\n      this.refresh();\n    }\n    const [entities, value] = this._lastResult;\n    return this._reducer ? value : entities;\n  }\n  expectOne() {\n    const entities = this.entities;\n    assert4(entities.length === 1, `Expected one result; got ${entities.length}`);\n    return entities[0];\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/selection/selection.ts\nvar createSelection = (itemsProvider, updateEventProvider, root, filter, value) => {\n  const predicate = filter ? filterToPredicate(filter) : () => true;\n  const visitor = (options) => {\n    const items = itemsProvider().filter(createQueryOptionsFilter(options)).filter(predicate);\n    return [\n      items,\n      value\n    ];\n  };\n  return new Selection(visitor, updateEventProvider(), root, value !== void 0);\n};\nvar createItemSelection = (root, update, value) => new Selection(() => [\n  [\n    root\n  ],\n  value\n], update, root, value !== void 0);\nvar Selection = class {\n  constructor(_visitor, _update, _root, _reducer = false) {\n    this._visitor = _visitor;\n    this._update = _update;\n    this._root = _root;\n    this._reducer = _reducer;\n  }\n  _createSubSelection(map) {\n    return new Selection((options) => map(this._visitor(options), options), this._update, this._root, this._reducer);\n  }\n  exec(options = {}) {\n    return this.query(options);\n  }\n  query(options = {}) {\n    return new SelectionResult(() => this._visitor(options), this._update, this._root, this._reducer);\n  }\n  get root() {\n    return this._root;\n  }\n  call(visitor) {\n    return this._createSubSelection(([items, result]) => [\n      items,\n      visitor(items, result)\n    ]);\n  }\n  filter(filter) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([items, result]) => [\n      items.filter(predicate),\n      result\n    ]);\n  }\n  children(filter) {\n    const predicate = filter ? filterToPredicate(filter) : Boolean;\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => Array.from(item._children.values()).filter(createQueryOptionsFilter(options)).filter(predicate)),\n      result\n    ]);\n  }\n  parent() {\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.parent ? [\n        item.parent\n      ].filter(createQueryOptionsFilter(options)) : []),\n      result\n    ]);\n  }\n  links(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.links.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  refs(filter = {}) {\n    const predicate = linkFilterToPredicate(filter);\n    return this._createSubSelection(([items, result], options) => [\n      items.flatMap((item) => item.refs.filter(predicate).filter(createQueryOptionsFilter(options))),\n      result\n    ]);\n  }\n  target(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.target).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n  source(filter = {}) {\n    const predicate = filterToPredicate(filter);\n    return this._createSubSelection(([links, result], options) => [\n      links.flatMap((link) => link.source).filter(predicate).filter(createQueryOptionsFilter(options)),\n      result\n    ]);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item.ts\nvar log2 = debug2(\"dxos:echo-db:item\");\nvar Item = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, _writeStream, parent) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._writeStream = _writeStream;\n    this._parent = null;\n    this._deleted = false;\n    this._children = /* @__PURE__ */ new Set();\n    this._links = /* @__PURE__ */ new Set();\n    this._refs = /* @__PURE__ */ new Set();\n    this._updateParent(parent);\n  }\n  toString() {\n    var _a;\n    return `Item(${JSON.stringify({\n      itemId: this.id,\n      parentId: (_a = this.parent) == null ? void 0 : _a.id,\n      itemType: this.type\n    })})`;\n  }\n  get readOnly() {\n    return !this._writeStream || this._deleted;\n  }\n  get deleted() {\n    return this._deleted;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return Array.from(this._children.values()).filter((item) => !item.deleted);\n  }\n  get links() {\n    return Array.from(this._links.values()).filter((link) => !link._isDangling());\n  }\n  get refs() {\n    return Array.from(this._refs.values()).filter((link) => !link._isDangling());\n  }\n  select() {\n    return createItemSelection(this, this._itemManager.debouncedUpdate, void 0);\n  }\n  async delete() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (this.deleted) {\n      return;\n    }\n    const onUpdate = this._onUpdate.waitFor(() => this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.DELETE\n      }\n    });\n    await onUpdate;\n  }\n  async restore() {\n    if (!this._writeStream) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    if (!this.deleted) {\n      throw new Error(`Item was note delted: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => !this.deleted);\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        action: ItemMutation.Action.RESTORE\n      }\n    });\n    await onUpdate;\n  }\n  async setParent(parentId) {\n    if (!this._writeStream || this.readOnly) {\n      throw new Error(`Item is read-only: ${this.id}`);\n    }\n    const onUpdate = this._onUpdate.waitFor(() => {\n      var _a;\n      return parentId === ((_a = this._parent) == null ? void 0 : _a.id);\n    });\n    await this._writeStream.write({\n      itemId: this.id,\n      itemMutation: {\n        parentId\n      }\n    });\n    await onUpdate;\n  }\n  _processMutation(mutation, getItem) {\n    log2(\"_processMutation %s\", JSON.stringify(mutation));\n    const { action, parentId } = mutation;\n    switch (action) {\n      case ItemMutation.Action.DELETE: {\n        this._deleted = true;\n        break;\n      }\n      case ItemMutation.Action.RESTORE: {\n        this._deleted = false;\n        break;\n      }\n    }\n    if (parentId) {\n      const parent = getItem(parentId);\n      this._updateParent(parent);\n    }\n    this._onUpdate.emit(this);\n  }\n  _updateParent(parent) {\n    if (this._parent) {\n      this._parent._children.delete(this);\n    }\n    if (parent) {\n      this._parent = parent;\n      this._parent._children.add(this);\n    } else {\n      this._parent = null;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/link.ts\nimport assert5 from \"@dxos/node-std/assert\";\nvar Link = class extends Entity {\n  constructor(itemManager, itemId, itemType, stateManager, link) {\n    super(itemManager, itemId, itemType, stateManager);\n    this._link = link;\n  }\n  get isLink() {\n    return true;\n  }\n  get sourceId() {\n    return this._link.sourceId;\n  }\n  get targetId() {\n    return this._link.targetId;\n  }\n  get source() {\n    assert5(this._link.source, \"Dangling link\");\n    return this._link.source;\n  }\n  get target() {\n    assert5(this._link.target, \"Dangling link\");\n    return this._link.target;\n  }\n  _isDangling() {\n    return !this._link.source || !this._link.target;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service-host.ts\nvar log3 = debug3(\"dxos:echo-db:data-service-host\");\nvar DataServiceHost = class {\n  constructor(_itemManager, _itemDemuxer, _writeStream) {\n    this._itemManager = _itemManager;\n    this._itemDemuxer = _itemDemuxer;\n    this._writeStream = _writeStream;\n  }\n  subscribeEntitySet() {\n    return new Stream2(({ next }) => {\n      const trackedSet = /* @__PURE__ */ new Set();\n      const entityInfo = (id) => {\n        var _a, _b;\n        const entity = (_a = this._itemManager.entities.get(id)) != null ? _a : failUndefined2();\n        return {\n          itemId: id,\n          genesis: {\n            itemType: entity.type,\n            modelType: entity.modelType,\n            link: entity instanceof Link ? {\n              source: entity.sourceId,\n              target: entity.targetId\n            } : void 0\n          },\n          itemMutation: entity instanceof Item ? {\n            parentId: (_b = entity.parent) == null ? void 0 : _b.id\n          } : void 0\n        };\n      };\n      const update = () => {\n        const added = /* @__PURE__ */ new Set();\n        const deleted = /* @__PURE__ */ new Set();\n        for (const entity of this._itemManager.entities.keys()) {\n          if (!trackedSet.has(entity)) {\n            added.add(entity);\n            trackedSet.add(entity);\n          }\n        }\n        for (const entity1 of trackedSet) {\n          if (!this._itemManager.entities.has(entity1)) {\n            deleted.add(entity1);\n            trackedSet.delete(entity1);\n          }\n        }\n        next({\n          added: Array.from(added).map((id) => entityInfo(id)),\n          deleted: Array.from(added).map((id) => ({\n            itemId: id\n          }))\n        });\n      };\n      update();\n      return this._itemManager.debouncedUpdate.on(update);\n    });\n  }\n  subscribeEntityStream(request) {\n    return new Stream2(({ next }) => {\n      assert6(request.itemId);\n      const entityItem = this._itemManager.items.find((item) => item.id === request.itemId);\n      let snapshot;\n      if (entityItem) {\n        snapshot = this._itemDemuxer.createItemSnapshot(entityItem);\n      } else {\n        const entityLink = this._itemManager.links.find((link) => link.id === request.itemId);\n        if (entityLink) {\n          snapshot = this._itemDemuxer.createLinkSnapshot(entityLink);\n        } else {\n          raise(new EntityNotFoundError(request.itemId));\n        }\n      }\n      log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n        snapshot\n      })}`);\n      next({\n        snapshot\n      });\n      return this._itemDemuxer.mutation.on((mutation) => {\n        if (mutation.data.itemId !== request.itemId) {\n          return;\n        }\n        log3(`Entity stream ${request.itemId}: ${JSON.stringify({\n          mutation\n        })}`);\n        next({\n          mutation: {\n            data: mutation.data,\n            meta: {\n              feedKey: PublicKey.from(mutation.meta.feedKey),\n              memberKey: PublicKey.from(mutation.meta.memberKey),\n              seq: mutation.meta.seq,\n              timeframe: mutation.meta.timeframe\n            }\n          }\n        });\n      });\n    });\n  }\n  async write(request) {\n    assert6(this._writeStream, \"Cannot write mutations in readonly mode\");\n    return this._writeStream.write(request);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/data-service.ts\nimport assert7 from \"@dxos/node-std/assert\";\nimport { raise as raise2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar DataServiceSubscriptions = class {\n  constructor() {\n    this._spaces = new ComplexMap(PublicKey2.hash);\n  }\n  clear() {\n    this._spaces.clear();\n  }\n  registerSpace(spaceKey, host) {\n    this._spaces.set(spaceKey, host);\n  }\n  unregisterSpace(spaceKey) {\n    this._spaces.delete(spaceKey);\n  }\n  getDataService(spaceKey) {\n    return this._spaces.get(spaceKey);\n  }\n};\nvar DataServiceImpl = class {\n  constructor(_subscriptions) {\n    this._subscriptions = _subscriptions;\n  }\n  subscribeEntitySet(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntitySet();\n  }\n  subscribeEntityStream(request) {\n    var _a;\n    assert7(request.spaceKey);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.subscribeEntityStream(request);\n  }\n  write(request) {\n    var _a;\n    assert7(request.spaceKey);\n    assert7(request.mutation);\n    const host = (_a = this._subscriptions.getDataService(request.spaceKey)) != null ? _a : raise2(new SpaceNotFoundError(request.spaceKey));\n    return host.write(request.mutation);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nimport debug5 from \"debug\";\nimport assert9 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions as EventSubscriptions2 } from \"@dxos/async\";\n\n// packages/core/echo/echo-db/src/packlets/database/item-demuxer.ts\nimport debug4 from \"debug\";\nimport assert8 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { failUndefined as failUndefined3 } from \"@dxos/debug\";\nvar log4 = debug4(\"dxos:echo-db:item-demuxer\");\nvar ItemDemuxer = class {\n  constructor(_itemManager, _modelFactory, _options = {}) {\n    this._itemManager = _itemManager;\n    this._modelFactory = _modelFactory;\n    this._options = _options;\n    this.mutation = new Event5();\n  }\n  open() {\n    this._modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    });\n    return async (message) => {\n      var _a, _b, _c;\n      const { data: { itemId, genesis, itemMutation, mutation, snapshot }, meta } = message;\n      assert8(itemId);\n      if (genesis) {\n        const { itemType, modelType } = genesis;\n        assert8(modelType);\n        const modelOpts = {\n          itemId,\n          modelType,\n          snapshot: {\n            mutations: mutation ? [\n              {\n                mutation,\n                meta\n              }\n            ] : void 0\n          }\n        };\n        let entity;\n        if (genesis.link) {\n          entity = await this._itemManager.constructLink({\n            ...modelOpts,\n            itemType,\n            source: (_a = genesis.link.source) != null ? _a : failUndefined3(),\n            target: (_b = genesis.link.target) != null ? _b : failUndefined3()\n          });\n        } else {\n          entity = await this._itemManager.constructItem({\n            ...modelOpts,\n            parentId: itemMutation == null ? void 0 : itemMutation.parentId,\n            itemType\n          });\n        }\n        assert8(entity.id === itemId);\n      }\n      if (itemMutation) {\n        const item = this._itemManager.getItem(itemId);\n        assert8(item);\n        item._processMutation(itemMutation, (itemId2) => this._itemManager.getItem(itemId2));\n      }\n      if (mutation && !genesis) {\n        assert8(message.data.mutation);\n        const modelMessage = {\n          meta,\n          mutation\n        };\n        await this._itemManager.processModelMessage(itemId, modelMessage);\n      }\n      if (snapshot) {\n        const entity1 = (_c = this._itemManager.entities.get(itemId)) != null ? _c : failUndefined3();\n        entity1._stateManager.resetToSnapshot(snapshot);\n      }\n      this.mutation.emit(message);\n    };\n  }\n  createSnapshot() {\n    assert8(this._options.snapshots, \"Snapshots are disabled\");\n    return {\n      items: this._itemManager.items.map((item) => this.createItemSnapshot(item)),\n      links: this._itemManager.links.map((link) => this.createLinkSnapshot(link))\n    };\n  }\n  createItemSnapshot(item) {\n    var _a;\n    const model = item._stateManager.createSnapshot();\n    return {\n      itemId: item.id,\n      itemType: item.type,\n      modelType: item.modelType,\n      parentId: (_a = item.parent) == null ? void 0 : _a.id,\n      model\n    };\n  }\n  createLinkSnapshot(link) {\n    const model = link._stateManager.createSnapshot();\n    return {\n      linkId: link.id,\n      linkType: link.type,\n      modelType: link.modelMeta.type,\n      source: link.source.id,\n      target: link.target.id,\n      model\n    };\n  }\n  async restoreFromSnapshot(snapshot) {\n    const { items = [], links = [] } = snapshot;\n    log4(`Restoring ${items.length} items from snapshot.`);\n    for (const item of sortItemsTopologically(items)) {\n      assert8(item.itemId);\n      assert8(item.modelType);\n      assert8(item.model);\n      await this._itemManager.constructItem({\n        itemId: item.itemId,\n        modelType: item.modelType,\n        itemType: item.itemType,\n        parentId: item.parentId,\n        snapshot: item.model\n      });\n    }\n    log4(`Restoring ${links.length} links from snapshot.`);\n    for (const link of links) {\n      assert8(link.linkId);\n      assert8(link.modelType);\n      assert8(link.model);\n      await this._itemManager.constructLink({\n        itemId: link.linkId,\n        itemType: link.linkType,\n        modelType: link.modelType,\n        source: link.source,\n        target: link.target,\n        snapshot: link.model\n      });\n    }\n  }\n};\nvar sortItemsTopologically = (items) => {\n  const snapshots = [];\n  const seenIds = /* @__PURE__ */ new Set();\n  while (snapshots.length !== items.length) {\n    const prevLength = snapshots.length;\n    for (const item of items) {\n      assert8(item.itemId);\n      if (!seenIds.has(item.itemId) && (item.parentId == null || seenIds.has(item.parentId))) {\n        snapshots.push(item);\n        seenIds.add(item.itemId);\n      }\n    }\n    if (prevLength === snapshots.length && snapshots.length !== items.length) {\n      throw new Error(\"Cannot topologically sorts items in snapshot: some parents are missing.\");\n    }\n  }\n  return snapshots;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database-backend.ts\nvar log5 = debug5(\"dxos:echo-db:database-backend\");\nvar DatabaseBackendHost = class {\n  constructor(_outboundStream, _snapshot, _options = {}) {\n    this._outboundStream = _outboundStream;\n    this._snapshot = _snapshot;\n    this._options = _options;\n  }\n  get isReadOnly() {\n    return !!this._outboundStream;\n  }\n  get echoProcessor() {\n    return this._echoProcessor;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    this._itemDemuxer = new ItemDemuxer(itemManager, modelFactory, this._options);\n    this._echoProcessor = this._itemDemuxer.open();\n    if (this._snapshot) {\n      await this._itemDemuxer.restoreFromSnapshot(this._snapshot);\n    }\n  }\n  async close() {\n  }\n  getWriteStream() {\n    return this._outboundStream;\n  }\n  createSnapshot() {\n    return this._itemDemuxer.createSnapshot();\n  }\n  createDataServiceHost() {\n    var _a;\n    return new DataServiceHost(this._itemManager, this._itemDemuxer, (_a = this._outboundStream) != null ? _a : void 0);\n  }\n};\nvar DatabaseBackendProxy = class {\n  constructor(_service, _spaceKey) {\n    this._service = _service;\n    this._spaceKey = _spaceKey;\n    this._subscriptions = new EventSubscriptions2();\n  }\n  get isReadOnly() {\n    return false;\n  }\n  async open(itemManager, modelFactory) {\n    this._itemManager = itemManager;\n    const dataMirror = new DataMirror(this._itemManager, this._service, this._spaceKey);\n    this._subscriptions.add(modelFactory.registered.on(async (model) => {\n      for (const item of this._itemManager.getUninitializedEntities()) {\n        if (item._stateManager.modelType === model.meta.type) {\n          await this._itemManager.initializeModel(item.id);\n        }\n      }\n    }));\n    dataMirror.open();\n  }\n  async close() {\n    this._subscriptions.clear();\n  }\n  getWriteStream() {\n    return {\n      write: async (mutation) => {\n        log5(\"write\", mutation);\n        const { feedKey, seq } = await this._service.write({\n          mutation,\n          spaceKey: this._spaceKey\n        });\n        assert9(feedKey);\n        assert9(seq !== void 0);\n        return {\n          feedKey,\n          seq\n        };\n      }\n    };\n  }\n  createSnapshot() {\n    throw new Error(\"Method not supported.\");\n  }\n  createDataServiceHost() {\n    throw new Error(\"Method not supported.\");\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/database/item-manager.ts\nimport debug6 from \"debug\";\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Event as Event6, trigger } from \"@dxos/async\";\nimport { createId } from \"@dxos/crypto\";\nimport { timed } from \"@dxos/debug\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar log6 = debug6(\"dxos:echo-db:item-manager\");\nvar ItemManager = class {\n  constructor(_modelFactory, _memberKey, _writeStream) {\n    this._modelFactory = _modelFactory;\n    this._memberKey = _memberKey;\n    this._writeStream = _writeStream;\n    this.update = new Event6();\n    this.debouncedUpdate = debounceEntityUpdateEvent(this.update);\n    this._entities = /* @__PURE__ */ new Map();\n    this._pendingItems = /* @__PURE__ */ new Map();\n  }\n  get entities() {\n    return this._entities;\n  }\n  get items() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Item);\n  }\n  get links() {\n    return Array.from(this._entities.values()).filter((entity) => entity instanceof Link);\n  }\n  async createItem(modelType, itemType, parentId, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Model does not support initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis\", {\n      itemId\n    });\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType\n      },\n      itemMutation: parentId ? {\n        parentId\n      } : void 0,\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const item = await waitForCreation();\n    assert10(item instanceof Item);\n    return item;\n  }\n  async createLink(modelType, itemType, source, target, initProps) {\n    assert10(this._writeStream);\n    assert10(modelType);\n    if (!this._modelFactory.hasModel(modelType)) {\n      throw new UnknownModelError(modelType);\n    }\n    let mutation;\n    if (initProps) {\n      const meta = this._modelFactory.getModelMeta(modelType);\n      if (!meta.getInitMutation) {\n        throw new Error(\"Tried to provide initialization params to a model with no initializer.\");\n      }\n      mutation = meta.mutationCodec.encode(await meta.getInitMutation(initProps));\n    }\n    const [waitForCreation, callback] = trigger();\n    const itemId = createId();\n    this._pendingItems.set(itemId, callback);\n    log6(\"Item Genesis:\", itemId);\n    await this._writeStream.write({\n      itemId,\n      genesis: {\n        itemType,\n        modelType,\n        link: {\n          source,\n          target\n        }\n      },\n      mutation\n    });\n    log6(\"Pending Item:\", itemId);\n    const link = await waitForCreation();\n    assert10(link instanceof Link);\n    return link;\n  }\n  async _constructModel({ modelType, itemId, snapshot }) {\n    const outboundTransform = this._writeStream && createMappedFeedWriter((mutation) => ({\n      itemId,\n      mutation\n    }), this._writeStream);\n    return this._modelFactory.createModel(modelType, itemId, snapshot, this._memberKey, outboundTransform);\n  }\n  _addEntity(entity, parent) {\n    var _a;\n    assert10(!this._entities.has(entity.id));\n    this._entities.set(entity.id, entity);\n    log6(\"New entity:\", String(entity));\n    this.update.emit(entity);\n    entity.subscribe(() => {\n      this.update.emit(entity);\n    });\n    (_a = this._pendingItems.get(entity.id)) == null ? void 0 : _a(entity);\n  }\n  async constructItem({ itemId, itemType, modelType, parentId, snapshot }) {\n    assert10(itemId);\n    assert10(modelType);\n    const parent = parentId ? this._entities.get(parentId) : null;\n    if (parentId && !parent) {\n      throw new Error(`Missing parent: ${parentId}`);\n    }\n    assert10(!parent || parent instanceof Item);\n    const modelStateManager = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const item = new Item(this, itemId, itemType, modelStateManager, this._writeStream, parent);\n    if (parent) {\n      this.update.emit(parent);\n    }\n    this._addEntity(item);\n    return item;\n  }\n  async constructLink({ itemId, itemType, modelType, snapshot, source, target }) {\n    assert10(itemId);\n    assert10(modelType);\n    const model = await this._constructModel({\n      itemId,\n      modelType,\n      snapshot\n    });\n    const sourceItem = this.getItem(source);\n    const targetItem = this.getItem(target);\n    const link = new Link(this, itemId, itemType, model, {\n      sourceId: source,\n      targetId: target,\n      source: sourceItem,\n      target: targetItem\n    });\n    if (sourceItem) {\n      sourceItem._links.add(link);\n      this.update.emit(sourceItem);\n    }\n    if (targetItem) {\n      targetItem._refs.add(link);\n      this.update.emit(targetItem);\n    }\n    this._addEntity(link);\n    return link;\n  }\n  async processModelMessage(itemId, message) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    await item._stateManager.processMessage(message.meta, message.mutation);\n    this.update.emit(item);\n  }\n  getItem(itemId) {\n    const entity = this._entities.get(itemId);\n    if (entity) {\n      assert10(entity instanceof Item);\n    }\n    return entity;\n  }\n  getUninitializedEntities() {\n    return Array.from(this._entities.values()).filter((entity) => !entity._stateManager.initialized);\n  }\n  deconstructItem(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    this._entities.delete(itemId);\n    if (item instanceof Item) {\n      if (item.parent) {\n        item.parent._children.delete(item);\n      }\n      for (const child of item.children) {\n        this.deconstructItem(child.id);\n      }\n      for (const ref of item.refs) {\n        ref._link.target = void 0;\n      }\n      for (const link of item.links) {\n        link._link.source = void 0;\n      }\n    }\n  }\n  async initializeModel(itemId) {\n    const item = this._entities.get(itemId);\n    assert10(item);\n    const model = this._modelFactory.getModel(item._stateManager.modelType);\n    assert10(model, \"Model not registered\");\n    item._stateManager.initialize(model.constructor);\n    this.update.emit(item);\n  }\n};\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"createLink\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructItem\", null);\n__decorate([\n  timed(5e3)\n], ItemManager.prototype, \"constructLink\", null);\nvar debounceEntityUpdateEvent = (event) => {\n  const debouncedEvent = new Event6();\n  let firing = false;\n  const emittedSinceLastFired = /* @__PURE__ */ new Set();\n  debouncedEvent.addEffect(() => event.on((arg) => {\n    emittedSinceLastFired.add(arg);\n    if (!firing) {\n      firing = true;\n      setTimeout(() => {\n        firing = false;\n        const args = Array.from(emittedSinceLastFired);\n        emittedSinceLastFired.clear();\n        debouncedEvent.emit(args);\n      }, 0);\n    }\n  }));\n  return debouncedEvent;\n};\n\n// packages/core/echo/echo-db/src/packlets/database/database.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport { synchronized } from \"@dxos/async\";\nimport { validateModelClass } from \"@dxos/model-factory\";\nimport { ObjectModel } from \"@dxos/object-model\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar State;\n(function(State2) {\n  State2[\"NULL\"] = \"NULL\";\n  State2[\"INITIALIZED\"] = \"INITIALIZED\";\n  State2[\"DESTROYED\"] = \"DESTROYED\";\n})(State || (State = {}));\nvar Database = class {\n  constructor(_modelFactory, _backend, memberKey) {\n    this._modelFactory = _modelFactory;\n    this._backend = _backend;\n    this._state = State.NULL;\n    this._itemManager = new ItemManager(this._modelFactory, memberKey, this._backend.getWriteStream());\n  }\n  get state() {\n    return this._state;\n  }\n  get isReadOnly() {\n    return this._backend.isReadOnly;\n  }\n  get update() {\n    return this._itemManager.debouncedUpdate;\n  }\n  get entityUpdate() {\n    return this._itemManager.update;\n  }\n  async initialize() {\n    if (this._state !== State.NULL) {\n      throw new Error(\"Invalid state: database was already initialized.\");\n    }\n    await this._backend.open(this._itemManager, this._modelFactory);\n    this._state = State.INITIALIZED;\n  }\n  async destroy() {\n    if (this._state === State.DESTROYED || this._state === State.NULL) {\n      return;\n    }\n    await this._backend.close();\n    this._state = State.DESTROYED;\n  }\n  async createItem(options = {}) {\n    this._assertInitialized();\n    if (!options.model) {\n      options.model = ObjectModel;\n    }\n    validateModelClass(options.model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    if (options.parent && typeof options.parent !== \"string\") {\n      throw new TypeError(\"Optional parent item id must be a string id of an existing item.\");\n    }\n    return await this._itemManager.createItem(options.model.meta.type, options.type, options.parent, options.props);\n  }\n  async createLink(options) {\n    var _a;\n    this._assertInitialized();\n    const model = (_a = options.model) != null ? _a : ObjectModel;\n    if (!model) {\n      throw new TypeError(\"Missing model class.\");\n    }\n    validateModelClass(model);\n    if (options.type && typeof options.type !== \"string\") {\n      throw new TypeError(\"Invalid type.\");\n    }\n    return this._itemManager.createLink(model.meta.type, options.type, options.source.id, options.target.id, options.props);\n  }\n  getItem(itemId) {\n    this._assertInitialized();\n    return this._itemManager.getItem(itemId);\n  }\n  async waitForItem(filter) {\n    const result = this.select(filter).exec();\n    await result.update.waitForCondition(() => result.entities.length > 0);\n    const item = result.expectOne();\n    assert11(item, \"Possible race condition detected.\");\n    return item;\n  }\n  select(filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, void 0);\n  }\n  reduce(result, filter) {\n    return createSelection(() => this._itemManager.items, () => this._itemManager.debouncedUpdate, this, filter, result);\n  }\n  createSnapshot() {\n    this._assertInitialized();\n    return this._backend.createSnapshot();\n  }\n  createDataServiceHost() {\n    return this._backend.createDataServiceHost();\n  }\n  _assertInitialized() {\n    if (this._state !== State.INITIALIZED) {\n      throw new Error(\"Database not initialized.\");\n    }\n  }\n};\n__decorate2([\n  synchronized\n], Database.prototype, \"initialize\", null);\n__decorate2([\n  synchronized\n], Database.prototype, \"destroy\", null);\n\n// packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { log as log7 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar STORAGE_VERSION = 1;\nvar emptyEchoMetadata = () => ({\n  version: STORAGE_VERSION,\n  spaces: [],\n  created: new Date(),\n  updated: new Date()\n});\nvar MetadataStore = class {\n  constructor(_directory) {\n    this._directory = _directory;\n    this._metadata = emptyEchoMetadata();\n  }\n  get version() {\n    var _a;\n    return (_a = this._metadata.version) != null ? _a : 0;\n  }\n  get spaces() {\n    var _a;\n    return (_a = this._metadata.spaces) != null ? _a : [];\n  }\n  async load() {\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const { size: fileLength } = await file.stat();\n      if (fileLength < 4) {\n        return;\n      }\n      const dataSize = fromBytesInt32(await file.read(0, 4));\n      log7(\"loaded\", {\n        size: dataSize\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 67,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      {\n        if (fileLength < dataSize + 4) {\n          throw new Error(\"Metadata storage is corrupted\");\n        }\n      }\n      const data = await file.read(4, dataSize);\n      this._metadata = schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").decode(data);\n    } catch (err) {\n      log7.error(\"failed to load metadata\", {\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 79,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._metadata = emptyEchoMetadata();\n    } finally {\n      await file.close();\n    }\n  }\n  async _save() {\n    var _a;\n    const data = {\n      ...this._metadata,\n      version: STORAGE_VERSION,\n      created: (_a = this._metadata.created) != null ? _a : new Date(),\n      updated: new Date()\n    };\n    const file = this._directory.getOrCreateFile(\"EchoMetadata\");\n    try {\n      const encoded = Buffer.from(schema2.getCodecForType(\"dxos.echo.metadata.EchoMetadata\").encode(data));\n      await file.write(0, toBytesInt32(encoded.length));\n      log7(\"saved\", {\n        size: encoded.length\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n        line: 102,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await file.write(4, encoded);\n    } finally {\n      await file.close();\n    }\n  }\n  async clear() {\n    log7(\"clearing all metadata\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/metadata/metadata-store.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._directory.delete();\n  }\n  getIdentityRecord() {\n    return this._metadata.identity;\n  }\n  async setIdentityRecord(record) {\n    assert12(!this._metadata.identity, \"Cannot overwrite existing identity in metadata\");\n    this._metadata.identity = record;\n    await this._save();\n  }\n  async addSpace(record) {\n    var _a, _b, _c;\n    assert12(!((_a = this._metadata.spaces) != null ? _a : []).find((space) => space.key === record.key), \"Cannot overwrite existing space in metadata\");\n    ((_c = (_b = this._metadata).spaces) != null ? _c : _b.spaces = []).push(record);\n    await this._save();\n  }\n};\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"load\", null);\n__decorate3([\n  synchronized2\n], MetadataStore.prototype, \"_save\", null);\nvar toBytesInt32 = (num) => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32LE(num, 0);\n  return buf;\n};\nvar fromBytesInt32 = (buf) => buf.readInt32LE(0);\n\n// packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { log as log8 } from \"@dxos/log\";\nimport { Extension, ERR_EXTENSION_RESPONSE_FAILED } from \"@dxos/mesh-protocol\";\nvar EXTENSION_NAME = \"dxos.credentials.auth\";\nvar AuthPlugin = class {\n  constructor(_swarmIdentity, requireAuthForExtensions = []) {\n    this._swarmIdentity = _swarmIdentity;\n    this.authenticationFailed = new Event7();\n    this._requiredForExtensions = new Set(requireAuthForExtensions);\n  }\n  createExtension() {\n    return new Extension(EXTENSION_NAME, {\n      binary: true\n    }).setHandshakeHandler(this._onHandshake.bind(this));\n  }\n  async _onHandshake(protocol) {\n    var _a;\n    try {\n      assert13(protocol);\n      const { credentials, peerId: sessionPeerId } = (_a = protocol == null ? void 0 : protocol.getSession()) != null ? _a : {};\n      log8(\"Handshake\", {\n        credentials,\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 66,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!credentials) {\n        if (this._requiredForExtensions.size) {\n          let authRequired = false;\n          for (const name of protocol.stream.remoteExtensions.names) {\n            if (this._requiredForExtensions.has(name)) {\n              log8(`Auth required for extension: ${name}`, {}, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n                line: 74,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              authRequired = true;\n              break;\n            }\n          }\n          if (!authRequired) {\n            log8(`Unauthenticated access allowed for ${sessionPeerId}; no extensions which require authentication are active on remote Protocol.`, {}, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n              line: 84,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            return;\n          }\n        }\n        log8(\"No credentials provided; dropping connection\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: no credentials.\");\n      }\n      const nonce = Buffer.from(\"\");\n      const credentialsBuf = Buffer.from(credentials, \"base64\");\n      const isAuthenticated = await this._swarmIdentity.credentialAuthenticator(nonce, credentialsBuf);\n      if (!isAuthenticated) {\n        log8(\"Unauthenticated access denied\", {\n          sessionPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n          line: 110,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.authenticationFailed.emit();\n        protocol.stream.destroy();\n        throw new ERR_EXTENSION_RESPONSE_FAILED(EXTENSION_NAME, \"ERR_AUTH_REJECTED\", \"Authentication rejected: bad credentials.\");\n      }\n      log8(\"Authenticated access granted\", {\n        sessionPeerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 121,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log8(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/auth-plugin.ts\",\n        line: 129,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw err;\n    }\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\nimport { Event as Event8 } from \"@dxos/async\";\nimport { log as log9 } from \"@dxos/log\";\nimport { ReplicatorPlugin as AbstractReplicatorPlugin } from \"@dxos/protocol-plugin-replicator\";\nvar ReplicatorPlugin = class extends AbstractReplicatorPlugin {\n  constructor() {\n    super({\n      load: async () => {\n        const feeds = Array.from(this._feeds);\n        log9(\"loading feeds\", {\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 31,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds.map((feed) => ({\n          discoveryKey: feed.properties.discoveryKey\n        }));\n      },\n      subscribe: (addFeedToReplicatedSet) => this._feedAdded.on(async (feed) => {\n        log9(\"adding feed\", {\n          feedKey: feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 39,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        addFeedToReplicatedSet({\n          discoveryKey: feed.properties.discoveryKey\n        });\n      }),\n      replicate: async (remoteFeeds, info) => {\n        const feeds = Array.from(this._feeds);\n        log9(\"replicating\", {\n          peerId: info.session,\n          feeds: feeds.map((feed) => feed.key)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return feeds;\n      }\n    });\n    this._feedAdded = new Event8();\n    this._feeds = /* @__PURE__ */ new Set();\n  }\n  addFeed(feed) {\n    log9(\"adding feed\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/replicator-plugin.ts\",\n      line: 21,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._feeds.add(feed);\n    this._feedAdded.emit(feed);\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nimport assert16 from \"@dxos/node-std/assert\";\nimport { Event as Event10, synchronized as synchronized3 } from \"@dxos/async\";\nimport { failUndefined as failUndefined4 } from \"@dxos/debug\";\nimport { log as log14, logInfo } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { Callback as Callback2 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nimport assert15 from \"@dxos/node-std/assert\";\nimport { FeedSetIterator } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\n\n// packages/core/echo/echo-db/src/packlets/pipeline/message-selector.ts\nimport debug7 from \"debug\";\nimport assert14 from \"@dxos/node-std/assert\";\nvar log10 = debug7(\"dxos:echo-db:message-selector\");\nvar createMessageSelector = (timeframeClock) => {\n  return (messages) => {\n    for (let i = 0; i < messages.length; i++) {\n      const { data: { timeframe } } = messages[i];\n      assert14(timeframe);\n      if (!timeframeClock.hasGaps(timeframe)) {\n        return i;\n      }\n    }\n    log10(\"Skipping...\");\n  };\n};\n\n// packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\nimport { Event as Event9 } from \"@dxos/async\";\nimport { timed as timed2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar __decorate4 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar mapTimeframeToFeedIndexes = (timeframe) => timeframe.frames().map(([feedKey, index]) => ({\n  feedKey,\n  index\n}));\nvar mapFeedIndexesToTimeframe = (indexes) => new Timeframe(indexes.map(({ feedKey, index }) => [\n  feedKey,\n  index\n]));\nvar TimeframeClock = class {\n  constructor(_timeframe = new Timeframe()) {\n    this._timeframe = _timeframe;\n    this.update = new Event9();\n  }\n  get timeframe() {\n    return this._timeframe;\n  }\n  updateTimeframe(key, seq) {\n    this._timeframe = Timeframe.merge(this._timeframe, new Timeframe([\n      [\n        key,\n        seq\n      ]\n    ]));\n    this.update.emit(this._timeframe);\n  }\n  hasGaps(timeframe) {\n    const gaps = Timeframe.dependencies(timeframe, this._timeframe);\n    return !gaps.isEmpty();\n  }\n  async waitUntilReached(target) {\n    log11.debug(\"waitUntilReached\", {\n      target,\n      current: this._timeframe\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n      line: 45,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.update.waitForCondition(() => {\n      log11(\"check if reached\", {\n        target,\n        current: this._timeframe,\n        deps: Timeframe.dependencies(target, this._timeframe)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/timeframe-clock.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return Timeframe.dependencies(target, this._timeframe).isEmpty();\n    });\n  }\n};\n__decorate4([\n  timed2(5e3)\n], TimeframeClock.prototype, \"waitUntilReached\", null);\n\n// packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\nvar PipelineState = class {\n  constructor(_iterator, _timeframeClock) {\n    this._iterator = _iterator;\n    this._timeframeClock = _timeframeClock;\n    this.timeframeUpdate = this._timeframeClock.updateTimeframe;\n  }\n  get endTimeframe() {\n    return mapFeedIndexesToTimeframe(this._iterator.feeds.filter((feed) => feed.properties.length > 0).map((feed) => ({\n      feedKey: feed.key,\n      index: feed.properties.length - 1\n    })));\n  }\n  get timeframe() {\n    return this._timeframeClock.timeframe;\n  }\n  async waitUntilTimeframe(target) {\n    await this._timeframeClock.waitUntilReached(target);\n  }\n};\nvar Pipeline = class {\n  constructor(_initialTimeframe = new Timeframe2()) {\n    this._initialTimeframe = _initialTimeframe;\n    this._timeframeClock = new TimeframeClock(this._initialTimeframe);\n    this.feedSetIterator = new FeedSetIterator(createMessageSelector(this._timeframeClock), {\n      start: mapTimeframeToFeedIndexes(this._initialTimeframe),\n      stallTimeout: 1e3\n    });\n    this._state = new PipelineState(this.feedSetIterator, this._timeframeClock);\n    this._isOpen = false;\n    this.feedSetIterator.stalled.on((iterator) => {\n      log12.warn(`Stalled after ${iterator.options.stallTimeout}ms with ${iterator.size} feeds.`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n        line: 110,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n  }\n  get state() {\n    return this._state;\n  }\n  get writer() {\n    assert15(this._writer, \"Writer not set.\");\n    return this._writer;\n  }\n  async addFeed(feed) {\n    await this.feedSetIterator.addFeed(feed);\n  }\n  setWriteFeed(feed) {\n    assert15(!this._writer, \"Writer already set.\");\n    assert15(feed.properties.writable, \"Feed must be writable.\");\n    this._writer = createMappedFeedWriter((data) => ({\n      timeframe: this._timeframeClock.timeframe,\n      payload: data\n    }), feed.createFeedWriter());\n  }\n  async start() {\n    log12(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.open();\n    log12(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 143,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log12(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.feedSetIterator.close();\n    log12(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/pipeline/pipeline.ts\",\n      line: 149,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async *consume() {\n    assert15(!this._isOpen, \"Pipeline is already being consumed.\");\n    this._isOpen = true;\n    for await (const block of this.feedSetIterator) {\n      yield block;\n      this._timeframeClock.updateTimeframe(PublicKey3.from(block.feedKey), block.seq);\n    }\n    this._isOpen = false;\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\nimport { SpaceStateMachine } from \"@dxos/credentials\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { AdmittedFeed } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback } from \"@dxos/util\";\nvar ControlPipeline = class {\n  constructor({ spaceKey, genesisFeed, feedProvider, initialTimeframe }) {\n    this.onFeedAdmitted = new Callback();\n    this._pipeline = new Pipeline(initialTimeframe);\n    void this._pipeline.addFeed(genesisFeed);\n    this._spaceStateMachine = new SpaceStateMachine(spaceKey);\n    this._spaceStateMachine.onFeedAdmitted.set(async (info) => {\n      log13(\"feed admitted\", {\n        info\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (info.assertion.designation === AdmittedFeed.Designation.CONTROL && !info.key.equals(genesisFeed.key)) {\n        try {\n          const feed = await feedProvider(info.key);\n          await this._pipeline.addFeed(feed);\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 48,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n      await this.onFeedAdmitted.callIfSet(info);\n    });\n    this.onMemberAdmitted = this._spaceStateMachine.onMemberAdmitted;\n    this.onCredentialProcessed = this._spaceStateMachine.onCredentialProcessed;\n  }\n  get spaceState() {\n    return this._spaceStateMachine;\n  }\n  get pipeline() {\n    return this._pipeline;\n  }\n  setWriteFeed(feed) {\n    this._pipeline.setWriteFeed(feed);\n  }\n  async start() {\n    log13(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 72,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    setTimeout(async () => {\n      for await (const msg of this._pipeline.consume()) {\n        try {\n          log13(\"processing\", {\n            msg\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 76,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (msg.data.payload[\"@type\"] === \"dxos.echo.feed.CredentialsMessage\") {\n            const result = await this._spaceStateMachine.process(msg.data.payload.credential, PublicKey4.from(msg.feedKey));\n            if (!result) {\n              log13.warn(\"processing failed\", {\n                msg\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n                line: 83,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n            }\n          }\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n            line: 87,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this._pipeline.start();\n    log13(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 93,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    log13(\"stopping...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 97,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._pipeline.stop();\n    log13(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/control-pipeline.ts\",\n      line: 99,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space.ts\nvar __decorate5 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Space = class {\n  constructor({ spaceKey, protocol, genesisFeed, controlFeed, dataFeed, feedProvider, databaseFactory, initialTimeframe }) {\n    this.onCredentialProcessed = new Callback2();\n    this.stateUpdate = new Event10();\n    this._isOpen = false;\n    assert16(spaceKey && dataFeed && feedProvider);\n    this._key = spaceKey;\n    this._controlFeed = controlFeed;\n    this._dataFeed = dataFeed;\n    this._feedProvider = feedProvider;\n    this._genesisFeedKey = genesisFeed.key;\n    this._databaseFactory = databaseFactory;\n    this._controlPipeline = new ControlPipeline({\n      spaceKey,\n      genesisFeed,\n      feedProvider,\n      initialTimeframe\n    });\n    this._controlPipeline.setWriteFeed(controlFeed);\n    this._controlPipeline.onFeedAdmitted.set(async (info) => {\n      if (info.assertion.designation === AdmittedFeed2.Designation.DATA) {\n        if (!this._dataPipeline) {\n          return;\n        }\n        await this._dataPipeline.addFeed(await feedProvider(info.key));\n      }\n      if (!info.key.equals(genesisFeed.key)) {\n        this._protocol.addFeed(await feedProvider(info.key));\n      }\n    });\n    this._controlPipeline.onCredentialProcessed.set(async (credential) => {\n      await this.onCredentialProcessed.callIfSet(credential);\n      log14(\"onCredentialProcessed\", {\n        credential\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.stateUpdate.emit();\n    });\n    this._protocol = protocol;\n    this._protocol.addFeed(genesisFeed);\n  }\n  get key() {\n    return this._key;\n  }\n  get isOpen() {\n    return this._isOpen;\n  }\n  get database() {\n    if (!this._database) {\n      throw new Error(\"Space not open.\");\n    }\n    return this._database;\n  }\n  get genesisFeedKey() {\n    return this._genesisFeedKey;\n  }\n  get controlFeedKey() {\n    return this._controlFeed.key;\n  }\n  get dataFeedKey() {\n    return this._dataFeed.key;\n  }\n  get spaceState() {\n    return this._controlPipeline.spaceState;\n  }\n  get controlPipeline() {\n    return this._controlPipeline.pipeline;\n  }\n  async open() {\n    log14(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 171,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._isOpen) {\n      return;\n    }\n    await this._controlPipeline.start();\n    await this._openDataPipeline();\n    await this._protocol.start();\n    this._isOpen = true;\n    log14(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 182,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    log14(\"closing...\", {\n      key: this._key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 187,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._isOpen) {\n      return;\n    }\n    await this._protocol.stop();\n    await this._closeDataPipeline();\n    await this._controlPipeline.stop();\n    this._isOpen = false;\n    log14(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n      line: 198,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _openDataPipeline() {\n    var _a;\n    assert16(!this._dataPipeline, \"Data pipeline already initialized.\");\n    {\n      this._dataPipeline = new Pipeline(new Timeframe3());\n      this._dataPipeline.setWriteFeed(this._dataFeed);\n      for (const feed of this._controlPipeline.spaceState.feeds.values()) {\n        await this._dataPipeline.addFeed(await this._feedProvider(feed.key));\n      }\n    }\n    {\n      const feedWriter = createMappedFeedWriter((msg) => ({\n        \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n        ...msg\n      }), (_a = this._dataPipeline.writer) != null ? _a : failUndefined4());\n      this._databaseBackend = new DatabaseBackendHost(feedWriter, {}, {\n        snapshots: true\n      });\n    }\n    {\n      this._database = await this._databaseFactory({\n        databaseBackend: this._databaseBackend\n      });\n      await this._database.initialize();\n    }\n    await this._dataPipeline.start();\n    setTimeout(async () => {\n      assert16(this._dataPipeline);\n      for await (const msg of this._dataPipeline.consume()) {\n        const { feedKey, seq, data } = msg;\n        log14(\"processing message\", {\n          msg\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n          line: 246,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        try {\n          const payload = data.payload;\n          if (payload[\"@type\"] === \"dxos.echo.feed.EchoEnvelope\") {\n            const feedInfo = this._controlPipeline.spaceState.feeds.get(feedKey);\n            if (!feedInfo) {\n              log14.error(\"Could not find feed.\", {\n                feedKey\n              }, {\n                file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n                line: 253,\n                scope: this,\n                callSite: (f, a) => f(...a)\n              });\n              continue;\n            }\n            await this._databaseBackend.echoProcessor({\n              data: payload,\n              meta: {\n                feedKey,\n                seq,\n                timeframe: data.timeframe,\n                memberKey: feedInfo.assertion.identityKey\n              }\n            });\n          }\n        } catch (err) {\n          log14.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space.ts\",\n            line: 268,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n  }\n  async _closeDataPipeline() {\n    var _a, _b, _c;\n    assert16(this._dataPipeline, \"Data pipeline not initialized.\");\n    await ((_a = this._dataPipeline) == null ? void 0 : _a.stop());\n    await ((_b = this._databaseBackend) == null ? void 0 : _b.close());\n    await ((_c = this._database) == null ? void 0 : _c.destroy());\n  }\n};\n__decorate5([\n  logInfo\n], Space.prototype, \"key\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"open\", null);\n__decorate5([\n  synchronized3\n], Space.prototype, \"close\", null);\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nimport { Event as Event11 } from \"@dxos/async\";\nimport { CredentialGenerator } from \"@dxos/credentials\";\nimport { failUndefined as failUndefined5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log16 } from \"@dxos/log\";\nimport { AdmittedFeed as AdmittedFeed3 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\nimport { discoveryKey, sha256 } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { log as log15 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nimport { adaptProtocolProvider, MMSTTopology } from \"@dxos/network-manager\";\nimport { PresencePlugin } from \"@dxos/protocol-plugin-presence\";\nimport { Teleport } from \"@dxos/teleport\";\nimport { ReplicatorExtension as TeleportReplicatorExtension } from \"@dxos/teleport-plugin-replicator\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MOCK_AUTH_PROVIDER = async (nonce) => Buffer.from(\"mock\");\nvar MOCK_AUTH_VERIFIER = async (nonce, credential) => true;\nvar USE_TELEPORT = true;\nvar SpaceProtocol = class {\n  constructor({ topic, identity, networkManager, plugins = [] }) {\n    this._replicator = new ReplicatorPlugin();\n    this._feeds = /* @__PURE__ */ new Set();\n    this._sessions = new ComplexMap2(PublicKey5.hash);\n    this._networkManager = networkManager;\n    this._swarmIdentity = identity;\n    this._presencePlugin = new PresencePlugin(this._swarmIdentity.peerKey.asBuffer());\n    this._authPlugin = new AuthPlugin(this._swarmIdentity, []);\n    this._customPlugins = plugins;\n    this._discoveryKey = PublicKey5.from(discoveryKey(sha256(topic.toHex())));\n    this._peerId = PublicKey5.from(discoveryKey(sha256(this._swarmIdentity.peerKey.toHex())));\n    this.authenticationFailed = this._authPlugin.authenticationFailed;\n  }\n  addFeed(feed) {\n    if (USE_TELEPORT) {\n      this._feeds.add(feed);\n      for (const session of this._sessions.values()) {\n        session.replicator.addFeed(feed);\n      }\n    } else {\n      this._replicator.addFeed(feed);\n    }\n  }\n  async start() {\n    if (this._connection) {\n      return;\n    }\n    const credentials = await this._swarmIdentity.credentialProvider(Buffer.from(\"\"));\n    const topologyConfig = {\n      originateConnections: 4,\n      maxPeers: 10,\n      sampleSize: 20\n    };\n    log15(\"starting...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connection = await this._networkManager.joinSwarm({\n      protocolProvider: this._createProtocolProvider(credentials),\n      peerId: this._peerId,\n      topic: this._discoveryKey,\n      presence: this._presencePlugin,\n      topology: new MMSTTopology(topologyConfig),\n      label: `Protocol swarm: ${this._discoveryKey}`\n    });\n    log15(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async stop() {\n    if (this._connection) {\n      log15(\"stopping...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 130,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._connection.close();\n      log15(\"stopped\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-protocol.ts\",\n        line: 132,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  _createProtocolProvider(credentials) {\n    if (USE_TELEPORT) {\n      return (params) => {\n        const session = new SpaceProtocolSession(params);\n        this._sessions.set(params.remotePeerId, session);\n        for (const feed of this._feeds) {\n          session.replicator.addFeed(feed);\n        }\n        return session;\n      };\n    } else {\n      return adaptProtocolProvider(({ channel, initiator }) => {\n        const protocol = new Protocol({\n          streamOptions: {\n            live: true\n          },\n          discoveryKey: channel,\n          discoveryToPublicKey: (discoveryKey2) => {\n            if (!PublicKey5.from(discoveryKey2).equals(this._discoveryKey)) {\n              return void 0;\n            }\n            protocol.setContext({\n              topic: this._discoveryKey.toHex()\n            });\n            return this._discoveryKey.asBuffer();\n          },\n          userSession: {\n            peerId: this._peerId.toHex(),\n            credentials: credentials ? Buffer.from(credentials).toString(\"base64\") : void 0\n          },\n          initiator\n        });\n        const plugins = [\n          this._presencePlugin,\n          this._authPlugin,\n          this._replicator,\n          ...this._customPlugins\n        ];\n        protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n        return protocol;\n      });\n    }\n  }\n  get peers() {\n    return this._presencePlugin.peers.map((peer) => PublicKey5.from(peer));\n  }\n};\nvar SpaceProtocolSession = class {\n  constructor({ initiator, localPeerId, remotePeerId }) {\n    this.replicator = new TeleportReplicatorExtension().setOptions({\n      upload: true\n    });\n    this._teleport = new Teleport({\n      initiator,\n      localPeerId,\n      remotePeerId\n    });\n  }\n  get stream() {\n    return this._teleport.stream;\n  }\n  async initialize() {\n    await this._teleport.open();\n    this._teleport.addExtension(\"dxos.mesh.teleport.replicator\", this.replicator);\n  }\n  async destroy() {\n    await this._teleport.close();\n  }\n};\n\n// packages/core/echo/echo-db/src/packlets/space/space-manager.ts\nvar SpaceManager = class {\n  constructor({ metadataStore, feedStore, networkManager, keyring, dataServiceSubscriptions, modelFactory, signingContext }) {\n    this.updated = new Event11();\n    this._spaces = new ComplexMap3(PublicKey6.hash);\n    this._metadataStore = metadataStore;\n    this._feedStore = feedStore;\n    this._networkManager = networkManager;\n    this._keyring = keyring;\n    this._dataServiceSubscriptions = dataServiceSubscriptions;\n    this._modelFactory = modelFactory;\n    this._signingContext = signingContext;\n  }\n  get spaces() {\n    return this._spaces;\n  }\n  async open() {\n    await this._metadataStore.load();\n    for (const spaceMetadata of this._metadataStore.spaces) {\n      const space = await this._constructSpace(spaceMetadata);\n      await space.open();\n      this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n      this._spaces.set(spaceMetadata.key, space);\n    }\n  }\n  async close() {\n    await Promise.all([\n      ...this._spaces.values()\n    ].map((space) => space.close()));\n  }\n  async createSpace() {\n    const spaceKey = await this._keyring.createKey();\n    const controlFeedKey = await this._keyring.createKey();\n    const dataFeedKey = await this._keyring.createKey();\n    const metadata = {\n      key: spaceKey,\n      genesisFeedKey: controlFeedKey,\n      controlFeedKey,\n      dataFeedKey\n    };\n    log16(\"creating space...\", {\n      spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    {\n      const generator = new CredentialGenerator(this._keyring, this._signingContext.identityKey, this._signingContext.deviceKey);\n      const credentials = [\n        ...await generator.createSpaceGenesis(spaceKey, controlFeedKey, this._signingContext.profile),\n        await generator.createFeedAdmission(spaceKey, dataFeedKey, AdmittedFeed3.Designation.DATA)\n      ];\n      for (const credential of credentials) {\n        await space.controlPipeline.writer.write({\n          \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n          credential\n        });\n      }\n    }\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  async acceptSpace(opts) {\n    const metadata = {\n      key: opts.spaceKey,\n      genesisFeedKey: opts.genesisFeedKey,\n      controlFeedKey: await this._keyring.createKey(),\n      dataFeedKey: await this._keyring.createKey()\n    };\n    log16(\"accepting space...\", {\n      spaceKey: opts.spaceKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 161,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const space = await this._constructSpace(metadata);\n    await space.open();\n    await this._metadataStore.addSpace(metadata);\n    this._insertSpace(space);\n    return space;\n  }\n  _insertSpace(space) {\n    this._dataServiceSubscriptions.registerSpace(space.key, space.database.createDataServiceHost());\n    this._spaces.set(space.key, space);\n    this.updated.emit();\n  }\n  async _constructSpace(metadata) {\n    var _a, _b, _c;\n    log16(\"constructing space...\", {\n      spaceKey: metadata.genesisFeedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/echo-db/src/packlets/space/space-manager.ts\",\n      line: 177,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const controlFeed = await this._feedStore.openFeed((_a = metadata.controlFeedKey) != null ? _a : failUndefined5(), {\n      writable: true\n    });\n    const dataFeed = await this._feedStore.openFeed((_b = metadata.dataFeedKey) != null ? _b : failUndefined5(), {\n      writable: true\n    });\n    const genesisFeed = await this._feedStore.openFeed((_c = metadata.genesisFeedKey) != null ? _c : failUndefined5());\n    const spaceKey = metadata.key;\n    const protocol = new SpaceProtocol({\n      topic: spaceKey,\n      identity: {\n        peerKey: this._signingContext.deviceKey,\n        credentialProvider: this._signingContext.credentialProvider,\n        credentialAuthenticator: this._signingContext.credentialAuthenticator\n      },\n      networkManager: this._networkManager\n    });\n    return new Space({\n      spaceKey,\n      protocol,\n      genesisFeed,\n      controlFeed,\n      dataFeed,\n      feedProvider: (feedKey) => this._feedStore.openFeed(feedKey),\n      databaseFactory: async ({ databaseBackend }) => new Database(this._modelFactory, databaseBackend, this._signingContext.identityKey)\n    });\n  }\n};\nexport {\n  AuthPlugin,\n  DBError,\n  DataMirror,\n  DataServiceHost,\n  DataServiceImpl,\n  DataServiceSubscriptions,\n  Database,\n  DatabaseBackendHost,\n  DatabaseBackendProxy,\n  Entity,\n  EntityNotFoundError,\n  IdentityNotInitializedError,\n  InvalidInvitationError,\n  InvalidStorageVersionError,\n  Item,\n  ItemDemuxer,\n  ItemFilterDeleted,\n  ItemManager,\n  Link,\n  MOCK_AUTH_PROVIDER,\n  MOCK_AUTH_VERIFIER,\n  MetadataStore,\n  ReplicatorPlugin,\n  ResultSet,\n  STORAGE_VERSION,\n  Schema,\n  Selection,\n  SelectionResult,\n  Space,\n  SpaceManager,\n  SpaceNotFoundError,\n  SpaceProtocol,\n  SpaceProtocolSession,\n  State,\n  TYPE_SCHEMA,\n  USE_TELEPORT,\n  UnknownModelError,\n  codec,\n  coerceToId,\n  createItemSelection,\n  createMappedFeedWriter,\n  createQueryOptionsFilter,\n  createSelection,\n  dedupe,\n  filterToPredicate,\n  itemFilterToPredicate,\n  linkFilterToPredicate,\n  resultSetToStream,\n  sortItemsTopologically,\n  streamToResultSet,\n  testOneOrMultiple,\n  valueEncoding\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466023,"end":1670465466057,"order":"normal"}]}
