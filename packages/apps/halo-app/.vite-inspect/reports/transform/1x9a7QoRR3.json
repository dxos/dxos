{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/echo/text-model/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/echo/text-model/src/text-model.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Doc, XmlElement, XmlText, XmlFragment, applyUpdate, encodeStateAsUpdate } from \"yjs\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nvar TextModelStateMachine = class {\n  constructor() {\n    this._doc = new Doc();\n  }\n  getState() {\n    return this._doc;\n  }\n  process(mutation, meta) {\n    const { update, clientId } = mutation;\n    assert(update);\n    if (clientId !== this._doc.clientID) {\n      applyUpdate(this._doc, update, {\n        docClientId: clientId\n      });\n    }\n  }\n  snapshot() {\n    return {\n      data: encodeStateAsUpdate(this._doc)\n    };\n  }\n  reset(snapshot) {\n    assert(snapshot.data);\n    applyUpdate(this._doc, snapshot.data);\n  }\n};\nvar TextModel = class extends Model {\n  constructor(meta, itemId, getState, writeStream) {\n    super(meta, itemId, getState, writeStream);\n    this._textContentInner = (node) => {\n      if (node instanceof XmlText) {\n        return node.toString();\n      }\n      if (node.length === 0) {\n        return node instanceof XmlFragment ? \"\" : \"\\n\";\n      }\n      const textContentNodes = [];\n      const nodes = node.toArray();\n      for (const childNode of nodes) {\n        textContentNodes.push(this._textContentInner(childNode));\n      }\n      return textContentNodes.join(\"\\n\");\n    };\n    this._insertInner = (node, index, text) => {\n      if (node instanceof XmlText) {\n        if (index <= node.length) {\n          node.insert(index, text);\n          return true;\n        }\n        return node.length;\n      }\n      let innerIndex = index;\n      let childLength = 0;\n      if (node instanceof XmlFragment && node.length === 0) {\n        const paragraph = new XmlElement(\"paragraph\");\n        paragraph.insert(0, [\n          new XmlText(\"\")\n        ]);\n        node.insert(0, [\n          paragraph\n        ]);\n      }\n      for (const childNode of node.toArray()) {\n        const inserted = this._insertInner(childNode, innerIndex, text);\n        if (inserted === true) {\n          return true;\n        }\n        childLength += inserted;\n        innerIndex -= inserted + 1;\n      }\n      return childLength;\n    };\n    let unsubscribe = this._subscribeToDocUpdates();\n    this.update.on(() => {\n      unsubscribe();\n      unsubscribe = this._subscribeToDocUpdates();\n    });\n  }\n  get doc() {\n    return this._getState();\n  }\n  get content() {\n    return this._getState().getXmlFragment(\"content\");\n  }\n  get textContent() {\n    return this._textContentInner(this.content);\n  }\n  _subscribeToDocUpdates() {\n    const cb = this._handleDocUpdated.bind(this);\n    this._getState().on(\"update\", cb);\n    return () => this._getState().off(\"update\", cb);\n  }\n  async _handleDocUpdated(update, origin) {\n    const remote = origin && origin.docClientId && origin.docClientId !== this._getState().clientID;\n    if (!remote) {\n      await this.write({\n        clientId: this._getState().clientID,\n        update\n      });\n    }\n  }\n  _transact(fn) {\n    return this._getState().transact(fn, {\n      docClientId: this._getState().clientID\n    });\n  }\n  insert(text, index) {\n    return this._transact(() => this._insertInner(this.content, index, text));\n  }\n  insertTextNode(text, index = 0) {\n    const paragraph = new XmlElement(\"paragraph\");\n    const yXmlText = new XmlText(text);\n    paragraph.insert(0, [\n      yXmlText\n    ]);\n    return this._transact(() => this.content.insert(index, [\n      paragraph\n    ]));\n  }\n};\nTextModel.meta = {\n  type: \"dxos:model/text\",\n  stateMachine: () => new TextModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.text.Mutation\"),\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.text.Snapshot\")\n};\nexport {\n  TextModel\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466992,"end":1670465467181},{"name":"vite:react-babel","result":"// packages/core/echo/text-model/src/text-model.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Doc, XmlElement, XmlText, XmlFragment, applyUpdate, encodeStateAsUpdate } from \"yjs\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nvar TextModelStateMachine = class {\n  constructor() {\n    this._doc = new Doc();\n  }\n  getState() {\n    return this._doc;\n  }\n  process(mutation, meta) {\n    const { update, clientId } = mutation;\n    assert(update);\n    if (clientId !== this._doc.clientID) {\n      applyUpdate(this._doc, update, {\n        docClientId: clientId\n      });\n    }\n  }\n  snapshot() {\n    return {\n      data: encodeStateAsUpdate(this._doc)\n    };\n  }\n  reset(snapshot) {\n    assert(snapshot.data);\n    applyUpdate(this._doc, snapshot.data);\n  }\n};\nvar TextModel = class extends Model {\n  constructor(meta, itemId, getState, writeStream) {\n    super(meta, itemId, getState, writeStream);\n    this._textContentInner = (node) => {\n      if (node instanceof XmlText) {\n        return node.toString();\n      }\n      if (node.length === 0) {\n        return node instanceof XmlFragment ? \"\" : \"\\n\";\n      }\n      const textContentNodes = [];\n      const nodes = node.toArray();\n      for (const childNode of nodes) {\n        textContentNodes.push(this._textContentInner(childNode));\n      }\n      return textContentNodes.join(\"\\n\");\n    };\n    this._insertInner = (node, index, text) => {\n      if (node instanceof XmlText) {\n        if (index <= node.length) {\n          node.insert(index, text);\n          return true;\n        }\n        return node.length;\n      }\n      let innerIndex = index;\n      let childLength = 0;\n      if (node instanceof XmlFragment && node.length === 0) {\n        const paragraph = new XmlElement(\"paragraph\");\n        paragraph.insert(0, [\n          new XmlText(\"\")\n        ]);\n        node.insert(0, [\n          paragraph\n        ]);\n      }\n      for (const childNode of node.toArray()) {\n        const inserted = this._insertInner(childNode, innerIndex, text);\n        if (inserted === true) {\n          return true;\n        }\n        childLength += inserted;\n        innerIndex -= inserted + 1;\n      }\n      return childLength;\n    };\n    let unsubscribe = this._subscribeToDocUpdates();\n    this.update.on(() => {\n      unsubscribe();\n      unsubscribe = this._subscribeToDocUpdates();\n    });\n  }\n  get doc() {\n    return this._getState();\n  }\n  get content() {\n    return this._getState().getXmlFragment(\"content\");\n  }\n  get textContent() {\n    return this._textContentInner(this.content);\n  }\n  _subscribeToDocUpdates() {\n    const cb = this._handleDocUpdated.bind(this);\n    this._getState().on(\"update\", cb);\n    return () => this._getState().off(\"update\", cb);\n  }\n  async _handleDocUpdated(update, origin) {\n    const remote = origin && origin.docClientId && origin.docClientId !== this._getState().clientID;\n    if (!remote) {\n      await this.write({\n        clientId: this._getState().clientID,\n        update\n      });\n    }\n  }\n  _transact(fn) {\n    return this._getState().transact(fn, {\n      docClientId: this._getState().clientID\n    });\n  }\n  insert(text, index) {\n    return this._transact(() => this._insertInner(this.content, index, text));\n  }\n  insertTextNode(text, index = 0) {\n    const paragraph = new XmlElement(\"paragraph\");\n    const yXmlText = new XmlText(text);\n    paragraph.insert(0, [\n      yXmlText\n    ]);\n    return this._transact(() => this.content.insert(index, [\n      paragraph\n    ]));\n  }\n};\nTextModel.meta = {\n  type: \"dxos:model/text\",\n  stateMachine: () => new TextModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.text.Mutation\"),\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.text.Snapshot\")\n};\nexport {\n  TextModel\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467181,"end":1670465467181,"order":"pre"},{"name":"polyfill-node","result":"// packages/core/echo/text-model/src/text-model.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Doc, XmlElement, XmlText, XmlFragment, applyUpdate, encodeStateAsUpdate } from \"yjs\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nvar TextModelStateMachine = class {\n  constructor() {\n    this._doc = new Doc();\n  }\n  getState() {\n    return this._doc;\n  }\n  process(mutation, meta) {\n    const { update, clientId } = mutation;\n    assert(update);\n    if (clientId !== this._doc.clientID) {\n      applyUpdate(this._doc, update, {\n        docClientId: clientId\n      });\n    }\n  }\n  snapshot() {\n    return {\n      data: encodeStateAsUpdate(this._doc)\n    };\n  }\n  reset(snapshot) {\n    assert(snapshot.data);\n    applyUpdate(this._doc, snapshot.data);\n  }\n};\nvar TextModel = class extends Model {\n  constructor(meta, itemId, getState, writeStream) {\n    super(meta, itemId, getState, writeStream);\n    this._textContentInner = (node) => {\n      if (node instanceof XmlText) {\n        return node.toString();\n      }\n      if (node.length === 0) {\n        return node instanceof XmlFragment ? \"\" : \"\\n\";\n      }\n      const textContentNodes = [];\n      const nodes = node.toArray();\n      for (const childNode of nodes) {\n        textContentNodes.push(this._textContentInner(childNode));\n      }\n      return textContentNodes.join(\"\\n\");\n    };\n    this._insertInner = (node, index, text) => {\n      if (node instanceof XmlText) {\n        if (index <= node.length) {\n          node.insert(index, text);\n          return true;\n        }\n        return node.length;\n      }\n      let innerIndex = index;\n      let childLength = 0;\n      if (node instanceof XmlFragment && node.length === 0) {\n        const paragraph = new XmlElement(\"paragraph\");\n        paragraph.insert(0, [\n          new XmlText(\"\")\n        ]);\n        node.insert(0, [\n          paragraph\n        ]);\n      }\n      for (const childNode of node.toArray()) {\n        const inserted = this._insertInner(childNode, innerIndex, text);\n        if (inserted === true) {\n          return true;\n        }\n        childLength += inserted;\n        innerIndex -= inserted + 1;\n      }\n      return childLength;\n    };\n    let unsubscribe = this._subscribeToDocUpdates();\n    this.update.on(() => {\n      unsubscribe();\n      unsubscribe = this._subscribeToDocUpdates();\n    });\n  }\n  get doc() {\n    return this._getState();\n  }\n  get content() {\n    return this._getState().getXmlFragment(\"content\");\n  }\n  get textContent() {\n    return this._textContentInner(this.content);\n  }\n  _subscribeToDocUpdates() {\n    const cb = this._handleDocUpdated.bind(this);\n    this._getState().on(\"update\", cb);\n    return () => this._getState().off(\"update\", cb);\n  }\n  async _handleDocUpdated(update, origin) {\n    const remote = origin && origin.docClientId && origin.docClientId !== this._getState().clientID;\n    if (!remote) {\n      await this.write({\n        clientId: this._getState().clientID,\n        update\n      });\n    }\n  }\n  _transact(fn) {\n    return this._getState().transact(fn, {\n      docClientId: this._getState().clientID\n    });\n  }\n  insert(text, index) {\n    return this._transact(() => this._insertInner(this.content, index, text));\n  }\n  insertTextNode(text, index = 0) {\n    const paragraph = new XmlElement(\"paragraph\");\n    const yXmlText = new XmlText(text);\n    paragraph.insert(0, [\n      yXmlText\n    ]);\n    return this._transact(() => this.content.insert(index, [\n      paragraph\n    ]));\n  }\n};\nTextModel.meta = {\n  type: \"dxos:model/text\",\n  stateMachine: () => new TextModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.text.Mutation\"),\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.text.Snapshot\")\n};\nexport {\n  TextModel\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467181,"end":1670465467182,"order":"normal"}]}
