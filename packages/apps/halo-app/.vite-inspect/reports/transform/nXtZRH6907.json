{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/keys/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/keys/src/public-key.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport randomBytes from \"randombytes\";\nimport { truncateKey } from \"@dxos/debug\";\nvar PUBLIC_KEY_LENGTH = 32;\nvar SECRET_KEY_LENGTH = 64;\nvar PublicKey = class {\n  static from(source) {\n    assert(source);\n    if (source instanceof PublicKey) {\n      return source;\n    } else if (source instanceof Buffer) {\n      return new PublicKey(new Uint8Array(source));\n    } else if (source instanceof Uint8Array) {\n      return new PublicKey(source);\n    } else if (typeof source === \"string\") {\n      return PublicKey.fromHex(source);\n    } else if (source.asUint8Array) {\n      return new PublicKey(source.asUint8Array());\n    } else {\n      throw new TypeError(`Unable to create PublicKey from ${source}`);\n    }\n  }\n  static fromHex(hex) {\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n    return new PublicKey(new Uint8Array(Buffer.from(hex, \"hex\")));\n  }\n  static random() {\n    return PublicKey.from(randomBytes(32));\n  }\n  static isPublicKey(value) {\n    return value instanceof PublicKey;\n  }\n  static assertValidPublicKey(value) {\n    if (!this.isPublicKey(value)) {\n      throw new TypeError(\"Invalid PublicKey\");\n    }\n  }\n  static equals(left, right) {\n    return PublicKey.from(left).equals(right);\n  }\n  static bufferize(str) {\n    assert(typeof str === \"string\", \"Invalid type\");\n    const buffer = Buffer.from(str, \"hex\");\n    return buffer;\n  }\n  static stringify(key) {\n    if (key instanceof PublicKey) {\n      key = key.asBuffer();\n    } else if (key instanceof Uint8Array) {\n      key = Buffer.from(key);\n    }\n    assert(key instanceof Buffer, \"Invalid type\");\n    return key.toString(\"hex\");\n  }\n  static hash(key) {\n    return key.toHex();\n  }\n  constructor(_value) {\n    this._value = _value;\n    if (!(_value instanceof Uint8Array)) {\n      throw new TypeError(`Expected Uint8Array, got: ${_value}`);\n    }\n  }\n  truncate(length = 4) {\n    return truncateKey(this, length);\n  }\n  toString() {\n    return this.toHex();\n  }\n  toJSON() {\n    return this.toHex();\n  }\n  toHex() {\n    return this.asBuffer().toString(\"hex\");\n  }\n  asBuffer() {\n    return Buffer.from(this._value);\n  }\n  asUint8Array() {\n    return this._value;\n  }\n  getInsecureHash(modulo) {\n    return Math.abs(this._value.reduce((acc, val) => acc ^ val | 0, 0)) % modulo;\n  }\n  [inspect.custom](depth, options) {\n    if (!options.colors || !process.stdout.hasColors()) {\n      return `<PublicKey ${this.truncate()}>`;\n    }\n    const printControlCode = (code) => {\n      return `\\x1B[${code}m`;\n    };\n    const colors = [\n      \"red\",\n      \"green\",\n      \"yellow\",\n      \"blue\",\n      \"magenta\",\n      \"cyan\",\n      \"redBright\",\n      \"greenBright\",\n      \"yellowBright\",\n      \"blueBright\",\n      \"magentaBright\",\n      \"cyanBright\",\n      \"whiteBright\"\n    ];\n    const color = colors[this.getInsecureHash(colors.length)];\n    return `PublicKey(${printControlCode(inspect.colors[color][0])}${this.truncate()}${printControlCode(inspect.colors.reset[0])})`;\n  }\n  equals(other) {\n    const otherConverted = PublicKey.from(other);\n    if (this._value.length !== otherConverted._value.length) {\n      return false;\n    }\n    let equal = true;\n    for (let i = 0; i < this._value.length; i++) {\n      equal && (equal = this._value[i] === otherConverted._value[i]);\n    }\n    return equal;\n  }\n};\nvar DevtoolsFormatter = class {\n  register() {\n    var _a;\n    if (typeof window !== \"undefined\") {\n      ((_a = window.devtoolsFormatters) != null ? _a : window.devtoolsFormatters = []).push(this);\n    }\n  }\n};\nvar PublicKeyFormatter = class extends DevtoolsFormatter {\n  header(value) {\n    if (!PublicKey.isPublicKey(value)) {\n      return null;\n    }\n    const colors = [\n      \"darkred\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"darkmagenta\",\n      \"darkcyan\",\n      \"red\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"magenta\",\n      \"darkcyan\",\n      \"black\"\n    ];\n    const color = colors[value.getInsecureHash(colors.length)];\n    return [\n      \"span\",\n      {},\n      [\n        \"span\",\n        {},\n        \"PublicKey(\"\n      ],\n      [\n        \"span\",\n        {\n          style: `color: ${color};`\n        },\n        value.truncate()\n      ],\n      [\n        \"span\",\n        {},\n        \")\"\n      ]\n    ];\n  }\n  hasBody(value) {\n    return false;\n  }\n  body(value) {\n    return null;\n  }\n};\nnew PublicKeyFormatter().register();\nexport {\n  PUBLIC_KEY_LENGTH,\n  PublicKey,\n  SECRET_KEY_LENGTH\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465438903,"end":1670465440502},{"name":"vite:react-babel","result":"// packages/common/keys/src/public-key.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport randomBytes from \"randombytes\";\nimport { truncateKey } from \"@dxos/debug\";\nvar PUBLIC_KEY_LENGTH = 32;\nvar SECRET_KEY_LENGTH = 64;\nvar PublicKey = class {\n  static from(source) {\n    assert(source);\n    if (source instanceof PublicKey) {\n      return source;\n    } else if (source instanceof Buffer) {\n      return new PublicKey(new Uint8Array(source));\n    } else if (source instanceof Uint8Array) {\n      return new PublicKey(source);\n    } else if (typeof source === \"string\") {\n      return PublicKey.fromHex(source);\n    } else if (source.asUint8Array) {\n      return new PublicKey(source.asUint8Array());\n    } else {\n      throw new TypeError(`Unable to create PublicKey from ${source}`);\n    }\n  }\n  static fromHex(hex) {\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n    return new PublicKey(new Uint8Array(Buffer.from(hex, \"hex\")));\n  }\n  static random() {\n    return PublicKey.from(randomBytes(32));\n  }\n  static isPublicKey(value) {\n    return value instanceof PublicKey;\n  }\n  static assertValidPublicKey(value) {\n    if (!this.isPublicKey(value)) {\n      throw new TypeError(\"Invalid PublicKey\");\n    }\n  }\n  static equals(left, right) {\n    return PublicKey.from(left).equals(right);\n  }\n  static bufferize(str) {\n    assert(typeof str === \"string\", \"Invalid type\");\n    const buffer = Buffer.from(str, \"hex\");\n    return buffer;\n  }\n  static stringify(key) {\n    if (key instanceof PublicKey) {\n      key = key.asBuffer();\n    } else if (key instanceof Uint8Array) {\n      key = Buffer.from(key);\n    }\n    assert(key instanceof Buffer, \"Invalid type\");\n    return key.toString(\"hex\");\n  }\n  static hash(key) {\n    return key.toHex();\n  }\n  constructor(_value) {\n    this._value = _value;\n    if (!(_value instanceof Uint8Array)) {\n      throw new TypeError(`Expected Uint8Array, got: ${_value}`);\n    }\n  }\n  truncate(length = 4) {\n    return truncateKey(this, length);\n  }\n  toString() {\n    return this.toHex();\n  }\n  toJSON() {\n    return this.toHex();\n  }\n  toHex() {\n    return this.asBuffer().toString(\"hex\");\n  }\n  asBuffer() {\n    return Buffer.from(this._value);\n  }\n  asUint8Array() {\n    return this._value;\n  }\n  getInsecureHash(modulo) {\n    return Math.abs(this._value.reduce((acc, val) => acc ^ val | 0, 0)) % modulo;\n  }\n  [inspect.custom](depth, options) {\n    if (!options.colors || !process.stdout.hasColors()) {\n      return `<PublicKey ${this.truncate()}>`;\n    }\n    const printControlCode = (code) => {\n      return `\\x1B[${code}m`;\n    };\n    const colors = [\n      \"red\",\n      \"green\",\n      \"yellow\",\n      \"blue\",\n      \"magenta\",\n      \"cyan\",\n      \"redBright\",\n      \"greenBright\",\n      \"yellowBright\",\n      \"blueBright\",\n      \"magentaBright\",\n      \"cyanBright\",\n      \"whiteBright\"\n    ];\n    const color = colors[this.getInsecureHash(colors.length)];\n    return `PublicKey(${printControlCode(inspect.colors[color][0])}${this.truncate()}${printControlCode(inspect.colors.reset[0])})`;\n  }\n  equals(other) {\n    const otherConverted = PublicKey.from(other);\n    if (this._value.length !== otherConverted._value.length) {\n      return false;\n    }\n    let equal = true;\n    for (let i = 0; i < this._value.length; i++) {\n      equal && (equal = this._value[i] === otherConverted._value[i]);\n    }\n    return equal;\n  }\n};\nvar DevtoolsFormatter = class {\n  register() {\n    var _a;\n    if (typeof window !== \"undefined\") {\n      ((_a = window.devtoolsFormatters) != null ? _a : window.devtoolsFormatters = []).push(this);\n    }\n  }\n};\nvar PublicKeyFormatter = class extends DevtoolsFormatter {\n  header(value) {\n    if (!PublicKey.isPublicKey(value)) {\n      return null;\n    }\n    const colors = [\n      \"darkred\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"darkmagenta\",\n      \"darkcyan\",\n      \"red\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"magenta\",\n      \"darkcyan\",\n      \"black\"\n    ];\n    const color = colors[value.getInsecureHash(colors.length)];\n    return [\n      \"span\",\n      {},\n      [\n        \"span\",\n        {},\n        \"PublicKey(\"\n      ],\n      [\n        \"span\",\n        {\n          style: `color: ${color};`\n        },\n        value.truncate()\n      ],\n      [\n        \"span\",\n        {},\n        \")\"\n      ]\n    ];\n  }\n  hasBody(value) {\n    return false;\n  }\n  body(value) {\n    return null;\n  }\n};\nnew PublicKeyFormatter().register();\nexport {\n  PUBLIC_KEY_LENGTH,\n  PublicKey,\n  SECRET_KEY_LENGTH\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440503,"end":1670465440503,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport { default as process } from '\u0000polyfill-node.process';\n\n// packages/common/keys/src/public-key.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport randomBytes from \"randombytes\";\nimport { truncateKey } from \"@dxos/debug\";\nvar PUBLIC_KEY_LENGTH = 32;\nvar SECRET_KEY_LENGTH = 64;\nvar PublicKey = class {\n  static from(source) {\n    assert(source);\n    if (source instanceof PublicKey) {\n      return source;\n    } else if (source instanceof Buffer) {\n      return new PublicKey(new Uint8Array(source));\n    } else if (source instanceof Uint8Array) {\n      return new PublicKey(source);\n    } else if (typeof source === \"string\") {\n      return PublicKey.fromHex(source);\n    } else if (source.asUint8Array) {\n      return new PublicKey(source.asUint8Array());\n    } else {\n      throw new TypeError(`Unable to create PublicKey from ${source}`);\n    }\n  }\n  static fromHex(hex) {\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n    return new PublicKey(new Uint8Array(Buffer.from(hex, \"hex\")));\n  }\n  static random() {\n    return PublicKey.from(randomBytes(32));\n  }\n  static isPublicKey(value) {\n    return value instanceof PublicKey;\n  }\n  static assertValidPublicKey(value) {\n    if (!this.isPublicKey(value)) {\n      throw new TypeError(\"Invalid PublicKey\");\n    }\n  }\n  static equals(left, right) {\n    return PublicKey.from(left).equals(right);\n  }\n  static bufferize(str) {\n    assert(typeof str === \"string\", \"Invalid type\");\n    const buffer = Buffer.from(str, \"hex\");\n    return buffer;\n  }\n  static stringify(key) {\n    if (key instanceof PublicKey) {\n      key = key.asBuffer();\n    } else if (key instanceof Uint8Array) {\n      key = Buffer.from(key);\n    }\n    assert(key instanceof Buffer, \"Invalid type\");\n    return key.toString(\"hex\");\n  }\n  static hash(key) {\n    return key.toHex();\n  }\n  constructor(_value) {\n    this._value = _value;\n    if (!(_value instanceof Uint8Array)) {\n      throw new TypeError(`Expected Uint8Array, got: ${_value}`);\n    }\n  }\n  truncate(length = 4) {\n    return truncateKey(this, length);\n  }\n  toString() {\n    return this.toHex();\n  }\n  toJSON() {\n    return this.toHex();\n  }\n  toHex() {\n    return this.asBuffer().toString(\"hex\");\n  }\n  asBuffer() {\n    return Buffer.from(this._value);\n  }\n  asUint8Array() {\n    return this._value;\n  }\n  getInsecureHash(modulo) {\n    return Math.abs(this._value.reduce((acc, val) => acc ^ val | 0, 0)) % modulo;\n  }\n  [inspect.custom](depth, options) {\n    if (!options.colors || !process.stdout.hasColors()) {\n      return `<PublicKey ${this.truncate()}>`;\n    }\n    const printControlCode = (code) => {\n      return `\\x1B[${code}m`;\n    };\n    const colors = [\n      \"red\",\n      \"green\",\n      \"yellow\",\n      \"blue\",\n      \"magenta\",\n      \"cyan\",\n      \"redBright\",\n      \"greenBright\",\n      \"yellowBright\",\n      \"blueBright\",\n      \"magentaBright\",\n      \"cyanBright\",\n      \"whiteBright\"\n    ];\n    const color = colors[this.getInsecureHash(colors.length)];\n    return `PublicKey(${printControlCode(inspect.colors[color][0])}${this.truncate()}${printControlCode(inspect.colors.reset[0])})`;\n  }\n  equals(other) {\n    const otherConverted = PublicKey.from(other);\n    if (this._value.length !== otherConverted._value.length) {\n      return false;\n    }\n    let equal = true;\n    for (let i = 0; i < this._value.length; i++) {\n      equal && (equal = this._value[i] === otherConverted._value[i]);\n    }\n    return equal;\n  }\n};\nvar DevtoolsFormatter = class {\n  register() {\n    var _a;\n    if (typeof window !== \"undefined\") {\n      ((_a = window.devtoolsFormatters) != null ? _a : window.devtoolsFormatters = []).push(this);\n    }\n  }\n};\nvar PublicKeyFormatter = class extends DevtoolsFormatter {\n  header(value) {\n    if (!PublicKey.isPublicKey(value)) {\n      return null;\n    }\n    const colors = [\n      \"darkred\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"darkmagenta\",\n      \"darkcyan\",\n      \"red\",\n      \"green\",\n      \"orange\",\n      \"blue\",\n      \"magenta\",\n      \"darkcyan\",\n      \"black\"\n    ];\n    const color = colors[value.getInsecureHash(colors.length)];\n    return [\n      \"span\",\n      {},\n      [\n        \"span\",\n        {},\n        \"PublicKey(\"\n      ],\n      [\n        \"span\",\n        {\n          style: `color: ${color};`\n        },\n        value.truncate()\n      ],\n      [\n        \"span\",\n        {},\n        \")\"\n      ]\n    ];\n  }\n  hasBody(value) {\n    return false;\n  }\n  body(value) {\n    return null;\n  }\n};\nnew PublicKeyFormatter().register();\nexport {\n  PUBLIC_KEY_LENGTH,\n  PublicKey,\n  SECRET_KEY_LENGTH\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465440503,"end":1670465440506,"order":"normal"}]}
