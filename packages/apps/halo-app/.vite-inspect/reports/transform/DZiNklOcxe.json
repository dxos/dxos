{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/crypto/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/crypto/src/encrypt.ts\nimport CryptoJS from \"crypto-js\";\nimport assert from \"@dxos/node-std/assert\";\nvar encrypt = (plaintext, passphrase, cipher = \"AES\") => {\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  return CryptoJS[cipher].encrypt(plaintext, passphrase).toString();\n};\nvar decrypt = (ciphertext, passphrase, cipher = \"AES\") => {\n  assert(typeof ciphertext === \"string\");\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  const bytes = CryptoJS[cipher].decrypt(ciphertext, passphrase);\n  return bytes.toString(CryptoJS.enc.Utf8);\n};\n\n// packages/common/crypto/src/hash.ts\nimport CryptoJS2 from \"crypto-js\";\nimport assert2 from \"@dxos/node-std/assert\";\nvar _hash = (algorithm, plaintext) => {\n  assert2(typeof algorithm === \"string\");\n  assert2(typeof plaintext === \"string\");\n  return CryptoJS2[algorithm](plaintext).toString();\n};\nvar sha1 = (text) => _hash(\"SHA1\", text);\nvar sha256 = (text) => _hash(\"SHA256\", text);\nvar sha512 = (text) => _hash(\"SHA512\", text);\nvar ripemd160 = (text) => _hash(\"RIPEMD160\", text);\n\n// packages/common/crypto/src/keys.ts\nimport crypto2 from \"hypercore-crypto\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH } from \"@dxos/keys\";\nvar createId = () => PublicKey.stringify(randomBytes(32));\nvar SIGNATURE_LENGTH = 64;\nvar zeroKey = () => new Uint8Array(32);\nvar createKeyPair = (seed) => {\n  if (seed) {\n    assert3(seed.length >= 32, \"Seedphrase too sort. Expecting length of 32.\");\n    return crypto2.keyPair(seed.slice(0, 32));\n  }\n  return crypto2.keyPair();\n};\nvar validateKeyPair = (publicKey, secretKey) => crypto2.validateKeyPair({\n  publicKey: publicKey.asBuffer(),\n  secretKey\n});\nvar discoveryKey = (key) => crypto2.discoveryKey(PublicKey.from(key).asBuffer().slice(1));\nvar randomBytes = (length = 32) => crypto2.randomBytes(length);\nvar sign = (message, secretKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH);\n  return crypto2.sign(message, secretKey);\n};\nvar verify = (message, signature, publicKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH);\n  assert3(Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH);\n  return crypto2.verify(message, signature, publicKey);\n};\n\n// packages/common/crypto/src/browser/subtle.ts\nvar subtleCrypto = crypto.subtle;\n\n// packages/common/crypto/src/validator.ts\nimport { verify as verify2 } from \"hypercore-crypto\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar getSignatureValidator = (publicKey) => (message, signature) => verify2(message, signature, PublicKey2.bufferize(publicKey));\n\n// packages/common/crypto/src/verify.ts\nvar verifySignature = async (key, message, signature) => {\n  let publicKey;\n  try {\n    publicKey = await subtleCrypto.importKey(\"raw\", key.asUint8Array(), {\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"verify\"\n    ]);\n  } catch (e) {\n    return false;\n  }\n  return subtleCrypto.verify({\n    name: \"ECDSA\",\n    hash: \"SHA-256\"\n  }, publicKey, signature, message);\n};\nexport {\n  SIGNATURE_LENGTH,\n  createId,\n  createKeyPair,\n  decrypt,\n  discoveryKey,\n  encrypt,\n  getSignatureValidator,\n  randomBytes,\n  ripemd160,\n  sha1,\n  sha256,\n  sha512,\n  sign,\n  subtleCrypto,\n  validateKeyPair,\n  verify,\n  verifySignature,\n  zeroKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466939,"end":1670465466988},{"name":"vite:react-babel","result":"// packages/common/crypto/src/encrypt.ts\nimport CryptoJS from \"crypto-js\";\nimport assert from \"@dxos/node-std/assert\";\nvar encrypt = (plaintext, passphrase, cipher = \"AES\") => {\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  return CryptoJS[cipher].encrypt(plaintext, passphrase).toString();\n};\nvar decrypt = (ciphertext, passphrase, cipher = \"AES\") => {\n  assert(typeof ciphertext === \"string\");\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  const bytes = CryptoJS[cipher].decrypt(ciphertext, passphrase);\n  return bytes.toString(CryptoJS.enc.Utf8);\n};\n\n// packages/common/crypto/src/hash.ts\nimport CryptoJS2 from \"crypto-js\";\nimport assert2 from \"@dxos/node-std/assert\";\nvar _hash = (algorithm, plaintext) => {\n  assert2(typeof algorithm === \"string\");\n  assert2(typeof plaintext === \"string\");\n  return CryptoJS2[algorithm](plaintext).toString();\n};\nvar sha1 = (text) => _hash(\"SHA1\", text);\nvar sha256 = (text) => _hash(\"SHA256\", text);\nvar sha512 = (text) => _hash(\"SHA512\", text);\nvar ripemd160 = (text) => _hash(\"RIPEMD160\", text);\n\n// packages/common/crypto/src/keys.ts\nimport crypto2 from \"hypercore-crypto\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH } from \"@dxos/keys\";\nvar createId = () => PublicKey.stringify(randomBytes(32));\nvar SIGNATURE_LENGTH = 64;\nvar zeroKey = () => new Uint8Array(32);\nvar createKeyPair = (seed) => {\n  if (seed) {\n    assert3(seed.length >= 32, \"Seedphrase too sort. Expecting length of 32.\");\n    return crypto2.keyPair(seed.slice(0, 32));\n  }\n  return crypto2.keyPair();\n};\nvar validateKeyPair = (publicKey, secretKey) => crypto2.validateKeyPair({\n  publicKey: publicKey.asBuffer(),\n  secretKey\n});\nvar discoveryKey = (key) => crypto2.discoveryKey(PublicKey.from(key).asBuffer().slice(1));\nvar randomBytes = (length = 32) => crypto2.randomBytes(length);\nvar sign = (message, secretKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH);\n  return crypto2.sign(message, secretKey);\n};\nvar verify = (message, signature, publicKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH);\n  assert3(Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH);\n  return crypto2.verify(message, signature, publicKey);\n};\n\n// packages/common/crypto/src/browser/subtle.ts\nvar subtleCrypto = crypto.subtle;\n\n// packages/common/crypto/src/validator.ts\nimport { verify as verify2 } from \"hypercore-crypto\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar getSignatureValidator = (publicKey) => (message, signature) => verify2(message, signature, PublicKey2.bufferize(publicKey));\n\n// packages/common/crypto/src/verify.ts\nvar verifySignature = async (key, message, signature) => {\n  let publicKey;\n  try {\n    publicKey = await subtleCrypto.importKey(\"raw\", key.asUint8Array(), {\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"verify\"\n    ]);\n  } catch (e) {\n    return false;\n  }\n  return subtleCrypto.verify({\n    name: \"ECDSA\",\n    hash: \"SHA-256\"\n  }, publicKey, signature, message);\n};\nexport {\n  SIGNATURE_LENGTH,\n  createId,\n  createKeyPair,\n  decrypt,\n  discoveryKey,\n  encrypt,\n  getSignatureValidator,\n  randomBytes,\n  ripemd160,\n  sha1,\n  sha256,\n  sha512,\n  sign,\n  subtleCrypto,\n  validateKeyPair,\n  verify,\n  verifySignature,\n  zeroKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466988,"end":1670465466988,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/crypto/src/encrypt.ts\nimport CryptoJS from \"crypto-js\";\nimport assert from \"@dxos/node-std/assert\";\nvar encrypt = (plaintext, passphrase, cipher = \"AES\") => {\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  return CryptoJS[cipher].encrypt(plaintext, passphrase).toString();\n};\nvar decrypt = (ciphertext, passphrase, cipher = \"AES\") => {\n  assert(typeof ciphertext === \"string\");\n  assert(typeof passphrase === \"string\");\n  assert(typeof cipher === \"string\");\n  const bytes = CryptoJS[cipher].decrypt(ciphertext, passphrase);\n  return bytes.toString(CryptoJS.enc.Utf8);\n};\n\n// packages/common/crypto/src/hash.ts\nimport CryptoJS2 from \"crypto-js\";\nimport assert2 from \"@dxos/node-std/assert\";\nvar _hash = (algorithm, plaintext) => {\n  assert2(typeof algorithm === \"string\");\n  assert2(typeof plaintext === \"string\");\n  return CryptoJS2[algorithm](plaintext).toString();\n};\nvar sha1 = (text) => _hash(\"SHA1\", text);\nvar sha256 = (text) => _hash(\"SHA256\", text);\nvar sha512 = (text) => _hash(\"SHA512\", text);\nvar ripemd160 = (text) => _hash(\"RIPEMD160\", text);\n\n// packages/common/crypto/src/keys.ts\nimport crypto2 from \"hypercore-crypto\";\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH } from \"@dxos/keys\";\nvar createId = () => PublicKey.stringify(randomBytes(32));\nvar SIGNATURE_LENGTH = 64;\nvar zeroKey = () => new Uint8Array(32);\nvar createKeyPair = (seed) => {\n  if (seed) {\n    assert3(seed.length >= 32, \"Seedphrase too sort. Expecting length of 32.\");\n    return crypto2.keyPair(seed.slice(0, 32));\n  }\n  return crypto2.keyPair();\n};\nvar validateKeyPair = (publicKey, secretKey) => crypto2.validateKeyPair({\n  publicKey: publicKey.asBuffer(),\n  secretKey\n});\nvar discoveryKey = (key) => crypto2.discoveryKey(PublicKey.from(key).asBuffer().slice(1));\nvar randomBytes = (length = 32) => crypto2.randomBytes(length);\nvar sign = (message, secretKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(secretKey) && secretKey.length === SECRET_KEY_LENGTH);\n  return crypto2.sign(message, secretKey);\n};\nvar verify = (message, signature, publicKey) => {\n  assert3(Buffer.isBuffer(message));\n  assert3(Buffer.isBuffer(signature) && signature.length === SIGNATURE_LENGTH);\n  assert3(Buffer.isBuffer(publicKey) && publicKey.length === PUBLIC_KEY_LENGTH);\n  return crypto2.verify(message, signature, publicKey);\n};\n\n// packages/common/crypto/src/browser/subtle.ts\nvar subtleCrypto = crypto.subtle;\n\n// packages/common/crypto/src/validator.ts\nimport { verify as verify2 } from \"hypercore-crypto\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nvar getSignatureValidator = (publicKey) => (message, signature) => verify2(message, signature, PublicKey2.bufferize(publicKey));\n\n// packages/common/crypto/src/verify.ts\nvar verifySignature = async (key, message, signature) => {\n  let publicKey;\n  try {\n    publicKey = await subtleCrypto.importKey(\"raw\", key.asUint8Array(), {\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"verify\"\n    ]);\n  } catch (e) {\n    return false;\n  }\n  return subtleCrypto.verify({\n    name: \"ECDSA\",\n    hash: \"SHA-256\"\n  }, publicKey, signature, message);\n};\nexport {\n  SIGNATURE_LENGTH,\n  createId,\n  createKeyPair,\n  decrypt,\n  discoveryKey,\n  encrypt,\n  getSignatureValidator,\n  randomBytes,\n  ripemd160,\n  sha1,\n  sha256,\n  sha512,\n  sign,\n  subtleCrypto,\n  validateKeyPair,\n  verify,\n  verifySignature,\n  zeroKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466988,"end":1670465466989,"order":"normal"}]}
