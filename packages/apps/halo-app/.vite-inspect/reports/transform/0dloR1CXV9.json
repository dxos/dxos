{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js","transforms":[{"name":"vite:load-fallback","result":"var varint = require('varint')\nvar svarint = require('signed-varint')\nvar b4a = require('b4a')\n\nexports.make = encoder\n\nexports.name = function (enc) {\n  var keys = Object.keys(exports)\n  for (var i = 0; i < keys.length; i++) {\n    if (exports[keys[i]] === enc) return keys[i]\n  }\n  return null\n}\n\nexports.skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset)\n      return offset + varint.decode.bytes\n\n    case 1:\n      return offset + 8\n\n    case 2:\n      var len = varint.decode(buffer, offset)\n      return offset + varint.decode.bytes + len\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported')\n\n    case 5:\n      return offset + 4\n  }\n\n  throw new Error('Unknown wire type: ' + type)\n}\n\nexports.bytes = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = bufferLength(val)\n\n    varint.encode(len, buffer, offset)\n    offset += varint.encode.bytes\n\n    if (b4a.isBuffer(val)) b4a.copy(val, buffer, offset)\n    else b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = buffer.subarray(offset, offset + len)\n    offset += val.length\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = bufferLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.string = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = b4a.byteLength(val)\n\n    varint.encode(len, buffer, offset, 'utf-8')\n    offset += varint.encode.bytes\n\n    b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = b4a.toString(buffer, 'utf-8', offset, offset + len)\n    offset += len\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = b4a.byteLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.bool = encoder(0,\n  function encode (val, buffer, offset) {\n    buffer[offset] = val ? 1 : 0\n    encode.bytes = 1\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var bool = buffer[offset] > 0\n    decode.bytes = 1\n    return bool\n  },\n  function encodingLength () {\n    return 1\n  }\n)\n\nexports.int32 = encoder(0,\n  function encode (val, buffer, offset) {\n    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n    encode.bytes = varint.encode.bytes\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    decode.bytes = varint.decode.bytes\n    return val > 2147483647 ? val - 4294967296 : val\n  },\n  function encodingLength (val) {\n    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n  }\n)\n\nexports.int64 = encoder(0,\n  function encode (val, buffer, offset) {\n    if (val < 0) {\n      var last = offset + 9\n      varint.encode(val * -1, buffer, offset)\n      offset += varint.encode.bytes - 1\n      buffer[offset] = buffer[offset] | 0x80\n      while (offset < last - 1) {\n        offset++\n        buffer[offset] = 0xff\n      }\n      buffer[last] = 0x01\n      encode.bytes = 10\n    } else {\n      varint.encode(val, buffer, offset)\n      encode.bytes = varint.encode.bytes\n    }\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    if (val >= Math.pow(2, 63)) {\n      var limit = 9\n      while (buffer[offset + limit - 1] === 0xff) limit--\n      limit = limit || 9\n      var subset = b4a.allocUnsafe(limit)\n      b4a.copy(buffer, subset, 0, offset, offset + limit)\n      subset[limit - 1] = subset[limit - 1] & 0x7f\n      val = -1 * varint.decode(subset, 0)\n      decode.bytes = 10\n    } else {\n      decode.bytes = varint.decode.bytes\n    }\n    return val\n  },\n  function encodingLength (val) {\n    return val < 0 ? 10 : varint.encodingLength(val)\n  }\n)\n\nexports.sint32 =\nexports.sint64 = encoder(0,\n  svarint.encode,\n  svarint.decode,\n  svarint.encodingLength\n)\n\nexports.uint32 =\nexports.uint64 =\nexports.enum =\nexports.varint = encoder(0,\n  varint.encode,\n  varint.decode,\n  varint.encodingLength\n)\n\n// we cannot represent these in javascript so we just use buffers\nexports.fixed64 =\nexports.sfixed64 = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.copy(val, buffer, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.subarray(offset, offset + 8)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.double = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.writeDoubleLE(buffer, val, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readDoubleLE(buffer, offset)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.fixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeUInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readUInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.sfixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.float = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeFloatLE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readFloatLE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nfunction encoder (type, encode, decode, encodingLength) {\n  encode.bytes = decode.bytes = 0\n\n  return {\n    type: type,\n    encode: encode,\n    decode: decode,\n    encodingLength: encodingLength\n  }\n}\n\nfunction bufferLength (val) {\n  return b4a.isBuffer(val) ? val.length : b4a.byteLength(val)\n}\n","start":1670465470837,"end":1670465470914},{"name":"vite:react-babel","result":"var varint = require('varint')\nvar svarint = require('signed-varint')\nvar b4a = require('b4a')\n\nexports.make = encoder\n\nexports.name = function (enc) {\n  var keys = Object.keys(exports)\n  for (var i = 0; i < keys.length; i++) {\n    if (exports[keys[i]] === enc) return keys[i]\n  }\n  return null\n}\n\nexports.skip = function (type, buffer, offset) {\n  switch (type) {\n    case 0:\n      varint.decode(buffer, offset)\n      return offset + varint.decode.bytes\n\n    case 1:\n      return offset + 8\n\n    case 2:\n      var len = varint.decode(buffer, offset)\n      return offset + varint.decode.bytes + len\n\n    case 3:\n    case 4:\n      throw new Error('Groups are not supported')\n\n    case 5:\n      return offset + 4\n  }\n\n  throw new Error('Unknown wire type: ' + type)\n}\n\nexports.bytes = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = bufferLength(val)\n\n    varint.encode(len, buffer, offset)\n    offset += varint.encode.bytes\n\n    if (b4a.isBuffer(val)) b4a.copy(val, buffer, offset)\n    else b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = buffer.subarray(offset, offset + len)\n    offset += val.length\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = bufferLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.string = encoder(2,\n  function encode (val, buffer, offset) {\n    var oldOffset = offset\n    var len = b4a.byteLength(val)\n\n    varint.encode(len, buffer, offset, 'utf-8')\n    offset += varint.encode.bytes\n\n    b4a.write(buffer, val, offset, len)\n    offset += len\n\n    encode.bytes = offset - oldOffset\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var oldOffset = offset\n\n    var len = varint.decode(buffer, offset)\n    offset += varint.decode.bytes\n\n    var val = b4a.toString(buffer, 'utf-8', offset, offset + len)\n    offset += len\n\n    decode.bytes = offset - oldOffset\n    return val\n  },\n  function encodingLength (val) {\n    var len = b4a.byteLength(val)\n    return varint.encodingLength(len) + len\n  }\n)\n\nexports.bool = encoder(0,\n  function encode (val, buffer, offset) {\n    buffer[offset] = val ? 1 : 0\n    encode.bytes = 1\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var bool = buffer[offset] > 0\n    decode.bytes = 1\n    return bool\n  },\n  function encodingLength () {\n    return 1\n  }\n)\n\nexports.int32 = encoder(0,\n  function encode (val, buffer, offset) {\n    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n    encode.bytes = varint.encode.bytes\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    decode.bytes = varint.decode.bytes\n    return val > 2147483647 ? val - 4294967296 : val\n  },\n  function encodingLength (val) {\n    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n  }\n)\n\nexports.int64 = encoder(0,\n  function encode (val, buffer, offset) {\n    if (val < 0) {\n      var last = offset + 9\n      varint.encode(val * -1, buffer, offset)\n      offset += varint.encode.bytes - 1\n      buffer[offset] = buffer[offset] | 0x80\n      while (offset < last - 1) {\n        offset++\n        buffer[offset] = 0xff\n      }\n      buffer[last] = 0x01\n      encode.bytes = 10\n    } else {\n      varint.encode(val, buffer, offset)\n      encode.bytes = varint.encode.bytes\n    }\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = varint.decode(buffer, offset)\n    if (val >= Math.pow(2, 63)) {\n      var limit = 9\n      while (buffer[offset + limit - 1] === 0xff) limit--\n      limit = limit || 9\n      var subset = b4a.allocUnsafe(limit)\n      b4a.copy(buffer, subset, 0, offset, offset + limit)\n      subset[limit - 1] = subset[limit - 1] & 0x7f\n      val = -1 * varint.decode(subset, 0)\n      decode.bytes = 10\n    } else {\n      decode.bytes = varint.decode.bytes\n    }\n    return val\n  },\n  function encodingLength (val) {\n    return val < 0 ? 10 : varint.encodingLength(val)\n  }\n)\n\nexports.sint32 =\nexports.sint64 = encoder(0,\n  svarint.encode,\n  svarint.decode,\n  svarint.encodingLength\n)\n\nexports.uint32 =\nexports.uint64 =\nexports.enum =\nexports.varint = encoder(0,\n  varint.encode,\n  varint.decode,\n  varint.encodingLength\n)\n\n// we cannot represent these in javascript so we just use buffers\nexports.fixed64 =\nexports.sfixed64 = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.copy(val, buffer, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = buffer.subarray(offset, offset + 8)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.double = encoder(1,\n  function encode (val, buffer, offset) {\n    b4a.writeDoubleLE(buffer, val, offset)\n    encode.bytes = 8\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readDoubleLE(buffer, offset)\n    decode.bytes = 8\n    return val\n  },\n  function encodingLength () {\n    return 8\n  }\n)\n\nexports.fixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeUInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readUInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.sfixed32 = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeInt32LE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readInt32LE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nexports.float = encoder(5,\n  function encode (val, buffer, offset) {\n    b4a.writeFloatLE(buffer, val, offset)\n    encode.bytes = 4\n    return buffer\n  },\n  function decode (buffer, offset) {\n    var val = b4a.readFloatLE(buffer, offset)\n    decode.bytes = 4\n    return val\n  },\n  function encodingLength () {\n    return 4\n  }\n)\n\nfunction encoder (type, encode, decode, encodingLength) {\n  encode.bytes = decode.bytes = 0\n\n  return {\n    type: type,\n    encode: encode,\n    decode: decode,\n    encodingLength: encodingLength\n  }\n}\n\nfunction bufferLength (val) {\n  return b4a.isBuffer(val) ? val.length : b4a.byteLength(val)\n}\n","start":1670465470915,"end":1670465470915,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as protocolBuffersEncodings } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-proxy\";\n\n(function (exports) {\n\tvar varint = require$$0\n\tvar svarint = require$$1\n\tvar b4a = require$$2\n\n\texports.make = encoder\n\n\texports.name = function (enc) {\n\t  var keys = Object.keys(exports)\n\t  for (var i = 0; i < keys.length; i++) {\n\t    if (exports[keys[i]] === enc) return keys[i]\n\t  }\n\t  return null\n\t}\n\n\texports.skip = function (type, buffer, offset) {\n\t  switch (type) {\n\t    case 0:\n\t      varint.decode(buffer, offset)\n\t      return offset + varint.decode.bytes\n\n\t    case 1:\n\t      return offset + 8\n\n\t    case 2:\n\t      var len = varint.decode(buffer, offset)\n\t      return offset + varint.decode.bytes + len\n\n\t    case 3:\n\t    case 4:\n\t      throw new Error('Groups are not supported')\n\n\t    case 5:\n\t      return offset + 4\n\t  }\n\n\t  throw new Error('Unknown wire type: ' + type)\n\t}\n\n\texports.bytes = encoder(2,\n\t  function encode (val, buffer, offset) {\n\t    var oldOffset = offset\n\t    var len = bufferLength(val)\n\n\t    varint.encode(len, buffer, offset)\n\t    offset += varint.encode.bytes\n\n\t    if (b4a.isBuffer(val)) b4a.copy(val, buffer, offset)\n\t    else b4a.write(buffer, val, offset, len)\n\t    offset += len\n\n\t    encode.bytes = offset - oldOffset\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var oldOffset = offset\n\n\t    var len = varint.decode(buffer, offset)\n\t    offset += varint.decode.bytes\n\n\t    var val = buffer.subarray(offset, offset + len)\n\t    offset += val.length\n\n\t    decode.bytes = offset - oldOffset\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    var len = bufferLength(val)\n\t    return varint.encodingLength(len) + len\n\t  }\n\t)\n\n\texports.string = encoder(2,\n\t  function encode (val, buffer, offset) {\n\t    var oldOffset = offset\n\t    var len = b4a.byteLength(val)\n\n\t    varint.encode(len, buffer, offset, 'utf-8')\n\t    offset += varint.encode.bytes\n\n\t    b4a.write(buffer, val, offset, len)\n\t    offset += len\n\n\t    encode.bytes = offset - oldOffset\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var oldOffset = offset\n\n\t    var len = varint.decode(buffer, offset)\n\t    offset += varint.decode.bytes\n\n\t    var val = b4a.toString(buffer, 'utf-8', offset, offset + len)\n\t    offset += len\n\n\t    decode.bytes = offset - oldOffset\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    var len = b4a.byteLength(val)\n\t    return varint.encodingLength(len) + len\n\t  }\n\t)\n\n\texports.bool = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    buffer[offset] = val ? 1 : 0\n\t    encode.bytes = 1\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var bool = buffer[offset] > 0\n\t    decode.bytes = 1\n\t    return bool\n\t  },\n\t  function encodingLength () {\n\t    return 1\n\t  }\n\t)\n\n\texports.int32 = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n\t    encode.bytes = varint.encode.bytes\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = varint.decode(buffer, offset)\n\t    decode.bytes = varint.decode.bytes\n\t    return val > 2147483647 ? val - 4294967296 : val\n\t  },\n\t  function encodingLength (val) {\n\t    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n\t  }\n\t)\n\n\texports.int64 = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    if (val < 0) {\n\t      var last = offset + 9\n\t      varint.encode(val * -1, buffer, offset)\n\t      offset += varint.encode.bytes - 1\n\t      buffer[offset] = buffer[offset] | 0x80\n\t      while (offset < last - 1) {\n\t        offset++\n\t        buffer[offset] = 0xff\n\t      }\n\t      buffer[last] = 0x01\n\t      encode.bytes = 10\n\t    } else {\n\t      varint.encode(val, buffer, offset)\n\t      encode.bytes = varint.encode.bytes\n\t    }\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = varint.decode(buffer, offset)\n\t    if (val >= Math.pow(2, 63)) {\n\t      var limit = 9\n\t      while (buffer[offset + limit - 1] === 0xff) limit--\n\t      limit = limit || 9\n\t      var subset = b4a.allocUnsafe(limit)\n\t      b4a.copy(buffer, subset, 0, offset, offset + limit)\n\t      subset[limit - 1] = subset[limit - 1] & 0x7f\n\t      val = -1 * varint.decode(subset, 0)\n\t      decode.bytes = 10\n\t    } else {\n\t      decode.bytes = varint.decode.bytes\n\t    }\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    return val < 0 ? 10 : varint.encodingLength(val)\n\t  }\n\t)\n\n\texports.sint32 =\n\texports.sint64 = encoder(0,\n\t  svarint.encode,\n\t  svarint.decode,\n\t  svarint.encodingLength\n\t)\n\n\texports.uint32 =\n\texports.uint64 =\n\texports.enum =\n\texports.varint = encoder(0,\n\t  varint.encode,\n\t  varint.decode,\n\t  varint.encodingLength\n\t)\n\n\t// we cannot represent these in javascript so we just use buffers\n\texports.fixed64 =\n\texports.sfixed64 = encoder(1,\n\t  function encode (val, buffer, offset) {\n\t    b4a.copy(val, buffer, offset)\n\t    encode.bytes = 8\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = buffer.subarray(offset, offset + 8)\n\t    decode.bytes = 8\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 8\n\t  }\n\t)\n\n\texports.double = encoder(1,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeDoubleLE(buffer, val, offset)\n\t    encode.bytes = 8\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readDoubleLE(buffer, offset)\n\t    decode.bytes = 8\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 8\n\t  }\n\t)\n\n\texports.fixed32 = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeUInt32LE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readUInt32LE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\texports.sfixed32 = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeInt32LE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readInt32LE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\texports.float = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeFloatLE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readFloatLE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\tfunction encoder (type, encode, decode, encodingLength) {\n\t  encode.bytes = decode.bytes = 0\n\n\t  return {\n\t    type: type,\n\t    encode: encode,\n\t    decode: decode,\n\t    encodingLength: encodingLength\n\t  }\n\t}\n\n\tfunction bufferLength (val) {\n\t  return b4a.isBuffer(val) ? val.length : b4a.byteLength(val)\n\t}\n} (protocolBuffersEncodings));\n\nexport default protocolBuffersEncodings;\nexport { protocolBuffersEncodings as __moduleExports };","start":1670465470915,"end":1670465471625,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as protocolBuffersEncodings } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.0/node_modules/varint/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/signed-varint@2.0.1/node_modules/signed-varint/index.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-proxy\";\n\n(function (exports) {\n\tvar varint = require$$0\n\tvar svarint = require$$1\n\tvar b4a = require$$2\n\n\texports.make = encoder\n\n\texports.name = function (enc) {\n\t  var keys = Object.keys(exports)\n\t  for (var i = 0; i < keys.length; i++) {\n\t    if (exports[keys[i]] === enc) return keys[i]\n\t  }\n\t  return null\n\t}\n\n\texports.skip = function (type, buffer, offset) {\n\t  switch (type) {\n\t    case 0:\n\t      varint.decode(buffer, offset)\n\t      return offset + varint.decode.bytes\n\n\t    case 1:\n\t      return offset + 8\n\n\t    case 2:\n\t      var len = varint.decode(buffer, offset)\n\t      return offset + varint.decode.bytes + len\n\n\t    case 3:\n\t    case 4:\n\t      throw new Error('Groups are not supported')\n\n\t    case 5:\n\t      return offset + 4\n\t  }\n\n\t  throw new Error('Unknown wire type: ' + type)\n\t}\n\n\texports.bytes = encoder(2,\n\t  function encode (val, buffer, offset) {\n\t    var oldOffset = offset\n\t    var len = bufferLength(val)\n\n\t    varint.encode(len, buffer, offset)\n\t    offset += varint.encode.bytes\n\n\t    if (b4a.isBuffer(val)) b4a.copy(val, buffer, offset)\n\t    else b4a.write(buffer, val, offset, len)\n\t    offset += len\n\n\t    encode.bytes = offset - oldOffset\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var oldOffset = offset\n\n\t    var len = varint.decode(buffer, offset)\n\t    offset += varint.decode.bytes\n\n\t    var val = buffer.subarray(offset, offset + len)\n\t    offset += val.length\n\n\t    decode.bytes = offset - oldOffset\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    var len = bufferLength(val)\n\t    return varint.encodingLength(len) + len\n\t  }\n\t)\n\n\texports.string = encoder(2,\n\t  function encode (val, buffer, offset) {\n\t    var oldOffset = offset\n\t    var len = b4a.byteLength(val)\n\n\t    varint.encode(len, buffer, offset, 'utf-8')\n\t    offset += varint.encode.bytes\n\n\t    b4a.write(buffer, val, offset, len)\n\t    offset += len\n\n\t    encode.bytes = offset - oldOffset\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var oldOffset = offset\n\n\t    var len = varint.decode(buffer, offset)\n\t    offset += varint.decode.bytes\n\n\t    var val = b4a.toString(buffer, 'utf-8', offset, offset + len)\n\t    offset += len\n\n\t    decode.bytes = offset - oldOffset\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    var len = b4a.byteLength(val)\n\t    return varint.encodingLength(len) + len\n\t  }\n\t)\n\n\texports.bool = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    buffer[offset] = val ? 1 : 0\n\t    encode.bytes = 1\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var bool = buffer[offset] > 0\n\t    decode.bytes = 1\n\t    return bool\n\t  },\n\t  function encodingLength () {\n\t    return 1\n\t  }\n\t)\n\n\texports.int32 = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)\n\t    encode.bytes = varint.encode.bytes\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = varint.decode(buffer, offset)\n\t    decode.bytes = varint.decode.bytes\n\t    return val > 2147483647 ? val - 4294967296 : val\n\t  },\n\t  function encodingLength (val) {\n\t    return varint.encodingLength(val < 0 ? val + 4294967296 : val)\n\t  }\n\t)\n\n\texports.int64 = encoder(0,\n\t  function encode (val, buffer, offset) {\n\t    if (val < 0) {\n\t      var last = offset + 9\n\t      varint.encode(val * -1, buffer, offset)\n\t      offset += varint.encode.bytes - 1\n\t      buffer[offset] = buffer[offset] | 0x80\n\t      while (offset < last - 1) {\n\t        offset++\n\t        buffer[offset] = 0xff\n\t      }\n\t      buffer[last] = 0x01\n\t      encode.bytes = 10\n\t    } else {\n\t      varint.encode(val, buffer, offset)\n\t      encode.bytes = varint.encode.bytes\n\t    }\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = varint.decode(buffer, offset)\n\t    if (val >= Math.pow(2, 63)) {\n\t      var limit = 9\n\t      while (buffer[offset + limit - 1] === 0xff) limit--\n\t      limit = limit || 9\n\t      var subset = b4a.allocUnsafe(limit)\n\t      b4a.copy(buffer, subset, 0, offset, offset + limit)\n\t      subset[limit - 1] = subset[limit - 1] & 0x7f\n\t      val = -1 * varint.decode(subset, 0)\n\t      decode.bytes = 10\n\t    } else {\n\t      decode.bytes = varint.decode.bytes\n\t    }\n\t    return val\n\t  },\n\t  function encodingLength (val) {\n\t    return val < 0 ? 10 : varint.encodingLength(val)\n\t  }\n\t)\n\n\texports.sint32 =\n\texports.sint64 = encoder(0,\n\t  svarint.encode,\n\t  svarint.decode,\n\t  svarint.encodingLength\n\t)\n\n\texports.uint32 =\n\texports.uint64 =\n\texports.enum =\n\texports.varint = encoder(0,\n\t  varint.encode,\n\t  varint.decode,\n\t  varint.encodingLength\n\t)\n\n\t// we cannot represent these in javascript so we just use buffers\n\texports.fixed64 =\n\texports.sfixed64 = encoder(1,\n\t  function encode (val, buffer, offset) {\n\t    b4a.copy(val, buffer, offset)\n\t    encode.bytes = 8\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = buffer.subarray(offset, offset + 8)\n\t    decode.bytes = 8\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 8\n\t  }\n\t)\n\n\texports.double = encoder(1,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeDoubleLE(buffer, val, offset)\n\t    encode.bytes = 8\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readDoubleLE(buffer, offset)\n\t    decode.bytes = 8\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 8\n\t  }\n\t)\n\n\texports.fixed32 = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeUInt32LE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readUInt32LE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\texports.sfixed32 = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeInt32LE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readInt32LE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\texports.float = encoder(5,\n\t  function encode (val, buffer, offset) {\n\t    b4a.writeFloatLE(buffer, val, offset)\n\t    encode.bytes = 4\n\t    return buffer\n\t  },\n\t  function decode (buffer, offset) {\n\t    var val = b4a.readFloatLE(buffer, offset)\n\t    decode.bytes = 4\n\t    return val\n\t  },\n\t  function encodingLength () {\n\t    return 4\n\t  }\n\t)\n\n\tfunction encoder (type, encode, decode, encodingLength) {\n\t  encode.bytes = decode.bytes = 0\n\n\t  return {\n\t    type: type,\n\t    encode: encode,\n\t    decode: decode,\n\t    encodingLength: encodingLength\n\t  }\n\t}\n\n\tfunction bufferLength (val) {\n\t  return b4a.isBuffer(val) ? val.length : b4a.byteLength(val)\n\t}\n} (protocolBuffersEncodings));\n\nexport default protocolBuffersEncodings;\nexport { protocolBuffersEncodings as __moduleExports };","start":1670465471625,"end":1670465471627,"order":"normal"}]}
