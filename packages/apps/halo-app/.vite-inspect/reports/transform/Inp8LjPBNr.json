{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/halo/credentials/src/invitations.ts\nvar defaultSecretProvider = async () => Buffer.from(\"0000\");\nvar defaultSecretValidator = async (invitation, secret) => true;\n\n// packages/core/halo/credentials/src/seedphrase.ts\nimport { generateMnemonic, mnemonicToSeedSync } from \"bip39\";\nimport assert from \"@dxos/node-std/assert\";\nimport { createKeyPair } from \"@dxos/crypto\";\nvar generateSeedPhrase = () => generateMnemonic();\nvar keyPairFromSeedPhrase = (seedPhrase) => {\n  assert(seedPhrase);\n  const seed = mnemonicToSeedSync(seedPhrase);\n  return createKeyPair(seed);\n};\n\n// packages/core/halo/credentials/src/passcode.ts\nvar generatePasscode = (length = 4) => {\n  let passcode = \"\";\n  for (let i = 0; i < length; i++) {\n    passcode += `${Math.floor(Math.random() * 10)}`;\n  }\n  return passcode;\n};\n\n// packages/core/halo/credentials/src/credentials/assertions.ts\nvar getCredentialAssertion = (credential) => credential.subject.assertion;\nvar isValidAuthorizedDeviceCredential = (credential, identityKey, deviceKey) => {\n  const assertion = getCredentialAssertion(credential);\n  return credential.subject.id.equals(deviceKey) && credential.issuer.equals(identityKey) && assertion[\"@type\"] === \"dxos.halo.credentials.AuthorizedDevice\" && assertion.identityKey.equals(identityKey) && assertion.deviceKey.equals(deviceKey);\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nimport assert2 from \"@dxos/node-std/assert\";\n\n// packages/core/halo/credentials/src/credentials/signing.ts\nimport stableStringify from \"json-stable-stringify\";\nimport { PublicKey } from \"@dxos/keys\";\nvar getSignaturePayload = (credential) => {\n  const copy = {\n    ...credential,\n    proof: {\n      ...credential.proof,\n      value: new Uint8Array(),\n      chain: void 0\n    }\n  };\n  return Buffer.from(canonicalStringify(copy));\n};\nvar canonicalStringify = (obj) => stableStringify(obj, {\n  replacer: (key, value) => {\n    if (key.toString().startsWith(\"__\") || key.toString() === \"@type\") {\n      return void 0;\n    }\n    if (value) {\n      if (PublicKey.isPublicKey(value)) {\n        return value.toHex();\n      }\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"hex\");\n      }\n      if (value instanceof Uint8Array || value.data && value.type === \"Buffer\") {\n        return Buffer.from(value).toString(\"hex\");\n      }\n    }\n    return value;\n  }\n});\n\n// packages/core/halo/credentials/src/credentials/verifier.ts\nimport { verifySignature } from \"@dxos/crypto\";\nvar SIGNATURE_TYPE_ED25519 = \"ED25519Signature\";\nvar verifyCredential = async (credential) => {\n  if (!credential.issuer.equals(credential.proof.signer)) {\n    if (!credential.proof.chain) {\n      return {\n        kind: \"fail\",\n        errors: [\n          \"Delegated credential is missing credential chain.\"\n        ]\n      };\n    }\n    const result = await verifyChain(credential.proof.chain, credential.issuer, credential.proof.signer);\n    if (result.kind === \"fail\") {\n      return result;\n    }\n  }\n  const result1 = await verifyCredentialSignature(credential);\n  if (result1.kind === \"fail\") {\n    return result1;\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyCredentialSignature = async (credential) => {\n  if (credential.proof.type !== SIGNATURE_TYPE_ED25519) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid signature type: ${credential.proof.type}`\n      ]\n    };\n  }\n  const signData = getSignaturePayload(credential);\n  if (!await verifySignature(credential.proof.signer, signData, credential.proof.value)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        \"Invalid signature\"\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyChain = async (chain, authority, subject) => {\n  const result = await verifyCredential(chain.credential);\n  if (result.kind === \"fail\") {\n    return result;\n  }\n  if (!isValidAuthorizedDeviceCredential(chain.credential, authority, subject)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid credential chain: invalid assertion for key: ${subject}`\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nvar createCredential = async ({ signer, issuer, subject, assertion, signingKey, chain, nonce }) => {\n  assert2(assertion[\"@type\"], \"Invalid assertion.\");\n  assert2(!!signingKey === !!chain, \"Chain must be provided if and only if the signing key differs from the issuer.\");\n  if (chain) {\n    const result = await verifyChain(chain, issuer, signingKey);\n    assert2(result.kind === \"pass\", \"Invalid chain.\");\n  }\n  const credential = {\n    issuer,\n    issuanceDate: new Date(),\n    subject: {\n      id: subject,\n      assertion\n    },\n    proof: {\n      type: SIGNATURE_TYPE_ED25519,\n      creationDate: new Date(),\n      signer: signingKey != null ? signingKey : issuer,\n      value: new Uint8Array(),\n      nonce\n    }\n  };\n  const signedPayload = getSignaturePayload(credential);\n  credential.proof.value = await signer.sign(signingKey != null ? signingKey : issuer, signedPayload);\n  if (chain) {\n    credential.proof.chain = chain;\n  }\n  return credential;\n};\nvar createCredentialMessage = (credential) => {\n  return {\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  };\n};\nvar createCredentialSignerWithKey = (signer, issuer) => ({\n  getIssuer: () => issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer,\n    subject,\n    assertion,\n    nonce\n  })\n});\nvar createCredentialSignerWithChain = (signer, chain, signingKey) => ({\n  getIssuer: () => chain.credential.issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer: chain.credential.issuer,\n    signingKey,\n    chain,\n    subject,\n    assertion,\n    nonce\n  })\n});\n\n// packages/core/halo/credentials/src/credentials/credential-generator.ts\nimport { AdmittedFeed, SpaceMember } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar CredentialGenerator = class {\n  constructor(_signer, _identityKey, _deviceKey) {\n    this._signer = _signer;\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n  }\n  async createSpaceGenesis(spaceKey, controlKey, creatorProfile) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: spaceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceGenesis\",\n          spaceKey\n        }\n      }),\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: this._identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.ADMIN,\n          profile: creatorProfile\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL)\n    ];\n  }\n  async createMemberInvitation(spaceKey, identityKey, deviceKey, controlKey, dataKey) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: this._identityKey,\n        subject: identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.MEMBER\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL),\n      await this.createFeedAdmission(spaceKey, dataKey, AdmittedFeed.Designation.DATA)\n    ];\n  }\n  async createDeviceAuthorization(deviceKey) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey: this._identityKey,\n        deviceKey\n      }\n    });\n  }\n  async createFeedAdmission(spaceKey, feedKey, designation) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: feedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        identityKey: this._identityKey,\n        deviceKey: this._deviceKey,\n        designation\n      }\n    });\n  }\n  async createProfileCredential(profile) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: this._identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.IdentityProfile\",\n        profile\n      }\n    });\n  }\n};\nvar createDeviceAuthorization = async (signer, identityKey, deviceKey) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey,\n        deviceKey\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\nvar createAdmissionCredentials = async (signer, identityKey, deviceKey, spaceKey, controlFeedKey, dataFeedKey, profile) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.SpaceMember\",\n        spaceKey,\n        role: SpaceMember.Role.ADMIN,\n        profile\n      }\n    }),\n    await signer.createCredential({\n      subject: controlFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.CONTROL\n      }\n    }),\n    await signer.createCredential({\n      subject: dataFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.DATA\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nimport { log as log2 } from \"@dxos/log\";\nimport { SpaceMember as SpaceMember2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback as Callback3 } from \"@dxos/util\";\n\n// packages/core/halo/credentials/src/state-machine/feed-state-machine.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { Callback, ComplexMap } from \"@dxos/util\";\nvar FeedStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._feeds = new ComplexMap(PublicKey2.hash);\n    this.onFeedAdmitted = new Callback();\n  }\n  get feeds() {\n    return this._feeds;\n  }\n  async process(credential, fromFeed) {\n    const assertion = getCredentialAssertion(credential);\n    assert3(assertion[\"@type\"] === \"dxos.halo.credentials.AdmittedFeed\");\n    assert3(assertion.spaceKey.equals(this._spaceKey));\n    assert3(!this._feeds.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion,\n      parent: fromFeed\n    };\n    this._feeds.set(credential.subject.id, info);\n    await this.onFeedAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/member-state-machine.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { Callback as Callback2, ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MemberStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new ComplexMap2(PublicKey3.hash);\n    this.onMemberAdmitted = new Callback2();\n  }\n  get members() {\n    return this._members;\n  }\n  getRole(member) {\n    var _a;\n    return (_a = this._members.get(member)) == null ? void 0 : _a.assertion.role;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    assert4(assertion[\"@type\"] === \"dxos.halo.credentials.SpaceMember\");\n    assert4(assertion.spaceKey.equals(this._spaceKey));\n    assert4(!this._members.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion\n    };\n    this._members.set(credential.subject.id, info);\n    log(\"member added\", {\n      member: credential.subject.id,\n      space: this._spaceKey,\n      role: assertion.role,\n      profile: assertion.profile\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/member-state-machine.ts\",\n      line: 63,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.onMemberAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nvar SpaceStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new MemberStateMachine(this._spaceKey);\n    this._feeds = new FeedStateMachine(this._spaceKey);\n    this._credentials = [];\n    this.onCredentialProcessed = new Callback3();\n    this.onMemberAdmitted = this._members.onMemberAdmitted;\n    this.onFeedAdmitted = this._feeds.onFeedAdmitted;\n  }\n  get genesisCredential() {\n    return this._genesisCredential;\n  }\n  get members() {\n    return this._members.members;\n  }\n  get feeds() {\n    return this._feeds.feeds;\n  }\n  get credentials() {\n    return this._credentials;\n  }\n  async process(credential, fromFeed) {\n    const result = await verifyCredential(credential);\n    if (result.kind !== \"pass\") {\n      log2.warn(`Invalid credential: ${result.errors.join(\", \")}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return false;\n    }\n    switch (getCredentialAssertion(credential)[\"@type\"]) {\n      case \"dxos.halo.credentials.SpaceGenesis\":\n        if (this._genesisCredential) {\n          log2.warn(\"Space already has a genesis credential.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 70,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.issuer.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued by space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 74,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.subject.id.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued to space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 78,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        this._genesisCredential = credential;\n        break;\n      case \"dxos.halo.credentials.SpaceMember\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before adding members.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 85,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canInviteNewMembers(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to invite new members.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 89,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._members.process(credential);\n        break;\n      case \"dxos.halo.credentials.AdmittedFeed\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before admitting feeds.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 96,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canAdmitFeeds(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to admit feeds.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 100,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._feeds.process(credential, fromFeed);\n        break;\n    }\n    this._credentials.push(credential);\n    await this.onCredentialProcessed.callIfSet(credential);\n    return true;\n  }\n  _canInviteNewMembers(key) {\n    return key.equals(this._spaceKey) || this._members.getRole(key) === SpaceMember2.Role.ADMIN;\n  }\n  _canAdmitFeeds(key) {\n    const role = this._members.getRole(key);\n    return role === SpaceMember2.Role.MEMBER || role === SpaceMember2.Role.ADMIN;\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/device-state-machine.ts\nimport { Trigger } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nimport { ComplexSet } from \"@dxos/util\";\nvar DeviceStateMachine = class {\n  constructor(_identityKey, _deviceKey) {\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n    this.authorizedDeviceKeys = new ComplexSet(PublicKey4.hash);\n    this.deviceChainReady = new Trigger();\n  }\n  async process(credential) {\n    log3(\"processing credential...\", {\n      identityKey: this._identityKey,\n      deviceKey: this._deviceKey,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n      line: 30,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (isValidAuthorizedDeviceCredential(credential, this._identityKey, this._deviceKey)) {\n      this.deviceCredentialChain = {\n        credential\n      };\n      this.deviceChainReady.wake();\n    }\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.AuthorizedDevice\": {\n        this.authorizedDeviceKeys.add(assertion.deviceKey);\n        log3(\"added device\", {\n          localDeviceKey: this._deviceKey,\n          deviceKey: assertion.deviceKey,\n          size: this.authorizedDeviceKeys.size\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n          line: 43,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\nimport { log as log4 } from \"@dxos/log\";\nvar ProfileStateMachine = class {\n  constructor(_identityKey) {\n    this._identityKey = _identityKey;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.IdentityProfile\": {\n        if (!credential.issuer.equals(this._identityKey) || !credential.subject.id.equals(this._identityKey)) {\n          log4.warn(\"Invalid profile credential\", {\n            expectedIdentity: this._identityKey,\n            credential\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n            line: 28,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return;\n        }\n        this.profile = assertion.profile;\n        log4(\"updated profile\", {\n          identityKey: this._identityKey,\n          profile: this.profile\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n          line: 34,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\nexport {\n  CredentialGenerator,\n  DeviceStateMachine,\n  FeedStateMachine,\n  MemberStateMachine,\n  ProfileStateMachine,\n  SIGNATURE_TYPE_ED25519,\n  SpaceStateMachine,\n  canonicalStringify,\n  createAdmissionCredentials,\n  createCredential,\n  createCredentialMessage,\n  createCredentialSignerWithChain,\n  createCredentialSignerWithKey,\n  createDeviceAuthorization,\n  defaultSecretProvider,\n  defaultSecretValidator,\n  generatePasscode,\n  generateSeedPhrase,\n  getCredentialAssertion,\n  getSignaturePayload,\n  isValidAuthorizedDeviceCredential,\n  keyPairFromSeedPhrase,\n  verifyChain,\n  verifyCredential,\n  verifyCredentialSignature\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465322,"end":1670465465998},{"name":"vite:react-babel","result":"// packages/core/halo/credentials/src/invitations.ts\nvar defaultSecretProvider = async () => Buffer.from(\"0000\");\nvar defaultSecretValidator = async (invitation, secret) => true;\n\n// packages/core/halo/credentials/src/seedphrase.ts\nimport { generateMnemonic, mnemonicToSeedSync } from \"bip39\";\nimport assert from \"@dxos/node-std/assert\";\nimport { createKeyPair } from \"@dxos/crypto\";\nvar generateSeedPhrase = () => generateMnemonic();\nvar keyPairFromSeedPhrase = (seedPhrase) => {\n  assert(seedPhrase);\n  const seed = mnemonicToSeedSync(seedPhrase);\n  return createKeyPair(seed);\n};\n\n// packages/core/halo/credentials/src/passcode.ts\nvar generatePasscode = (length = 4) => {\n  let passcode = \"\";\n  for (let i = 0; i < length; i++) {\n    passcode += `${Math.floor(Math.random() * 10)}`;\n  }\n  return passcode;\n};\n\n// packages/core/halo/credentials/src/credentials/assertions.ts\nvar getCredentialAssertion = (credential) => credential.subject.assertion;\nvar isValidAuthorizedDeviceCredential = (credential, identityKey, deviceKey) => {\n  const assertion = getCredentialAssertion(credential);\n  return credential.subject.id.equals(deviceKey) && credential.issuer.equals(identityKey) && assertion[\"@type\"] === \"dxos.halo.credentials.AuthorizedDevice\" && assertion.identityKey.equals(identityKey) && assertion.deviceKey.equals(deviceKey);\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nimport assert2 from \"@dxos/node-std/assert\";\n\n// packages/core/halo/credentials/src/credentials/signing.ts\nimport stableStringify from \"json-stable-stringify\";\nimport { PublicKey } from \"@dxos/keys\";\nvar getSignaturePayload = (credential) => {\n  const copy = {\n    ...credential,\n    proof: {\n      ...credential.proof,\n      value: new Uint8Array(),\n      chain: void 0\n    }\n  };\n  return Buffer.from(canonicalStringify(copy));\n};\nvar canonicalStringify = (obj) => stableStringify(obj, {\n  replacer: (key, value) => {\n    if (key.toString().startsWith(\"__\") || key.toString() === \"@type\") {\n      return void 0;\n    }\n    if (value) {\n      if (PublicKey.isPublicKey(value)) {\n        return value.toHex();\n      }\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"hex\");\n      }\n      if (value instanceof Uint8Array || value.data && value.type === \"Buffer\") {\n        return Buffer.from(value).toString(\"hex\");\n      }\n    }\n    return value;\n  }\n});\n\n// packages/core/halo/credentials/src/credentials/verifier.ts\nimport { verifySignature } from \"@dxos/crypto\";\nvar SIGNATURE_TYPE_ED25519 = \"ED25519Signature\";\nvar verifyCredential = async (credential) => {\n  if (!credential.issuer.equals(credential.proof.signer)) {\n    if (!credential.proof.chain) {\n      return {\n        kind: \"fail\",\n        errors: [\n          \"Delegated credential is missing credential chain.\"\n        ]\n      };\n    }\n    const result = await verifyChain(credential.proof.chain, credential.issuer, credential.proof.signer);\n    if (result.kind === \"fail\") {\n      return result;\n    }\n  }\n  const result1 = await verifyCredentialSignature(credential);\n  if (result1.kind === \"fail\") {\n    return result1;\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyCredentialSignature = async (credential) => {\n  if (credential.proof.type !== SIGNATURE_TYPE_ED25519) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid signature type: ${credential.proof.type}`\n      ]\n    };\n  }\n  const signData = getSignaturePayload(credential);\n  if (!await verifySignature(credential.proof.signer, signData, credential.proof.value)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        \"Invalid signature\"\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyChain = async (chain, authority, subject) => {\n  const result = await verifyCredential(chain.credential);\n  if (result.kind === \"fail\") {\n    return result;\n  }\n  if (!isValidAuthorizedDeviceCredential(chain.credential, authority, subject)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid credential chain: invalid assertion for key: ${subject}`\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nvar createCredential = async ({ signer, issuer, subject, assertion, signingKey, chain, nonce }) => {\n  assert2(assertion[\"@type\"], \"Invalid assertion.\");\n  assert2(!!signingKey === !!chain, \"Chain must be provided if and only if the signing key differs from the issuer.\");\n  if (chain) {\n    const result = await verifyChain(chain, issuer, signingKey);\n    assert2(result.kind === \"pass\", \"Invalid chain.\");\n  }\n  const credential = {\n    issuer,\n    issuanceDate: new Date(),\n    subject: {\n      id: subject,\n      assertion\n    },\n    proof: {\n      type: SIGNATURE_TYPE_ED25519,\n      creationDate: new Date(),\n      signer: signingKey != null ? signingKey : issuer,\n      value: new Uint8Array(),\n      nonce\n    }\n  };\n  const signedPayload = getSignaturePayload(credential);\n  credential.proof.value = await signer.sign(signingKey != null ? signingKey : issuer, signedPayload);\n  if (chain) {\n    credential.proof.chain = chain;\n  }\n  return credential;\n};\nvar createCredentialMessage = (credential) => {\n  return {\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  };\n};\nvar createCredentialSignerWithKey = (signer, issuer) => ({\n  getIssuer: () => issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer,\n    subject,\n    assertion,\n    nonce\n  })\n});\nvar createCredentialSignerWithChain = (signer, chain, signingKey) => ({\n  getIssuer: () => chain.credential.issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer: chain.credential.issuer,\n    signingKey,\n    chain,\n    subject,\n    assertion,\n    nonce\n  })\n});\n\n// packages/core/halo/credentials/src/credentials/credential-generator.ts\nimport { AdmittedFeed, SpaceMember } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar CredentialGenerator = class {\n  constructor(_signer, _identityKey, _deviceKey) {\n    this._signer = _signer;\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n  }\n  async createSpaceGenesis(spaceKey, controlKey, creatorProfile) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: spaceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceGenesis\",\n          spaceKey\n        }\n      }),\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: this._identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.ADMIN,\n          profile: creatorProfile\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL)\n    ];\n  }\n  async createMemberInvitation(spaceKey, identityKey, deviceKey, controlKey, dataKey) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: this._identityKey,\n        subject: identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.MEMBER\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL),\n      await this.createFeedAdmission(spaceKey, dataKey, AdmittedFeed.Designation.DATA)\n    ];\n  }\n  async createDeviceAuthorization(deviceKey) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey: this._identityKey,\n        deviceKey\n      }\n    });\n  }\n  async createFeedAdmission(spaceKey, feedKey, designation) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: feedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        identityKey: this._identityKey,\n        deviceKey: this._deviceKey,\n        designation\n      }\n    });\n  }\n  async createProfileCredential(profile) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: this._identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.IdentityProfile\",\n        profile\n      }\n    });\n  }\n};\nvar createDeviceAuthorization = async (signer, identityKey, deviceKey) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey,\n        deviceKey\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\nvar createAdmissionCredentials = async (signer, identityKey, deviceKey, spaceKey, controlFeedKey, dataFeedKey, profile) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.SpaceMember\",\n        spaceKey,\n        role: SpaceMember.Role.ADMIN,\n        profile\n      }\n    }),\n    await signer.createCredential({\n      subject: controlFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.CONTROL\n      }\n    }),\n    await signer.createCredential({\n      subject: dataFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.DATA\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nimport { log as log2 } from \"@dxos/log\";\nimport { SpaceMember as SpaceMember2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback as Callback3 } from \"@dxos/util\";\n\n// packages/core/halo/credentials/src/state-machine/feed-state-machine.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { Callback, ComplexMap } from \"@dxos/util\";\nvar FeedStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._feeds = new ComplexMap(PublicKey2.hash);\n    this.onFeedAdmitted = new Callback();\n  }\n  get feeds() {\n    return this._feeds;\n  }\n  async process(credential, fromFeed) {\n    const assertion = getCredentialAssertion(credential);\n    assert3(assertion[\"@type\"] === \"dxos.halo.credentials.AdmittedFeed\");\n    assert3(assertion.spaceKey.equals(this._spaceKey));\n    assert3(!this._feeds.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion,\n      parent: fromFeed\n    };\n    this._feeds.set(credential.subject.id, info);\n    await this.onFeedAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/member-state-machine.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { Callback as Callback2, ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MemberStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new ComplexMap2(PublicKey3.hash);\n    this.onMemberAdmitted = new Callback2();\n  }\n  get members() {\n    return this._members;\n  }\n  getRole(member) {\n    var _a;\n    return (_a = this._members.get(member)) == null ? void 0 : _a.assertion.role;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    assert4(assertion[\"@type\"] === \"dxos.halo.credentials.SpaceMember\");\n    assert4(assertion.spaceKey.equals(this._spaceKey));\n    assert4(!this._members.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion\n    };\n    this._members.set(credential.subject.id, info);\n    log(\"member added\", {\n      member: credential.subject.id,\n      space: this._spaceKey,\n      role: assertion.role,\n      profile: assertion.profile\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/member-state-machine.ts\",\n      line: 63,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.onMemberAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nvar SpaceStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new MemberStateMachine(this._spaceKey);\n    this._feeds = new FeedStateMachine(this._spaceKey);\n    this._credentials = [];\n    this.onCredentialProcessed = new Callback3();\n    this.onMemberAdmitted = this._members.onMemberAdmitted;\n    this.onFeedAdmitted = this._feeds.onFeedAdmitted;\n  }\n  get genesisCredential() {\n    return this._genesisCredential;\n  }\n  get members() {\n    return this._members.members;\n  }\n  get feeds() {\n    return this._feeds.feeds;\n  }\n  get credentials() {\n    return this._credentials;\n  }\n  async process(credential, fromFeed) {\n    const result = await verifyCredential(credential);\n    if (result.kind !== \"pass\") {\n      log2.warn(`Invalid credential: ${result.errors.join(\", \")}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return false;\n    }\n    switch (getCredentialAssertion(credential)[\"@type\"]) {\n      case \"dxos.halo.credentials.SpaceGenesis\":\n        if (this._genesisCredential) {\n          log2.warn(\"Space already has a genesis credential.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 70,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.issuer.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued by space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 74,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.subject.id.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued to space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 78,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        this._genesisCredential = credential;\n        break;\n      case \"dxos.halo.credentials.SpaceMember\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before adding members.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 85,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canInviteNewMembers(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to invite new members.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 89,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._members.process(credential);\n        break;\n      case \"dxos.halo.credentials.AdmittedFeed\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before admitting feeds.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 96,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canAdmitFeeds(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to admit feeds.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 100,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._feeds.process(credential, fromFeed);\n        break;\n    }\n    this._credentials.push(credential);\n    await this.onCredentialProcessed.callIfSet(credential);\n    return true;\n  }\n  _canInviteNewMembers(key) {\n    return key.equals(this._spaceKey) || this._members.getRole(key) === SpaceMember2.Role.ADMIN;\n  }\n  _canAdmitFeeds(key) {\n    const role = this._members.getRole(key);\n    return role === SpaceMember2.Role.MEMBER || role === SpaceMember2.Role.ADMIN;\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/device-state-machine.ts\nimport { Trigger } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nimport { ComplexSet } from \"@dxos/util\";\nvar DeviceStateMachine = class {\n  constructor(_identityKey, _deviceKey) {\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n    this.authorizedDeviceKeys = new ComplexSet(PublicKey4.hash);\n    this.deviceChainReady = new Trigger();\n  }\n  async process(credential) {\n    log3(\"processing credential...\", {\n      identityKey: this._identityKey,\n      deviceKey: this._deviceKey,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n      line: 30,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (isValidAuthorizedDeviceCredential(credential, this._identityKey, this._deviceKey)) {\n      this.deviceCredentialChain = {\n        credential\n      };\n      this.deviceChainReady.wake();\n    }\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.AuthorizedDevice\": {\n        this.authorizedDeviceKeys.add(assertion.deviceKey);\n        log3(\"added device\", {\n          localDeviceKey: this._deviceKey,\n          deviceKey: assertion.deviceKey,\n          size: this.authorizedDeviceKeys.size\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n          line: 43,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\nimport { log as log4 } from \"@dxos/log\";\nvar ProfileStateMachine = class {\n  constructor(_identityKey) {\n    this._identityKey = _identityKey;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.IdentityProfile\": {\n        if (!credential.issuer.equals(this._identityKey) || !credential.subject.id.equals(this._identityKey)) {\n          log4.warn(\"Invalid profile credential\", {\n            expectedIdentity: this._identityKey,\n            credential\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n            line: 28,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return;\n        }\n        this.profile = assertion.profile;\n        log4(\"updated profile\", {\n          identityKey: this._identityKey,\n          profile: this.profile\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n          line: 34,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\nexport {\n  CredentialGenerator,\n  DeviceStateMachine,\n  FeedStateMachine,\n  MemberStateMachine,\n  ProfileStateMachine,\n  SIGNATURE_TYPE_ED25519,\n  SpaceStateMachine,\n  canonicalStringify,\n  createAdmissionCredentials,\n  createCredential,\n  createCredentialMessage,\n  createCredentialSignerWithChain,\n  createCredentialSignerWithKey,\n  createDeviceAuthorization,\n  defaultSecretProvider,\n  defaultSecretValidator,\n  generatePasscode,\n  generateSeedPhrase,\n  getCredentialAssertion,\n  getSignaturePayload,\n  isValidAuthorizedDeviceCredential,\n  keyPairFromSeedPhrase,\n  verifyChain,\n  verifyCredential,\n  verifyCredentialSignature\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465998,"end":1670465465998,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/halo/credentials/src/invitations.ts\nvar defaultSecretProvider = async () => Buffer.from(\"0000\");\nvar defaultSecretValidator = async (invitation, secret) => true;\n\n// packages/core/halo/credentials/src/seedphrase.ts\nimport { generateMnemonic, mnemonicToSeedSync } from \"bip39\";\nimport assert from \"@dxos/node-std/assert\";\nimport { createKeyPair } from \"@dxos/crypto\";\nvar generateSeedPhrase = () => generateMnemonic();\nvar keyPairFromSeedPhrase = (seedPhrase) => {\n  assert(seedPhrase);\n  const seed = mnemonicToSeedSync(seedPhrase);\n  return createKeyPair(seed);\n};\n\n// packages/core/halo/credentials/src/passcode.ts\nvar generatePasscode = (length = 4) => {\n  let passcode = \"\";\n  for (let i = 0; i < length; i++) {\n    passcode += `${Math.floor(Math.random() * 10)}`;\n  }\n  return passcode;\n};\n\n// packages/core/halo/credentials/src/credentials/assertions.ts\nvar getCredentialAssertion = (credential) => credential.subject.assertion;\nvar isValidAuthorizedDeviceCredential = (credential, identityKey, deviceKey) => {\n  const assertion = getCredentialAssertion(credential);\n  return credential.subject.id.equals(deviceKey) && credential.issuer.equals(identityKey) && assertion[\"@type\"] === \"dxos.halo.credentials.AuthorizedDevice\" && assertion.identityKey.equals(identityKey) && assertion.deviceKey.equals(deviceKey);\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nimport assert2 from \"@dxos/node-std/assert\";\n\n// packages/core/halo/credentials/src/credentials/signing.ts\nimport stableStringify from \"json-stable-stringify\";\nimport { PublicKey } from \"@dxos/keys\";\nvar getSignaturePayload = (credential) => {\n  const copy = {\n    ...credential,\n    proof: {\n      ...credential.proof,\n      value: new Uint8Array(),\n      chain: void 0\n    }\n  };\n  return Buffer.from(canonicalStringify(copy));\n};\nvar canonicalStringify = (obj) => stableStringify(obj, {\n  replacer: (key, value) => {\n    if (key.toString().startsWith(\"__\") || key.toString() === \"@type\") {\n      return void 0;\n    }\n    if (value) {\n      if (PublicKey.isPublicKey(value)) {\n        return value.toHex();\n      }\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"hex\");\n      }\n      if (value instanceof Uint8Array || value.data && value.type === \"Buffer\") {\n        return Buffer.from(value).toString(\"hex\");\n      }\n    }\n    return value;\n  }\n});\n\n// packages/core/halo/credentials/src/credentials/verifier.ts\nimport { verifySignature } from \"@dxos/crypto\";\nvar SIGNATURE_TYPE_ED25519 = \"ED25519Signature\";\nvar verifyCredential = async (credential) => {\n  if (!credential.issuer.equals(credential.proof.signer)) {\n    if (!credential.proof.chain) {\n      return {\n        kind: \"fail\",\n        errors: [\n          \"Delegated credential is missing credential chain.\"\n        ]\n      };\n    }\n    const result = await verifyChain(credential.proof.chain, credential.issuer, credential.proof.signer);\n    if (result.kind === \"fail\") {\n      return result;\n    }\n  }\n  const result1 = await verifyCredentialSignature(credential);\n  if (result1.kind === \"fail\") {\n    return result1;\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyCredentialSignature = async (credential) => {\n  if (credential.proof.type !== SIGNATURE_TYPE_ED25519) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid signature type: ${credential.proof.type}`\n      ]\n    };\n  }\n  const signData = getSignaturePayload(credential);\n  if (!await verifySignature(credential.proof.signer, signData, credential.proof.value)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        \"Invalid signature\"\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\nvar verifyChain = async (chain, authority, subject) => {\n  const result = await verifyCredential(chain.credential);\n  if (result.kind === \"fail\") {\n    return result;\n  }\n  if (!isValidAuthorizedDeviceCredential(chain.credential, authority, subject)) {\n    return {\n      kind: \"fail\",\n      errors: [\n        `Invalid credential chain: invalid assertion for key: ${subject}`\n      ]\n    };\n  }\n  return {\n    kind: \"pass\"\n  };\n};\n\n// packages/core/halo/credentials/src/credentials/credential-factory.ts\nvar createCredential = async ({ signer, issuer, subject, assertion, signingKey, chain, nonce }) => {\n  assert2(assertion[\"@type\"], \"Invalid assertion.\");\n  assert2(!!signingKey === !!chain, \"Chain must be provided if and only if the signing key differs from the issuer.\");\n  if (chain) {\n    const result = await verifyChain(chain, issuer, signingKey);\n    assert2(result.kind === \"pass\", \"Invalid chain.\");\n  }\n  const credential = {\n    issuer,\n    issuanceDate: new Date(),\n    subject: {\n      id: subject,\n      assertion\n    },\n    proof: {\n      type: SIGNATURE_TYPE_ED25519,\n      creationDate: new Date(),\n      signer: signingKey != null ? signingKey : issuer,\n      value: new Uint8Array(),\n      nonce\n    }\n  };\n  const signedPayload = getSignaturePayload(credential);\n  credential.proof.value = await signer.sign(signingKey != null ? signingKey : issuer, signedPayload);\n  if (chain) {\n    credential.proof.chain = chain;\n  }\n  return credential;\n};\nvar createCredentialMessage = (credential) => {\n  return {\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  };\n};\nvar createCredentialSignerWithKey = (signer, issuer) => ({\n  getIssuer: () => issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer,\n    subject,\n    assertion,\n    nonce\n  })\n});\nvar createCredentialSignerWithChain = (signer, chain, signingKey) => ({\n  getIssuer: () => chain.credential.issuer,\n  createCredential: ({ subject, assertion, nonce }) => createCredential({\n    signer,\n    issuer: chain.credential.issuer,\n    signingKey,\n    chain,\n    subject,\n    assertion,\n    nonce\n  })\n});\n\n// packages/core/halo/credentials/src/credentials/credential-generator.ts\nimport { AdmittedFeed, SpaceMember } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nvar CredentialGenerator = class {\n  constructor(_signer, _identityKey, _deviceKey) {\n    this._signer = _signer;\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n  }\n  async createSpaceGenesis(spaceKey, controlKey, creatorProfile) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: spaceKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceGenesis\",\n          spaceKey\n        }\n      }),\n      await createCredential({\n        signer: this._signer,\n        issuer: spaceKey,\n        subject: this._identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.ADMIN,\n          profile: creatorProfile\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL)\n    ];\n  }\n  async createMemberInvitation(spaceKey, identityKey, deviceKey, controlKey, dataKey) {\n    return [\n      await createCredential({\n        signer: this._signer,\n        issuer: this._identityKey,\n        subject: identityKey,\n        assertion: {\n          \"@type\": \"dxos.halo.credentials.SpaceMember\",\n          spaceKey,\n          role: SpaceMember.Role.MEMBER\n        }\n      }),\n      await this.createFeedAdmission(spaceKey, controlKey, AdmittedFeed.Designation.CONTROL),\n      await this.createFeedAdmission(spaceKey, dataKey, AdmittedFeed.Designation.DATA)\n    ];\n  }\n  async createDeviceAuthorization(deviceKey) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey: this._identityKey,\n        deviceKey\n      }\n    });\n  }\n  async createFeedAdmission(spaceKey, feedKey, designation) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: feedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        identityKey: this._identityKey,\n        deviceKey: this._deviceKey,\n        designation\n      }\n    });\n  }\n  async createProfileCredential(profile) {\n    return createCredential({\n      signer: this._signer,\n      issuer: this._identityKey,\n      subject: this._identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.IdentityProfile\",\n        profile\n      }\n    });\n  }\n};\nvar createDeviceAuthorization = async (signer, identityKey, deviceKey) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: deviceKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AuthorizedDevice\",\n        identityKey,\n        deviceKey\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\nvar createAdmissionCredentials = async (signer, identityKey, deviceKey, spaceKey, controlFeedKey, dataFeedKey, profile) => {\n  const credentials = await Promise.all([\n    await signer.createCredential({\n      subject: identityKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.SpaceMember\",\n        spaceKey,\n        role: SpaceMember.Role.ADMIN,\n        profile\n      }\n    }),\n    await signer.createCredential({\n      subject: controlFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.CONTROL\n      }\n    }),\n    await signer.createCredential({\n      subject: dataFeedKey,\n      assertion: {\n        \"@type\": \"dxos.halo.credentials.AdmittedFeed\",\n        spaceKey,\n        deviceKey,\n        identityKey,\n        designation: AdmittedFeed.Designation.DATA\n      }\n    })\n  ]);\n  return credentials.map((credential) => ({\n    \"@type\": \"dxos.echo.feed.CredentialsMessage\",\n    credential\n  }));\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nimport { log as log2 } from \"@dxos/log\";\nimport { SpaceMember as SpaceMember2 } from \"@dxos/protocols/proto/dxos/halo/credentials\";\nimport { Callback as Callback3 } from \"@dxos/util\";\n\n// packages/core/halo/credentials/src/state-machine/feed-state-machine.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { Callback, ComplexMap } from \"@dxos/util\";\nvar FeedStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._feeds = new ComplexMap(PublicKey2.hash);\n    this.onFeedAdmitted = new Callback();\n  }\n  get feeds() {\n    return this._feeds;\n  }\n  async process(credential, fromFeed) {\n    const assertion = getCredentialAssertion(credential);\n    assert3(assertion[\"@type\"] === \"dxos.halo.credentials.AdmittedFeed\");\n    assert3(assertion.spaceKey.equals(this._spaceKey));\n    assert3(!this._feeds.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion,\n      parent: fromFeed\n    };\n    this._feeds.set(credential.subject.id, info);\n    await this.onFeedAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/member-state-machine.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { Callback as Callback2, ComplexMap as ComplexMap2 } from \"@dxos/util\";\nvar MemberStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new ComplexMap2(PublicKey3.hash);\n    this.onMemberAdmitted = new Callback2();\n  }\n  get members() {\n    return this._members;\n  }\n  getRole(member) {\n    var _a;\n    return (_a = this._members.get(member)) == null ? void 0 : _a.assertion.role;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    assert4(assertion[\"@type\"] === \"dxos.halo.credentials.SpaceMember\");\n    assert4(assertion.spaceKey.equals(this._spaceKey));\n    assert4(!this._members.has(credential.subject.id));\n    const info = {\n      key: credential.subject.id,\n      credential,\n      assertion\n    };\n    this._members.set(credential.subject.id, info);\n    log(\"member added\", {\n      member: credential.subject.id,\n      space: this._spaceKey,\n      role: assertion.role,\n      profile: assertion.profile\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/member-state-machine.ts\",\n      line: 63,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.onMemberAdmitted.callIfSet(info);\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/space-state-machine.ts\nvar SpaceStateMachine = class {\n  constructor(_spaceKey) {\n    this._spaceKey = _spaceKey;\n    this._members = new MemberStateMachine(this._spaceKey);\n    this._feeds = new FeedStateMachine(this._spaceKey);\n    this._credentials = [];\n    this.onCredentialProcessed = new Callback3();\n    this.onMemberAdmitted = this._members.onMemberAdmitted;\n    this.onFeedAdmitted = this._feeds.onFeedAdmitted;\n  }\n  get genesisCredential() {\n    return this._genesisCredential;\n  }\n  get members() {\n    return this._members.members;\n  }\n  get feeds() {\n    return this._feeds.feeds;\n  }\n  get credentials() {\n    return this._credentials;\n  }\n  async process(credential, fromFeed) {\n    const result = await verifyCredential(credential);\n    if (result.kind !== \"pass\") {\n      log2.warn(`Invalid credential: ${result.errors.join(\", \")}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return false;\n    }\n    switch (getCredentialAssertion(credential)[\"@type\"]) {\n      case \"dxos.halo.credentials.SpaceGenesis\":\n        if (this._genesisCredential) {\n          log2.warn(\"Space already has a genesis credential.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 70,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.issuer.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued by space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 74,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!credential.subject.id.equals(this._spaceKey)) {\n          log2.warn(\"Space genesis credential must be issued to space.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 78,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        this._genesisCredential = credential;\n        break;\n      case \"dxos.halo.credentials.SpaceMember\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before adding members.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 85,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canInviteNewMembers(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to invite new members.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 89,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._members.process(credential);\n        break;\n      case \"dxos.halo.credentials.AdmittedFeed\":\n        if (!this._genesisCredential) {\n          log2.warn(\"Space must have a genesis credential before admitting feeds.\", {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 96,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        if (!this._canAdmitFeeds(credential.issuer)) {\n          log2.warn(`Space member ${credential.issuer} is not authorized to admit feeds.`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/space-state-machine.ts\",\n            line: 100,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return false;\n        }\n        await this._feeds.process(credential, fromFeed);\n        break;\n    }\n    this._credentials.push(credential);\n    await this.onCredentialProcessed.callIfSet(credential);\n    return true;\n  }\n  _canInviteNewMembers(key) {\n    return key.equals(this._spaceKey) || this._members.getRole(key) === SpaceMember2.Role.ADMIN;\n  }\n  _canAdmitFeeds(key) {\n    const role = this._members.getRole(key);\n    return role === SpaceMember2.Role.MEMBER || role === SpaceMember2.Role.ADMIN;\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/device-state-machine.ts\nimport { Trigger } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nimport { ComplexSet } from \"@dxos/util\";\nvar DeviceStateMachine = class {\n  constructor(_identityKey, _deviceKey) {\n    this._identityKey = _identityKey;\n    this._deviceKey = _deviceKey;\n    this.authorizedDeviceKeys = new ComplexSet(PublicKey4.hash);\n    this.deviceChainReady = new Trigger();\n  }\n  async process(credential) {\n    log3(\"processing credential...\", {\n      identityKey: this._identityKey,\n      deviceKey: this._deviceKey,\n      credential\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n      line: 30,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (isValidAuthorizedDeviceCredential(credential, this._identityKey, this._deviceKey)) {\n      this.deviceCredentialChain = {\n        credential\n      };\n      this.deviceChainReady.wake();\n    }\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.AuthorizedDevice\": {\n        this.authorizedDeviceKeys.add(assertion.deviceKey);\n        log3(\"added device\", {\n          localDeviceKey: this._deviceKey,\n          deviceKey: assertion.deviceKey,\n          size: this.authorizedDeviceKeys.size\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/device-state-machine.ts\",\n          line: 43,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\n\n// packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\nimport { log as log4 } from \"@dxos/log\";\nvar ProfileStateMachine = class {\n  constructor(_identityKey) {\n    this._identityKey = _identityKey;\n  }\n  async process(credential) {\n    const assertion = getCredentialAssertion(credential);\n    switch (assertion[\"@type\"]) {\n      case \"dxos.halo.credentials.IdentityProfile\": {\n        if (!credential.issuer.equals(this._identityKey) || !credential.subject.id.equals(this._identityKey)) {\n          log4.warn(\"Invalid profile credential\", {\n            expectedIdentity: this._identityKey,\n            credential\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n            line: 28,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return;\n        }\n        this.profile = assertion.profile;\n        log4(\"updated profile\", {\n          identityKey: this._identityKey,\n          profile: this.profile\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/halo/credentials/src/state-machine/profile-state-machine.ts\",\n          line: 34,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        break;\n      }\n    }\n  }\n};\nexport {\n  CredentialGenerator,\n  DeviceStateMachine,\n  FeedStateMachine,\n  MemberStateMachine,\n  ProfileStateMachine,\n  SIGNATURE_TYPE_ED25519,\n  SpaceStateMachine,\n  canonicalStringify,\n  createAdmissionCredentials,\n  createCredential,\n  createCredentialMessage,\n  createCredentialSignerWithChain,\n  createCredentialSignerWithKey,\n  createDeviceAuthorization,\n  defaultSecretProvider,\n  defaultSecretValidator,\n  generatePasscode,\n  generateSeedPhrase,\n  getCredentialAssertion,\n  getSignaturePayload,\n  isValidAuthorizedDeviceCredential,\n  keyPairFromSeedPhrase,\n  verifyChain,\n  verifyCredential,\n  verifyCredentialSignature\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465998,"end":1670465466004,"order":"normal"}]}
