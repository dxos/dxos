{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/halo/keyring/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/halo/keyring/src/keyring.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { subtleCrypto } from \"@dxos/crypto\";\nimport { todo } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { schema } from \"@dxos/protocols\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { ComplexMap } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Keyring = class {\n  constructor(_storage = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(\"keyring\")) {\n    this._storage = _storage;\n    this._keyCache = new ComplexMap(PublicKey.hash);\n    this.keysUpdate = new Event();\n  }\n  async sign(key, message) {\n    const keyPair = await this._getKey(key);\n    return new Uint8Array(await subtleCrypto.sign({\n      name: \"ECDSA\",\n      hash: \"SHA-256\"\n    }, keyPair.privateKey, message));\n  }\n  async createKey() {\n    const keyPair = await subtleCrypto.generateKey({\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"sign\",\n      \"verify\"\n    ]);\n    await this._setKey(keyPair);\n    return keyPairToPublicKey(keyPair);\n  }\n  async _getKey(key) {\n    if (!this._keyCache.has(key)) {\n      const file = this._storage.getOrCreateFile(key.toHex());\n      const { size } = await file.stat();\n      if (size === 0) {\n        throw new Error(`Key not found: ${key.toHex()}`);\n      }\n      const recordBytes = await file.read(0, size);\n      await file.close();\n      const record = schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").decode(recordBytes);\n      const publicKey = PublicKey.from(record.publicKey);\n      assert(key.equals(publicKey), \"Corrupted keyring: Key mismatch\");\n      assert(record.privateKey, \"Corrupted keyring: Missing private key\");\n      const keyPair = {\n        publicKey: await subtleCrypto.importKey(\"raw\", record.publicKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"verify\"\n        ]),\n        privateKey: await subtleCrypto.importKey(\"pkcs8\", record.privateKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"sign\"\n        ])\n      };\n      this._keyCache.set(publicKey, keyPair);\n    }\n    return this._keyCache.get(key);\n  }\n  async _setKey(keyPair) {\n    const publicKey = await keyPairToPublicKey(keyPair);\n    this._keyCache.set(publicKey, keyPair);\n    const record = {\n      publicKey: publicKey.asUint8Array(),\n      privateKey: new Uint8Array(await subtleCrypto.exportKey(\"pkcs8\", keyPair.privateKey))\n    };\n    const file = this._storage.getOrCreateFile(publicKey.toHex());\n    await file.write(0, Buffer.from(schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").encode(record)));\n    await file.close();\n    this.keysUpdate.emit();\n  }\n  deleteKey(key) {\n    return todo(\"We need a method to delete a file.\");\n  }\n  list() {\n    const keys = [];\n    for (const path of this._storage.getFiles().keys()) {\n      const fileName = path.split(\"/\").pop();\n      assert(fileName, \"Invalid file name\");\n      keys.push({\n        publicKey: PublicKey.fromHex(fileName).asUint8Array()\n      });\n    }\n    return keys;\n  }\n};\n__decorate([\n  synchronized\n], Keyring.prototype, \"_getKey\", null);\n__decorate([\n  synchronized\n], Keyring.prototype, \"_setKey\", null);\nvar keyPairToPublicKey = async (keyPair) => {\n  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey(\"raw\", keyPair.publicKey)));\n};\nexport {\n  Keyring\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466989,"end":1670465467176},{"name":"vite:react-babel","result":"// packages/core/halo/keyring/src/keyring.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { subtleCrypto } from \"@dxos/crypto\";\nimport { todo } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { schema } from \"@dxos/protocols\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { ComplexMap } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Keyring = class {\n  constructor(_storage = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(\"keyring\")) {\n    this._storage = _storage;\n    this._keyCache = new ComplexMap(PublicKey.hash);\n    this.keysUpdate = new Event();\n  }\n  async sign(key, message) {\n    const keyPair = await this._getKey(key);\n    return new Uint8Array(await subtleCrypto.sign({\n      name: \"ECDSA\",\n      hash: \"SHA-256\"\n    }, keyPair.privateKey, message));\n  }\n  async createKey() {\n    const keyPair = await subtleCrypto.generateKey({\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"sign\",\n      \"verify\"\n    ]);\n    await this._setKey(keyPair);\n    return keyPairToPublicKey(keyPair);\n  }\n  async _getKey(key) {\n    if (!this._keyCache.has(key)) {\n      const file = this._storage.getOrCreateFile(key.toHex());\n      const { size } = await file.stat();\n      if (size === 0) {\n        throw new Error(`Key not found: ${key.toHex()}`);\n      }\n      const recordBytes = await file.read(0, size);\n      await file.close();\n      const record = schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").decode(recordBytes);\n      const publicKey = PublicKey.from(record.publicKey);\n      assert(key.equals(publicKey), \"Corrupted keyring: Key mismatch\");\n      assert(record.privateKey, \"Corrupted keyring: Missing private key\");\n      const keyPair = {\n        publicKey: await subtleCrypto.importKey(\"raw\", record.publicKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"verify\"\n        ]),\n        privateKey: await subtleCrypto.importKey(\"pkcs8\", record.privateKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"sign\"\n        ])\n      };\n      this._keyCache.set(publicKey, keyPair);\n    }\n    return this._keyCache.get(key);\n  }\n  async _setKey(keyPair) {\n    const publicKey = await keyPairToPublicKey(keyPair);\n    this._keyCache.set(publicKey, keyPair);\n    const record = {\n      publicKey: publicKey.asUint8Array(),\n      privateKey: new Uint8Array(await subtleCrypto.exportKey(\"pkcs8\", keyPair.privateKey))\n    };\n    const file = this._storage.getOrCreateFile(publicKey.toHex());\n    await file.write(0, Buffer.from(schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").encode(record)));\n    await file.close();\n    this.keysUpdate.emit();\n  }\n  deleteKey(key) {\n    return todo(\"We need a method to delete a file.\");\n  }\n  list() {\n    const keys = [];\n    for (const path of this._storage.getFiles().keys()) {\n      const fileName = path.split(\"/\").pop();\n      assert(fileName, \"Invalid file name\");\n      keys.push({\n        publicKey: PublicKey.fromHex(fileName).asUint8Array()\n      });\n    }\n    return keys;\n  }\n};\n__decorate([\n  synchronized\n], Keyring.prototype, \"_getKey\", null);\n__decorate([\n  synchronized\n], Keyring.prototype, \"_setKey\", null);\nvar keyPairToPublicKey = async (keyPair) => {\n  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey(\"raw\", keyPair.publicKey)));\n};\nexport {\n  Keyring\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467176,"end":1670465467176,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/halo/keyring/src/keyring.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { subtleCrypto } from \"@dxos/crypto\";\nimport { todo } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { schema } from \"@dxos/protocols\";\nimport { createStorage, StorageType } from \"@dxos/random-access-storage\";\nimport { ComplexMap } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Keyring = class {\n  constructor(_storage = createStorage({\n    type: StorageType.RAM\n  }).createDirectory(\"keyring\")) {\n    this._storage = _storage;\n    this._keyCache = new ComplexMap(PublicKey.hash);\n    this.keysUpdate = new Event();\n  }\n  async sign(key, message) {\n    const keyPair = await this._getKey(key);\n    return new Uint8Array(await subtleCrypto.sign({\n      name: \"ECDSA\",\n      hash: \"SHA-256\"\n    }, keyPair.privateKey, message));\n  }\n  async createKey() {\n    const keyPair = await subtleCrypto.generateKey({\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, true, [\n      \"sign\",\n      \"verify\"\n    ]);\n    await this._setKey(keyPair);\n    return keyPairToPublicKey(keyPair);\n  }\n  async _getKey(key) {\n    if (!this._keyCache.has(key)) {\n      const file = this._storage.getOrCreateFile(key.toHex());\n      const { size } = await file.stat();\n      if (size === 0) {\n        throw new Error(`Key not found: ${key.toHex()}`);\n      }\n      const recordBytes = await file.read(0, size);\n      await file.close();\n      const record = schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").decode(recordBytes);\n      const publicKey = PublicKey.from(record.publicKey);\n      assert(key.equals(publicKey), \"Corrupted keyring: Key mismatch\");\n      assert(record.privateKey, \"Corrupted keyring: Missing private key\");\n      const keyPair = {\n        publicKey: await subtleCrypto.importKey(\"raw\", record.publicKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"verify\"\n        ]),\n        privateKey: await subtleCrypto.importKey(\"pkcs8\", record.privateKey, {\n          name: \"ECDSA\",\n          namedCurve: \"P-256\"\n        }, true, [\n          \"sign\"\n        ])\n      };\n      this._keyCache.set(publicKey, keyPair);\n    }\n    return this._keyCache.get(key);\n  }\n  async _setKey(keyPair) {\n    const publicKey = await keyPairToPublicKey(keyPair);\n    this._keyCache.set(publicKey, keyPair);\n    const record = {\n      publicKey: publicKey.asUint8Array(),\n      privateKey: new Uint8Array(await subtleCrypto.exportKey(\"pkcs8\", keyPair.privateKey))\n    };\n    const file = this._storage.getOrCreateFile(publicKey.toHex());\n    await file.write(0, Buffer.from(schema.getCodecForType(\"dxos.halo.keyring.KeyRecord\").encode(record)));\n    await file.close();\n    this.keysUpdate.emit();\n  }\n  deleteKey(key) {\n    return todo(\"We need a method to delete a file.\");\n  }\n  list() {\n    const keys = [];\n    for (const path of this._storage.getFiles().keys()) {\n      const fileName = path.split(\"/\").pop();\n      assert(fileName, \"Invalid file name\");\n      keys.push({\n        publicKey: PublicKey.fromHex(fileName).asUint8Array()\n      });\n    }\n    return keys;\n  }\n};\n__decorate([\n  synchronized\n], Keyring.prototype, \"_getKey\", null);\n__decorate([\n  synchronized\n], Keyring.prototype, \"_setKey\", null);\nvar keyPairToPublicKey = async (keyPair) => {\n  return PublicKey.from(new Uint8Array(await subtleCrypto.exportKey(\"raw\", keyPair.publicKey)));\n};\nexport {\n  Keyring\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467177,"end":1670465467178,"order":"normal"}]}
