{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/internal/hchacha20.js","transforms":[{"name":"vite:load-fallback","result":"/* eslint-disable camelcase */\nconst { sodium_malloc } = require('../memory')\nconst assert = require('nanoassert')\n\nif (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.')\n\nconst crypto_core_hchacha20_OUTPUTBYTES = 32\nconst crypto_core_hchacha20_INPUTBYTES = 16\nconst crypto_core_hchacha20_KEYBYTES = 32\nconst crypto_core_hchacha20_CONSTBYTES = 16\n\nfunction ROTL32 (x, b) {\n  x &= 0xFFFFFFFF\n  b &= 0xFFFFFFFF\n  return (x << b) | (x >>> (32 - b))\n}\n\nfunction LOAD32_LE (src, offset) {\n  assert(src instanceof Uint8Array, 'src not byte array')\n  let w = src[offset]\n  w |= src[offset + 1] << 8\n  w |= src[offset + 2] << 16\n  w |= src[offset + 3] << 24\n  return w\n}\n\nfunction STORE32_LE (dest, int, offset) {\n  assert(dest instanceof Uint8Array, 'dest not byte array')\n  var mul = 1\n  var i = 0\n  dest[offset] = int & 0xFF // grab bottom byte\n  while (++i < 4 && (mul *= 0x100)) {\n    dest[offset + i] = (int / mul) & 0xFF\n  }\n}\n\nfunction QUARTERROUND (l, A, B, C, D) {\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 16)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 12)\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 8)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 7)\n}\n\nfunction crypto_core_hchacha20 (out, _in, k, c) {\n  assert(out instanceof Uint8Array && out.length === 32, 'out is not an array of 32 bytes')\n  assert(k instanceof Uint8Array && k.length === 32, 'k is not an array of 32 bytes')\n  assert(c === null || (c instanceof Uint8Array && c.length === 16), 'c is not null or an array of 16 bytes')\n\n  let i = 0\n  const x = new Uint32Array(16)\n  if (!c) {\n    x[0] = 0x61707865\n    x[1] = 0x3320646E\n    x[2] = 0x79622D32\n    x[3] = 0x6B206574\n  } else {\n    x[0] = LOAD32_LE(c, 0)\n    x[1] = LOAD32_LE(c, 4)\n    x[2] = LOAD32_LE(c, 8)\n    x[3] = LOAD32_LE(c, 12)\n  }\n  x[4] = LOAD32_LE(k, 0)\n  x[5] = LOAD32_LE(k, 4)\n  x[6] = LOAD32_LE(k, 8)\n  x[7] = LOAD32_LE(k, 12)\n  x[8] = LOAD32_LE(k, 16)\n  x[9] = LOAD32_LE(k, 20)\n  x[10] = LOAD32_LE(k, 24)\n  x[11] = LOAD32_LE(k, 28)\n  x[12] = LOAD32_LE(_in, 0)\n  x[13] = LOAD32_LE(_in, 4)\n  x[14] = LOAD32_LE(_in, 8)\n  x[15] = LOAD32_LE(_in, 12)\n\n  for (i = 0; i < 10; i++) {\n    QUARTERROUND(x, 0, 4, 8, 12)\n    QUARTERROUND(x, 1, 5, 9, 13)\n    QUARTERROUND(x, 2, 6, 10, 14)\n    QUARTERROUND(x, 3, 7, 11, 15)\n    QUARTERROUND(x, 0, 5, 10, 15)\n    QUARTERROUND(x, 1, 6, 11, 12)\n    QUARTERROUND(x, 2, 7, 8, 13)\n    QUARTERROUND(x, 3, 4, 9, 14)\n  }\n\n  STORE32_LE(out, x[0], 0)\n  STORE32_LE(out, x[1], 4)\n  STORE32_LE(out, x[2], 8)\n  STORE32_LE(out, x[3], 12)\n  STORE32_LE(out, x[12], 16)\n  STORE32_LE(out, x[13], 20)\n  STORE32_LE(out, x[14], 24)\n  STORE32_LE(out, x[15], 28)\n\n  return 0\n}\n\nfunction crypto_core_hchacha20_outputbytes () {\n  return crypto_core_hchacha20_OUTPUTBYTES\n}\n\nfunction crypto_core_hchacha20_inputbytes () {\n  return crypto_core_hchacha20_INPUTBYTES\n}\n\nfunction crypto_core_hchacha20_keybytes () {\n  return crypto_core_hchacha20_KEYBYTES\n}\n\nfunction crypto_core_hchacha20_constbytes () {\n  return crypto_core_hchacha20_CONSTBYTES\n}\n\nmodule.exports = {\n  crypto_core_hchacha20_INPUTBYTES,\n  LOAD32_LE,\n  STORE32_LE,\n  QUARTERROUND,\n  crypto_core_hchacha20,\n  crypto_core_hchacha20_outputbytes,\n  crypto_core_hchacha20_inputbytes,\n  crypto_core_hchacha20_keybytes,\n  crypto_core_hchacha20_constbytes\n}\n","start":1670465470996,"end":1670465471120},{"name":"vite:react-babel","result":"/* eslint-disable camelcase */\nconst { sodium_malloc } = require('../memory')\nconst assert = require('nanoassert')\n\nif (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.')\n\nconst crypto_core_hchacha20_OUTPUTBYTES = 32\nconst crypto_core_hchacha20_INPUTBYTES = 16\nconst crypto_core_hchacha20_KEYBYTES = 32\nconst crypto_core_hchacha20_CONSTBYTES = 16\n\nfunction ROTL32 (x, b) {\n  x &= 0xFFFFFFFF\n  b &= 0xFFFFFFFF\n  return (x << b) | (x >>> (32 - b))\n}\n\nfunction LOAD32_LE (src, offset) {\n  assert(src instanceof Uint8Array, 'src not byte array')\n  let w = src[offset]\n  w |= src[offset + 1] << 8\n  w |= src[offset + 2] << 16\n  w |= src[offset + 3] << 24\n  return w\n}\n\nfunction STORE32_LE (dest, int, offset) {\n  assert(dest instanceof Uint8Array, 'dest not byte array')\n  var mul = 1\n  var i = 0\n  dest[offset] = int & 0xFF // grab bottom byte\n  while (++i < 4 && (mul *= 0x100)) {\n    dest[offset + i] = (int / mul) & 0xFF\n  }\n}\n\nfunction QUARTERROUND (l, A, B, C, D) {\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 16)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 12)\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 8)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 7)\n}\n\nfunction crypto_core_hchacha20 (out, _in, k, c) {\n  assert(out instanceof Uint8Array && out.length === 32, 'out is not an array of 32 bytes')\n  assert(k instanceof Uint8Array && k.length === 32, 'k is not an array of 32 bytes')\n  assert(c === null || (c instanceof Uint8Array && c.length === 16), 'c is not null or an array of 16 bytes')\n\n  let i = 0\n  const x = new Uint32Array(16)\n  if (!c) {\n    x[0] = 0x61707865\n    x[1] = 0x3320646E\n    x[2] = 0x79622D32\n    x[3] = 0x6B206574\n  } else {\n    x[0] = LOAD32_LE(c, 0)\n    x[1] = LOAD32_LE(c, 4)\n    x[2] = LOAD32_LE(c, 8)\n    x[3] = LOAD32_LE(c, 12)\n  }\n  x[4] = LOAD32_LE(k, 0)\n  x[5] = LOAD32_LE(k, 4)\n  x[6] = LOAD32_LE(k, 8)\n  x[7] = LOAD32_LE(k, 12)\n  x[8] = LOAD32_LE(k, 16)\n  x[9] = LOAD32_LE(k, 20)\n  x[10] = LOAD32_LE(k, 24)\n  x[11] = LOAD32_LE(k, 28)\n  x[12] = LOAD32_LE(_in, 0)\n  x[13] = LOAD32_LE(_in, 4)\n  x[14] = LOAD32_LE(_in, 8)\n  x[15] = LOAD32_LE(_in, 12)\n\n  for (i = 0; i < 10; i++) {\n    QUARTERROUND(x, 0, 4, 8, 12)\n    QUARTERROUND(x, 1, 5, 9, 13)\n    QUARTERROUND(x, 2, 6, 10, 14)\n    QUARTERROUND(x, 3, 7, 11, 15)\n    QUARTERROUND(x, 0, 5, 10, 15)\n    QUARTERROUND(x, 1, 6, 11, 12)\n    QUARTERROUND(x, 2, 7, 8, 13)\n    QUARTERROUND(x, 3, 4, 9, 14)\n  }\n\n  STORE32_LE(out, x[0], 0)\n  STORE32_LE(out, x[1], 4)\n  STORE32_LE(out, x[2], 8)\n  STORE32_LE(out, x[3], 12)\n  STORE32_LE(out, x[12], 16)\n  STORE32_LE(out, x[13], 20)\n  STORE32_LE(out, x[14], 24)\n  STORE32_LE(out, x[15], 28)\n\n  return 0\n}\n\nfunction crypto_core_hchacha20_outputbytes () {\n  return crypto_core_hchacha20_OUTPUTBYTES\n}\n\nfunction crypto_core_hchacha20_inputbytes () {\n  return crypto_core_hchacha20_INPUTBYTES\n}\n\nfunction crypto_core_hchacha20_keybytes () {\n  return crypto_core_hchacha20_KEYBYTES\n}\n\nfunction crypto_core_hchacha20_constbytes () {\n  return crypto_core_hchacha20_CONSTBYTES\n}\n\nmodule.exports = {\n  crypto_core_hchacha20_INPUTBYTES,\n  LOAD32_LE,\n  STORE32_LE,\n  QUARTERROUND,\n  crypto_core_hchacha20,\n  crypto_core_hchacha20_outputbytes,\n  crypto_core_hchacha20_inputbytes,\n  crypto_core_hchacha20_keybytes,\n  crypto_core_hchacha20_constbytes\n}\n","start":1670465471120,"end":1670465471120,"order":"pre"},{"name":"commonjs","result":"/* eslint-disable camelcase */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/memory.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\n\nconst { sodium_malloc } = require$$0\nconst assert = require$$1\n\nif (new Uint16Array([1])[0] !== 1) throw new Error('Big endian architecture is not supported.')\n\nconst crypto_core_hchacha20_OUTPUTBYTES = 32\nconst crypto_core_hchacha20_INPUTBYTES = 16\nconst crypto_core_hchacha20_KEYBYTES = 32\nconst crypto_core_hchacha20_CONSTBYTES = 16\n\nfunction ROTL32 (x, b) {\n  x &= 0xFFFFFFFF\n  b &= 0xFFFFFFFF\n  return (x << b) | (x >>> (32 - b))\n}\n\nfunction LOAD32_LE (src, offset) {\n  assert(src instanceof Uint8Array, 'src not byte array')\n  let w = src[offset]\n  w |= src[offset + 1] << 8\n  w |= src[offset + 2] << 16\n  w |= src[offset + 3] << 24\n  return w\n}\n\nfunction STORE32_LE (dest, int, offset) {\n  assert(dest instanceof Uint8Array, 'dest not byte array')\n  var mul = 1\n  var i = 0\n  dest[offset] = int & 0xFF // grab bottom byte\n  while (++i < 4 && (mul *= 0x100)) {\n    dest[offset + i] = (int / mul) & 0xFF\n  }\n}\n\nfunction QUARTERROUND (l, A, B, C, D) {\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 16)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 12)\n  l[A] += l[B]\n  l[D] = ROTL32(l[D] ^ l[A], 8)\n  l[C] += l[D]\n  l[B] = ROTL32(l[B] ^ l[C], 7)\n}\n\nfunction crypto_core_hchacha20 (out, _in, k, c) {\n  assert(out instanceof Uint8Array && out.length === 32, 'out is not an array of 32 bytes')\n  assert(k instanceof Uint8Array && k.length === 32, 'k is not an array of 32 bytes')\n  assert(c === null || (c instanceof Uint8Array && c.length === 16), 'c is not null or an array of 16 bytes')\n\n  let i = 0\n  const x = new Uint32Array(16)\n  if (!c) {\n    x[0] = 0x61707865\n    x[1] = 0x3320646E\n    x[2] = 0x79622D32\n    x[3] = 0x6B206574\n  } else {\n    x[0] = LOAD32_LE(c, 0)\n    x[1] = LOAD32_LE(c, 4)\n    x[2] = LOAD32_LE(c, 8)\n    x[3] = LOAD32_LE(c, 12)\n  }\n  x[4] = LOAD32_LE(k, 0)\n  x[5] = LOAD32_LE(k, 4)\n  x[6] = LOAD32_LE(k, 8)\n  x[7] = LOAD32_LE(k, 12)\n  x[8] = LOAD32_LE(k, 16)\n  x[9] = LOAD32_LE(k, 20)\n  x[10] = LOAD32_LE(k, 24)\n  x[11] = LOAD32_LE(k, 28)\n  x[12] = LOAD32_LE(_in, 0)\n  x[13] = LOAD32_LE(_in, 4)\n  x[14] = LOAD32_LE(_in, 8)\n  x[15] = LOAD32_LE(_in, 12)\n\n  for (i = 0; i < 10; i++) {\n    QUARTERROUND(x, 0, 4, 8, 12)\n    QUARTERROUND(x, 1, 5, 9, 13)\n    QUARTERROUND(x, 2, 6, 10, 14)\n    QUARTERROUND(x, 3, 7, 11, 15)\n    QUARTERROUND(x, 0, 5, 10, 15)\n    QUARTERROUND(x, 1, 6, 11, 12)\n    QUARTERROUND(x, 2, 7, 8, 13)\n    QUARTERROUND(x, 3, 4, 9, 14)\n  }\n\n  STORE32_LE(out, x[0], 0)\n  STORE32_LE(out, x[1], 4)\n  STORE32_LE(out, x[2], 8)\n  STORE32_LE(out, x[3], 12)\n  STORE32_LE(out, x[12], 16)\n  STORE32_LE(out, x[13], 20)\n  STORE32_LE(out, x[14], 24)\n  STORE32_LE(out, x[15], 28)\n\n  return 0\n}\n\nfunction crypto_core_hchacha20_outputbytes () {\n  return crypto_core_hchacha20_OUTPUTBYTES\n}\n\nfunction crypto_core_hchacha20_inputbytes () {\n  return crypto_core_hchacha20_INPUTBYTES\n}\n\nfunction crypto_core_hchacha20_keybytes () {\n  return crypto_core_hchacha20_KEYBYTES\n}\n\nfunction crypto_core_hchacha20_constbytes () {\n  return crypto_core_hchacha20_CONSTBYTES\n}\n\nvar hchacha20 = {\n  crypto_core_hchacha20_INPUTBYTES,\n  LOAD32_LE,\n  STORE32_LE,\n  QUARTERROUND,\n  crypto_core_hchacha20,\n  crypto_core_hchacha20_outputbytes,\n  crypto_core_hchacha20_inputbytes,\n  crypto_core_hchacha20_keybytes,\n  crypto_core_hchacha20_constbytes\n}\n\nexport default hchacha20;\nexport { hchacha20 as __moduleExports };","start":1670465471121,"end":1670465471123,"order":"normal"}]}
