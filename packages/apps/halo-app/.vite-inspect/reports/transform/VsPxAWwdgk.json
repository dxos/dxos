{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/converter.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(\"./enum\"),\n    util = require(\"./util\");\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                if (field.repeated && values[keys[i]] === field.typeDefault) gen\n                (\"default:\");\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","start":1670465470533,"end":1670465470634},{"name":"vite:react-babel","result":"\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(\"./enum\"),\n    util = require(\"./util\");\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                if (field.repeated && values[keys[i]] === field.typeDefault) gen\n                (\"default:\");\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","start":1670465470634,"end":1670465470634,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as converter_1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/converter.js?commonjs-exports\"\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar hasRequiredConverter;\n\nfunction requireConverter () {\n\tif (hasRequiredConverter) return converter_1;\n\thasRequiredConverter = 1;\n\t(function (exports) {\n\t\t\"use strict\";\n\t\t/**\n\t\t * Runtime message from/to plain object converters.\n\t\t * @namespace\n\t\t */\n\t\tvar converter = exports;\n\n\t\tvar Enum = require$$0(),\n\t\t    util = require$$1();\n\n\t\t/**\n\t\t * Generates a partial value fromObject conveter.\n\t\t * @param {Codegen} gen Codegen instance\n\t\t * @param {Field} field Reflected field\n\t\t * @param {number} fieldIndex Field index\n\t\t * @param {string} prop Property reference\n\t\t * @returns {Codegen} Codegen instance\n\t\t * @ignore\n\t\t */\n\t\tfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    if (field.resolvedType) {\n\t\t        if (field.resolvedType instanceof Enum) { gen\n\t\t            (\"switch(d%s){\", prop);\n\t\t            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n\t\t                if (field.repeated && values[keys[i]] === field.typeDefault) gen\n\t\t                (\"default:\");\n\t\t                gen\n\t\t                (\"case%j:\", keys[i])\n\t\t                (\"case %i:\", values[keys[i]])\n\t\t                    (\"m%s=%j\", prop, values[keys[i]])\n\t\t                    (\"break\");\n\t\t            } gen\n\t\t            (\"}\");\n\t\t        } else gen\n\t\t            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n\t\t                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n\t\t            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n\t\t    } else {\n\t\t        var isUnsigned = false;\n\t\t        switch (field.type) {\n\t\t            case \"double\":\n\t\t            case \"float\": gen\n\t\t                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n\t\t                break;\n\t\t            case \"uint32\":\n\t\t            case \"fixed32\": gen\n\t\t                (\"m%s=d%s>>>0\", prop, prop);\n\t\t                break;\n\t\t            case \"int32\":\n\t\t            case \"sint32\":\n\t\t            case \"sfixed32\": gen\n\t\t                (\"m%s=d%s|0\", prop, prop);\n\t\t                break;\n\t\t            case \"uint64\":\n\t\t                isUnsigned = true;\n\t\t                // eslint-disable-line no-fallthrough\n\t\t            case \"int64\":\n\t\t            case \"sint64\":\n\t\t            case \"fixed64\":\n\t\t            case \"sfixed64\": gen\n\t\t                (\"if(util.Long)\")\n\t\t                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n\t\t                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n\t\t                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n\t\t                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n\t\t                    (\"m%s=d%s\", prop, prop)\n\t\t                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n\t\t                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n\t\t                break;\n\t\t            case \"bytes\": gen\n\t\t                (\"if(typeof d%s===\\\"string\\\")\", prop)\n\t\t                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n\t\t                (\"else if(d%s.length)\", prop)\n\t\t                    (\"m%s=d%s\", prop, prop);\n\t\t                break;\n\t\t            case \"string\": gen\n\t\t                (\"m%s=String(d%s)\", prop, prop);\n\t\t                break;\n\t\t            case \"bool\": gen\n\t\t                (\"m%s=Boolean(d%s)\", prop, prop);\n\t\t                break;\n\t\t            /* default: gen\n\t\t                (\"m%s=d%s\", prop, prop);\n\t\t                break; */\n\t\t        }\n\t\t    }\n\t\t    return gen;\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t}\n\n\t\t/**\n\t\t * Generates a plain object to runtime message converter specific to the specified message type.\n\t\t * @param {Type} mtype Message type\n\t\t * @returns {Codegen} Codegen instance\n\t\t */\n\t\tconverter.fromObject = function fromObject(mtype) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    var fields = mtype.fieldsArray;\n\t\t    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n\t\t    (\"if(d instanceof this.ctor)\")\n\t\t        (\"return d\");\n\t\t    if (!fields.length) return gen\n\t\t    (\"return new this.ctor\");\n\t\t    gen\n\t\t    (\"var m=new this.ctor\");\n\t\t    for (var i = 0; i < fields.length; ++i) {\n\t\t        var field  = fields[i].resolve(),\n\t\t            prop   = util.safeProp(field.name);\n\n\t\t        // Map fields\n\t\t        if (field.map) { gen\n\t\t    (\"if(d%s){\", prop)\n\t\t        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n\t\t            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n\t\t        (\"m%s={}\", prop)\n\t\t        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n\t\t            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n\t\t        (\"}\")\n\t\t    (\"}\");\n\n\t\t        // Repeated fields\n\t\t        } else if (field.repeated) { gen\n\t\t    (\"if(d%s){\", prop)\n\t\t        (\"if(!Array.isArray(d%s))\", prop)\n\t\t            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n\t\t        (\"m%s=[]\", prop)\n\t\t        (\"for(var i=0;i<d%s.length;++i){\", prop);\n\t\t            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n\t\t        (\"}\")\n\t\t    (\"}\");\n\n\t\t        // Non-repeated fields\n\t\t        } else {\n\t\t            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n\t\t    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n\t\t        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n\t\t            if (!(field.resolvedType instanceof Enum)) gen\n\t\t    (\"}\");\n\t\t        }\n\t\t    } return gen\n\t\t    (\"return m\");\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t};\n\n\t\t/**\n\t\t * Generates a partial value toObject converter.\n\t\t * @param {Codegen} gen Codegen instance\n\t\t * @param {Field} field Reflected field\n\t\t * @param {number} fieldIndex Field index\n\t\t * @param {string} prop Property reference\n\t\t * @returns {Codegen} Codegen instance\n\t\t * @ignore\n\t\t */\n\t\tfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    if (field.resolvedType) {\n\t\t        if (field.resolvedType instanceof Enum) gen\n\t\t            (\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", prop, fieldIndex, prop, prop);\n\t\t        else gen\n\t\t            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n\t\t    } else {\n\t\t        var isUnsigned = false;\n\t\t        switch (field.type) {\n\t\t            case \"double\":\n\t\t            case \"float\": gen\n\t\t            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n\t\t                break;\n\t\t            case \"uint64\":\n\t\t                isUnsigned = true;\n\t\t                // eslint-disable-line no-fallthrough\n\t\t            case \"int64\":\n\t\t            case \"sint64\":\n\t\t            case \"fixed64\":\n\t\t            case \"sfixed64\": gen\n\t\t            (\"if(typeof m%s===\\\"number\\\")\", prop)\n\t\t                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n\t\t            (\"else\") // Long-like\n\t\t                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n\t\t                break;\n\t\t            case \"bytes\": gen\n\t\t            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n\t\t                break;\n\t\t            default: gen\n\t\t            (\"d%s=m%s\", prop, prop);\n\t\t                break;\n\t\t        }\n\t\t    }\n\t\t    return gen;\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t}\n\n\t\t/**\n\t\t * Generates a runtime message to plain object converter specific to the specified message type.\n\t\t * @param {Type} mtype Message type\n\t\t * @returns {Codegen} Codegen instance\n\t\t */\n\t\tconverter.toObject = function toObject(mtype) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\t\t    if (!fields.length)\n\t\t        return util.codegen()(\"return {}\");\n\t\t    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n\t\t    (\"if(!o)\")\n\t\t        (\"o={}\")\n\t\t    (\"var d={}\");\n\n\t\t    var repeatedFields = [],\n\t\t        mapFields = [],\n\t\t        normalFields = [],\n\t\t        i = 0;\n\t\t    for (; i < fields.length; ++i)\n\t\t        if (!fields[i].partOf)\n\t\t            ( fields[i].resolve().repeated ? repeatedFields\n\t\t            : fields[i].map ? mapFields\n\t\t            : normalFields).push(fields[i]);\n\n\t\t    if (repeatedFields.length) { gen\n\t\t    (\"if(o.arrays||o.defaults){\");\n\t\t        for (i = 0; i < repeatedFields.length; ++i) gen\n\t\t        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\n\t\t    if (mapFields.length) { gen\n\t\t    (\"if(o.objects||o.defaults){\");\n\t\t        for (i = 0; i < mapFields.length; ++i) gen\n\t\t        (\"d%s={}\", util.safeProp(mapFields[i].name));\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\n\t\t    if (normalFields.length) { gen\n\t\t    (\"if(o.defaults){\");\n\t\t        for (i = 0; i < normalFields.length; ++i) {\n\t\t            var field = normalFields[i],\n\t\t                prop  = util.safeProp(field.name);\n\t\t            if (field.resolvedType instanceof Enum) gen\n\t\t        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n\t\t            else if (field.long) gen\n\t\t        (\"if(util.Long){\")\n\t\t            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n\t\t            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n\t\t        (\"}else\")\n\t\t            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n\t\t            else if (field.bytes) {\n\t\t                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n\t\t                gen\n\t\t        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n\t\t        (\"else{\")\n\t\t            (\"d%s=%s\", prop, arrayDefault)\n\t\t            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n\t\t        (\"}\");\n\t\t            } else gen\n\t\t        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n\t\t        } gen\n\t\t    (\"}\");\n\t\t    }\n\t\t    var hasKs2 = false;\n\t\t    for (i = 0; i < fields.length; ++i) {\n\t\t        var field = fields[i],\n\t\t            index = mtype._fieldsArray.indexOf(field),\n\t\t            prop  = util.safeProp(field.name);\n\t\t        if (field.map) {\n\t\t            if (!hasKs2) { hasKs2 = true; gen\n\t\t    (\"var ks2\");\n\t\t            } gen\n\t\t    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n\t\t        (\"d%s={}\", prop)\n\t\t        (\"for(var j=0;j<ks2.length;++j){\");\n\t\t            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n\t\t        (\"}\");\n\t\t        } else if (field.repeated) { gen\n\t\t    (\"if(m%s&&m%s.length){\", prop, prop)\n\t\t        (\"d%s=[]\", prop)\n\t\t        (\"for(var j=0;j<m%s.length;++j){\", prop);\n\t\t            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n\t\t        (\"}\");\n\t\t        } else { gen\n\t\t    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n\t\t        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n\t\t        if (field.partOf) gen\n\t\t        (\"if(o.oneofs)\")\n\t\t            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n\t\t        }\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\t\t    return gen\n\t\t    (\"return d\");\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t};\n} (converter_1));\n\treturn converter_1;\n}\n\nexport { requireConverter as __require };","start":1670465470634,"end":1670465471407,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as converter_1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/converter.js?commonjs-exports\"\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar hasRequiredConverter;\n\nfunction requireConverter () {\n\tif (hasRequiredConverter) return converter_1;\n\thasRequiredConverter = 1;\n\t(function (exports) {\n\t\t\"use strict\";\n\t\t/**\n\t\t * Runtime message from/to plain object converters.\n\t\t * @namespace\n\t\t */\n\t\tvar converter = exports;\n\n\t\tvar Enum = require$$0(),\n\t\t    util = require$$1();\n\n\t\t/**\n\t\t * Generates a partial value fromObject conveter.\n\t\t * @param {Codegen} gen Codegen instance\n\t\t * @param {Field} field Reflected field\n\t\t * @param {number} fieldIndex Field index\n\t\t * @param {string} prop Property reference\n\t\t * @returns {Codegen} Codegen instance\n\t\t * @ignore\n\t\t */\n\t\tfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    if (field.resolvedType) {\n\t\t        if (field.resolvedType instanceof Enum) { gen\n\t\t            (\"switch(d%s){\", prop);\n\t\t            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n\t\t                if (field.repeated && values[keys[i]] === field.typeDefault) gen\n\t\t                (\"default:\");\n\t\t                gen\n\t\t                (\"case%j:\", keys[i])\n\t\t                (\"case %i:\", values[keys[i]])\n\t\t                    (\"m%s=%j\", prop, values[keys[i]])\n\t\t                    (\"break\");\n\t\t            } gen\n\t\t            (\"}\");\n\t\t        } else gen\n\t\t            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n\t\t                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n\t\t            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n\t\t    } else {\n\t\t        var isUnsigned = false;\n\t\t        switch (field.type) {\n\t\t            case \"double\":\n\t\t            case \"float\": gen\n\t\t                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n\t\t                break;\n\t\t            case \"uint32\":\n\t\t            case \"fixed32\": gen\n\t\t                (\"m%s=d%s>>>0\", prop, prop);\n\t\t                break;\n\t\t            case \"int32\":\n\t\t            case \"sint32\":\n\t\t            case \"sfixed32\": gen\n\t\t                (\"m%s=d%s|0\", prop, prop);\n\t\t                break;\n\t\t            case \"uint64\":\n\t\t                isUnsigned = true;\n\t\t                // eslint-disable-line no-fallthrough\n\t\t            case \"int64\":\n\t\t            case \"sint64\":\n\t\t            case \"fixed64\":\n\t\t            case \"sfixed64\": gen\n\t\t                (\"if(util.Long)\")\n\t\t                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n\t\t                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n\t\t                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n\t\t                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n\t\t                    (\"m%s=d%s\", prop, prop)\n\t\t                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n\t\t                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n\t\t                break;\n\t\t            case \"bytes\": gen\n\t\t                (\"if(typeof d%s===\\\"string\\\")\", prop)\n\t\t                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n\t\t                (\"else if(d%s.length)\", prop)\n\t\t                    (\"m%s=d%s\", prop, prop);\n\t\t                break;\n\t\t            case \"string\": gen\n\t\t                (\"m%s=String(d%s)\", prop, prop);\n\t\t                break;\n\t\t            case \"bool\": gen\n\t\t                (\"m%s=Boolean(d%s)\", prop, prop);\n\t\t                break;\n\t\t            /* default: gen\n\t\t                (\"m%s=d%s\", prop, prop);\n\t\t                break; */\n\t\t        }\n\t\t    }\n\t\t    return gen;\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t}\n\n\t\t/**\n\t\t * Generates a plain object to runtime message converter specific to the specified message type.\n\t\t * @param {Type} mtype Message type\n\t\t * @returns {Codegen} Codegen instance\n\t\t */\n\t\tconverter.fromObject = function fromObject(mtype) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    var fields = mtype.fieldsArray;\n\t\t    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n\t\t    (\"if(d instanceof this.ctor)\")\n\t\t        (\"return d\");\n\t\t    if (!fields.length) return gen\n\t\t    (\"return new this.ctor\");\n\t\t    gen\n\t\t    (\"var m=new this.ctor\");\n\t\t    for (var i = 0; i < fields.length; ++i) {\n\t\t        var field  = fields[i].resolve(),\n\t\t            prop   = util.safeProp(field.name);\n\n\t\t        // Map fields\n\t\t        if (field.map) { gen\n\t\t    (\"if(d%s){\", prop)\n\t\t        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n\t\t            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n\t\t        (\"m%s={}\", prop)\n\t\t        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n\t\t            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n\t\t        (\"}\")\n\t\t    (\"}\");\n\n\t\t        // Repeated fields\n\t\t        } else if (field.repeated) { gen\n\t\t    (\"if(d%s){\", prop)\n\t\t        (\"if(!Array.isArray(d%s))\", prop)\n\t\t            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n\t\t        (\"m%s=[]\", prop)\n\t\t        (\"for(var i=0;i<d%s.length;++i){\", prop);\n\t\t            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n\t\t        (\"}\")\n\t\t    (\"}\");\n\n\t\t        // Non-repeated fields\n\t\t        } else {\n\t\t            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n\t\t    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n\t\t        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n\t\t            if (!(field.resolvedType instanceof Enum)) gen\n\t\t    (\"}\");\n\t\t        }\n\t\t    } return gen\n\t\t    (\"return m\");\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t};\n\n\t\t/**\n\t\t * Generates a partial value toObject converter.\n\t\t * @param {Codegen} gen Codegen instance\n\t\t * @param {Field} field Reflected field\n\t\t * @param {number} fieldIndex Field index\n\t\t * @param {string} prop Property reference\n\t\t * @returns {Codegen} Codegen instance\n\t\t * @ignore\n\t\t */\n\t\tfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    if (field.resolvedType) {\n\t\t        if (field.resolvedType instanceof Enum) gen\n\t\t            (\"d%s=o.enums===String?types[%i].values[m%s]:m%s\", prop, fieldIndex, prop, prop);\n\t\t        else gen\n\t\t            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n\t\t    } else {\n\t\t        var isUnsigned = false;\n\t\t        switch (field.type) {\n\t\t            case \"double\":\n\t\t            case \"float\": gen\n\t\t            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n\t\t                break;\n\t\t            case \"uint64\":\n\t\t                isUnsigned = true;\n\t\t                // eslint-disable-line no-fallthrough\n\t\t            case \"int64\":\n\t\t            case \"sint64\":\n\t\t            case \"fixed64\":\n\t\t            case \"sfixed64\": gen\n\t\t            (\"if(typeof m%s===\\\"number\\\")\", prop)\n\t\t                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n\t\t            (\"else\") // Long-like\n\t\t                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n\t\t                break;\n\t\t            case \"bytes\": gen\n\t\t            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n\t\t                break;\n\t\t            default: gen\n\t\t            (\"d%s=m%s\", prop, prop);\n\t\t                break;\n\t\t        }\n\t\t    }\n\t\t    return gen;\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t}\n\n\t\t/**\n\t\t * Generates a runtime message to plain object converter specific to the specified message type.\n\t\t * @param {Type} mtype Message type\n\t\t * @returns {Codegen} Codegen instance\n\t\t */\n\t\tconverter.toObject = function toObject(mtype) {\n\t\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\t\t    if (!fields.length)\n\t\t        return util.codegen()(\"return {}\");\n\t\t    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n\t\t    (\"if(!o)\")\n\t\t        (\"o={}\")\n\t\t    (\"var d={}\");\n\n\t\t    var repeatedFields = [],\n\t\t        mapFields = [],\n\t\t        normalFields = [],\n\t\t        i = 0;\n\t\t    for (; i < fields.length; ++i)\n\t\t        if (!fields[i].partOf)\n\t\t            ( fields[i].resolve().repeated ? repeatedFields\n\t\t            : fields[i].map ? mapFields\n\t\t            : normalFields).push(fields[i]);\n\n\t\t    if (repeatedFields.length) { gen\n\t\t    (\"if(o.arrays||o.defaults){\");\n\t\t        for (i = 0; i < repeatedFields.length; ++i) gen\n\t\t        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\n\t\t    if (mapFields.length) { gen\n\t\t    (\"if(o.objects||o.defaults){\");\n\t\t        for (i = 0; i < mapFields.length; ++i) gen\n\t\t        (\"d%s={}\", util.safeProp(mapFields[i].name));\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\n\t\t    if (normalFields.length) { gen\n\t\t    (\"if(o.defaults){\");\n\t\t        for (i = 0; i < normalFields.length; ++i) {\n\t\t            var field = normalFields[i],\n\t\t                prop  = util.safeProp(field.name);\n\t\t            if (field.resolvedType instanceof Enum) gen\n\t\t        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n\t\t            else if (field.long) gen\n\t\t        (\"if(util.Long){\")\n\t\t            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n\t\t            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n\t\t        (\"}else\")\n\t\t            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n\t\t            else if (field.bytes) {\n\t\t                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n\t\t                gen\n\t\t        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n\t\t        (\"else{\")\n\t\t            (\"d%s=%s\", prop, arrayDefault)\n\t\t            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n\t\t        (\"}\");\n\t\t            } else gen\n\t\t        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n\t\t        } gen\n\t\t    (\"}\");\n\t\t    }\n\t\t    var hasKs2 = false;\n\t\t    for (i = 0; i < fields.length; ++i) {\n\t\t        var field = fields[i],\n\t\t            index = mtype._fieldsArray.indexOf(field),\n\t\t            prop  = util.safeProp(field.name);\n\t\t        if (field.map) {\n\t\t            if (!hasKs2) { hasKs2 = true; gen\n\t\t    (\"var ks2\");\n\t\t            } gen\n\t\t    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n\t\t        (\"d%s={}\", prop)\n\t\t        (\"for(var j=0;j<ks2.length;++j){\");\n\t\t            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n\t\t        (\"}\");\n\t\t        } else if (field.repeated) { gen\n\t\t    (\"if(m%s&&m%s.length){\", prop, prop)\n\t\t        (\"d%s=[]\", prop)\n\t\t        (\"for(var j=0;j<m%s.length;++j){\", prop);\n\t\t            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n\t\t        (\"}\");\n\t\t        } else { gen\n\t\t    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n\t\t        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n\t\t        if (field.partOf) gen\n\t\t        (\"if(o.oneofs)\")\n\t\t            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n\t\t        }\n\t\t        gen\n\t\t    (\"}\");\n\t\t    }\n\t\t    return gen\n\t\t    (\"return d\");\n\t\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t\t};\n} (converter_1));\n\treturn converter_1;\n}\n\nexport { requireConverter as __require };","start":1670465471408,"end":1670465471415,"order":"normal"}]}
