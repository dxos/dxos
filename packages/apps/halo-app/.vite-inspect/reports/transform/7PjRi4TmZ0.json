{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/rpc/src/rpc.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { asyncTimeout, synchronized, Trigger } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { StackTrace } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { exponentialBackoffInterval } from \"@dxos/util\";\n\n// packages/core/mesh/rpc/src/errors.ts\nvar SerializedRpcError = class extends Error {\n  constructor(name, message, remoteStack, rpcMethod) {\n    super(message);\n    this.remoteStack = remoteStack;\n    this.rpcMethod = rpcMethod;\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = name;\n    this.stack = remoteStack + `\n at RPC call: ${rpcMethod} \n` + preprocessStack(this.stack);\n  }\n};\nvar preprocessStack = (stack) => {\n  const match = /^\\s+at/gm.exec(stack);\n  if (!match) {\n    return stack;\n  }\n  return stack.slice(match.index);\n};\nvar RpcClosedError = class extends Error {\n  constructor() {\n    super(\"Request was terminated because the RPC endpoint is closed.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar RpcNotOpenError = class extends Error {\n  constructor() {\n    super(\"RPC has not been opened.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// packages/core/mesh/rpc/src/rpc.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_TIMEOUT = 3e3;\nvar PendingRpcRequest = class {\n  constructor(resolve, reject, stream) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.stream = stream;\n  }\n};\nvar codec = schema.getCodecForType(\"dxos.rpc.RpcMessage\");\nvar RpcPeer = class {\n  constructor(_options) {\n    this._options = _options;\n    this._outgoingRequests = /* @__PURE__ */ new Map();\n    this._localStreams = /* @__PURE__ */ new Map();\n    this._remoteOpenTrigger = new Trigger();\n    this._nextId = 0;\n    this._open = false;\n  }\n  async open() {\n    var _a;\n    if (this._open) {\n      return;\n    }\n    this._unsubscribe = this._options.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err) {\n        log.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 96,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    this._open = true;\n    if (this._options.noHandshake) {\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n    log(\"sending open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 107,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      open: true\n    });\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({\n        open: true\n      }).catch((err) => log.warn(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 112,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }, 50);\n    await this._remoteOpenTrigger.wait();\n    (_a = this._clearOpenInterval) == null ? void 0 : _a.call(this);\n    log(\"sending second open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      openAck: true\n    });\n  }\n  async close() {\n    var _a, _b;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    (_b = this._clearOpenInterval) == null ? void 0 : _b.call(this);\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n    this._open = false;\n  }\n  async _receive(msg) {\n    var _a, _b;\n    const decoded = codec.decode(msg, {\n      preserveAny: true\n    });\n    if (decoded.request) {\n      if (!this._open) {\n        log(\"received request while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 146,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError())\n          }\n        });\n        return;\n      }\n      const req = decoded.request;\n      if (req.stream) {\n        log(\"stream request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 158,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._callStreamHandler(req, (response) => {\n          var _a2;\n          log(\"sending stream response\", {\n            method: req.method,\n            response: (_a2 = response.payload) == null ? void 0 : _a2.type_url,\n            error: response.error,\n            close: response.close\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 160,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          void this._sendMessage({\n            response\n          }).catch((err) => {\n            log.warn(\"failed during close\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n              line: 168,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          });\n        });\n      } else {\n        log(\"request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 172,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const response = await this._callHandler(req);\n        log(\"sending response\", {\n          method: req.method,\n          response: (_a = response.payload) == null ? void 0 : _a.type_url,\n          error: response.error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 175,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response\n        });\n      }\n    } else if (decoded.response) {\n      if (!this._open) {\n        log(\"received response while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 184,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const responseId = decoded.response.id;\n      assert(typeof responseId === \"number\");\n      if (!this._outgoingRequests.has(responseId)) {\n        log(\"received response with invalid id\", {\n          responseId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 191,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const item = this._outgoingRequests.get(responseId);\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n      log(\"response\", {\n        type_url: (_b = decoded.response.payload) == null ? void 0 : _b.type_url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log(\"received open message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 204,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      await this._sendMessage({\n        openAck: true\n      });\n    } else if (decoded.openAck) {\n      log(\"received openAck message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 211,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (!this._open) {\n        log(\"received stream close while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 219,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"received stream close\", {\n        id: decoded.streamClose.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 223,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert(typeof decoded.streamClose.id === \"number\");\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log(\"no local stream\", {\n          id: decoded.streamClose.id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 227,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      this._localStreams.delete(decoded.streamClose.id);\n      stream.close();\n    } else {\n      log.error(\"received malformed message\", {\n        msg\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 234,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw new Error(\"Malformed message.\");\n    }\n  }\n  async call(method, request) {\n    var _a, _b, _c, _d;\n    log(\"calling\", {\n      method\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 244,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    let response;\n    try {\n      const id = this._nextId++;\n      const responseReceived = new Promise((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false\n        }\n      });\n      const waiting = asyncTimeout(responseReceived, (_a = this._options.timeout) != null ? _a : DEFAULT_TIMEOUT);\n      await Promise.race([\n        sending,\n        waiting\n      ]);\n      response = await waiting;\n      assert(response.id === id);\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        const error = new RpcClosedError();\n        error.stack += `\n\nRPC client was closed at:\n${err.stack}`;\n        throw error;\n      }\n      throw err;\n    }\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw new SerializedRpcError((_b = response.error.name) != null ? _b : \"Error\", (_c = response.error.message) != null ? _c : \"Unknown Error\", (_d = response.error.stack) != null ? _d : \"\", method);\n    } else {\n      throw new Error(\"Malformed response.\");\n    }\n  }\n  callStream(method, request) {\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    const id = this._nextId++;\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response) => {\n        var _a, _b, _c;\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          close(new SerializedRpcError((_a = response.error.name) != null ? _a : \"Error\", (_b = response.error.message) != null ? _b : \"Unknown Error\", (_c = response.error.stack) != null ? _c : \"\", method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error(\"Malformed response.\");\n        }\n      };\n      const stack = new StackTrace();\n      const closeStream = (err) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\n\nError happened in the stream at:\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true\n        }\n      }).catch((err) => {\n        close(err);\n      });\n      return () => {\n        this._sendMessage({\n          streamClose: {\n            id\n          }\n        }).catch((err) => {\n          log.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 359,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      };\n    });\n  }\n  async _sendMessage(message) {\n    await this._options.port.send(codec.encode(message, {\n      preserveAny: true\n    }));\n  }\n  async _callHandler(req) {\n    try {\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const response = await this._options.callHandler(req.method, req.payload);\n      return {\n        id: req.id,\n        payload: response\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err)\n      };\n    }\n  }\n  _callStreamHandler(req, callback) {\n    try {\n      assert(this._options.streamHandler, \"Requests with streaming responses are not supported.\");\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const responseStream = this._options.streamHandler(req.method, req.payload);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true\n        });\n      });\n      responseStream.subscribe((msg) => {\n        callback({\n          id: req.id,\n          payload: msg\n        });\n      }, (error) => {\n        if (error) {\n          callback({\n            id: req.id,\n            error: encodeError(error)\n          });\n        } else {\n          callback({\n            id: req.id,\n            close: true\n          });\n        }\n      });\n      this._localStreams.set(req.id, responseStream);\n    } catch (err) {\n      callback({\n        id: req.id,\n        error: encodeError(err)\n      });\n    }\n  }\n};\n__decorate([\n  synchronized\n], RpcPeer.prototype, \"open\", null);\nvar encodeError = (err) => {\n  if (typeof err === \"object\" && (err == null ? void 0 : err.message)) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  } else if (typeof err === \"string\") {\n    return {\n      message: err\n    };\n  } else {\n    return {\n      message: JSON.stringify(err)\n    };\n  }\n};\n\n// packages/core/mesh/rpc/src/service.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createServiceBundle = (services) => services;\nvar ProtoRpcPeer = class {\n  constructor(rpc, _peer) {\n    this.rpc = rpc;\n    this._peer = _peer;\n  }\n  async open() {\n    await this._peer.open();\n  }\n  async close() {\n    await this._peer.close();\n  }\n};\nvar createProtoRpcPeer = ({ requested, exposed, handlers, encodingOptions, ...rest }) => {\n  const exposedRpcs = {};\n  if (exposed) {\n    assert2(handlers);\n    for (const serviceName of Object.keys(exposed)) {\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n  const peer = new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].callStream(methodName, request);\n    }\n  });\n  const requestedRpcs = {};\n  if (requested) {\n    for (const serviceName1 of Object.keys(requested)) {\n      const serviceFqn1 = requested[serviceName1].serviceProto.fullName.slice(1);\n      requestedRpcs[serviceName1] = requested[serviceName1].createClient({\n        call: (method, req) => peer.call(`${serviceFqn1}.${method}`, req),\n        callStream: (method, req) => peer.callStream(`${serviceFqn1}.${method}`, req)\n      }, encodingOptions);\n    }\n  }\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\nvar parseMethodName = (method) => {\n  const separator = method.lastIndexOf(\".\");\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n  return [\n    serviceName,\n    methodName\n  ];\n};\nvar createRpcClient = (serviceDef, options) => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error(\"Requests to client are not supported.\");\n    }\n  });\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer)\n  });\n  return new ProtoRpcPeer(client, peer);\n};\nvar createRpcServer = ({ service, handlers, ...rest }) => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server)\n  });\n};\nvar createBundledRpcClient = (descriptors, options) => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options\n  });\n};\nvar createBundledRpcServer = ({ services, handlers, ...rest }) => {\n  const rpc = {};\n  for (const serviceName of Object.keys(services)) {\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName]);\n  }\n  return new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].callStream(methodName, request);\n    }\n  });\n};\n\n// packages/core/mesh/rpc/src/testing.ts\nvar createLinkedPorts = () => {\n  let port1Received;\n  let port2Received;\n  const port1 = {\n    send: (msg) => port2Received == null ? void 0 : port2Received(msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    }\n  };\n  const port2 = {\n    send: (msg) => port1Received == null ? void 0 : port1Received(msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    }\n  };\n  return [\n    port1,\n    port2\n  ];\n};\n\n// packages/core/mesh/rpc/src/trace.ts\nimport { Event } from \"@dxos/async\";\nimport { MessageTrace } from \"@dxos/protocols/proto/dxos/rpc\";\nvar PortTracer = class {\n  constructor(_wrappedPort) {\n    this._wrappedPort = _wrappedPort;\n    this.message = new Event();\n    this._port = {\n      send: (msg) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg\n        });\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg\n          });\n          cb(msg);\n        });\n      }\n    };\n  }\n  get port() {\n    return this._port;\n  }\n};\nexport {\n  PortTracer,\n  ProtoRpcPeer,\n  RpcClosedError,\n  RpcNotOpenError,\n  RpcPeer,\n  SerializedRpcError,\n  createBundledRpcClient,\n  createBundledRpcServer,\n  createLinkedPorts,\n  createProtoRpcPeer,\n  createRpcClient,\n  createRpcServer,\n  createServiceBundle\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465436,"end":1670465466203},{"name":"vite:react-babel","result":"// packages/core/mesh/rpc/src/rpc.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { asyncTimeout, synchronized, Trigger } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { StackTrace } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { exponentialBackoffInterval } from \"@dxos/util\";\n\n// packages/core/mesh/rpc/src/errors.ts\nvar SerializedRpcError = class extends Error {\n  constructor(name, message, remoteStack, rpcMethod) {\n    super(message);\n    this.remoteStack = remoteStack;\n    this.rpcMethod = rpcMethod;\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = name;\n    this.stack = remoteStack + `\n at RPC call: ${rpcMethod} \n` + preprocessStack(this.stack);\n  }\n};\nvar preprocessStack = (stack) => {\n  const match = /^\\s+at/gm.exec(stack);\n  if (!match) {\n    return stack;\n  }\n  return stack.slice(match.index);\n};\nvar RpcClosedError = class extends Error {\n  constructor() {\n    super(\"Request was terminated because the RPC endpoint is closed.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar RpcNotOpenError = class extends Error {\n  constructor() {\n    super(\"RPC has not been opened.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// packages/core/mesh/rpc/src/rpc.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_TIMEOUT = 3e3;\nvar PendingRpcRequest = class {\n  constructor(resolve, reject, stream) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.stream = stream;\n  }\n};\nvar codec = schema.getCodecForType(\"dxos.rpc.RpcMessage\");\nvar RpcPeer = class {\n  constructor(_options) {\n    this._options = _options;\n    this._outgoingRequests = /* @__PURE__ */ new Map();\n    this._localStreams = /* @__PURE__ */ new Map();\n    this._remoteOpenTrigger = new Trigger();\n    this._nextId = 0;\n    this._open = false;\n  }\n  async open() {\n    var _a;\n    if (this._open) {\n      return;\n    }\n    this._unsubscribe = this._options.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err) {\n        log.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 96,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    this._open = true;\n    if (this._options.noHandshake) {\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n    log(\"sending open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 107,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      open: true\n    });\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({\n        open: true\n      }).catch((err) => log.warn(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 112,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }, 50);\n    await this._remoteOpenTrigger.wait();\n    (_a = this._clearOpenInterval) == null ? void 0 : _a.call(this);\n    log(\"sending second open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      openAck: true\n    });\n  }\n  async close() {\n    var _a, _b;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    (_b = this._clearOpenInterval) == null ? void 0 : _b.call(this);\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n    this._open = false;\n  }\n  async _receive(msg) {\n    var _a, _b;\n    const decoded = codec.decode(msg, {\n      preserveAny: true\n    });\n    if (decoded.request) {\n      if (!this._open) {\n        log(\"received request while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 146,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError())\n          }\n        });\n        return;\n      }\n      const req = decoded.request;\n      if (req.stream) {\n        log(\"stream request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 158,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._callStreamHandler(req, (response) => {\n          var _a2;\n          log(\"sending stream response\", {\n            method: req.method,\n            response: (_a2 = response.payload) == null ? void 0 : _a2.type_url,\n            error: response.error,\n            close: response.close\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 160,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          void this._sendMessage({\n            response\n          }).catch((err) => {\n            log.warn(\"failed during close\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n              line: 168,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          });\n        });\n      } else {\n        log(\"request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 172,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const response = await this._callHandler(req);\n        log(\"sending response\", {\n          method: req.method,\n          response: (_a = response.payload) == null ? void 0 : _a.type_url,\n          error: response.error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 175,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response\n        });\n      }\n    } else if (decoded.response) {\n      if (!this._open) {\n        log(\"received response while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 184,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const responseId = decoded.response.id;\n      assert(typeof responseId === \"number\");\n      if (!this._outgoingRequests.has(responseId)) {\n        log(\"received response with invalid id\", {\n          responseId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 191,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const item = this._outgoingRequests.get(responseId);\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n      log(\"response\", {\n        type_url: (_b = decoded.response.payload) == null ? void 0 : _b.type_url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log(\"received open message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 204,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      await this._sendMessage({\n        openAck: true\n      });\n    } else if (decoded.openAck) {\n      log(\"received openAck message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 211,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (!this._open) {\n        log(\"received stream close while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 219,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"received stream close\", {\n        id: decoded.streamClose.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 223,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert(typeof decoded.streamClose.id === \"number\");\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log(\"no local stream\", {\n          id: decoded.streamClose.id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 227,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      this._localStreams.delete(decoded.streamClose.id);\n      stream.close();\n    } else {\n      log.error(\"received malformed message\", {\n        msg\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 234,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw new Error(\"Malformed message.\");\n    }\n  }\n  async call(method, request) {\n    var _a, _b, _c, _d;\n    log(\"calling\", {\n      method\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 244,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    let response;\n    try {\n      const id = this._nextId++;\n      const responseReceived = new Promise((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false\n        }\n      });\n      const waiting = asyncTimeout(responseReceived, (_a = this._options.timeout) != null ? _a : DEFAULT_TIMEOUT);\n      await Promise.race([\n        sending,\n        waiting\n      ]);\n      response = await waiting;\n      assert(response.id === id);\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        const error = new RpcClosedError();\n        error.stack += `\n\nRPC client was closed at:\n${err.stack}`;\n        throw error;\n      }\n      throw err;\n    }\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw new SerializedRpcError((_b = response.error.name) != null ? _b : \"Error\", (_c = response.error.message) != null ? _c : \"Unknown Error\", (_d = response.error.stack) != null ? _d : \"\", method);\n    } else {\n      throw new Error(\"Malformed response.\");\n    }\n  }\n  callStream(method, request) {\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    const id = this._nextId++;\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response) => {\n        var _a, _b, _c;\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          close(new SerializedRpcError((_a = response.error.name) != null ? _a : \"Error\", (_b = response.error.message) != null ? _b : \"Unknown Error\", (_c = response.error.stack) != null ? _c : \"\", method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error(\"Malformed response.\");\n        }\n      };\n      const stack = new StackTrace();\n      const closeStream = (err) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\n\nError happened in the stream at:\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true\n        }\n      }).catch((err) => {\n        close(err);\n      });\n      return () => {\n        this._sendMessage({\n          streamClose: {\n            id\n          }\n        }).catch((err) => {\n          log.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 359,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      };\n    });\n  }\n  async _sendMessage(message) {\n    await this._options.port.send(codec.encode(message, {\n      preserveAny: true\n    }));\n  }\n  async _callHandler(req) {\n    try {\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const response = await this._options.callHandler(req.method, req.payload);\n      return {\n        id: req.id,\n        payload: response\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err)\n      };\n    }\n  }\n  _callStreamHandler(req, callback) {\n    try {\n      assert(this._options.streamHandler, \"Requests with streaming responses are not supported.\");\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const responseStream = this._options.streamHandler(req.method, req.payload);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true\n        });\n      });\n      responseStream.subscribe((msg) => {\n        callback({\n          id: req.id,\n          payload: msg\n        });\n      }, (error) => {\n        if (error) {\n          callback({\n            id: req.id,\n            error: encodeError(error)\n          });\n        } else {\n          callback({\n            id: req.id,\n            close: true\n          });\n        }\n      });\n      this._localStreams.set(req.id, responseStream);\n    } catch (err) {\n      callback({\n        id: req.id,\n        error: encodeError(err)\n      });\n    }\n  }\n};\n__decorate([\n  synchronized\n], RpcPeer.prototype, \"open\", null);\nvar encodeError = (err) => {\n  if (typeof err === \"object\" && (err == null ? void 0 : err.message)) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  } else if (typeof err === \"string\") {\n    return {\n      message: err\n    };\n  } else {\n    return {\n      message: JSON.stringify(err)\n    };\n  }\n};\n\n// packages/core/mesh/rpc/src/service.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createServiceBundle = (services) => services;\nvar ProtoRpcPeer = class {\n  constructor(rpc, _peer) {\n    this.rpc = rpc;\n    this._peer = _peer;\n  }\n  async open() {\n    await this._peer.open();\n  }\n  async close() {\n    await this._peer.close();\n  }\n};\nvar createProtoRpcPeer = ({ requested, exposed, handlers, encodingOptions, ...rest }) => {\n  const exposedRpcs = {};\n  if (exposed) {\n    assert2(handlers);\n    for (const serviceName of Object.keys(exposed)) {\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n  const peer = new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].callStream(methodName, request);\n    }\n  });\n  const requestedRpcs = {};\n  if (requested) {\n    for (const serviceName1 of Object.keys(requested)) {\n      const serviceFqn1 = requested[serviceName1].serviceProto.fullName.slice(1);\n      requestedRpcs[serviceName1] = requested[serviceName1].createClient({\n        call: (method, req) => peer.call(`${serviceFqn1}.${method}`, req),\n        callStream: (method, req) => peer.callStream(`${serviceFqn1}.${method}`, req)\n      }, encodingOptions);\n    }\n  }\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\nvar parseMethodName = (method) => {\n  const separator = method.lastIndexOf(\".\");\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n  return [\n    serviceName,\n    methodName\n  ];\n};\nvar createRpcClient = (serviceDef, options) => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error(\"Requests to client are not supported.\");\n    }\n  });\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer)\n  });\n  return new ProtoRpcPeer(client, peer);\n};\nvar createRpcServer = ({ service, handlers, ...rest }) => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server)\n  });\n};\nvar createBundledRpcClient = (descriptors, options) => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options\n  });\n};\nvar createBundledRpcServer = ({ services, handlers, ...rest }) => {\n  const rpc = {};\n  for (const serviceName of Object.keys(services)) {\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName]);\n  }\n  return new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].callStream(methodName, request);\n    }\n  });\n};\n\n// packages/core/mesh/rpc/src/testing.ts\nvar createLinkedPorts = () => {\n  let port1Received;\n  let port2Received;\n  const port1 = {\n    send: (msg) => port2Received == null ? void 0 : port2Received(msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    }\n  };\n  const port2 = {\n    send: (msg) => port1Received == null ? void 0 : port1Received(msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    }\n  };\n  return [\n    port1,\n    port2\n  ];\n};\n\n// packages/core/mesh/rpc/src/trace.ts\nimport { Event } from \"@dxos/async\";\nimport { MessageTrace } from \"@dxos/protocols/proto/dxos/rpc\";\nvar PortTracer = class {\n  constructor(_wrappedPort) {\n    this._wrappedPort = _wrappedPort;\n    this.message = new Event();\n    this._port = {\n      send: (msg) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg\n        });\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg\n          });\n          cb(msg);\n        });\n      }\n    };\n  }\n  get port() {\n    return this._port;\n  }\n};\nexport {\n  PortTracer,\n  ProtoRpcPeer,\n  RpcClosedError,\n  RpcNotOpenError,\n  RpcPeer,\n  SerializedRpcError,\n  createBundledRpcClient,\n  createBundledRpcServer,\n  createLinkedPorts,\n  createProtoRpcPeer,\n  createRpcClient,\n  createRpcServer,\n  createServiceBundle\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466203,"end":1670465466203,"order":"pre"},{"name":"polyfill-node","result":"// packages/core/mesh/rpc/src/rpc.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { asyncTimeout, synchronized, Trigger } from \"@dxos/async\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { StackTrace } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { exponentialBackoffInterval } from \"@dxos/util\";\n\n// packages/core/mesh/rpc/src/errors.ts\nvar SerializedRpcError = class extends Error {\n  constructor(name, message, remoteStack, rpcMethod) {\n    super(message);\n    this.remoteStack = remoteStack;\n    this.rpcMethod = rpcMethod;\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = name;\n    this.stack = remoteStack + `\n at RPC call: ${rpcMethod} \n` + preprocessStack(this.stack);\n  }\n};\nvar preprocessStack = (stack) => {\n  const match = /^\\s+at/gm.exec(stack);\n  if (!match) {\n    return stack;\n  }\n  return stack.slice(match.index);\n};\nvar RpcClosedError = class extends Error {\n  constructor() {\n    super(\"Request was terminated because the RPC endpoint is closed.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\nvar RpcNotOpenError = class extends Error {\n  constructor() {\n    super(\"RPC has not been opened.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// packages/core/mesh/rpc/src/rpc.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_TIMEOUT = 3e3;\nvar PendingRpcRequest = class {\n  constructor(resolve, reject, stream) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.stream = stream;\n  }\n};\nvar codec = schema.getCodecForType(\"dxos.rpc.RpcMessage\");\nvar RpcPeer = class {\n  constructor(_options) {\n    this._options = _options;\n    this._outgoingRequests = /* @__PURE__ */ new Map();\n    this._localStreams = /* @__PURE__ */ new Map();\n    this._remoteOpenTrigger = new Trigger();\n    this._nextId = 0;\n    this._open = false;\n  }\n  async open() {\n    var _a;\n    if (this._open) {\n      return;\n    }\n    this._unsubscribe = this._options.port.subscribe(async (msg) => {\n      try {\n        await this._receive(msg);\n      } catch (err) {\n        log.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 96,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    this._open = true;\n    if (this._options.noHandshake) {\n      this._remoteOpenTrigger.wake();\n      return;\n    }\n    log(\"sending open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 107,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      open: true\n    });\n    this._clearOpenInterval = exponentialBackoffInterval(() => {\n      void this._sendMessage({\n        open: true\n      }).catch((err) => log.warn(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 112,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }, 50);\n    await this._remoteOpenTrigger.wait();\n    (_a = this._clearOpenInterval) == null ? void 0 : _a.call(this);\n    log(\"sending second open message\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._sendMessage({\n      openAck: true\n    });\n  }\n  async close() {\n    var _a, _b;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    (_b = this._clearOpenInterval) == null ? void 0 : _b.call(this);\n    for (const req of this._outgoingRequests.values()) {\n      req.reject(new RpcClosedError());\n    }\n    this._outgoingRequests.clear();\n    this._open = false;\n  }\n  async _receive(msg) {\n    var _a, _b;\n    const decoded = codec.decode(msg, {\n      preserveAny: true\n    });\n    if (decoded.request) {\n      if (!this._open) {\n        log(\"received request while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 146,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response: {\n            id: decoded.request.id,\n            error: encodeError(new RpcClosedError())\n          }\n        });\n        return;\n      }\n      const req = decoded.request;\n      if (req.stream) {\n        log(\"stream request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 158,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._callStreamHandler(req, (response) => {\n          var _a2;\n          log(\"sending stream response\", {\n            method: req.method,\n            response: (_a2 = response.payload) == null ? void 0 : _a2.type_url,\n            error: response.error,\n            close: response.close\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 160,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          void this._sendMessage({\n            response\n          }).catch((err) => {\n            log.warn(\"failed during close\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n              line: 168,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          });\n        });\n      } else {\n        log(\"request\", {\n          method: req.method\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 172,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const response = await this._callHandler(req);\n        log(\"sending response\", {\n          method: req.method,\n          response: (_a = response.payload) == null ? void 0 : _a.type_url,\n          error: response.error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 175,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await this._sendMessage({\n          response\n        });\n      }\n    } else if (decoded.response) {\n      if (!this._open) {\n        log(\"received response while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 184,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const responseId = decoded.response.id;\n      assert(typeof responseId === \"number\");\n      if (!this._outgoingRequests.has(responseId)) {\n        log(\"received response with invalid id\", {\n          responseId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 191,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      const item = this._outgoingRequests.get(responseId);\n      if (!item.stream) {\n        this._outgoingRequests.delete(responseId);\n      }\n      log(\"response\", {\n        type_url: (_b = decoded.response.payload) == null ? void 0 : _b.type_url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      item.resolve(decoded.response);\n    } else if (decoded.open) {\n      log(\"received open message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 204,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      await this._sendMessage({\n        openAck: true\n      });\n    } else if (decoded.openAck) {\n      log(\"received openAck message\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 211,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._options.noHandshake) {\n        return;\n      }\n      this._remoteOpenTrigger.wake();\n    } else if (decoded.streamClose) {\n      if (!this._open) {\n        log(\"received stream close while closed\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 219,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"received stream close\", {\n        id: decoded.streamClose.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 223,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      assert(typeof decoded.streamClose.id === \"number\");\n      const stream = this._localStreams.get(decoded.streamClose.id);\n      if (!stream) {\n        log(\"no local stream\", {\n          id: decoded.streamClose.id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n          line: 227,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      this._localStreams.delete(decoded.streamClose.id);\n      stream.close();\n    } else {\n      log.error(\"received malformed message\", {\n        msg\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n        line: 234,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      throw new Error(\"Malformed message.\");\n    }\n  }\n  async call(method, request) {\n    var _a, _b, _c, _d;\n    log(\"calling\", {\n      method\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n      line: 244,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    let response;\n    try {\n      const id = this._nextId++;\n      const responseReceived = new Promise((resolve, reject) => {\n        this._outgoingRequests.set(id, new PendingRpcRequest(resolve, reject, false));\n      });\n      const sending = this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: false\n        }\n      });\n      const waiting = asyncTimeout(responseReceived, (_a = this._options.timeout) != null ? _a : DEFAULT_TIMEOUT);\n      await Promise.race([\n        sending,\n        waiting\n      ]);\n      response = await waiting;\n      assert(response.id === id);\n    } catch (err) {\n      if (err instanceof RpcClosedError) {\n        const error = new RpcClosedError();\n        error.stack += `\n\nRPC client was closed at:\n${err.stack}`;\n        throw error;\n      }\n      throw err;\n    }\n    if (response.payload) {\n      return response.payload;\n    } else if (response.error) {\n      throw new SerializedRpcError((_b = response.error.name) != null ? _b : \"Error\", (_c = response.error.message) != null ? _c : \"Unknown Error\", (_d = response.error.stack) != null ? _d : \"\", method);\n    } else {\n      throw new Error(\"Malformed response.\");\n    }\n  }\n  callStream(method, request) {\n    if (!this._open) {\n      throw new RpcNotOpenError();\n    }\n    const id = this._nextId++;\n    return new Stream(({ ready, next, close }) => {\n      const onResponse = (response) => {\n        var _a, _b, _c;\n        if (response.streamReady) {\n          ready();\n        } else if (response.close) {\n          close();\n        } else if (response.error) {\n          close(new SerializedRpcError((_a = response.error.name) != null ? _a : \"Error\", (_b = response.error.message) != null ? _b : \"Unknown Error\", (_c = response.error.stack) != null ? _c : \"\", method));\n        } else if (response.payload) {\n          next(response.payload);\n        } else {\n          throw new Error(\"Malformed response.\");\n        }\n      };\n      const stack = new StackTrace();\n      const closeStream = (err) => {\n        if (!err) {\n          close();\n        } else {\n          err.stack += `\n\nError happened in the stream at:\n${stack.getStack()}`;\n          close(err);\n        }\n      };\n      this._outgoingRequests.set(id, new PendingRpcRequest(onResponse, closeStream, true));\n      this._sendMessage({\n        request: {\n          id,\n          method,\n          payload: request,\n          stream: true\n        }\n      }).catch((err) => {\n        close(err);\n      });\n      return () => {\n        this._sendMessage({\n          streamClose: {\n            id\n          }\n        }).catch((err) => {\n          log.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc/src/rpc.ts\",\n            line: 359,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        });\n      };\n    });\n  }\n  async _sendMessage(message) {\n    await this._options.port.send(codec.encode(message, {\n      preserveAny: true\n    }));\n  }\n  async _callHandler(req) {\n    try {\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const response = await this._options.callHandler(req.method, req.payload);\n      return {\n        id: req.id,\n        payload: response\n      };\n    } catch (err) {\n      return {\n        id: req.id,\n        error: encodeError(err)\n      };\n    }\n  }\n  _callStreamHandler(req, callback) {\n    try {\n      assert(this._options.streamHandler, \"Requests with streaming responses are not supported.\");\n      assert(typeof req.id === \"number\");\n      assert(req.payload);\n      assert(req.method);\n      const responseStream = this._options.streamHandler(req.method, req.payload);\n      responseStream.onReady(() => {\n        callback({\n          id: req.id,\n          streamReady: true\n        });\n      });\n      responseStream.subscribe((msg) => {\n        callback({\n          id: req.id,\n          payload: msg\n        });\n      }, (error) => {\n        if (error) {\n          callback({\n            id: req.id,\n            error: encodeError(error)\n          });\n        } else {\n          callback({\n            id: req.id,\n            close: true\n          });\n        }\n      });\n      this._localStreams.set(req.id, responseStream);\n    } catch (err) {\n      callback({\n        id: req.id,\n        error: encodeError(err)\n      });\n    }\n  }\n};\n__decorate([\n  synchronized\n], RpcPeer.prototype, \"open\", null);\nvar encodeError = (err) => {\n  if (typeof err === \"object\" && (err == null ? void 0 : err.message)) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  } else if (typeof err === \"string\") {\n    return {\n      message: err\n    };\n  } else {\n    return {\n      message: JSON.stringify(err)\n    };\n  }\n};\n\n// packages/core/mesh/rpc/src/service.ts\nimport assert2 from \"@dxos/node-std/assert\";\nvar createServiceBundle = (services) => services;\nvar ProtoRpcPeer = class {\n  constructor(rpc, _peer) {\n    this.rpc = rpc;\n    this._peer = _peer;\n  }\n  async open() {\n    await this._peer.open();\n  }\n  async close() {\n    await this._peer.close();\n  }\n};\nvar createProtoRpcPeer = ({ requested, exposed, handlers, encodingOptions, ...rest }) => {\n  const exposedRpcs = {};\n  if (exposed) {\n    assert2(handlers);\n    for (const serviceName of Object.keys(exposed)) {\n      const serviceFqn = exposed[serviceName].serviceProto.fullName.slice(1);\n      const serviceProvider = handlers[serviceName];\n      exposedRpcs[serviceFqn] = exposed[serviceName].createServer(serviceProvider, encodingOptions);\n    }\n  }\n  const peer = new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!exposedRpcs[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return exposedRpcs[serviceName].callStream(methodName, request);\n    }\n  });\n  const requestedRpcs = {};\n  if (requested) {\n    for (const serviceName1 of Object.keys(requested)) {\n      const serviceFqn1 = requested[serviceName1].serviceProto.fullName.slice(1);\n      requestedRpcs[serviceName1] = requested[serviceName1].createClient({\n        call: (method, req) => peer.call(`${serviceFqn1}.${method}`, req),\n        callStream: (method, req) => peer.callStream(`${serviceFqn1}.${method}`, req)\n      }, encodingOptions);\n    }\n  }\n  return new ProtoRpcPeer(requestedRpcs, peer);\n};\nvar parseMethodName = (method) => {\n  const separator = method.lastIndexOf(\".\");\n  const serviceName = method.slice(0, separator);\n  const methodName = method.slice(separator + 1);\n  if (serviceName.length === 0 || methodName.length === 0) {\n    throw new Error(`Invalid method: ${method}`);\n  }\n  return [\n    serviceName,\n    methodName\n  ];\n};\nvar createRpcClient = (serviceDef, options) => {\n  const peer = new RpcPeer({\n    ...options,\n    callHandler: () => {\n      throw new Error(\"Requests to client are not supported.\");\n    }\n  });\n  const client = serviceDef.createClient({\n    call: peer.call.bind(peer),\n    callStream: peer.callStream.bind(peer)\n  });\n  return new ProtoRpcPeer(client, peer);\n};\nvar createRpcServer = ({ service, handlers, ...rest }) => {\n  const server = service.createServer(handlers);\n  return new RpcPeer({\n    ...rest,\n    callHandler: server.call.bind(server),\n    streamHandler: server.callStream.bind(server)\n  });\n};\nvar createBundledRpcClient = (descriptors, options) => {\n  return createProtoRpcPeer({\n    requested: descriptors,\n    ...options\n  });\n};\nvar createBundledRpcServer = ({ services, handlers, ...rest }) => {\n  const rpc = {};\n  for (const serviceName of Object.keys(services)) {\n    const serviceFqn = services[serviceName].serviceProto.fullName.slice(1);\n    rpc[serviceFqn] = services[serviceName].createServer(handlers[serviceName]);\n  }\n  return new RpcPeer({\n    ...rest,\n    callHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].call(methodName, request);\n    },\n    streamHandler: (method, request) => {\n      const [serviceName, methodName] = parseMethodName(method);\n      if (!rpc[serviceName]) {\n        throw new Error(`Service not supported: ${serviceName}`);\n      }\n      return rpc[serviceName].callStream(methodName, request);\n    }\n  });\n};\n\n// packages/core/mesh/rpc/src/testing.ts\nvar createLinkedPorts = () => {\n  let port1Received;\n  let port2Received;\n  const port1 = {\n    send: (msg) => port2Received == null ? void 0 : port2Received(msg),\n    subscribe: (cb) => {\n      port1Received = cb;\n    }\n  };\n  const port2 = {\n    send: (msg) => port1Received == null ? void 0 : port1Received(msg),\n    subscribe: (cb) => {\n      port2Received = cb;\n    }\n  };\n  return [\n    port1,\n    port2\n  ];\n};\n\n// packages/core/mesh/rpc/src/trace.ts\nimport { Event } from \"@dxos/async\";\nimport { MessageTrace } from \"@dxos/protocols/proto/dxos/rpc\";\nvar PortTracer = class {\n  constructor(_wrappedPort) {\n    this._wrappedPort = _wrappedPort;\n    this.message = new Event();\n    this._port = {\n      send: (msg) => {\n        this.message.emit({\n          direction: MessageTrace.Direction.OUTGOING,\n          data: msg\n        });\n        return this._wrappedPort.send(msg);\n      },\n      subscribe: (cb) => {\n        return this._wrappedPort.subscribe((msg) => {\n          this.message.emit({\n            direction: MessageTrace.Direction.INCOMING,\n            data: msg\n          });\n          cb(msg);\n        });\n      }\n    };\n  }\n  get port() {\n    return this._port;\n  }\n};\nexport {\n  PortTracer,\n  ProtoRpcPeer,\n  RpcClosedError,\n  RpcNotOpenError,\n  RpcPeer,\n  SerializedRpcError,\n  createBundledRpcClient,\n  createBundledRpcServer,\n  createLinkedPorts,\n  createProtoRpcPeer,\n  createRpcClient,\n  createRpcServer,\n  createServiceBundle\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466203,"end":1670465466209,"order":"normal"}]}
