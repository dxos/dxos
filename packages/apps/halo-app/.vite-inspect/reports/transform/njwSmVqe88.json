{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/replicate.js","transforms":[{"name":"vite:load-fallback","result":"var Protocol = require('hypercore-protocol')\nvar timeout = require('timeout-refresh')\nvar bitfield = require('fast-bitfield')\nvar set = require('unordered-set')\nvar rle = require('bitfield-rle').align(4)\nvar treeIndex = require('./tree-index')\n\nvar EMPTY = new Uint8Array(1024)\n\nmodule.exports = replicate\n\nfunction replicate (feed, initiator, opts) {\n  feed.ifAvailable.wait()\n  var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream\n\n  if (!stream) {\n    if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair\n    stream = new Protocol(initiator, opts)\n  }\n\n  if (feed.opened) onready(null)\n  else feed.ready(onready)\n\n  return stream\n\n  function onready (err) {\n    feed.ifAvailable.continue()\n\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n\n    if (opts.noise !== false && opts.onfeedauthenticate) {\n      if (!stream.remotePublicKey) {\n        feed.ifAvailable.wait()\n        stream.setMaxListeners(0)\n        stream.on('close', onhandshake)\n        stream.on('handshake', onhandshake)\n        return\n      }\n      feedauthenticate()\n      return\n    }\n    replicatePeer()\n  }\n\n  function onhandshake () {\n    feed.ifAvailable.continue()\n    stream.off('close', onhandshake)\n    stream.off('handshake', onhandshake)\n    feedauthenticate()\n  }\n\n  function feedauthenticate () {\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n    feed.ifAvailable.wait()\n    opts.onfeedauthenticate(feed, stream.remotePublicKey, function (err) {\n      feed.ifAvailable.continue()\n      if (stream.destroyed) return\n      if (stream.opened(feed.key)) return\n      if (err) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n      replicatePeer()\n    })\n  }\n\n  function replicatePeer () {\n    if (opts.noise !== false) {\n      if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n    }\n\n    var peer = new Peer(feed, opts)\n\n    peer.feed = feed\n    peer.stream = stream.open(feed.key, peer)\n\n    stream.setMaxListeners(0)\n    peer.ready()\n    feed.emit('replicating', stream)\n  }\n}\n\nfunction Peer (feed, opts) {\n  if (opts.extensions) throw new Error('Per peer extensions is not supported. Use feed.registerExtension instead')\n\n  this.feed = feed\n  this.stream = null // set by replicate just after creation\n  this.wants = bitfield()\n  this.remoteBitfield = bitfield()\n  this.remoteLength = 0\n  this.remoteWant = false\n  this.remoteTree = null\n  this.remoteAck = false\n  this.remoteOpened = false\n  this.live = !!opts.live\n  this.sparse = feed.sparse\n  this.ack = !!opts.ack\n\n  this.remoteDownloading = true\n  this.remoteUploading = true\n  this.remoteExtensions = feed.extensions.remote()\n  this.downloading = typeof opts.download === 'boolean' ? opts.download : feed.downloading\n  this.uploading = typeof opts.upload === 'boolean' ? opts.upload : feed.uploading\n\n  this.updated = false\n\n  this.maxRequests = opts.maxRequests || feed.maxRequests || 16\n  this.urgentRequests = this.maxRequests + 16\n  this.inflightRequests = []\n  this.inflightWants = 0\n\n  this._index = -1\n  this._lastBytes = 0\n  this._first = true\n  this._closed = false\n  this._destroyed = false\n  this._defaultDownloading = this.downloading\n  this._iterator = this.remoteBitfield.iterator()\n  this._requestTimeout = null\n\n  this.stats = !opts.stats ? null : {\n    uploadedBytes: 0,\n    uploadedBlocks: 0,\n    downloadedBytes: 0,\n    downloadedBlocks: 0\n  }\n}\n\nObject.defineProperty(Peer.prototype, 'remoteAddress', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteAddress\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remoteType', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteType\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remotePublicKey', {\n  enumerable: true,\n  get: function () {\n    return this.stream.state.remotePublicKey\n  }\n})\n\nPeer.prototype.onwant = function (want) {\n  if (!this.uploading) return\n  // We only reploy to multipla of 8192 in terms of offsets and lengths for want messages\n  // since this is much easier for the bitfield, in terms of paging.\n  if ((want.start & 8191) || (want.length & 8191)) return\n  if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {\n    // Eagerly send the length of the feed to the otherside\n    // TODO: only send this if the remote is not wanting a region\n    // where this is contained in\n    this.stream.have({ start: this.feed.length - 1 })\n  }\n  this.remoteWant = true\n  var rle = this.feed.bitfield.compress(want.start, want.length)\n  this.stream.have({ start: want.start, length: want.length, bitfield: rle })\n}\n\nPeer.prototype.ondata = function (data) {\n  var self = this\n\n  // Ignore unrequested messages unless we allow push\n  // TODO: would be better to check if the byte range was requested instead, but this works fine\n  var allowPush = this.feed.allowPush || !data.value\n  if (!allowPush && !this.feed._reserved.get(data.index)) {\n    // If we do not have this block, send back unhave message for this index,\n    // to let the remote know we rejected it.\n    // TODO: we might want to have some \"unwanted push\" threshold to punish spammers\n    if (!self.feed.bitfield.get(data.index)) self.unhave({ start: data.index })\n    self._clear(data.index, !data.value)\n    return\n  }\n\n  this.feed._putBuffer(data.index, data.value, data, this, function (err) {\n    if (err) return self.destroy(err)\n    if (data.value) self.remoteBitfield.set(data.index, false)\n    if (self.remoteAck) {\n      // Send acknowledgement.\n      // In the future this could batch several ACKs at once\n      self.stream.have({ start: data.index, length: 1, ack: true })\n    }\n    if (self.stats && data.value) {\n      self.stats.downloadedBlocks += 1\n      self.stats.downloadedBytes += data.value.length\n    }\n    self._clear(data.index, !data.value)\n  })\n}\n\nPeer.prototype._clear = function (index, hash) {\n  // TODO: optimize me (no splice and do not run through all ...)\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].index === index) {\n      if (this._requestTimeout !== null) this._requestTimeout.refresh()\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.feed._reserved.set(index, false)\n  // TODO: only update all if we have overlapping selections\n  this.feed._updatePeers()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.onrequest = function (request) {\n  if (!this.uploading) return\n  if (request.bytes) return this._onbytes(request)\n\n  // lazily instantiate the remote tree\n  if (!this.remoteTree) this.remoteTree = treeIndex()\n\n  var self = this\n  var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree }\n\n  this.feed.proof(request.index, opts, onproof)\n\n  function onproof (err, proof) {\n    if (err) return self.destroy(err)\n    if (request.hash) onvalue(null, null)\n    else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue)\n\n    function onvalue (err, value) {\n      if (!self.uploading) return\n      if (err) return self.destroy(err)\n\n      if (value) {\n        if (self.stats) {\n          self.stats.uploadedBlocks += 1\n          self.stats.uploadedBytes += value.length\n          self.feed._stats.uploadedBlocks += 1\n          self.feed._stats.uploadedBytes += value.length\n        }\n        self.feed.emit('upload', request.index, value, self)\n      }\n\n      // TODO: prob not needed with new bitfield\n      if (request.index + 1 > self.remoteLength) {\n        self.remoteLength = request.index + 1\n        self._updateEnd()\n      }\n\n      self.stream.data({\n        index: request.index,\n        value: value,\n        nodes: proof.nodes,\n        signature: proof.signature\n      })\n    }\n  }\n}\n\nPeer.prototype._updateOptions = function () {\n  if (this.ack || this.feed.extensions.length) {\n    this.stream.options({\n      ack: this.ack,\n      extensions: this.feed.extensions.names()\n    })\n  }\n}\n\nPeer.prototype.setDownloading = function (downloading) {\n  if (downloading === this.downloading) return\n  this.downloading = downloading\n  this.stream.status({\n    downloading,\n    uploading: this.uploading\n  })\n  this.update()\n}\n\nPeer.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.stream.status({\n    downloading: this.downloading,\n    uploading\n  })\n  this.update()\n}\n\nPeer.prototype._onbytes = function (request) {\n  var self = this\n\n  this.feed.seek(request.bytes, { wait: false }, function (err, index) {\n    if (err) {\n      request.bytes = 0\n      self.onrequest(request)\n      return\n    }\n\n    // quick'n'dirty filter for parallel bytes requests\n    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization\n    if (self._lastBytes === request.bytes) return\n    self._lastBytes = request.bytes\n\n    request.bytes = 0\n    request.index = index\n    request.nodes = 0\n\n    self.onrequest(request)\n  })\n}\n\nPeer.prototype._onrequesttimeout = function () {\n  this._requestTimeout = null\n  if (!this.inflightRequests.length) return\n\n  var first = this.inflightRequests[0]\n\n  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n    // prob a bytes response\n    this.inflightRequests.shift()\n    this.feed._reserved.set(first.index, false)\n\n    if (this.stream.stream.timeout) {\n      this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n    }\n    return\n  }\n\n  this.destroy(new Error('Request timeout'))\n}\n\nPeer.prototype.onhave = function (have) {\n  this.feed.emit('peer-ack', this, have)\n\n  if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {\n    this.stream.stream.emit('ack', have)\n    return\n  }\n\n  var updated = this._first\n  if (this._first) this._first = false\n\n  // In this impl, we only sent WANTs for 1024 * 1024 length ranges\n  // so if we get a HAVE for that it is a reply to a WANT.\n  if (have.length === 1024 * 1024 && this.inflightWants > 0) {\n    this.feed.ifAvailable.continue()\n    this.inflightWants--\n  }\n\n  if (have.bitfield) { // TODO: handle start !== 0\n    if (have.length === 0 || have.length === 1) { // length === 1 is for backwards compat\n      this.wants = null // we are in backwards compat mode where we subscribe everything\n    }\n    var buf = rle.decode(have.bitfield)\n    var bits = buf.length * 8\n    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start)\n    this.remoteBitfield.fill(buf, have.start)\n    if (bits > this.remoteLength) {\n      this.remoteLength = this.remoteBitfield.last() + 1\n      updated = true\n    }\n  } else {\n    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield\n\n    var start = have.start\n    var len = have.length || 1\n\n    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++))\n    if (start > this.remoteLength) {\n      this.remoteLength = start\n      updated = true\n    }\n  }\n\n  if (updated) {\n    this.updated = true\n    this.feed.emit('remote-update', this)\n  }\n\n  this._updateEnd()\n  this.update()\n}\n\nPeer.prototype._updateEnd = function () {\n  if (this.live || this.feed.sparse || !this.feed._selections.length) return\n\n  var sel = this.feed._selections[0]\n  var remoteLength = this.feed.length || -1\n\n  for (var i = 0; i < this.feed.peers.length; i++) {\n    if (this.feed.peers[i].remoteLength > remoteLength) {\n      remoteLength = this.feed.peers[i].remoteLength\n    }\n  }\n\n  sel.end = remoteLength\n}\n\nPeer.prototype.onextension = function (id, message) {\n  this.remoteExtensions.onmessage(id, message, this)\n}\n\nPeer.prototype.onstatus = function (info) {\n  this.remoteUploading = info.uploading\n  this.remoteDownloading = info.downloading\n\n  if (!info.uploading) {\n    while (this.inflightRequests.length) {\n      const data = this.inflightRequests[0]\n      this._clear(data.index, !data.value)\n    }\n    for (var i = 0; i < this.inflightWants; i++) {\n      this.feed.ifAvailable.continue()\n    }\n    this.inflightWants = 0\n    this.wants = bitfield()\n  }\n  this.update()\n  if (info.downloading || this.live) return\n  if (this.feed._selections.length && this.downloading) return\n  this._autoEnd()\n}\n\nPeer.prototype._autoEnd = function () {\n  if (this.uploading && this.remoteDownloading) return\n  if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return\n  this.end()\n}\n\nPeer.prototype.onunhave = function (unhave) {\n  var start = unhave.start\n  var len = unhave.length || 1\n\n  if (start === 0 && len >= this.remoteLength) {\n    this.remoteLength = 0\n    this.remoteBitfield = bitfield()\n    return\n  }\n\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.onunwant =\nPeer.prototype.oncancel = function () {\n  // TODO: impl all of me\n}\n\nPeer.prototype.onclose = function () {\n  this._close()\n}\n\nPeer.prototype.have = function (have) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.have(have)\n  var start = have.start\n  var len = have.length\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.unhave = function (unhave) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.unhave(unhave)\n}\n\nPeer.prototype.haveBytes = function (bytes) { // called by feed\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].bytes === bytes) {\n      this.feed._reserved.set(this.inflightRequests[i].index, false)\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.update()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.update = function () {\n  // do nothing\n  while (this._update()) {}\n  this._sendWantsMaybe()\n}\n\nPeer.prototype._update = function () {\n  // should return true if mutated false if not\n  if (!this.downloading || !this.remoteUploading) return false\n  var selections = this.feed._selections\n  var waiting = this.feed._waiting\n  var wlen = waiting.length\n  var slen = selections.length\n  var inflight = this.inflightRequests.length\n  var offset = 0\n  var i = 0\n\n  // TODO: less duplicate code here\n  // TODO: re-add priority levels\n\n  while (inflight < this.urgentRequests) {\n    offset = Math.floor(Math.random() * waiting.length)\n\n    for (i = 0; i < waiting.length; i++) {\n      var w = waiting[offset++]\n      if (offset === waiting.length) offset = 0\n\n      this._downloadWaiting(w)\n      if (waiting.length !== wlen) return true // mutated\n      if (this.inflightRequests.length >= this.urgentRequests) return false\n    }\n    if (inflight === this.inflightRequests.length) break\n    inflight = this.inflightRequests.length\n  }\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * selections.length)\n\n    for (i = 0; i < selections.length; i++) {\n      var s = selections[offset++]\n      if (offset === selections.length) offset = 0\n\n      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end)\n      if (s.blocks) this._downloadBlocks(s)\n      else this._downloadRange(s)\n      if (selections.length !== slen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n\n    if (inflight === this.inflightRequests.length) return false\n    inflight = this.inflightRequests.length\n  }\n\n  return false\n}\n\nPeer.prototype.onopen = function () {\n  this.feed.ifAvailable.continue()\n  this.remoteOpened = true\n\n  this._updateOptions()\n\n  if (!this.uploading || !this.downloading) {\n    this.stream.status({\n      uploading: this.uploading,\n      downloading: this.downloading\n    })\n  }\n\n  this._sendWants()\n  this.feed.emit('peer-open', this)\n}\n\nPeer.prototype.onoptions = function (options) {\n  this.remoteAck = options.ack\n  this.remoteExtensions.update(options.extensions)\n}\n\nPeer.prototype.ready = function () {\n  this.feed.ifAvailable.wait() // continued by onopen or close\n  set.add(this.feed.peers, this)\n  this.feed.emit('peer-add', this)\n  if (this.stream.remoteOpened) this.onopen()\n}\n\nPeer.prototype.end = function () {\n  if (!this.downloading && !this.remoteDownloading && !this.live) {\n    if (!this._defaultDownloading) {\n      this.stream.status({ downloading: false, uploading: false })\n    }\n    this._close()\n    return\n  }\n  if (!this._closed) {\n    this._closed = true\n    this.downloading = false\n    this.stream.status({ downloading: false, uploading: true })\n  } else {\n    if (!this.live) this._close()\n  }\n}\n\nPeer.prototype._close = function () {\n  if (!this._destroyed) {\n    this._destroyed = true\n    this.stream.close()\n  }\n  if (this._index === -1) return\n  set.remove(this.feed.peers, this)\n  this._index = -1\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    this.feed._reserved.set(this.inflightRequests[i].index, false)\n  }\n  if (this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n  this._updateEnd()\n  this.remoteWant = false\n  this.feed._updatePeers()\n  this.feed.emit('peer-remove', this)\n  for (i = 0; i < this.inflightWants; i++) {\n    this.feed.ifAvailable.continue()\n  }\n  if (!this.remoteOpened) {\n    this.feed.ifAvailable.continue()\n  }\n}\n\nPeer.prototype.destroy = function (err) {\n  if (this._index === -1 || this._destroyed) return\n  this.stream.destroy(err)\n  this._destroyed = true\n  this._close()\n}\n\nPeer.prototype._sendWantsMaybe = function () {\n  if (this.inflightRequests.length < this.urgentRequests) this._sendWants()\n}\n\nPeer.prototype._sendWants = function () {\n  if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return\n  if (this.inflightWants >= 16) return\n\n  var i\n\n  for (i = 0; i < this.feed._waiting.length; i++) {\n    var w = this.feed._waiting[i]\n    if (w.index === -1) this._sendWantRange(w)\n    else this._sendWant(w.index)\n    if (this.inflightWants >= 16) return\n  }\n\n  for (i = 0; i < this.feed._selections.length; i++) {\n    var s = this.feed._selections[i]\n    this._sendWantRange(s)\n    if (this.inflightWants >= 16) return\n  }\n\n  // always sub to the first range for now, usually what you want\n  this._sendWant(0)\n}\n\nPeer.prototype._sendWantRange = function (s) {\n  if (s.blocks) {\n    if (!s.selected) s.selected = new WeakSet()\n    if (s.selected.has(this)) return\n    s.selected.add(this)\n    for (const block of s.blocks) {\n      this._sendWant(block)\n    }\n    return\n  }\n\n  var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0\n\n  while (true) {\n    if (want >= this.remoteLength) return\n    if (s.end !== -1 && want >= s.end) return\n\n    if (this._sendWant(want)) return\n\n    // check if region is already selected - if so try next one\n    if (!this.wants.get(Math.floor(want / 1024 / 1024))) return\n    want += 1024 * 1024\n  }\n}\n\nPeer.prototype._sendWant = function (index) {\n  var len = 1024 * 1024\n  var j = Math.floor(index / len)\n  if (this.wants.get(j)) return false\n  this.wants.set(j, true)\n  this.inflightWants++\n  this.feed.ifAvailable.wait()\n  this.stream.want({ start: j * len, length: len })\n  return true\n}\n\nPeer.prototype._downloadWaiting = function (wait) {\n  if (!wait.bytes) {\n    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {\n      if (!wait.update || this.feed._reserved.get(wait.index)) return\n      const i = this._iterator.seek(wait.index).next(true)\n      if (i === -1 || !this.feed._reserved.set(i, true)) return\n      wait.index = i\n    }\n    this._request(wait.index, 0, wait.hash === true)\n    return\n  }\n\n  this._downloadRange(wait)\n}\n\nPeer.prototype._downloadBlocks = function (range) {\n  while (range.blocksDownloaded < range.blocks.length) {\n    const blk = range.blocks[range.blocksDownloaded]\n    if (!this.feed.bitfield.get(blk)) break\n    range.blocksDownloaded++\n  }\n\n  if (range.blocksDownloaded >= range.blocks.length) {\n    set.remove(this.feed._selections, range)\n    range.callback(null)\n    return\n  }\n\n  for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {\n    const blk = range.blocks[i]\n    if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {\n      range.requested++\n      this._request(blk, 0, false)\n      return\n    }\n  }\n}\n\nPeer.prototype._downloadRange = function (range) {\n  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end)\n\n  var reserved = this.feed._reserved\n  var ite = this._iterator\n  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength)\n\n  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd)\n  var start = i\n\n  if (i === -1 || i >= wantedEnd) {\n    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n      set.remove(this.feed._selections, range)\n      range.callback(null)\n      if (!this.live && !this.sparse && !this.feed._selections.length) this.end()\n    }\n    return\n  }\n\n  while ((range.hash && this.feed.tree.get(2 * i)) || !reserved.set(i, true)) {\n    i = ite.next(true)\n\n    if (i > -1 && i < wantedEnd) {\n      // check this index\n      continue\n    }\n\n    if (!range.linear && start !== 0) {\n      // retry from the beginning since we are iterating randomly and started !== 0\n      i = ite.seek(range.start).next(true)\n      start = 0\n      if (i > -1 && i < wantedEnd) continue\n    }\n\n    // we have checked all indexes.\n    // if we are looking for hashes we should check if we have all now (first check only checks blocks)\n    if (range.hash) {\n      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots\n      // but we don't really request long ranges of hashes so yolo\n      for (var j = range.start; j < wantedEnd; j++) {\n        if (!this.feed.tree.get(2 * j)) return\n      }\n      if (!range.bytes) {\n        set.remove(this.feed._selections, range)\n        range.callback(null)\n      }\n    }\n\n    // exit the update loop - nothing to do\n    return\n  }\n\n  range.requested++\n  this._request(i, range.bytes || 0, range.hash)\n}\n\nPeer.prototype._request = function (index, bytes, hash) {\n  var request = {\n    bytes: bytes,\n    index: index,\n    hash: hash,\n    nodes: this.feed.digest(index)\n  }\n\n  if (this._requestTimeout === null && this.stream.stream.timeout) {\n    this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n  }\n  this.inflightRequests.push(request)\n  this.stream.request(request)\n}\n\nPeer.prototype.extension = function (id, message) {\n  this.stream.extension(id, message)\n}\n\nfunction createView (page) {\n  var buf = page ? page.buffer : EMPTY\n  return new DataView(buf.buffer, buf.byteOffset, 1024)\n}\n\nfunction remoteAndNotLocal (local, buf, le, start) {\n  var remote = new DataView(buf.buffer, buf.byteOffset)\n  var len = Math.floor(buf.length / 4)\n  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len)\n  var p = start / 8192 // 8192 is bits per bitfield page\n  var l = 0\n  var page = createView(local.pages.get(p++, true))\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * (l++), !le)\n\n    if (l === 256) {\n      page = createView(local.pages.get(p++, true))\n      l = 0\n    }\n  }\n}\n\nfunction nextRandom (ite, start, end) {\n  var len = end - start\n  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true)\n  return i === -1 || i >= end ? ite.seek(start).next(true) : i\n}\n","start":1670465469175,"end":1670465469245},{"name":"vite:react-babel","result":"var Protocol = require('hypercore-protocol')\nvar timeout = require('timeout-refresh')\nvar bitfield = require('fast-bitfield')\nvar set = require('unordered-set')\nvar rle = require('bitfield-rle').align(4)\nvar treeIndex = require('./tree-index')\n\nvar EMPTY = new Uint8Array(1024)\n\nmodule.exports = replicate\n\nfunction replicate (feed, initiator, opts) {\n  feed.ifAvailable.wait()\n  var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream\n\n  if (!stream) {\n    if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair\n    stream = new Protocol(initiator, opts)\n  }\n\n  if (feed.opened) onready(null)\n  else feed.ready(onready)\n\n  return stream\n\n  function onready (err) {\n    feed.ifAvailable.continue()\n\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n\n    if (opts.noise !== false && opts.onfeedauthenticate) {\n      if (!stream.remotePublicKey) {\n        feed.ifAvailable.wait()\n        stream.setMaxListeners(0)\n        stream.on('close', onhandshake)\n        stream.on('handshake', onhandshake)\n        return\n      }\n      feedauthenticate()\n      return\n    }\n    replicatePeer()\n  }\n\n  function onhandshake () {\n    feed.ifAvailable.continue()\n    stream.off('close', onhandshake)\n    stream.off('handshake', onhandshake)\n    feedauthenticate()\n  }\n\n  function feedauthenticate () {\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n    feed.ifAvailable.wait()\n    opts.onfeedauthenticate(feed, stream.remotePublicKey, function (err) {\n      feed.ifAvailable.continue()\n      if (stream.destroyed) return\n      if (stream.opened(feed.key)) return\n      if (err) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n      replicatePeer()\n    })\n  }\n\n  function replicatePeer () {\n    if (opts.noise !== false) {\n      if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n    }\n\n    var peer = new Peer(feed, opts)\n\n    peer.feed = feed\n    peer.stream = stream.open(feed.key, peer)\n\n    stream.setMaxListeners(0)\n    peer.ready()\n    feed.emit('replicating', stream)\n  }\n}\n\nfunction Peer (feed, opts) {\n  if (opts.extensions) throw new Error('Per peer extensions is not supported. Use feed.registerExtension instead')\n\n  this.feed = feed\n  this.stream = null // set by replicate just after creation\n  this.wants = bitfield()\n  this.remoteBitfield = bitfield()\n  this.remoteLength = 0\n  this.remoteWant = false\n  this.remoteTree = null\n  this.remoteAck = false\n  this.remoteOpened = false\n  this.live = !!opts.live\n  this.sparse = feed.sparse\n  this.ack = !!opts.ack\n\n  this.remoteDownloading = true\n  this.remoteUploading = true\n  this.remoteExtensions = feed.extensions.remote()\n  this.downloading = typeof opts.download === 'boolean' ? opts.download : feed.downloading\n  this.uploading = typeof opts.upload === 'boolean' ? opts.upload : feed.uploading\n\n  this.updated = false\n\n  this.maxRequests = opts.maxRequests || feed.maxRequests || 16\n  this.urgentRequests = this.maxRequests + 16\n  this.inflightRequests = []\n  this.inflightWants = 0\n\n  this._index = -1\n  this._lastBytes = 0\n  this._first = true\n  this._closed = false\n  this._destroyed = false\n  this._defaultDownloading = this.downloading\n  this._iterator = this.remoteBitfield.iterator()\n  this._requestTimeout = null\n\n  this.stats = !opts.stats ? null : {\n    uploadedBytes: 0,\n    uploadedBlocks: 0,\n    downloadedBytes: 0,\n    downloadedBlocks: 0\n  }\n}\n\nObject.defineProperty(Peer.prototype, 'remoteAddress', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteAddress\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remoteType', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteType\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remotePublicKey', {\n  enumerable: true,\n  get: function () {\n    return this.stream.state.remotePublicKey\n  }\n})\n\nPeer.prototype.onwant = function (want) {\n  if (!this.uploading) return\n  // We only reploy to multipla of 8192 in terms of offsets and lengths for want messages\n  // since this is much easier for the bitfield, in terms of paging.\n  if ((want.start & 8191) || (want.length & 8191)) return\n  if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {\n    // Eagerly send the length of the feed to the otherside\n    // TODO: only send this if the remote is not wanting a region\n    // where this is contained in\n    this.stream.have({ start: this.feed.length - 1 })\n  }\n  this.remoteWant = true\n  var rle = this.feed.bitfield.compress(want.start, want.length)\n  this.stream.have({ start: want.start, length: want.length, bitfield: rle })\n}\n\nPeer.prototype.ondata = function (data) {\n  var self = this\n\n  // Ignore unrequested messages unless we allow push\n  // TODO: would be better to check if the byte range was requested instead, but this works fine\n  var allowPush = this.feed.allowPush || !data.value\n  if (!allowPush && !this.feed._reserved.get(data.index)) {\n    // If we do not have this block, send back unhave message for this index,\n    // to let the remote know we rejected it.\n    // TODO: we might want to have some \"unwanted push\" threshold to punish spammers\n    if (!self.feed.bitfield.get(data.index)) self.unhave({ start: data.index })\n    self._clear(data.index, !data.value)\n    return\n  }\n\n  this.feed._putBuffer(data.index, data.value, data, this, function (err) {\n    if (err) return self.destroy(err)\n    if (data.value) self.remoteBitfield.set(data.index, false)\n    if (self.remoteAck) {\n      // Send acknowledgement.\n      // In the future this could batch several ACKs at once\n      self.stream.have({ start: data.index, length: 1, ack: true })\n    }\n    if (self.stats && data.value) {\n      self.stats.downloadedBlocks += 1\n      self.stats.downloadedBytes += data.value.length\n    }\n    self._clear(data.index, !data.value)\n  })\n}\n\nPeer.prototype._clear = function (index, hash) {\n  // TODO: optimize me (no splice and do not run through all ...)\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].index === index) {\n      if (this._requestTimeout !== null) this._requestTimeout.refresh()\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.feed._reserved.set(index, false)\n  // TODO: only update all if we have overlapping selections\n  this.feed._updatePeers()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.onrequest = function (request) {\n  if (!this.uploading) return\n  if (request.bytes) return this._onbytes(request)\n\n  // lazily instantiate the remote tree\n  if (!this.remoteTree) this.remoteTree = treeIndex()\n\n  var self = this\n  var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree }\n\n  this.feed.proof(request.index, opts, onproof)\n\n  function onproof (err, proof) {\n    if (err) return self.destroy(err)\n    if (request.hash) onvalue(null, null)\n    else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue)\n\n    function onvalue (err, value) {\n      if (!self.uploading) return\n      if (err) return self.destroy(err)\n\n      if (value) {\n        if (self.stats) {\n          self.stats.uploadedBlocks += 1\n          self.stats.uploadedBytes += value.length\n          self.feed._stats.uploadedBlocks += 1\n          self.feed._stats.uploadedBytes += value.length\n        }\n        self.feed.emit('upload', request.index, value, self)\n      }\n\n      // TODO: prob not needed with new bitfield\n      if (request.index + 1 > self.remoteLength) {\n        self.remoteLength = request.index + 1\n        self._updateEnd()\n      }\n\n      self.stream.data({\n        index: request.index,\n        value: value,\n        nodes: proof.nodes,\n        signature: proof.signature\n      })\n    }\n  }\n}\n\nPeer.prototype._updateOptions = function () {\n  if (this.ack || this.feed.extensions.length) {\n    this.stream.options({\n      ack: this.ack,\n      extensions: this.feed.extensions.names()\n    })\n  }\n}\n\nPeer.prototype.setDownloading = function (downloading) {\n  if (downloading === this.downloading) return\n  this.downloading = downloading\n  this.stream.status({\n    downloading,\n    uploading: this.uploading\n  })\n  this.update()\n}\n\nPeer.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.stream.status({\n    downloading: this.downloading,\n    uploading\n  })\n  this.update()\n}\n\nPeer.prototype._onbytes = function (request) {\n  var self = this\n\n  this.feed.seek(request.bytes, { wait: false }, function (err, index) {\n    if (err) {\n      request.bytes = 0\n      self.onrequest(request)\n      return\n    }\n\n    // quick'n'dirty filter for parallel bytes requests\n    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization\n    if (self._lastBytes === request.bytes) return\n    self._lastBytes = request.bytes\n\n    request.bytes = 0\n    request.index = index\n    request.nodes = 0\n\n    self.onrequest(request)\n  })\n}\n\nPeer.prototype._onrequesttimeout = function () {\n  this._requestTimeout = null\n  if (!this.inflightRequests.length) return\n\n  var first = this.inflightRequests[0]\n\n  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n    // prob a bytes response\n    this.inflightRequests.shift()\n    this.feed._reserved.set(first.index, false)\n\n    if (this.stream.stream.timeout) {\n      this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n    }\n    return\n  }\n\n  this.destroy(new Error('Request timeout'))\n}\n\nPeer.prototype.onhave = function (have) {\n  this.feed.emit('peer-ack', this, have)\n\n  if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {\n    this.stream.stream.emit('ack', have)\n    return\n  }\n\n  var updated = this._first\n  if (this._first) this._first = false\n\n  // In this impl, we only sent WANTs for 1024 * 1024 length ranges\n  // so if we get a HAVE for that it is a reply to a WANT.\n  if (have.length === 1024 * 1024 && this.inflightWants > 0) {\n    this.feed.ifAvailable.continue()\n    this.inflightWants--\n  }\n\n  if (have.bitfield) { // TODO: handle start !== 0\n    if (have.length === 0 || have.length === 1) { // length === 1 is for backwards compat\n      this.wants = null // we are in backwards compat mode where we subscribe everything\n    }\n    var buf = rle.decode(have.bitfield)\n    var bits = buf.length * 8\n    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start)\n    this.remoteBitfield.fill(buf, have.start)\n    if (bits > this.remoteLength) {\n      this.remoteLength = this.remoteBitfield.last() + 1\n      updated = true\n    }\n  } else {\n    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield\n\n    var start = have.start\n    var len = have.length || 1\n\n    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++))\n    if (start > this.remoteLength) {\n      this.remoteLength = start\n      updated = true\n    }\n  }\n\n  if (updated) {\n    this.updated = true\n    this.feed.emit('remote-update', this)\n  }\n\n  this._updateEnd()\n  this.update()\n}\n\nPeer.prototype._updateEnd = function () {\n  if (this.live || this.feed.sparse || !this.feed._selections.length) return\n\n  var sel = this.feed._selections[0]\n  var remoteLength = this.feed.length || -1\n\n  for (var i = 0; i < this.feed.peers.length; i++) {\n    if (this.feed.peers[i].remoteLength > remoteLength) {\n      remoteLength = this.feed.peers[i].remoteLength\n    }\n  }\n\n  sel.end = remoteLength\n}\n\nPeer.prototype.onextension = function (id, message) {\n  this.remoteExtensions.onmessage(id, message, this)\n}\n\nPeer.prototype.onstatus = function (info) {\n  this.remoteUploading = info.uploading\n  this.remoteDownloading = info.downloading\n\n  if (!info.uploading) {\n    while (this.inflightRequests.length) {\n      const data = this.inflightRequests[0]\n      this._clear(data.index, !data.value)\n    }\n    for (var i = 0; i < this.inflightWants; i++) {\n      this.feed.ifAvailable.continue()\n    }\n    this.inflightWants = 0\n    this.wants = bitfield()\n  }\n  this.update()\n  if (info.downloading || this.live) return\n  if (this.feed._selections.length && this.downloading) return\n  this._autoEnd()\n}\n\nPeer.prototype._autoEnd = function () {\n  if (this.uploading && this.remoteDownloading) return\n  if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return\n  this.end()\n}\n\nPeer.prototype.onunhave = function (unhave) {\n  var start = unhave.start\n  var len = unhave.length || 1\n\n  if (start === 0 && len >= this.remoteLength) {\n    this.remoteLength = 0\n    this.remoteBitfield = bitfield()\n    return\n  }\n\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.onunwant =\nPeer.prototype.oncancel = function () {\n  // TODO: impl all of me\n}\n\nPeer.prototype.onclose = function () {\n  this._close()\n}\n\nPeer.prototype.have = function (have) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.have(have)\n  var start = have.start\n  var len = have.length\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.unhave = function (unhave) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.unhave(unhave)\n}\n\nPeer.prototype.haveBytes = function (bytes) { // called by feed\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].bytes === bytes) {\n      this.feed._reserved.set(this.inflightRequests[i].index, false)\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.update()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.update = function () {\n  // do nothing\n  while (this._update()) {}\n  this._sendWantsMaybe()\n}\n\nPeer.prototype._update = function () {\n  // should return true if mutated false if not\n  if (!this.downloading || !this.remoteUploading) return false\n  var selections = this.feed._selections\n  var waiting = this.feed._waiting\n  var wlen = waiting.length\n  var slen = selections.length\n  var inflight = this.inflightRequests.length\n  var offset = 0\n  var i = 0\n\n  // TODO: less duplicate code here\n  // TODO: re-add priority levels\n\n  while (inflight < this.urgentRequests) {\n    offset = Math.floor(Math.random() * waiting.length)\n\n    for (i = 0; i < waiting.length; i++) {\n      var w = waiting[offset++]\n      if (offset === waiting.length) offset = 0\n\n      this._downloadWaiting(w)\n      if (waiting.length !== wlen) return true // mutated\n      if (this.inflightRequests.length >= this.urgentRequests) return false\n    }\n    if (inflight === this.inflightRequests.length) break\n    inflight = this.inflightRequests.length\n  }\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * selections.length)\n\n    for (i = 0; i < selections.length; i++) {\n      var s = selections[offset++]\n      if (offset === selections.length) offset = 0\n\n      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end)\n      if (s.blocks) this._downloadBlocks(s)\n      else this._downloadRange(s)\n      if (selections.length !== slen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n\n    if (inflight === this.inflightRequests.length) return false\n    inflight = this.inflightRequests.length\n  }\n\n  return false\n}\n\nPeer.prototype.onopen = function () {\n  this.feed.ifAvailable.continue()\n  this.remoteOpened = true\n\n  this._updateOptions()\n\n  if (!this.uploading || !this.downloading) {\n    this.stream.status({\n      uploading: this.uploading,\n      downloading: this.downloading\n    })\n  }\n\n  this._sendWants()\n  this.feed.emit('peer-open', this)\n}\n\nPeer.prototype.onoptions = function (options) {\n  this.remoteAck = options.ack\n  this.remoteExtensions.update(options.extensions)\n}\n\nPeer.prototype.ready = function () {\n  this.feed.ifAvailable.wait() // continued by onopen or close\n  set.add(this.feed.peers, this)\n  this.feed.emit('peer-add', this)\n  if (this.stream.remoteOpened) this.onopen()\n}\n\nPeer.prototype.end = function () {\n  if (!this.downloading && !this.remoteDownloading && !this.live) {\n    if (!this._defaultDownloading) {\n      this.stream.status({ downloading: false, uploading: false })\n    }\n    this._close()\n    return\n  }\n  if (!this._closed) {\n    this._closed = true\n    this.downloading = false\n    this.stream.status({ downloading: false, uploading: true })\n  } else {\n    if (!this.live) this._close()\n  }\n}\n\nPeer.prototype._close = function () {\n  if (!this._destroyed) {\n    this._destroyed = true\n    this.stream.close()\n  }\n  if (this._index === -1) return\n  set.remove(this.feed.peers, this)\n  this._index = -1\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    this.feed._reserved.set(this.inflightRequests[i].index, false)\n  }\n  if (this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n  this._updateEnd()\n  this.remoteWant = false\n  this.feed._updatePeers()\n  this.feed.emit('peer-remove', this)\n  for (i = 0; i < this.inflightWants; i++) {\n    this.feed.ifAvailable.continue()\n  }\n  if (!this.remoteOpened) {\n    this.feed.ifAvailable.continue()\n  }\n}\n\nPeer.prototype.destroy = function (err) {\n  if (this._index === -1 || this._destroyed) return\n  this.stream.destroy(err)\n  this._destroyed = true\n  this._close()\n}\n\nPeer.prototype._sendWantsMaybe = function () {\n  if (this.inflightRequests.length < this.urgentRequests) this._sendWants()\n}\n\nPeer.prototype._sendWants = function () {\n  if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return\n  if (this.inflightWants >= 16) return\n\n  var i\n\n  for (i = 0; i < this.feed._waiting.length; i++) {\n    var w = this.feed._waiting[i]\n    if (w.index === -1) this._sendWantRange(w)\n    else this._sendWant(w.index)\n    if (this.inflightWants >= 16) return\n  }\n\n  for (i = 0; i < this.feed._selections.length; i++) {\n    var s = this.feed._selections[i]\n    this._sendWantRange(s)\n    if (this.inflightWants >= 16) return\n  }\n\n  // always sub to the first range for now, usually what you want\n  this._sendWant(0)\n}\n\nPeer.prototype._sendWantRange = function (s) {\n  if (s.blocks) {\n    if (!s.selected) s.selected = new WeakSet()\n    if (s.selected.has(this)) return\n    s.selected.add(this)\n    for (const block of s.blocks) {\n      this._sendWant(block)\n    }\n    return\n  }\n\n  var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0\n\n  while (true) {\n    if (want >= this.remoteLength) return\n    if (s.end !== -1 && want >= s.end) return\n\n    if (this._sendWant(want)) return\n\n    // check if region is already selected - if so try next one\n    if (!this.wants.get(Math.floor(want / 1024 / 1024))) return\n    want += 1024 * 1024\n  }\n}\n\nPeer.prototype._sendWant = function (index) {\n  var len = 1024 * 1024\n  var j = Math.floor(index / len)\n  if (this.wants.get(j)) return false\n  this.wants.set(j, true)\n  this.inflightWants++\n  this.feed.ifAvailable.wait()\n  this.stream.want({ start: j * len, length: len })\n  return true\n}\n\nPeer.prototype._downloadWaiting = function (wait) {\n  if (!wait.bytes) {\n    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {\n      if (!wait.update || this.feed._reserved.get(wait.index)) return\n      const i = this._iterator.seek(wait.index).next(true)\n      if (i === -1 || !this.feed._reserved.set(i, true)) return\n      wait.index = i\n    }\n    this._request(wait.index, 0, wait.hash === true)\n    return\n  }\n\n  this._downloadRange(wait)\n}\n\nPeer.prototype._downloadBlocks = function (range) {\n  while (range.blocksDownloaded < range.blocks.length) {\n    const blk = range.blocks[range.blocksDownloaded]\n    if (!this.feed.bitfield.get(blk)) break\n    range.blocksDownloaded++\n  }\n\n  if (range.blocksDownloaded >= range.blocks.length) {\n    set.remove(this.feed._selections, range)\n    range.callback(null)\n    return\n  }\n\n  for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {\n    const blk = range.blocks[i]\n    if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {\n      range.requested++\n      this._request(blk, 0, false)\n      return\n    }\n  }\n}\n\nPeer.prototype._downloadRange = function (range) {\n  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end)\n\n  var reserved = this.feed._reserved\n  var ite = this._iterator\n  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength)\n\n  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd)\n  var start = i\n\n  if (i === -1 || i >= wantedEnd) {\n    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n      set.remove(this.feed._selections, range)\n      range.callback(null)\n      if (!this.live && !this.sparse && !this.feed._selections.length) this.end()\n    }\n    return\n  }\n\n  while ((range.hash && this.feed.tree.get(2 * i)) || !reserved.set(i, true)) {\n    i = ite.next(true)\n\n    if (i > -1 && i < wantedEnd) {\n      // check this index\n      continue\n    }\n\n    if (!range.linear && start !== 0) {\n      // retry from the beginning since we are iterating randomly and started !== 0\n      i = ite.seek(range.start).next(true)\n      start = 0\n      if (i > -1 && i < wantedEnd) continue\n    }\n\n    // we have checked all indexes.\n    // if we are looking for hashes we should check if we have all now (first check only checks blocks)\n    if (range.hash) {\n      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots\n      // but we don't really request long ranges of hashes so yolo\n      for (var j = range.start; j < wantedEnd; j++) {\n        if (!this.feed.tree.get(2 * j)) return\n      }\n      if (!range.bytes) {\n        set.remove(this.feed._selections, range)\n        range.callback(null)\n      }\n    }\n\n    // exit the update loop - nothing to do\n    return\n  }\n\n  range.requested++\n  this._request(i, range.bytes || 0, range.hash)\n}\n\nPeer.prototype._request = function (index, bytes, hash) {\n  var request = {\n    bytes: bytes,\n    index: index,\n    hash: hash,\n    nodes: this.feed.digest(index)\n  }\n\n  if (this._requestTimeout === null && this.stream.stream.timeout) {\n    this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n  }\n  this.inflightRequests.push(request)\n  this.stream.request(request)\n}\n\nPeer.prototype.extension = function (id, message) {\n  this.stream.extension(id, message)\n}\n\nfunction createView (page) {\n  var buf = page ? page.buffer : EMPTY\n  return new DataView(buf.buffer, buf.byteOffset, 1024)\n}\n\nfunction remoteAndNotLocal (local, buf, le, start) {\n  var remote = new DataView(buf.buffer, buf.byteOffset)\n  var len = Math.floor(buf.length / 4)\n  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len)\n  var p = start / 8192 // 8192 is bits per bitfield page\n  var l = 0\n  var page = createView(local.pages.get(p++, true))\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * (l++), !le)\n\n    if (l === 256) {\n      page = createView(local.pages.get(p++, true))\n      l = 0\n    }\n  }\n}\n\nfunction nextRandom (ite, start, end) {\n  var len = end - start\n  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true)\n  return i === -1 || i >= end ? ite.seek(start).next(true) : i\n}\n","start":1670465469245,"end":1670465469245,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js?commonjs-proxy\";\n\nvar Protocol = require$$0\nvar timeout = require$$1\nvar bitfield = require$$2\nvar set = require$$3\nvar rle = require$$4.align(4)\nvar treeIndex = require$$5\n\nvar EMPTY = new Uint8Array(1024)\n\nvar replicate_1 = replicate\n\nfunction replicate (feed, initiator, opts) {\n  feed.ifAvailable.wait()\n  var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream\n\n  if (!stream) {\n    if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair\n    stream = new Protocol(initiator, opts)\n  }\n\n  if (feed.opened) onready(null)\n  else feed.ready(onready)\n\n  return stream\n\n  function onready (err) {\n    feed.ifAvailable.continue()\n\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n\n    if (opts.noise !== false && opts.onfeedauthenticate) {\n      if (!stream.remotePublicKey) {\n        feed.ifAvailable.wait()\n        stream.setMaxListeners(0)\n        stream.on('close', onhandshake)\n        stream.on('handshake', onhandshake)\n        return\n      }\n      feedauthenticate()\n      return\n    }\n    replicatePeer()\n  }\n\n  function onhandshake () {\n    feed.ifAvailable.continue()\n    stream.off('close', onhandshake)\n    stream.off('handshake', onhandshake)\n    feedauthenticate()\n  }\n\n  function feedauthenticate () {\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n    feed.ifAvailable.wait()\n    opts.onfeedauthenticate(feed, stream.remotePublicKey, function (err) {\n      feed.ifAvailable.continue()\n      if (stream.destroyed) return\n      if (stream.opened(feed.key)) return\n      if (err) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n      replicatePeer()\n    })\n  }\n\n  function replicatePeer () {\n    if (opts.noise !== false) {\n      if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n    }\n\n    var peer = new Peer(feed, opts)\n\n    peer.feed = feed\n    peer.stream = stream.open(feed.key, peer)\n\n    stream.setMaxListeners(0)\n    peer.ready()\n    feed.emit('replicating', stream)\n  }\n}\n\nfunction Peer (feed, opts) {\n  if (opts.extensions) throw new Error('Per peer extensions is not supported. Use feed.registerExtension instead')\n\n  this.feed = feed\n  this.stream = null // set by replicate just after creation\n  this.wants = bitfield()\n  this.remoteBitfield = bitfield()\n  this.remoteLength = 0\n  this.remoteWant = false\n  this.remoteTree = null\n  this.remoteAck = false\n  this.remoteOpened = false\n  this.live = !!opts.live\n  this.sparse = feed.sparse\n  this.ack = !!opts.ack\n\n  this.remoteDownloading = true\n  this.remoteUploading = true\n  this.remoteExtensions = feed.extensions.remote()\n  this.downloading = typeof opts.download === 'boolean' ? opts.download : feed.downloading\n  this.uploading = typeof opts.upload === 'boolean' ? opts.upload : feed.uploading\n\n  this.updated = false\n\n  this.maxRequests = opts.maxRequests || feed.maxRequests || 16\n  this.urgentRequests = this.maxRequests + 16\n  this.inflightRequests = []\n  this.inflightWants = 0\n\n  this._index = -1\n  this._lastBytes = 0\n  this._first = true\n  this._closed = false\n  this._destroyed = false\n  this._defaultDownloading = this.downloading\n  this._iterator = this.remoteBitfield.iterator()\n  this._requestTimeout = null\n\n  this.stats = !opts.stats ? null : {\n    uploadedBytes: 0,\n    uploadedBlocks: 0,\n    downloadedBytes: 0,\n    downloadedBlocks: 0\n  }\n}\n\nObject.defineProperty(Peer.prototype, 'remoteAddress', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteAddress\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remoteType', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteType\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remotePublicKey', {\n  enumerable: true,\n  get: function () {\n    return this.stream.state.remotePublicKey\n  }\n})\n\nPeer.prototype.onwant = function (want) {\n  if (!this.uploading) return\n  // We only reploy to multipla of 8192 in terms of offsets and lengths for want messages\n  // since this is much easier for the bitfield, in terms of paging.\n  if ((want.start & 8191) || (want.length & 8191)) return\n  if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {\n    // Eagerly send the length of the feed to the otherside\n    // TODO: only send this if the remote is not wanting a region\n    // where this is contained in\n    this.stream.have({ start: this.feed.length - 1 })\n  }\n  this.remoteWant = true\n  var rle = this.feed.bitfield.compress(want.start, want.length)\n  this.stream.have({ start: want.start, length: want.length, bitfield: rle })\n}\n\nPeer.prototype.ondata = function (data) {\n  var self = this\n\n  // Ignore unrequested messages unless we allow push\n  // TODO: would be better to check if the byte range was requested instead, but this works fine\n  var allowPush = this.feed.allowPush || !data.value\n  if (!allowPush && !this.feed._reserved.get(data.index)) {\n    // If we do not have this block, send back unhave message for this index,\n    // to let the remote know we rejected it.\n    // TODO: we might want to have some \"unwanted push\" threshold to punish spammers\n    if (!self.feed.bitfield.get(data.index)) self.unhave({ start: data.index })\n    self._clear(data.index, !data.value)\n    return\n  }\n\n  this.feed._putBuffer(data.index, data.value, data, this, function (err) {\n    if (err) return self.destroy(err)\n    if (data.value) self.remoteBitfield.set(data.index, false)\n    if (self.remoteAck) {\n      // Send acknowledgement.\n      // In the future this could batch several ACKs at once\n      self.stream.have({ start: data.index, length: 1, ack: true })\n    }\n    if (self.stats && data.value) {\n      self.stats.downloadedBlocks += 1\n      self.stats.downloadedBytes += data.value.length\n    }\n    self._clear(data.index, !data.value)\n  })\n}\n\nPeer.prototype._clear = function (index, hash) {\n  // TODO: optimize me (no splice and do not run through all ...)\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].index === index) {\n      if (this._requestTimeout !== null) this._requestTimeout.refresh()\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.feed._reserved.set(index, false)\n  // TODO: only update all if we have overlapping selections\n  this.feed._updatePeers()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.onrequest = function (request) {\n  if (!this.uploading) return\n  if (request.bytes) return this._onbytes(request)\n\n  // lazily instantiate the remote tree\n  if (!this.remoteTree) this.remoteTree = treeIndex()\n\n  var self = this\n  var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree }\n\n  this.feed.proof(request.index, opts, onproof)\n\n  function onproof (err, proof) {\n    if (err) return self.destroy(err)\n    if (request.hash) onvalue(null, null)\n    else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue)\n\n    function onvalue (err, value) {\n      if (!self.uploading) return\n      if (err) return self.destroy(err)\n\n      if (value) {\n        if (self.stats) {\n          self.stats.uploadedBlocks += 1\n          self.stats.uploadedBytes += value.length\n          self.feed._stats.uploadedBlocks += 1\n          self.feed._stats.uploadedBytes += value.length\n        }\n        self.feed.emit('upload', request.index, value, self)\n      }\n\n      // TODO: prob not needed with new bitfield\n      if (request.index + 1 > self.remoteLength) {\n        self.remoteLength = request.index + 1\n        self._updateEnd()\n      }\n\n      self.stream.data({\n        index: request.index,\n        value: value,\n        nodes: proof.nodes,\n        signature: proof.signature\n      })\n    }\n  }\n}\n\nPeer.prototype._updateOptions = function () {\n  if (this.ack || this.feed.extensions.length) {\n    this.stream.options({\n      ack: this.ack,\n      extensions: this.feed.extensions.names()\n    })\n  }\n}\n\nPeer.prototype.setDownloading = function (downloading) {\n  if (downloading === this.downloading) return\n  this.downloading = downloading\n  this.stream.status({\n    downloading,\n    uploading: this.uploading\n  })\n  this.update()\n}\n\nPeer.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.stream.status({\n    downloading: this.downloading,\n    uploading\n  })\n  this.update()\n}\n\nPeer.prototype._onbytes = function (request) {\n  var self = this\n\n  this.feed.seek(request.bytes, { wait: false }, function (err, index) {\n    if (err) {\n      request.bytes = 0\n      self.onrequest(request)\n      return\n    }\n\n    // quick'n'dirty filter for parallel bytes requests\n    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization\n    if (self._lastBytes === request.bytes) return\n    self._lastBytes = request.bytes\n\n    request.bytes = 0\n    request.index = index\n    request.nodes = 0\n\n    self.onrequest(request)\n  })\n}\n\nPeer.prototype._onrequesttimeout = function () {\n  this._requestTimeout = null\n  if (!this.inflightRequests.length) return\n\n  var first = this.inflightRequests[0]\n\n  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n    // prob a bytes response\n    this.inflightRequests.shift()\n    this.feed._reserved.set(first.index, false)\n\n    if (this.stream.stream.timeout) {\n      this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n    }\n    return\n  }\n\n  this.destroy(new Error('Request timeout'))\n}\n\nPeer.prototype.onhave = function (have) {\n  this.feed.emit('peer-ack', this, have)\n\n  if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {\n    this.stream.stream.emit('ack', have)\n    return\n  }\n\n  var updated = this._first\n  if (this._first) this._first = false\n\n  // In this impl, we only sent WANTs for 1024 * 1024 length ranges\n  // so if we get a HAVE for that it is a reply to a WANT.\n  if (have.length === 1024 * 1024 && this.inflightWants > 0) {\n    this.feed.ifAvailable.continue()\n    this.inflightWants--\n  }\n\n  if (have.bitfield) { // TODO: handle start !== 0\n    if (have.length === 0 || have.length === 1) { // length === 1 is for backwards compat\n      this.wants = null // we are in backwards compat mode where we subscribe everything\n    }\n    var buf = rle.decode(have.bitfield)\n    var bits = buf.length * 8\n    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start)\n    this.remoteBitfield.fill(buf, have.start)\n    if (bits > this.remoteLength) {\n      this.remoteLength = this.remoteBitfield.last() + 1\n      updated = true\n    }\n  } else {\n    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield\n\n    var start = have.start\n    var len = have.length || 1\n\n    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++))\n    if (start > this.remoteLength) {\n      this.remoteLength = start\n      updated = true\n    }\n  }\n\n  if (updated) {\n    this.updated = true\n    this.feed.emit('remote-update', this)\n  }\n\n  this._updateEnd()\n  this.update()\n}\n\nPeer.prototype._updateEnd = function () {\n  if (this.live || this.feed.sparse || !this.feed._selections.length) return\n\n  var sel = this.feed._selections[0]\n  var remoteLength = this.feed.length || -1\n\n  for (var i = 0; i < this.feed.peers.length; i++) {\n    if (this.feed.peers[i].remoteLength > remoteLength) {\n      remoteLength = this.feed.peers[i].remoteLength\n    }\n  }\n\n  sel.end = remoteLength\n}\n\nPeer.prototype.onextension = function (id, message) {\n  this.remoteExtensions.onmessage(id, message, this)\n}\n\nPeer.prototype.onstatus = function (info) {\n  this.remoteUploading = info.uploading\n  this.remoteDownloading = info.downloading\n\n  if (!info.uploading) {\n    while (this.inflightRequests.length) {\n      const data = this.inflightRequests[0]\n      this._clear(data.index, !data.value)\n    }\n    for (var i = 0; i < this.inflightWants; i++) {\n      this.feed.ifAvailable.continue()\n    }\n    this.inflightWants = 0\n    this.wants = bitfield()\n  }\n  this.update()\n  if (info.downloading || this.live) return\n  if (this.feed._selections.length && this.downloading) return\n  this._autoEnd()\n}\n\nPeer.prototype._autoEnd = function () {\n  if (this.uploading && this.remoteDownloading) return\n  if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return\n  this.end()\n}\n\nPeer.prototype.onunhave = function (unhave) {\n  var start = unhave.start\n  var len = unhave.length || 1\n\n  if (start === 0 && len >= this.remoteLength) {\n    this.remoteLength = 0\n    this.remoteBitfield = bitfield()\n    return\n  }\n\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.onunwant =\nPeer.prototype.oncancel = function () {\n  // TODO: impl all of me\n}\n\nPeer.prototype.onclose = function () {\n  this._close()\n}\n\nPeer.prototype.have = function (have) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.have(have)\n  var start = have.start\n  var len = have.length\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.unhave = function (unhave) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.unhave(unhave)\n}\n\nPeer.prototype.haveBytes = function (bytes) { // called by feed\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].bytes === bytes) {\n      this.feed._reserved.set(this.inflightRequests[i].index, false)\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.update()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.update = function () {\n  // do nothing\n  while (this._update()) {}\n  this._sendWantsMaybe()\n}\n\nPeer.prototype._update = function () {\n  // should return true if mutated false if not\n  if (!this.downloading || !this.remoteUploading) return false\n  var selections = this.feed._selections\n  var waiting = this.feed._waiting\n  var wlen = waiting.length\n  var slen = selections.length\n  var inflight = this.inflightRequests.length\n  var offset = 0\n  var i = 0\n\n  // TODO: less duplicate code here\n  // TODO: re-add priority levels\n\n  while (inflight < this.urgentRequests) {\n    offset = Math.floor(Math.random() * waiting.length)\n\n    for (i = 0; i < waiting.length; i++) {\n      var w = waiting[offset++]\n      if (offset === waiting.length) offset = 0\n\n      this._downloadWaiting(w)\n      if (waiting.length !== wlen) return true // mutated\n      if (this.inflightRequests.length >= this.urgentRequests) return false\n    }\n    if (inflight === this.inflightRequests.length) break\n    inflight = this.inflightRequests.length\n  }\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * selections.length)\n\n    for (i = 0; i < selections.length; i++) {\n      var s = selections[offset++]\n      if (offset === selections.length) offset = 0\n\n      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end)\n      if (s.blocks) this._downloadBlocks(s)\n      else this._downloadRange(s)\n      if (selections.length !== slen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n\n    if (inflight === this.inflightRequests.length) return false\n    inflight = this.inflightRequests.length\n  }\n\n  return false\n}\n\nPeer.prototype.onopen = function () {\n  this.feed.ifAvailable.continue()\n  this.remoteOpened = true\n\n  this._updateOptions()\n\n  if (!this.uploading || !this.downloading) {\n    this.stream.status({\n      uploading: this.uploading,\n      downloading: this.downloading\n    })\n  }\n\n  this._sendWants()\n  this.feed.emit('peer-open', this)\n}\n\nPeer.prototype.onoptions = function (options) {\n  this.remoteAck = options.ack\n  this.remoteExtensions.update(options.extensions)\n}\n\nPeer.prototype.ready = function () {\n  this.feed.ifAvailable.wait() // continued by onopen or close\n  set.add(this.feed.peers, this)\n  this.feed.emit('peer-add', this)\n  if (this.stream.remoteOpened) this.onopen()\n}\n\nPeer.prototype.end = function () {\n  if (!this.downloading && !this.remoteDownloading && !this.live) {\n    if (!this._defaultDownloading) {\n      this.stream.status({ downloading: false, uploading: false })\n    }\n    this._close()\n    return\n  }\n  if (!this._closed) {\n    this._closed = true\n    this.downloading = false\n    this.stream.status({ downloading: false, uploading: true })\n  } else {\n    if (!this.live) this._close()\n  }\n}\n\nPeer.prototype._close = function () {\n  if (!this._destroyed) {\n    this._destroyed = true\n    this.stream.close()\n  }\n  if (this._index === -1) return\n  set.remove(this.feed.peers, this)\n  this._index = -1\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    this.feed._reserved.set(this.inflightRequests[i].index, false)\n  }\n  if (this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n  this._updateEnd()\n  this.remoteWant = false\n  this.feed._updatePeers()\n  this.feed.emit('peer-remove', this)\n  for (i = 0; i < this.inflightWants; i++) {\n    this.feed.ifAvailable.continue()\n  }\n  if (!this.remoteOpened) {\n    this.feed.ifAvailable.continue()\n  }\n}\n\nPeer.prototype.destroy = function (err) {\n  if (this._index === -1 || this._destroyed) return\n  this.stream.destroy(err)\n  this._destroyed = true\n  this._close()\n}\n\nPeer.prototype._sendWantsMaybe = function () {\n  if (this.inflightRequests.length < this.urgentRequests) this._sendWants()\n}\n\nPeer.prototype._sendWants = function () {\n  if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return\n  if (this.inflightWants >= 16) return\n\n  var i\n\n  for (i = 0; i < this.feed._waiting.length; i++) {\n    var w = this.feed._waiting[i]\n    if (w.index === -1) this._sendWantRange(w)\n    else this._sendWant(w.index)\n    if (this.inflightWants >= 16) return\n  }\n\n  for (i = 0; i < this.feed._selections.length; i++) {\n    var s = this.feed._selections[i]\n    this._sendWantRange(s)\n    if (this.inflightWants >= 16) return\n  }\n\n  // always sub to the first range for now, usually what you want\n  this._sendWant(0)\n}\n\nPeer.prototype._sendWantRange = function (s) {\n  if (s.blocks) {\n    if (!s.selected) s.selected = new WeakSet()\n    if (s.selected.has(this)) return\n    s.selected.add(this)\n    for (const block of s.blocks) {\n      this._sendWant(block)\n    }\n    return\n  }\n\n  var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0\n\n  while (true) {\n    if (want >= this.remoteLength) return\n    if (s.end !== -1 && want >= s.end) return\n\n    if (this._sendWant(want)) return\n\n    // check if region is already selected - if so try next one\n    if (!this.wants.get(Math.floor(want / 1024 / 1024))) return\n    want += 1024 * 1024\n  }\n}\n\nPeer.prototype._sendWant = function (index) {\n  var len = 1024 * 1024\n  var j = Math.floor(index / len)\n  if (this.wants.get(j)) return false\n  this.wants.set(j, true)\n  this.inflightWants++\n  this.feed.ifAvailable.wait()\n  this.stream.want({ start: j * len, length: len })\n  return true\n}\n\nPeer.prototype._downloadWaiting = function (wait) {\n  if (!wait.bytes) {\n    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {\n      if (!wait.update || this.feed._reserved.get(wait.index)) return\n      const i = this._iterator.seek(wait.index).next(true)\n      if (i === -1 || !this.feed._reserved.set(i, true)) return\n      wait.index = i\n    }\n    this._request(wait.index, 0, wait.hash === true)\n    return\n  }\n\n  this._downloadRange(wait)\n}\n\nPeer.prototype._downloadBlocks = function (range) {\n  while (range.blocksDownloaded < range.blocks.length) {\n    const blk = range.blocks[range.blocksDownloaded]\n    if (!this.feed.bitfield.get(blk)) break\n    range.blocksDownloaded++\n  }\n\n  if (range.blocksDownloaded >= range.blocks.length) {\n    set.remove(this.feed._selections, range)\n    range.callback(null)\n    return\n  }\n\n  for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {\n    const blk = range.blocks[i]\n    if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {\n      range.requested++\n      this._request(blk, 0, false)\n      return\n    }\n  }\n}\n\nPeer.prototype._downloadRange = function (range) {\n  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end)\n\n  var reserved = this.feed._reserved\n  var ite = this._iterator\n  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength)\n\n  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd)\n  var start = i\n\n  if (i === -1 || i >= wantedEnd) {\n    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n      set.remove(this.feed._selections, range)\n      range.callback(null)\n      if (!this.live && !this.sparse && !this.feed._selections.length) this.end()\n    }\n    return\n  }\n\n  while ((range.hash && this.feed.tree.get(2 * i)) || !reserved.set(i, true)) {\n    i = ite.next(true)\n\n    if (i > -1 && i < wantedEnd) {\n      // check this index\n      continue\n    }\n\n    if (!range.linear && start !== 0) {\n      // retry from the beginning since we are iterating randomly and started !== 0\n      i = ite.seek(range.start).next(true)\n      start = 0\n      if (i > -1 && i < wantedEnd) continue\n    }\n\n    // we have checked all indexes.\n    // if we are looking for hashes we should check if we have all now (first check only checks blocks)\n    if (range.hash) {\n      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots\n      // but we don't really request long ranges of hashes so yolo\n      for (var j = range.start; j < wantedEnd; j++) {\n        if (!this.feed.tree.get(2 * j)) return\n      }\n      if (!range.bytes) {\n        set.remove(this.feed._selections, range)\n        range.callback(null)\n      }\n    }\n\n    // exit the update loop - nothing to do\n    return\n  }\n\n  range.requested++\n  this._request(i, range.bytes || 0, range.hash)\n}\n\nPeer.prototype._request = function (index, bytes, hash) {\n  var request = {\n    bytes: bytes,\n    index: index,\n    hash: hash,\n    nodes: this.feed.digest(index)\n  }\n\n  if (this._requestTimeout === null && this.stream.stream.timeout) {\n    this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n  }\n  this.inflightRequests.push(request)\n  this.stream.request(request)\n}\n\nPeer.prototype.extension = function (id, message) {\n  this.stream.extension(id, message)\n}\n\nfunction createView (page) {\n  var buf = page ? page.buffer : EMPTY\n  return new DataView(buf.buffer, buf.byteOffset, 1024)\n}\n\nfunction remoteAndNotLocal (local, buf, le, start) {\n  var remote = new DataView(buf.buffer, buf.byteOffset)\n  var len = Math.floor(buf.length / 4)\n  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len)\n  var p = start / 8192 // 8192 is bits per bitfield page\n  var l = 0\n  var page = createView(local.pages.get(p++, true))\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * (l++), !le)\n\n    if (l === 256) {\n      page = createView(local.pages.get(p++, true))\n      l = 0\n    }\n  }\n}\n\nfunction nextRandom (ite, start, end) {\n  var len = end - start\n  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true)\n  return i === -1 || i >= end ? ite.seek(start).next(true) : i\n}\n\nexport default replicate_1;\nexport { replicate_1 as __moduleExports };","start":1670465469246,"end":1670465471840,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/fast-bitfield@1.2.2/node_modules/fast-bitfield/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/unordered-set@2.0.1/node_modules/unordered-set/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore@9.12.0/node_modules/hypercore/lib/tree-index.js?commonjs-proxy\";\n\nvar Protocol = require$$0\nvar timeout = require$$1\nvar bitfield = require$$2\nvar set = require$$3\nvar rle = require$$4.align(4)\nvar treeIndex = require$$5\n\nvar EMPTY = new Uint8Array(1024)\n\nvar replicate_1 = replicate\n\nfunction replicate (feed, initiator, opts) {\n  feed.ifAvailable.wait()\n  var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream\n\n  if (!stream) {\n    if (!opts.keyPair) opts.keyPair = feed.noiseKeyPair\n    stream = new Protocol(initiator, opts)\n  }\n\n  if (feed.opened) onready(null)\n  else feed.ready(onready)\n\n  return stream\n\n  function onready (err) {\n    feed.ifAvailable.continue()\n\n    if (err) return stream.destroy(err)\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n\n    if (opts.noise !== false && opts.onfeedauthenticate) {\n      if (!stream.remotePublicKey) {\n        feed.ifAvailable.wait()\n        stream.setMaxListeners(0)\n        stream.on('close', onhandshake)\n        stream.on('handshake', onhandshake)\n        return\n      }\n      feedauthenticate()\n      return\n    }\n    replicatePeer()\n  }\n\n  function onhandshake () {\n    feed.ifAvailable.continue()\n    stream.off('close', onhandshake)\n    stream.off('handshake', onhandshake)\n    feedauthenticate()\n  }\n\n  function feedauthenticate () {\n    if (stream.destroyed) return\n    if (stream.opened(feed.key)) return\n    feed.ifAvailable.wait()\n    opts.onfeedauthenticate(feed, stream.remotePublicKey, function (err) {\n      feed.ifAvailable.continue()\n      if (stream.destroyed) return\n      if (stream.opened(feed.key)) return\n      if (err) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n      replicatePeer()\n    })\n  }\n\n  function replicatePeer () {\n    if (opts.noise !== false) {\n      if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {\n        stream.close(feed.discoveryKey)\n        return\n      }\n    }\n\n    var peer = new Peer(feed, opts)\n\n    peer.feed = feed\n    peer.stream = stream.open(feed.key, peer)\n\n    stream.setMaxListeners(0)\n    peer.ready()\n    feed.emit('replicating', stream)\n  }\n}\n\nfunction Peer (feed, opts) {\n  if (opts.extensions) throw new Error('Per peer extensions is not supported. Use feed.registerExtension instead')\n\n  this.feed = feed\n  this.stream = null // set by replicate just after creation\n  this.wants = bitfield()\n  this.remoteBitfield = bitfield()\n  this.remoteLength = 0\n  this.remoteWant = false\n  this.remoteTree = null\n  this.remoteAck = false\n  this.remoteOpened = false\n  this.live = !!opts.live\n  this.sparse = feed.sparse\n  this.ack = !!opts.ack\n\n  this.remoteDownloading = true\n  this.remoteUploading = true\n  this.remoteExtensions = feed.extensions.remote()\n  this.downloading = typeof opts.download === 'boolean' ? opts.download : feed.downloading\n  this.uploading = typeof opts.upload === 'boolean' ? opts.upload : feed.uploading\n\n  this.updated = false\n\n  this.maxRequests = opts.maxRequests || feed.maxRequests || 16\n  this.urgentRequests = this.maxRequests + 16\n  this.inflightRequests = []\n  this.inflightWants = 0\n\n  this._index = -1\n  this._lastBytes = 0\n  this._first = true\n  this._closed = false\n  this._destroyed = false\n  this._defaultDownloading = this.downloading\n  this._iterator = this.remoteBitfield.iterator()\n  this._requestTimeout = null\n\n  this.stats = !opts.stats ? null : {\n    uploadedBytes: 0,\n    uploadedBlocks: 0,\n    downloadedBytes: 0,\n    downloadedBlocks: 0\n  }\n}\n\nObject.defineProperty(Peer.prototype, 'remoteAddress', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteAddress\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remoteType', {\n  enumerable: true,\n  get: function () {\n    return this.stream.stream.remoteType\n  }\n})\n\nObject.defineProperty(Peer.prototype, 'remotePublicKey', {\n  enumerable: true,\n  get: function () {\n    return this.stream.state.remotePublicKey\n  }\n})\n\nPeer.prototype.onwant = function (want) {\n  if (!this.uploading) return\n  // We only reploy to multipla of 8192 in terms of offsets and lengths for want messages\n  // since this is much easier for the bitfield, in terms of paging.\n  if ((want.start & 8191) || (want.length & 8191)) return\n  if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {\n    // Eagerly send the length of the feed to the otherside\n    // TODO: only send this if the remote is not wanting a region\n    // where this is contained in\n    this.stream.have({ start: this.feed.length - 1 })\n  }\n  this.remoteWant = true\n  var rle = this.feed.bitfield.compress(want.start, want.length)\n  this.stream.have({ start: want.start, length: want.length, bitfield: rle })\n}\n\nPeer.prototype.ondata = function (data) {\n  var self = this\n\n  // Ignore unrequested messages unless we allow push\n  // TODO: would be better to check if the byte range was requested instead, but this works fine\n  var allowPush = this.feed.allowPush || !data.value\n  if (!allowPush && !this.feed._reserved.get(data.index)) {\n    // If we do not have this block, send back unhave message for this index,\n    // to let the remote know we rejected it.\n    // TODO: we might want to have some \"unwanted push\" threshold to punish spammers\n    if (!self.feed.bitfield.get(data.index)) self.unhave({ start: data.index })\n    self._clear(data.index, !data.value)\n    return\n  }\n\n  this.feed._putBuffer(data.index, data.value, data, this, function (err) {\n    if (err) return self.destroy(err)\n    if (data.value) self.remoteBitfield.set(data.index, false)\n    if (self.remoteAck) {\n      // Send acknowledgement.\n      // In the future this could batch several ACKs at once\n      self.stream.have({ start: data.index, length: 1, ack: true })\n    }\n    if (self.stats && data.value) {\n      self.stats.downloadedBlocks += 1\n      self.stats.downloadedBytes += data.value.length\n    }\n    self._clear(data.index, !data.value)\n  })\n}\n\nPeer.prototype._clear = function (index, hash) {\n  // TODO: optimize me (no splice and do not run through all ...)\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].index === index) {\n      if (this._requestTimeout !== null) this._requestTimeout.refresh()\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.feed._reserved.set(index, false)\n  // TODO: only update all if we have overlapping selections\n  this.feed._updatePeers()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.onrequest = function (request) {\n  if (!this.uploading) return\n  if (request.bytes) return this._onbytes(request)\n\n  // lazily instantiate the remote tree\n  if (!this.remoteTree) this.remoteTree = treeIndex()\n\n  var self = this\n  var opts = { digest: request.nodes, hash: request.hash, tree: this.remoteTree }\n\n  this.feed.proof(request.index, opts, onproof)\n\n  function onproof (err, proof) {\n    if (err) return self.destroy(err)\n    if (request.hash) onvalue(null, null)\n    else if (self.feed.bitfield.get(request.index)) self.feed._getBuffer(request.index, onvalue)\n\n    function onvalue (err, value) {\n      if (!self.uploading) return\n      if (err) return self.destroy(err)\n\n      if (value) {\n        if (self.stats) {\n          self.stats.uploadedBlocks += 1\n          self.stats.uploadedBytes += value.length\n          self.feed._stats.uploadedBlocks += 1\n          self.feed._stats.uploadedBytes += value.length\n        }\n        self.feed.emit('upload', request.index, value, self)\n      }\n\n      // TODO: prob not needed with new bitfield\n      if (request.index + 1 > self.remoteLength) {\n        self.remoteLength = request.index + 1\n        self._updateEnd()\n      }\n\n      self.stream.data({\n        index: request.index,\n        value: value,\n        nodes: proof.nodes,\n        signature: proof.signature\n      })\n    }\n  }\n}\n\nPeer.prototype._updateOptions = function () {\n  if (this.ack || this.feed.extensions.length) {\n    this.stream.options({\n      ack: this.ack,\n      extensions: this.feed.extensions.names()\n    })\n  }\n}\n\nPeer.prototype.setDownloading = function (downloading) {\n  if (downloading === this.downloading) return\n  this.downloading = downloading\n  this.stream.status({\n    downloading,\n    uploading: this.uploading\n  })\n  this.update()\n}\n\nPeer.prototype.setUploading = function (uploading) {\n  if (uploading === this.uploading) return\n  this.uploading = uploading\n  this.stream.status({\n    downloading: this.downloading,\n    uploading\n  })\n  this.update()\n}\n\nPeer.prototype._onbytes = function (request) {\n  var self = this\n\n  this.feed.seek(request.bytes, { wait: false }, function (err, index) {\n    if (err) {\n      request.bytes = 0\n      self.onrequest(request)\n      return\n    }\n\n    // quick'n'dirty filter for parallel bytes requests\n    // it does not matter that this doesn't catch ALL parallel requests - just a bandwidth optimization\n    if (self._lastBytes === request.bytes) return\n    self._lastBytes = request.bytes\n\n    request.bytes = 0\n    request.index = index\n    request.nodes = 0\n\n    self.onrequest(request)\n  })\n}\n\nPeer.prototype._onrequesttimeout = function () {\n  this._requestTimeout = null\n  if (!this.inflightRequests.length) return\n\n  var first = this.inflightRequests[0]\n\n  if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {\n    // prob a bytes response\n    this.inflightRequests.shift()\n    this.feed._reserved.set(first.index, false)\n\n    if (this.stream.stream.timeout) {\n      this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n    }\n    return\n  }\n\n  this.destroy(new Error('Request timeout'))\n}\n\nPeer.prototype.onhave = function (have) {\n  this.feed.emit('peer-ack', this, have)\n\n  if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {\n    this.stream.stream.emit('ack', have)\n    return\n  }\n\n  var updated = this._first\n  if (this._first) this._first = false\n\n  // In this impl, we only sent WANTs for 1024 * 1024 length ranges\n  // so if we get a HAVE for that it is a reply to a WANT.\n  if (have.length === 1024 * 1024 && this.inflightWants > 0) {\n    this.feed.ifAvailable.continue()\n    this.inflightWants--\n  }\n\n  if (have.bitfield) { // TODO: handle start !== 0\n    if (have.length === 0 || have.length === 1) { // length === 1 is for backwards compat\n      this.wants = null // we are in backwards compat mode where we subscribe everything\n    }\n    var buf = rle.decode(have.bitfield)\n    var bits = buf.length * 8\n    remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start)\n    this.remoteBitfield.fill(buf, have.start)\n    if (bits > this.remoteLength) {\n      this.remoteLength = this.remoteBitfield.last() + 1\n      updated = true\n    }\n  } else {\n    // TODO: if len > something simply copy a 0b1111... buffer to the bitfield\n\n    var start = have.start\n    var len = have.length || 1\n\n    while (len--) this.remoteBitfield.set(start, !this.feed.bitfield.get(start++))\n    if (start > this.remoteLength) {\n      this.remoteLength = start\n      updated = true\n    }\n  }\n\n  if (updated) {\n    this.updated = true\n    this.feed.emit('remote-update', this)\n  }\n\n  this._updateEnd()\n  this.update()\n}\n\nPeer.prototype._updateEnd = function () {\n  if (this.live || this.feed.sparse || !this.feed._selections.length) return\n\n  var sel = this.feed._selections[0]\n  var remoteLength = this.feed.length || -1\n\n  for (var i = 0; i < this.feed.peers.length; i++) {\n    if (this.feed.peers[i].remoteLength > remoteLength) {\n      remoteLength = this.feed.peers[i].remoteLength\n    }\n  }\n\n  sel.end = remoteLength\n}\n\nPeer.prototype.onextension = function (id, message) {\n  this.remoteExtensions.onmessage(id, message, this)\n}\n\nPeer.prototype.onstatus = function (info) {\n  this.remoteUploading = info.uploading\n  this.remoteDownloading = info.downloading\n\n  if (!info.uploading) {\n    while (this.inflightRequests.length) {\n      const data = this.inflightRequests[0]\n      this._clear(data.index, !data.value)\n    }\n    for (var i = 0; i < this.inflightWants; i++) {\n      this.feed.ifAvailable.continue()\n    }\n    this.inflightWants = 0\n    this.wants = bitfield()\n  }\n  this.update()\n  if (info.downloading || this.live) return\n  if (this.feed._selections.length && this.downloading) return\n  this._autoEnd()\n}\n\nPeer.prototype._autoEnd = function () {\n  if (this.uploading && this.remoteDownloading) return\n  if ((this.sparse || this.live) && (this.remoteUploading || this.downloading)) return\n  this.end()\n}\n\nPeer.prototype.onunhave = function (unhave) {\n  var start = unhave.start\n  var len = unhave.length || 1\n\n  if (start === 0 && len >= this.remoteLength) {\n    this.remoteLength = 0\n    this.remoteBitfield = bitfield()\n    return\n  }\n\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.onunwant =\nPeer.prototype.oncancel = function () {\n  // TODO: impl all of me\n}\n\nPeer.prototype.onclose = function () {\n  this._close()\n}\n\nPeer.prototype.have = function (have) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.have(have)\n  var start = have.start\n  var len = have.length\n  while (len--) this.remoteBitfield.set(start++, false)\n}\n\nPeer.prototype.unhave = function (unhave) { // called by feed\n  if (this.stream && this.remoteWant) this.stream.unhave(unhave)\n}\n\nPeer.prototype.haveBytes = function (bytes) { // called by feed\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    if (this.inflightRequests[i].bytes === bytes) {\n      this.feed._reserved.set(this.inflightRequests[i].index, false)\n      this.inflightRequests.splice(i, 1)\n      i--\n    }\n  }\n\n  this.update()\n\n  if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n}\n\nPeer.prototype.update = function () {\n  // do nothing\n  while (this._update()) {}\n  this._sendWantsMaybe()\n}\n\nPeer.prototype._update = function () {\n  // should return true if mutated false if not\n  if (!this.downloading || !this.remoteUploading) return false\n  var selections = this.feed._selections\n  var waiting = this.feed._waiting\n  var wlen = waiting.length\n  var slen = selections.length\n  var inflight = this.inflightRequests.length\n  var offset = 0\n  var i = 0\n\n  // TODO: less duplicate code here\n  // TODO: re-add priority levels\n\n  while (inflight < this.urgentRequests) {\n    offset = Math.floor(Math.random() * waiting.length)\n\n    for (i = 0; i < waiting.length; i++) {\n      var w = waiting[offset++]\n      if (offset === waiting.length) offset = 0\n\n      this._downloadWaiting(w)\n      if (waiting.length !== wlen) return true // mutated\n      if (this.inflightRequests.length >= this.urgentRequests) return false\n    }\n    if (inflight === this.inflightRequests.length) break\n    inflight = this.inflightRequests.length\n  }\n\n  while (inflight < this.maxRequests) {\n    offset = Math.floor(Math.random() * selections.length)\n\n    for (i = 0; i < selections.length; i++) {\n      var s = selections[offset++]\n      if (offset === selections.length) offset = 0\n\n      if (!s.iterator) s.iterator = this.feed.bitfield.iterator(s.start, s.end)\n      if (s.blocks) this._downloadBlocks(s)\n      else this._downloadRange(s)\n      if (selections.length !== slen) return true // mutated\n      if (this.inflightRequests.length >= this.maxRequests) return false\n    }\n\n    if (inflight === this.inflightRequests.length) return false\n    inflight = this.inflightRequests.length\n  }\n\n  return false\n}\n\nPeer.prototype.onopen = function () {\n  this.feed.ifAvailable.continue()\n  this.remoteOpened = true\n\n  this._updateOptions()\n\n  if (!this.uploading || !this.downloading) {\n    this.stream.status({\n      uploading: this.uploading,\n      downloading: this.downloading\n    })\n  }\n\n  this._sendWants()\n  this.feed.emit('peer-open', this)\n}\n\nPeer.prototype.onoptions = function (options) {\n  this.remoteAck = options.ack\n  this.remoteExtensions.update(options.extensions)\n}\n\nPeer.prototype.ready = function () {\n  this.feed.ifAvailable.wait() // continued by onopen or close\n  set.add(this.feed.peers, this)\n  this.feed.emit('peer-add', this)\n  if (this.stream.remoteOpened) this.onopen()\n}\n\nPeer.prototype.end = function () {\n  if (!this.downloading && !this.remoteDownloading && !this.live) {\n    if (!this._defaultDownloading) {\n      this.stream.status({ downloading: false, uploading: false })\n    }\n    this._close()\n    return\n  }\n  if (!this._closed) {\n    this._closed = true\n    this.downloading = false\n    this.stream.status({ downloading: false, uploading: true })\n  } else {\n    if (!this.live) this._close()\n  }\n}\n\nPeer.prototype._close = function () {\n  if (!this._destroyed) {\n    this._destroyed = true\n    this.stream.close()\n  }\n  if (this._index === -1) return\n  set.remove(this.feed.peers, this)\n  this._index = -1\n  for (var i = 0; i < this.inflightRequests.length; i++) {\n    this.feed._reserved.set(this.inflightRequests[i].index, false)\n  }\n  if (this._requestTimeout !== null) {\n    this._requestTimeout.destroy()\n    this._requestTimeout = null\n  }\n  this._updateEnd()\n  this.remoteWant = false\n  this.feed._updatePeers()\n  this.feed.emit('peer-remove', this)\n  for (i = 0; i < this.inflightWants; i++) {\n    this.feed.ifAvailable.continue()\n  }\n  if (!this.remoteOpened) {\n    this.feed.ifAvailable.continue()\n  }\n}\n\nPeer.prototype.destroy = function (err) {\n  if (this._index === -1 || this._destroyed) return\n  this.stream.destroy(err)\n  this._destroyed = true\n  this._close()\n}\n\nPeer.prototype._sendWantsMaybe = function () {\n  if (this.inflightRequests.length < this.urgentRequests) this._sendWants()\n}\n\nPeer.prototype._sendWants = function () {\n  if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading) return\n  if (this.inflightWants >= 16) return\n\n  var i\n\n  for (i = 0; i < this.feed._waiting.length; i++) {\n    var w = this.feed._waiting[i]\n    if (w.index === -1) this._sendWantRange(w)\n    else this._sendWant(w.index)\n    if (this.inflightWants >= 16) return\n  }\n\n  for (i = 0; i < this.feed._selections.length; i++) {\n    var s = this.feed._selections[i]\n    this._sendWantRange(s)\n    if (this.inflightWants >= 16) return\n  }\n\n  // always sub to the first range for now, usually what you want\n  this._sendWant(0)\n}\n\nPeer.prototype._sendWantRange = function (s) {\n  if (s.blocks) {\n    if (!s.selected) s.selected = new WeakSet()\n    if (s.selected.has(this)) return\n    s.selected.add(this)\n    for (const block of s.blocks) {\n      this._sendWant(block)\n    }\n    return\n  }\n\n  var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0\n\n  while (true) {\n    if (want >= this.remoteLength) return\n    if (s.end !== -1 && want >= s.end) return\n\n    if (this._sendWant(want)) return\n\n    // check if region is already selected - if so try next one\n    if (!this.wants.get(Math.floor(want / 1024 / 1024))) return\n    want += 1024 * 1024\n  }\n}\n\nPeer.prototype._sendWant = function (index) {\n  var len = 1024 * 1024\n  var j = Math.floor(index / len)\n  if (this.wants.get(j)) return false\n  this.wants.set(j, true)\n  this.inflightWants++\n  this.feed.ifAvailable.wait()\n  this.stream.want({ start: j * len, length: len })\n  return true\n}\n\nPeer.prototype._downloadWaiting = function (wait) {\n  if (!wait.bytes) {\n    if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {\n      if (!wait.update || this.feed._reserved.get(wait.index)) return\n      const i = this._iterator.seek(wait.index).next(true)\n      if (i === -1 || !this.feed._reserved.set(i, true)) return\n      wait.index = i\n    }\n    this._request(wait.index, 0, wait.hash === true)\n    return\n  }\n\n  this._downloadRange(wait)\n}\n\nPeer.prototype._downloadBlocks = function (range) {\n  while (range.blocksDownloaded < range.blocks.length) {\n    const blk = range.blocks[range.blocksDownloaded]\n    if (!this.feed.bitfield.get(blk)) break\n    range.blocksDownloaded++\n  }\n\n  if (range.blocksDownloaded >= range.blocks.length) {\n    set.remove(this.feed._selections, range)\n    range.callback(null)\n    return\n  }\n\n  for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {\n    const blk = range.blocks[i]\n    if (this.remoteBitfield.get(blk) && this.feed._reserved.set(blk, true)) {\n      range.requested++\n      this._request(blk, 0, false)\n      return\n    }\n  }\n}\n\nPeer.prototype._downloadRange = function (range) {\n  if (!range.iterator) range.iterator = this.feed.bitfield.iterator(range.start, range.end)\n\n  var reserved = this.feed._reserved\n  var ite = this._iterator\n  var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength)\n\n  var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd)\n  var start = i\n\n  if (i === -1 || i >= wantedEnd) {\n    if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {\n      set.remove(this.feed._selections, range)\n      range.callback(null)\n      if (!this.live && !this.sparse && !this.feed._selections.length) this.end()\n    }\n    return\n  }\n\n  while ((range.hash && this.feed.tree.get(2 * i)) || !reserved.set(i, true)) {\n    i = ite.next(true)\n\n    if (i > -1 && i < wantedEnd) {\n      // check this index\n      continue\n    }\n\n    if (!range.linear && start !== 0) {\n      // retry from the beginning since we are iterating randomly and started !== 0\n      i = ite.seek(range.start).next(true)\n      start = 0\n      if (i > -1 && i < wantedEnd) continue\n    }\n\n    // we have checked all indexes.\n    // if we are looking for hashes we should check if we have all now (first check only checks blocks)\n    if (range.hash) {\n      // quick'n'dirty check if have all hashes - can be optimized be checking only tree roots\n      // but we don't really request long ranges of hashes so yolo\n      for (var j = range.start; j < wantedEnd; j++) {\n        if (!this.feed.tree.get(2 * j)) return\n      }\n      if (!range.bytes) {\n        set.remove(this.feed._selections, range)\n        range.callback(null)\n      }\n    }\n\n    // exit the update loop - nothing to do\n    return\n  }\n\n  range.requested++\n  this._request(i, range.bytes || 0, range.hash)\n}\n\nPeer.prototype._request = function (index, bytes, hash) {\n  var request = {\n    bytes: bytes,\n    index: index,\n    hash: hash,\n    nodes: this.feed.digest(index)\n  }\n\n  if (this._requestTimeout === null && this.stream.stream.timeout) {\n    this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this)\n  }\n  this.inflightRequests.push(request)\n  this.stream.request(request)\n}\n\nPeer.prototype.extension = function (id, message) {\n  this.stream.extension(id, message)\n}\n\nfunction createView (page) {\n  var buf = page ? page.buffer : EMPTY\n  return new DataView(buf.buffer, buf.byteOffset, 1024)\n}\n\nfunction remoteAndNotLocal (local, buf, le, start) {\n  var remote = new DataView(buf.buffer, buf.byteOffset)\n  var len = Math.floor(buf.length / 4)\n  var arr = new Uint32Array(buf.buffer, buf.byteOffset, len)\n  var p = start / 8192 // 8192 is bits per bitfield page\n  var l = 0\n  var page = createView(local.pages.get(p++, true))\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * (l++), !le)\n\n    if (l === 256) {\n      page = createView(local.pages.get(p++, true))\n      l = 0\n    }\n  }\n}\n\nfunction nextRandom (ite, start, end) {\n  var len = end - start\n  var i = ite.seek(Math.floor(Math.random() * len) + start).next(true)\n  return i === -1 || i >= end ? ite.seek(start).next(true) : i\n}\n\nexport default replicate_1;\nexport { replicate_1 as __moduleExports };","start":1670465471841,"end":1670465471854,"order":"normal"}]}
