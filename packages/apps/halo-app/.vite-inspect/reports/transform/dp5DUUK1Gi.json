{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/object.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(\"./util\");\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","start":1670465470539,"end":1670465470638},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(\"./util\");\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","start":1670465470638,"end":1670465470638,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar object;\nvar hasRequiredObject;\n\nfunction requireObject () {\n\tif (hasRequiredObject) return object;\n\thasRequiredObject = 1;\n\t\"use strict\";\n\tobject = ReflectionObject;\n\n\tReflectionObject.className = \"ReflectionObject\";\n\n\tvar util = require$$0();\n\n\tvar Root; // cyclic\n\n\t/**\n\t * Constructs a new reflection object instance.\n\t * @classdesc Base class of all reflection objects.\n\t * @constructor\n\t * @param {string} name Object name\n\t * @param {Object.<string,*>} [options] Declared options\n\t * @abstract\n\t */\n\tfunction ReflectionObject(name, options) {\n\n\t    if (!util.isString(name))\n\t        throw TypeError(\"name must be a string\");\n\n\t    if (options && !util.isObject(options))\n\t        throw TypeError(\"options must be an object\");\n\n\t    /**\n\t     * Options.\n\t     * @type {Object.<string,*>|undefined}\n\t     */\n\t    this.options = options; // toJSON\n\n\t    /**\n\t     * Parsed Options.\n\t     * @type {Array.<Object.<string,*>>|undefined}\n\t     */\n\t    this.parsedOptions = null;\n\n\t    /**\n\t     * Unique name within its namespace.\n\t     * @type {string}\n\t     */\n\t    this.name = name;\n\n\t    /**\n\t     * Parent namespace.\n\t     * @type {Namespace|null}\n\t     */\n\t    this.parent = null;\n\n\t    /**\n\t     * Whether already resolved or not.\n\t     * @type {boolean}\n\t     */\n\t    this.resolved = false;\n\n\t    /**\n\t     * Comment text, if any.\n\t     * @type {string|null}\n\t     */\n\t    this.comment = null;\n\n\t    /**\n\t     * Defining file name.\n\t     * @type {string|null}\n\t     */\n\t    this.filename = null;\n\t}\n\n\tObject.defineProperties(ReflectionObject.prototype, {\n\n\t    /**\n\t     * Reference to the root namespace.\n\t     * @name ReflectionObject#root\n\t     * @type {Root}\n\t     * @readonly\n\t     */\n\t    root: {\n\t        get: function() {\n\t            var ptr = this;\n\t            while (ptr.parent !== null)\n\t                ptr = ptr.parent;\n\t            return ptr;\n\t        }\n\t    },\n\n\t    /**\n\t     * Full name including leading dot.\n\t     * @name ReflectionObject#fullName\n\t     * @type {string}\n\t     * @readonly\n\t     */\n\t    fullName: {\n\t        get: function() {\n\t            var path = [ this.name ],\n\t                ptr = this.parent;\n\t            while (ptr) {\n\t                path.unshift(ptr.name);\n\t                ptr = ptr.parent;\n\t            }\n\t            return path.join(\".\");\n\t        }\n\t    }\n\t});\n\n\t/**\n\t * Converts this reflection object to its descriptor representation.\n\t * @returns {Object.<string,*>} Descriptor\n\t * @abstract\n\t */\n\tReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n\t    throw Error(); // not implemented, shouldn't happen\n\t};\n\n\t/**\n\t * Called when this object is added to a parent.\n\t * @param {ReflectionObject} parent Parent added to\n\t * @returns {undefined}\n\t */\n\tReflectionObject.prototype.onAdd = function onAdd(parent) {\n\t    if (this.parent && this.parent !== parent)\n\t        this.parent.remove(this);\n\t    this.parent = parent;\n\t    this.resolved = false;\n\t    var root = parent.root;\n\t    if (root instanceof Root)\n\t        root._handleAdd(this);\n\t};\n\n\t/**\n\t * Called when this object is removed from a parent.\n\t * @param {ReflectionObject} parent Parent removed from\n\t * @returns {undefined}\n\t */\n\tReflectionObject.prototype.onRemove = function onRemove(parent) {\n\t    var root = parent.root;\n\t    if (root instanceof Root)\n\t        root._handleRemove(this);\n\t    this.parent = null;\n\t    this.resolved = false;\n\t};\n\n\t/**\n\t * Resolves this objects type references.\n\t * @returns {ReflectionObject} `this`\n\t */\n\tReflectionObject.prototype.resolve = function resolve() {\n\t    if (this.resolved)\n\t        return this;\n\t    if (this.root instanceof Root)\n\t        this.resolved = true; // only if part of a root\n\t    return this;\n\t};\n\n\t/**\n\t * Gets an option value.\n\t * @param {string} name Option name\n\t * @returns {*} Option value or `undefined` if not set\n\t */\n\tReflectionObject.prototype.getOption = function getOption(name) {\n\t    if (this.options)\n\t        return this.options[name];\n\t    return undefined;\n\t};\n\n\t/**\n\t * Sets an option.\n\t * @param {string} name Option name\n\t * @param {*} value Option value\n\t * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n\t * @returns {ReflectionObject} `this`\n\t */\n\tReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n\t    if (!ifNotSet || !this.options || this.options[name] === undefined)\n\t        (this.options || (this.options = {}))[name] = value;\n\t    return this;\n\t};\n\n\t/**\n\t * Sets a parsed option.\n\t * @param {string} name parsed Option name\n\t * @param {*} value Option value\n\t * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n\t * @returns {ReflectionObject} `this`\n\t */\n\tReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n\t    if (!this.parsedOptions) {\n\t        this.parsedOptions = [];\n\t    }\n\t    var parsedOptions = this.parsedOptions;\n\t    if (propName) {\n\t        // If setting a sub property of an option then try to merge it\n\t        // with an existing option\n\t        var opt = parsedOptions.find(function (opt) {\n\t            return Object.prototype.hasOwnProperty.call(opt, name);\n\t        });\n\t        if (opt) {\n\t            // If we found an existing option - just merge the property value\n\t            var newValue = opt[name];\n\t            util.setProperty(newValue, propName, value);\n\t        } else {\n\t            // otherwise, create a new option, set it's property and add it to the list\n\t            opt = {};\n\t            opt[name] = util.setProperty({}, propName, value);\n\t            parsedOptions.push(opt);\n\t        }\n\t    } else {\n\t        // Always create a new option when setting the value of the option itself\n\t        var newOpt = {};\n\t        newOpt[name] = value;\n\t        parsedOptions.push(newOpt);\n\t    }\n\t    return this;\n\t};\n\n\t/**\n\t * Sets multiple options.\n\t * @param {Object.<string,*>} options Options to set\n\t * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n\t * @returns {ReflectionObject} `this`\n\t */\n\tReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n\t    if (options)\n\t        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n\t            this.setOption(keys[i], options[keys[i]], ifNotSet);\n\t    return this;\n\t};\n\n\t/**\n\t * Converts this instance to its string representation.\n\t * @returns {string} Class name[, space, full name]\n\t */\n\tReflectionObject.prototype.toString = function toString() {\n\t    var className = this.constructor.className,\n\t        fullName  = this.fullName;\n\t    if (fullName.length)\n\t        return className + \" \" + fullName;\n\t    return className;\n\t};\n\n\t// Sets up cyclic dependencies (called in index-light)\n\tReflectionObject._configure = function(Root_) {\n\t    Root = Root_;\n\t};\n\treturn object;\n}\n\nexport { requireObject as __require };","start":1670465470638,"end":1670465471364,"order":"normal"}]}
