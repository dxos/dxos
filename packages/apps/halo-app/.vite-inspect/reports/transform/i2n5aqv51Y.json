{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nimport { Event as Event4 } from \"@dxos/async\";\nimport { raise } from \"@dxos/debug\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/swarm/connection.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { ErrorStream } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ConnectionState;\n(function(ConnectionState4) {\n  ConnectionState4[\"INITIAL\"] = \"INITIAL\";\n  ConnectionState4[\"CONNECTING\"] = \"CONNECTING\";\n  ConnectionState4[\"CONNECTED\"] = \"CONNECTED\";\n  ConnectionState4[\"CLOSED\"] = \"CLOSED\";\n})(ConnectionState || (ConnectionState = {}));\nvar Connection = class {\n  constructor(topic, ownId, remoteId, sessionId, initiator, _signalMessaging, _protocol, _transportFactory) {\n    this.topic = topic;\n    this.ownId = ownId;\n    this.remoteId = remoteId;\n    this.sessionId = sessionId;\n    this.initiator = initiator;\n    this._signalMessaging = _signalMessaging;\n    this._protocol = _protocol;\n    this._transportFactory = _transportFactory;\n    this._state = ConnectionState.INITIAL;\n    this._bufferedSignals = [];\n    this.stateChanged = new Event();\n    this.errors = new ErrorStream();\n  }\n  get state() {\n    return this._state;\n  }\n  get transport() {\n    return this._transport;\n  }\n  get protocol() {\n    return this._protocol;\n  }\n  openConnection() {\n    assert(this._state === ConnectionState.INITIAL, \"Invalid state.\");\n    this._changeState(ConnectionState.CONNECTING);\n    this._protocol.initialize().catch((err) => {\n      this.errors.raise(err);\n    });\n    assert(!this._transport);\n    this._transport = this._transportFactory.createTransport({\n      initiator: this.initiator,\n      stream: this._protocol.stream,\n      sendSignal: async (signal) => {\n        await this._signalMessaging.signal({\n          author: this.ownId,\n          recipient: this.remoteId,\n          sessionId: this.sessionId,\n          topic: this.topic,\n          data: {\n            signal\n          }\n        });\n      }\n    });\n    this._transport.connected.once(() => {\n      this._changeState(ConnectionState.CONNECTED);\n    });\n    this._transport.closed.once(() => {\n      this._transport = void 0;\n      this.close().catch((err) => this.errors.raise(err));\n    });\n    this._transport.errors.pipeTo(this.errors);\n    for (const signal of this._bufferedSignals) {\n      void this._transport.signal(signal);\n    }\n    this._bufferedSignals = [];\n  }\n  async close() {\n    var _a;\n    if (this._state === ConnectionState.CLOSED) {\n      return;\n    }\n    log(\"closing...\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 131,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this._protocol.destroy();\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    try {\n      await ((_a = this._transport) == null ? void 0 : _a.destroy());\n    } catch (err1) {\n      log.catch(err1, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 144,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    log(\"closed\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._changeState(ConnectionState.CLOSED);\n  }\n  async signal(msg) {\n    var _a, _b;\n    assert(msg.sessionId);\n    if (!msg.sessionId.equals(this.sessionId)) {\n      log(\"dropping signal for incorrect session id\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 154,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert(msg.data.signal);\n    assert((_a = msg.author) == null ? void 0 : _a.equals(this.remoteId));\n    assert((_b = msg.recipient) == null ? void 0 : _b.equals(this.ownId));\n    if (this._state === ConnectionState.INITIAL) {\n      log(\"buffered signal\", {\n        peerId: this.ownId,\n        remoteId: this.remoteId,\n        msg: msg.data\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 162,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._bufferedSignals.push(msg.data.signal);\n      return;\n    }\n    assert(this._transport, \"Connection not ready to accept signals.\");\n    log(\"received signal\", {\n      peerId: this.ownId,\n      remoteId: this.remoteId,\n      msg: msg.data\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 168,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._transport.signal(msg.data.signal);\n  }\n  _changeState(state) {\n    assert(state !== this._state, \"Already in this state.\");\n    this._state = state;\n    this.stateChanged.emit(state);\n  }\n};\n__decorate([\n  synchronized\n], Connection.prototype, \"close\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask, sleep } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { ErrorStream as ErrorStream2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4, logInfo } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2, isNotNullOrUndefined } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/signal/message-router.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap } from \"@dxos/util\";\nvar MessageRouter = class {\n  constructor({ sendMessage, onSignal, onOffer, topic }) {\n    this._offerRecords = new ComplexMap((key) => key.toHex());\n    this._sendMessage = sendMessage;\n    this._onSignal = onSignal;\n    this._onOffer = onOffer;\n    this._topic = topic;\n  }\n  async receiveMessage({ author, recipient, payload }) {\n    var _a, _b, _c;\n    if (payload.type_url !== \"dxos.mesh.swarm.SwarmMessage\") {\n      return;\n    }\n    const message = schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").decode(payload.value);\n    if (!this._topic.equals(message.topic)) {\n      return;\n    }\n    log2(\"received\", {\n      from: author,\n      to: recipient,\n      msg: message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if ((_a = message.data) == null ? void 0 : _a.offer) {\n      await this._handleOffer({\n        author,\n        recipient,\n        message\n      });\n    } else if ((_b = message.data) == null ? void 0 : _b.answer) {\n      await this._resolveAnswers(message);\n    } else if ((_c = message.data) == null ? void 0 : _c.signal) {\n      await this._handleSignal({\n        author,\n        recipient,\n        message\n      });\n    }\n  }\n  async signal(message) {\n    var _a;\n    assert2((_a = message.data) == null ? void 0 : _a.signal);\n    await this._sendReliableMessage({\n      author: message.author,\n      recipient: message.recipient,\n      message\n    });\n  }\n  async offer(message) {\n    const networkMessage = {\n      ...message,\n      messageId: PublicKey.random()\n    };\n    return new Promise((resolve, reject) => {\n      this._offerRecords.set(networkMessage.messageId, {\n        resolve,\n        reject\n      });\n      return this._sendReliableMessage({\n        author: message.author,\n        recipient: message.recipient,\n        message: networkMessage\n      });\n    });\n  }\n  async _sendReliableMessage({ author, recipient, message }) {\n    var _a;\n    const networkMessage = {\n      ...message,\n      messageId: (_a = message.messageId) != null ? _a : PublicKey.random()\n    };\n    log2(\"sending\", {\n      from: author,\n      to: recipient,\n      msg: networkMessage\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      message: networkMessage\n    });\n  }\n  async _encodeAndSend({ author, recipient, message }) {\n    await this._sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.swarm.SwarmMessage\",\n        value: schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").encode(message)\n      }\n    });\n  }\n  async _resolveAnswers(message) {\n    var _a, _b, _c;\n    assert2((_b = (_a = message.data) == null ? void 0 : _a.answer) == null ? void 0 : _b.offerMessageId, \"No offerMessageId\");\n    const offerRecord = this._offerRecords.get(message.data.answer.offerMessageId);\n    if (offerRecord) {\n      this._offerRecords.delete(message.data.answer.offerMessageId);\n      assert2((_c = message.data) == null ? void 0 : _c.answer, \"No answer\");\n      log2(\"resolving\", {\n        answer: message.data.answer\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      offerRecord.resolve(message.data.answer);\n    }\n  }\n  async _handleOffer({ author, recipient, message }) {\n    assert2(message.data.offer, \"No offer\");\n    const offerMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        offer: message.data.offer\n      }\n    };\n    const answer = await this._onOffer(offerMessage);\n    answer.offerMessageId = message.messageId;\n    await this._sendReliableMessage({\n      author: recipient,\n      recipient: author,\n      message: {\n        topic: message.topic,\n        sessionId: message.sessionId,\n        data: {\n          answer\n        }\n      }\n    });\n  }\n  async _handleSignal({ author, recipient, message }) {\n    assert2(message.messageId);\n    assert2(message.data.signal, \"No Signal\");\n    const signalMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        signal: message.data.signal\n      }\n    };\n    await this._onSignal(signalMessage);\n  }\n};\n\n// packages/core/mesh/network-manager/src/swarm/peer.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Peer = class {\n  constructor(id, topic, localPeerId, _signalMessaging, _protocolProvider, _transportFactory, _callbacks) {\n    this.id = id;\n    this.topic = topic;\n    this.localPeerId = localPeerId;\n    this._signalMessaging = _signalMessaging;\n    this._protocolProvider = _protocolProvider;\n    this._transportFactory = _transportFactory;\n    this._callbacks = _callbacks;\n    this.advertizing = false;\n    this.initiating = false;\n  }\n  async onOffer(message) {\n    const remoteId = message.author;\n    if (this.connection || this.initiating) {\n      if (remoteId.toHex() < this.localPeerId.toHex()) {\n        log3.info(\"closing local connection and accepting remote peer's offer\", {\n          id: this.id,\n          topic: this.topic,\n          peerId: this.localPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (this.connection) {\n          await this.closeConnection();\n        }\n      } else {\n        return {\n          accept: false\n        };\n      }\n    }\n    if (await this._callbacks.onOffer(remoteId)) {\n      if (!this.connection) {\n        assert3(message.sessionId);\n        const connection = this._createConnection(false, message.sessionId);\n        try {\n          connection.openConnection();\n        } catch (err) {\n          log3.warn(\"connection error\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 107,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await this.closeConnection();\n        }\n        return {\n          accept: true\n        };\n      }\n    }\n    return {\n      accept: false\n    };\n  }\n  async initiateConnection() {\n    assert3(!this.initiating, \"Initiation in progress.\");\n    assert3(!this.connection, \"Already connected.\");\n    const sessionId = PublicKey2.random();\n    log3(\"initiating...\", {\n      id: this.id,\n      topic: this.topic,\n      peerId: this.id,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const connection = this._createConnection(true, sessionId);\n    this.initiating = true;\n    try {\n      const answer = await this._signalMessaging.offer({\n        author: this.localPeerId,\n        recipient: this.id,\n        sessionId,\n        topic: this.topic,\n        data: {\n          offer: {}\n        }\n      });\n      log3(\"received\", {\n        answer,\n        topic: this.topic,\n        ownId: this.localPeerId,\n        remoteId: this.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (connection.state !== ConnectionState.INITIAL) {\n        log3(\"ignoring response\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 139,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      if (!answer.accept) {\n        this._callbacks.onRejected();\n        return;\n      }\n      connection.openConnection();\n      this._callbacks.onAccepted();\n    } catch (err) {\n      log3.warn(\"initiation error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 150,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.closeConnection();\n      throw err;\n    } finally {\n      this.initiating = false;\n    }\n  }\n  _createConnection(initiator, sessionId) {\n    log3(\"creating connection\", {\n      topic: this.topic,\n      peerId: this.localPeerId,\n      remoteId: this.id,\n      initiator,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 164,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this.connection, \"Already connected.\");\n    const connection = new Connection(\n      this.topic,\n      this.localPeerId,\n      this.id,\n      sessionId,\n      initiator,\n      this._signalMessaging,\n      this._protocolProvider({\n        initiator,\n        localPeerId: this.localPeerId,\n        remotePeerId: this.id,\n        topic: this.topic\n      }),\n      this._transportFactory\n    );\n    this._callbacks.onInitiated(connection);\n    connection.stateChanged.on((state) => {\n      switch (state) {\n        case ConnectionState.CONNECTED: {\n          this._callbacks.onConnected();\n          break;\n        }\n        case ConnectionState.CLOSED: {\n          log3(\"connection closed\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            initiator\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 193,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          assert3(this.connection === connection, \"Connection mismatch (race condition).\");\n          this.connection = void 0;\n          this._callbacks.onDisconnected();\n          break;\n        }\n      }\n    });\n    connection.errors.handle((err) => {\n      log3.warn(\"connection error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        initiator,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 203,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      void this.closeConnection().catch(() => {\n        log3.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 207,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    });\n    this.connection = connection;\n    return connection;\n  }\n  async closeConnection() {\n    if (!this.connection) {\n      return;\n    }\n    const connection = this.connection;\n    log3(\"closing...\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 221,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await connection.close();\n    log3(\"closed\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 227,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async onSignal(message) {\n    if (!this.connection) {\n      log3(\"dropping signal message for non-existent connection\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 232,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    await this.connection.signal(message);\n  }\n  async destroy() {\n    var _a;\n    log3(\"Destroying peer\", {\n      peerId: this.id,\n      topic: this.topic\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 240,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await ((_a = this == null ? void 0 : this.connection) == null ? void 0 : _a.close());\n  }\n};\n__decorate2([\n  synchronized2\n], Peer.prototype, \"destroy\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar INITIATION_DELAY = 100;\nvar getClassName = (obj) => Object.getPrototypeOf(obj).constructor.name;\nvar Swarm = class {\n  constructor(_topic, _ownPeerId, _topology, _protocolProvider, _messenger, _transportFactory, _label) {\n    this._topic = _topic;\n    this._ownPeerId = _ownPeerId;\n    this._topology = _topology;\n    this._protocolProvider = _protocolProvider;\n    this._messenger = _messenger;\n    this._transportFactory = _transportFactory;\n    this._label = _label;\n    this._peers = new ComplexMap2(PublicKey3.hash);\n    this._ctx = new Context();\n    this.connectionAdded = new Event2();\n    this.disconnected = new Event2();\n    this.connected = new Event2();\n    this.errors = new ErrorStream2();\n    this.instanceId = PublicKey3.random();\n    log4(\"creating swarm\", {\n      peerId: _ownPeerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 80,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    _topology.init(this._getSwarmController());\n    this._swarmMessenger = new MessageRouter({\n      sendMessage: async (msg) => await this._messenger.sendMessage(msg),\n      onSignal: async (msg) => await this.onSignal(msg),\n      onOffer: async (msg) => await this.onOffer(msg),\n      topic: this._topic\n    });\n    this._messenger.listen({\n      peerId: this._ownPeerId,\n      payloadType: \"dxos.mesh.swarm.SwarmMessage\",\n      onMessage: async (message) => await this._swarmMessenger.receiveMessage(message)\n    }).catch((error) => log4.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 96,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get connections() {\n    return Array.from(this._peers.values()).map((peer) => peer.connection).filter(isNotNullOrUndefined);\n  }\n  get ownPeerId() {\n    return this._ownPeerId;\n  }\n  get label() {\n    return this._label;\n  }\n  get topic() {\n    return this._topic;\n  }\n  async destroy() {\n    log4(\"destroying...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 124,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._ctx.dispose();\n    await this._topology.destroy();\n    await Promise.all(Array.from(this._peers.keys()).map((key) => this._destroyPeer(key)));\n    log4(\"destroyed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 128,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async setTopology(topology) {\n    if (topology === this._topology) {\n      return;\n    }\n    log4(\"setting topology\", {\n      previous: getClassName(this._topology),\n      topology: getClassName(topology)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 135,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._topology.destroy();\n    this._topology = topology;\n    this._topology.init(this._getSwarmController());\n    this._topology.update();\n  }\n  _getOrCreatePeer(peerId) {\n    let peer = this._peers.get(peerId);\n    if (!peer) {\n      peer = new Peer(peerId, this._topic, this._ownPeerId, this._swarmMessenger, this._protocolProvider, this._transportFactory, {\n        onInitiated: (connection) => {\n          this.connectionAdded.emit(connection);\n        },\n        onConnected: () => {\n          this.connected.emit(peerId);\n        },\n        onDisconnected: async () => {\n          if (!peer.advertizing) {\n            await this._destroyPeer(peer.id);\n          }\n          this.disconnected.emit(peerId);\n          this._topology.update();\n        },\n        onRejected: () => {\n          if (this._peers.has(peerId)) {\n            void this._destroyPeer(peerId);\n          }\n        },\n        onAccepted: () => {\n          this._topology.update();\n        },\n        onOffer: (remoteId) => {\n          return this._topology.onOffer(remoteId);\n        }\n      });\n      this._peers.set(peerId, peer);\n    }\n    return peer;\n  }\n  async _destroyPeer(peerId) {\n    assert4(this._peers.has(peerId));\n    await this._peers.get(peerId).destroy();\n    this._peers.delete(peerId);\n  }\n  onSwarmEvent(swarmEvent) {\n    log4(\"swarm event\", {\n      swarmEvent\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 199,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.warn(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (swarmEvent.peerAvailable) {\n      const peerId = PublicKey3.from(swarmEvent.peerAvailable.peer);\n      log4(\"new peer\", {\n        peerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 207,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!peerId.equals(this._ownPeerId)) {\n        const peer = this._getOrCreatePeer(peerId);\n        peer.advertizing = true;\n      }\n    } else if (swarmEvent.peerLeft) {\n      const peer1 = this._peers.get(PublicKey3.from(swarmEvent.peerLeft.peer));\n      if (peer1) {\n        peer1.advertizing = false;\n        if (!peer1.connection) {\n          void this._destroyPeer(peer1.id);\n        }\n      }\n    }\n    this._topology.update();\n  }\n  async onOffer(message) {\n    var _a, _b;\n    log4(\"offer\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 226,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 228,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    assert4(message.author);\n    if (!((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId))) {\n      log4(\"rejecting offer with incorrect peerId\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 235,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    if (!((_b = message.topic) == null ? void 0 : _b.equals(this._topic))) {\n      log4(\"rejecting offer with incorrect topic\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 239,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    const peer = this._getOrCreatePeer(message.author);\n    const answer = await peer.onOffer(message);\n    this._topology.update();\n    return answer;\n  }\n  async onSignal(message) {\n    var _a, _b;\n    log4(\"signal\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 250,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 252,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert4((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId), `Invalid signal peer id expected=${this.ownPeerId}, actual=${message.recipient}`);\n    assert4((_b = message.topic) == null ? void 0 : _b.equals(this._topic));\n    assert4(message.author);\n    const peer = this._getOrCreatePeer(message.author);\n    await peer.onSignal(message);\n  }\n  _getSwarmController() {\n    return {\n      getState: () => ({\n        ownPeerId: this._ownPeerId,\n        connected: Array.from(this._peers.values()).filter((peer) => peer.connection).map((peer) => peer.id),\n        candidates: Array.from(this._peers.values()).filter((peer) => !peer.connection && peer.advertizing).map((peer) => peer.id)\n      }),\n      connect: (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          try {\n            await this._initiateConnection(peer);\n          } catch (err) {\n            log4.warn(\"initiation error\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n              line: 287,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          }\n        });\n      },\n      disconnect: async (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          await this._closeConnection(peer);\n          this._topology.update();\n        });\n      }\n    };\n  }\n  async _initiateConnection(remoteId) {\n    if (remoteId.toHex() < this._ownPeerId.toHex()) {\n      log4(\"initiation delay\", {\n        remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 312,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await sleep(INITIATION_DELAY);\n    }\n    if (this._ctx.disposed) {\n      return;\n    }\n    const peer = this._getOrCreatePeer(remoteId);\n    if (peer.connection) {\n      return;\n    }\n    log4(\"initiating connection...\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 326,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await peer.initiateConnection();\n    this._topology.update();\n    log4(\"initiated\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 329,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _closeConnection(peerId) {\n    const peer = this._peers.get(peerId);\n    if (!peer) {\n      return;\n    }\n    await peer.closeConnection();\n  }\n};\n__decorate3([\n  logInfo\n], Swarm.prototype, \"instanceId\", void 0);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"ownPeerId\", null);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"topic\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\nvar SwarmMapper = class {\n  get peers() {\n    return Array.from(this._peers.values());\n  }\n  constructor(_swarm, _presence) {\n    this._swarm = _swarm;\n    this._presence = _presence;\n    this._subscriptions = new EventSubscriptions();\n    this._connectionSubscriptions = new ComplexMap3(PublicKey4.hash);\n    this._peers = new ComplexMap3(PublicKey4.hash);\n    this.mapUpdated = new Event3();\n    this._subscriptions.add(_swarm.connectionAdded.on((connection) => {\n      this._update();\n      this._connectionSubscriptions.set(connection.remoteId, connection.stateChanged.on(() => {\n        this._update();\n      }));\n    }));\n    this._subscriptions.add(_swarm.disconnected.on((peerId) => {\n      var _a;\n      (_a = this._connectionSubscriptions.get(peerId)) == null ? void 0 : _a();\n      this._connectionSubscriptions.delete(peerId);\n      this._update();\n    }));\n    if (_presence) {\n      this._subscriptions.add(_presence.graphUpdated.on(() => {\n        this._update();\n      }));\n    }\n    this._update();\n  }\n  _update() {\n    log5(\"updating swarm\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peers.clear();\n    this._peers.set(this._swarm.ownPeerId, {\n      id: this._swarm.ownPeerId,\n      state: \"ME\",\n      connections: []\n    });\n    for (const connection of this._swarm.connections) {\n      this._peers.set(connection.remoteId, {\n        id: connection.remoteId,\n        state: connection.state,\n        connections: [\n          this._swarm.ownPeerId\n        ]\n      });\n    }\n    if (this._presence) {\n      this._presence.graph.forEachNode((node) => {\n        const id = PublicKey4.fromHex(node.id);\n        if (this._peers.has(id)) {\n          return;\n        }\n        this._peers.set(id, {\n          id,\n          state: \"INDIRECTLY_CONNECTED\",\n          connections: []\n        });\n      });\n      this._presence.graph.forEachLink((link) => {\n        const from = PublicKey4.from(link.fromId);\n        const to = PublicKey4.from(link.toId);\n        if (!from.equals(this._swarm.ownPeerId) && !to.equals(this._swarm.ownPeerId)) {\n          this._peers.get(from).connections.push(to);\n        }\n      });\n    }\n    log5(\"graph changed\", {\n      directConnections: this._swarm.connections.length,\n      totalPeersInSwarm: this._peers.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 118,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.mapUpdated.emit(Array.from(this._peers.values()));\n  }\n  destroy() {\n    Array.from(this._connectionSubscriptions.values()).forEach((cb) => cb());\n    this._subscriptions.clear();\n  }\n};\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nvar EventType;\n(function(EventType2) {\n  EventType2[\"CONNECTION_STATE_CHANGED\"] = \"CONNECTION_STATE_CHANGED\";\n  EventType2[\"PROTOCOL_ERROR\"] = \"PROTOCOL_ERROR\";\n  EventType2[\"PROTOCOL_EXTENSIONS_INITIALIZED\"] = \"PROTOCOL_EXTENSIONS_INITIALIZED\";\n  EventType2[\"PROTOCOL_EXTENSIONS_HANDSHAKE\"] = \"PROTOCOL_EXTENSIONS_HANDSHAKE\";\n  EventType2[\"PROTOCOL_HANDSHAKE\"] = \"PROTOCOL_HANDSHAKE\";\n})(EventType || (EventType = {}));\nvar ConnectionLog = class {\n  constructor() {\n    this._swarms = new ComplexMap4(PublicKey5.hash);\n    this.update = new Event4();\n  }\n  getSwarmInfo(swarmId) {\n    var _a;\n    return (_a = this._swarms.get(swarmId)) != null ? _a : raise(new Error(`Swarm not found: ${swarmId}`));\n  }\n  get swarms() {\n    return Array.from(this._swarms.values());\n  }\n  swarmJoined(swarm) {\n    const info = {\n      id: swarm.instanceId,\n      topic: swarm.topic,\n      isActive: true,\n      label: swarm.label,\n      connections: []\n    };\n    this._swarms.set(swarm.instanceId, info);\n    this.update.emit();\n    swarm.connectionAdded.on((connection) => {\n      var _a, _b, _c, _d, _e;\n      const connectionInfo = {\n        state: ConnectionState.INITIAL,\n        remotePeerId: connection.remoteId,\n        sessionId: connection.sessionId,\n        transport: connection.transport && Object.getPrototypeOf(connection.transport).constructor.name,\n        protocolExtensions: (_a = connection.protocol.protocol) == null ? void 0 : _a.extensionNames,\n        events: []\n      };\n      info.connections.push(connectionInfo);\n      this.update.emit();\n      connection.stateChanged.on((state) => {\n        connectionInfo.state = state;\n        connectionInfo.events.push({\n          type: EventType.CONNECTION_STATE_CHANGED,\n          newState: state\n        });\n        this.update.emit();\n      });\n      (_b = connection.protocol.protocol) == null ? void 0 : _b.error.on((error) => {\n        var _a2;\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_ERROR,\n          error: (_a2 = error.stack) != null ? _a2 : error.message\n        });\n        this.update.emit();\n      });\n      (_c = connection.protocol.protocol) == null ? void 0 : _c.extensionsInitialized.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_INITIALIZED\n        });\n        this.update.emit();\n      });\n      (_d = connection.protocol.protocol) == null ? void 0 : _d.extensionsHandshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_HANDSHAKE\n        });\n        this.update.emit();\n      });\n      (_e = connection.protocol.protocol) == null ? void 0 : _e.handshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_HANDSHAKE\n        });\n        this.update.emit();\n      });\n    });\n  }\n  swarmLeft(swarm) {\n    this.getSwarmInfo(swarm.instanceId).isActive = false;\n    this.update.emit();\n  }\n};\n\n// packages/core/mesh/network-manager/src/network-manager.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Messenger } from \"@dxos/messaging\";\nimport { ComplexMap as ComplexMap5 } from \"@dxos/util\";\nvar NetworkManager = class {\n  constructor({ transportFactory, signalManager, log: log14 }) {\n    this._swarms = new ComplexMap5(PublicKey6.hash);\n    this._mappers = new ComplexMap5(PublicKey6.hash);\n    this.topicsUpdated = new Event5();\n    this._transportFactory = transportFactory;\n    this._signalManager = signalManager;\n    this._signalManager.swarmEvent.on(({ topic, swarmEvent: event }) => {\n      var _a;\n      return (_a = this._swarms.get(topic)) == null ? void 0 : _a.onSwarmEvent(event);\n    });\n    this._messenger = new Messenger({\n      signalManager: this._signalManager\n    });\n    this._signalConnection = {\n      join: (opts) => this._signalManager.join(opts),\n      leave: (opts) => this._signalManager.leave(opts)\n    };\n    if (log14) {\n      this._connectionLog = new ConnectionLog();\n    }\n  }\n  get connectionLog() {\n    return this._connectionLog;\n  }\n  get signalManager() {\n    return this._signalManager;\n  }\n  get topics() {\n    return Array.from(this._swarms.keys());\n  }\n  getSwarmMap(topic) {\n    return this._mappers.get(topic);\n  }\n  getSwarm(topic) {\n    return this._swarms.get(topic);\n  }\n  async close() {\n    for (const topic of this._swarms.keys()) {\n      await this.leaveSwarm(topic).catch((err) => {\n        log6(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n          line: 128,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    }\n    await this._signalManager.destroy();\n  }\n  async joinSwarm({ topic, peerId, topology, protocolProvider: protocol, presence, label }) {\n    var _a;\n    assert5(PublicKey6.isPublicKey(topic));\n    assert5(PublicKey6.isPublicKey(peerId));\n    assert5(topology);\n    assert5(typeof protocol === \"function\");\n    if (this._swarms.has(topic)) {\n      throw new Error(`Already connected to swarm: ${PublicKey6.from(topic)}`);\n    }\n    log6(\"joining\", {\n      topic: PublicKey6.from(topic),\n      peerId,\n      topology: topology.toString()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 155,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = new Swarm(topic, peerId, topology, protocol, this._messenger, this._transportFactory, label);\n    swarm.errors.handle((error) => {\n      log6(\"swarm error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 158,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._swarms.set(topic, swarm);\n    this._signalConnection.join({\n      topic,\n      peerId\n    }).catch((error) => log6.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 162,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n    this._mappers.set(topic, new SwarmMapper(swarm, presence));\n    this.topicsUpdated.emit();\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmJoined(swarm);\n    log6(\"joined\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 167,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return {\n      close: () => this.leaveSwarm(topic)\n    };\n  }\n  async leaveSwarm(topic) {\n    var _a;\n    if (!this._swarms.has(topic)) {\n      log6.warn(\"swarm not open\", {\n        topic: PublicKey6.from(topic)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    log6(\"leaving\", {\n      topic: PublicKey6.from(topic)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = this._swarms.get(topic);\n    await this._signalConnection.leave({\n      topic,\n      peerId: swarm.ownPeerId\n    });\n    const map = this._mappers.get(topic);\n    map.destroy();\n    this._mappers.delete(topic);\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmLeft(swarm);\n    await swarm.destroy();\n    this._swarms.delete(topic);\n    await this.topicsUpdated.emit();\n    log6(\"left\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 197,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/protocol-factory.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { discoveryKey } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey7 } from \"@dxos/keys\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nvar protocolFactory = ({ session = {}, plugins = [], getTopics }) => {\n  assert6(getTopics);\n  return ({ channel, initiator }) => {\n    log7(\"creating protocol\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/protocol-factory.ts\",\n      line: 41,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    const protocol = new Protocol({\n      streamOptions: {\n        live: true\n      },\n      discoveryToPublicKey: (dk) => {\n        const publicKey = getTopics().find((topic) => discoveryKey(topic).equals(dk));\n        if (publicKey) {\n          protocol.setContext({\n            topic: PublicKey7.stringify(publicKey)\n          });\n        }\n        assert6(publicKey, \"PublicKey not found in discovery.\");\n        return publicKey;\n      },\n      initiator,\n      userSession: session,\n      discoveryKey: channel\n    });\n    protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n    return protocol;\n  };\n};\nvar createProtocolFactory = (topic, peerId, plugins) => protocolFactory({\n  getTopics: () => [\n    topic.asBuffer()\n  ],\n  session: {\n    peerId: PublicKey7.stringify(peerId.asBuffer())\n  },\n  plugins\n});\nvar transportProtocolProvider = (rendezvousKey, peerId, protocolPlugin) => {\n  return protocolFactory({\n    getTopics: () => [\n      rendezvousKey\n    ],\n    session: {\n      peerId: PublicKey7.stringify(peerId)\n    },\n    plugins: [\n      protocolPlugin\n    ]\n  });\n};\n\n// packages/core/mesh/network-manager/src/topology/fully-connected-topology.ts\nimport assert7 from \"@dxos/node-std/assert\";\nvar FullyConnectedTopology = class {\n  toString() {\n    return \"FullyConnectedTopology\";\n  }\n  init(controller) {\n    assert7(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert7(this._controller, \"Not initialized\");\n    const { candidates: discovered } = this._controller.getState();\n    for (const peer of discovered) {\n      this._controller.connect(peer);\n    }\n  }\n  async onOffer(peer) {\n    return true;\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/topology/mmst-topology.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport distance from \"xor-distance\";\nimport { log as log8 } from \"@dxos/log\";\nvar MMSTTopology = class {\n  constructor({ originateConnections = 2, maxPeers = 4, sampleSize = 10 } = {}) {\n    this._sampleCollected = false;\n    this._originateConnections = originateConnections;\n    this._maxPeers = maxPeers;\n    this._sampleSize = sampleSize;\n  }\n  init(controller) {\n    assert8(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates } = this._controller.getState();\n    if (this._sampleCollected || connected.length > this._maxPeers || candidates.length > 0) {\n      log8(\"Running the algorithm.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._sampleCollected = true;\n      this._runAlgorithm();\n    }\n  }\n  async onOffer(peer) {\n    assert8(this._controller, \"Not initialized\");\n    const { connected } = this._controller.getState();\n    const accept = connected.length < this._maxPeers;\n    log8(`Offer ${peer} accept=${accept}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return accept;\n  }\n  async destroy() {\n  }\n  _runAlgorithm() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates, ownPeerId } = this._controller.getState();\n    if (connected.length > this._maxPeers) {\n      const sorted = sortByXorDistance(connected, ownPeerId).reverse().slice(0, this._maxPeers - connected.length);\n      for (const peer of sorted) {\n        log8(`Disconnect ${peer}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.disconnect(peer);\n      }\n    } else if (connected.length < this._originateConnections) {\n      const sample = candidates.sort(() => Math.random() - 0.5).slice(0, this._sampleSize);\n      const sorted1 = sortByXorDistance(sample, ownPeerId).slice(0, this._originateConnections - connected.length);\n      for (const peer1 of sorted1) {\n        log8(`Connect ${peer1}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  toString() {\n    return \"MMSTTopology\";\n  }\n};\nvar sortByXorDistance = (keys, reference) => keys.sort((a, b) => distance.gt(distance(a.asBuffer(), reference.asBuffer()), distance(b.asBuffer(), reference.asBuffer())));\n\n// packages/core/mesh/network-manager/src/topology/star-topology.ts\nimport assert9 from \"@dxos/node-std/assert\";\nimport { log as log9 } from \"@dxos/log\";\nvar StarTopology = class {\n  constructor(_centralPeer) {\n    this._centralPeer = _centralPeer;\n  }\n  toString() {\n    return `StarTopology(${this._centralPeer.truncate()})`;\n  }\n  init(controller) {\n    assert9(!this._controller, \"Already initialized.\");\n    this._controller = controller;\n  }\n  update() {\n    assert9(this._controller, \"Not initialized.\");\n    const { candidates, connected, ownPeerId } = this._controller.getState();\n    if (!ownPeerId.equals(this._centralPeer)) {\n      log9(\"leaf peer dropping all connections apart from central peer.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n        line: 33,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      for (const peer of connected) {\n        if (!peer.equals(this._centralPeer)) {\n          log9(\"dropping connection\", {\n            peer\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n            line: 38,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._controller.disconnect(peer);\n        }\n      }\n    }\n    for (const peer1 of candidates) {\n      if (peer1.equals(this._centralPeer) || ownPeerId.equals(this._centralPeer)) {\n        log9(\"connecting to peer\", {\n          peer: peer1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  async onOffer(peer) {\n    assert9(this._controller, \"Not initialized.\");\n    const { ownPeerId } = this._controller.getState();\n    log9(\"offer\", {\n      peer,\n      isCentral: peer.equals(this._centralPeer),\n      isSelfCentral: ownPeerId.equals(this._centralPeer)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n      line: 56,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return ownPeerId.equals(this._centralPeer) || peer.equals(this._centralPeer);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/memory-transport.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Transform } from \"@dxos/node-std/stream\";\nimport { Event as Event6, Trigger } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream3 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey8 } from \"@dxos/keys\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap6 } from \"@dxos/util\";\nvar MEMORY_TRANSPORT_DELAY = 1;\nvar createStreamDelay = (delay) => {\n  return new Transform({\n    objectMode: true,\n    transform: (chunk, _, cb) => {\n      setTimeout(() => cb(null, chunk), delay);\n    }\n  });\n};\nvar MemoryTransportFactory = {\n  createTransport: (params) => new MemoryTransport(params)\n};\nvar _MemoryTransport = class {\n  constructor(options) {\n    var _a;\n    this.options = options;\n    this.closed = new Event6();\n    this.connected = new Event6();\n    this.errors = new ErrorStream3();\n    this._id = PublicKey8.random();\n    this._remote = new Trigger();\n    this._outgoingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._incomingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._destroyed = false;\n    log10(\"creating\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 59,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert10(!_MemoryTransport._connections.has(this._id), \"Duplicate memory connection\");\n    _MemoryTransport._connections.set(this._id, this);\n    if (this.options.initiator) {\n      setTimeout(async () => {\n        log10(\"sending signal\", {\n          transportId: this._id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 68,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        void this.options.sendSignal({\n          payload: {\n            transportId: this._id.toHex()\n          }\n        });\n      });\n    } else {\n      this._remote.wait({\n        timeout: (_a = this.options.timeout) != null ? _a : 1e3\n      }).then((remoteId) => {\n        if (this._destroyed) {\n          return;\n        }\n        this._remoteId = remoteId;\n        this._remoteConnection = _MemoryTransport._connections.get(this._remoteId);\n        if (!this._remoteConnection) {\n          this._destroyed = true;\n          this.closed.emit();\n          return;\n        }\n        assert10(!this._remoteConnection._remoteConnection, new Error(`Remote already connected: ${this._remoteId}`));\n        this._remoteConnection._remoteConnection = this;\n        this._remoteConnection._remoteId = this._id;\n        log10(\"connected\", {\n          id: this._id,\n          remote: this._remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 94,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.options.stream.pipe(this._outgoingDelay).pipe(this._remoteConnection.options.stream).pipe(this._incomingDelay).pipe(this.options.stream);\n        this.connected.emit();\n        this._remoteConnection.connected.emit();\n      }).catch((err) => {\n        if (this._destroyed) {\n          return;\n        }\n        this.errors.raise(err);\n      });\n    }\n  }\n  async destroy() {\n    log10(\"closing\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._destroyed = true;\n    _MemoryTransport._connections.delete(this._id);\n    if (this._remoteConnection) {\n      log10(\"closing\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._remoteConnection._destroyed = true;\n      _MemoryTransport._connections.delete(this._remoteId);\n      this._outgoingDelay.unpipe();\n      this._incomingDelay.unpipe();\n      this._remoteConnection.closed.emit();\n      this._remoteConnection._remoteConnection = void 0;\n      this._remoteConnection = void 0;\n      log10(\"closed\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 138,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    log10(\"closed\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    const { payload: json } = signal;\n    if (json && json.transportId) {\n      const transportId = json.transportId;\n      if (transportId) {\n        const remoteId = PublicKey8.fromHex(transportId);\n        log10(\"received signal\", {\n          id: this._id,\n          remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 152,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._remote.wake(remoteId);\n      }\n    }\n  }\n};\nvar MemoryTransport = _MemoryTransport;\nMemoryTransport._connections = new ComplexMap6(PublicKey8.hash);\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport SimplePeerConstructor from \"simple-peer\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream4, raise as raise2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\n\n// packages/core/mesh/network-manager/src/transport/webrtc.ts\nvar wrtc = null;\ntry {\n  wrtc = __require(\"@koush/wrtc\");\n} catch (e) {\n}\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nvar WebRTCTransport = class {\n  constructor(params) {\n    var _a;\n    this.params = params;\n    this.closed = new Event7();\n    this.connected = new Event7();\n    this.errors = new ErrorStream4();\n    log11(\"created connection\", params, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 34,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peer = new SimplePeerConstructor({\n      initiator: this.params.initiator,\n      wrtc: SimplePeerConstructor.WEBRTC_SUPPORT ? void 0 : (_a = wrtc) != null ? _a : raise2(new Error(\"wrtc not available\")),\n      config: this.params.webrtcConfig\n    });\n    this._peer.on(\"signal\", async (data) => {\n      log11(\"signal\", data, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 42,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.params.sendSignal({\n        payload: {\n          data\n        }\n      });\n    });\n    this._peer.on(\"connect\", () => {\n      log11(\"connected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.params.stream.pipe(this._peer).pipe(this.params.stream);\n      this.connected.emit();\n    });\n    this._peer.on(\"close\", async () => {\n      log11(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 53,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._disconnectStreams();\n      this.closed.emit();\n    });\n    this._peer.on(\"error\", async (err) => {\n      this.errors.raise(err);\n      await this.destroy();\n    });\n  }\n  async destroy() {\n    log11(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._disconnectStreams();\n    this._peer.destroy();\n    this.closed.emit();\n    log11(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    assert11(this._peer, \"Connection not ready to accept signals.\");\n    assert11(signal.payload.data, \"Signal message must contain signal data.\");\n    this._peer.signal(signal.payload.data);\n  }\n  async _disconnectStreams() {\n    var _a, _b, _c, _d;\n    (_d = (_c = (_b = (_a = this.params.stream).unpipe) == null ? void 0 : _b.call(_a, this._peer)) == null ? void 0 : _c.unpipe) == null ? void 0 : _d.call(_c, this.params.stream);\n  }\n};\nvar createWebRTCTransportFactory = (webrtcConfig) => ({\n  createTransport: (params) => new WebRTCTransport({\n    ...params,\n    webrtcConfig\n  })\n});\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey9 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState2 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nimport { ComplexMap as ComplexMap7 } from \"@dxos/util\";\nvar WebRTCTransportService = class {\n  constructor(_webrtcConfig) {\n    this._webrtcConfig = _webrtcConfig;\n    this.transports = new ComplexMap7(PublicKey9.hash);\n  }\n  open(request) {\n    const rpcStream = new Stream(({ ready, next, close }) => {\n      const duplex = new Duplex({\n        read: () => {\n        },\n        write: function(chunk, _, callback) {\n          next({\n            data: {\n              payload: chunk\n            }\n          });\n          callback();\n        }\n      });\n      const transport = new WebRTCTransport({\n        initiator: request.initiator,\n        stream: duplex,\n        sendSignal: async (signal) => {\n          next({\n            signal: {\n              payload: signal\n            }\n          });\n        }\n      });\n      next({\n        connection: {\n          state: ConnectionState2.CONNECTING\n        }\n      });\n      transport.connected.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CONNECTED\n          }\n        });\n      });\n      transport.errors.handle((err) => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED,\n            error: err.toString()\n          }\n        });\n        close(err);\n      });\n      transport.closed.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED\n          }\n        });\n        close();\n      });\n      ready();\n      this.transports.set(request.proxyId, {\n        transport,\n        stream: duplex\n      });\n    });\n    return rpcStream;\n  }\n  async sendSignal({ proxyId, signal }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).transport.signal(signal);\n  }\n  async sendData({ proxyId, payload }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).stream.push(payload);\n  }\n  async close({ proxyId }) {\n    var _a, _b;\n    await ((_a = this.transports.get(proxyId)) == null ? void 0 : _a.transport.destroy());\n    await ((_b = this.transports.get(proxyId)) == null ? void 0 : _b.stream.end());\n    this.transports.delete(proxyId);\n    log12(\"Closed.\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\",\n      line: 108,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event8 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey10 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState3 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nvar WebRTCTransportProxy = class {\n  constructor(_params) {\n    this._params = _params;\n    this.closed = new Event8();\n    this._closed = false;\n    this.connected = new Event8();\n    this.errors = new ErrorStream5();\n    this._proxyId = PublicKey10.random();\n    this._serviceStream = this._params.bridgeService.open({\n      proxyId: this._proxyId,\n      initiator: this._params.initiator\n    });\n    this._serviceStream.waitUntilReady().then(() => {\n      this._serviceStream.subscribe(async (event) => {\n        log13(\"WebRTCTransportProxy: event\", event, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n          line: 46,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (event.connection) {\n          await this._handleConnection(event.connection);\n        } else if (event.data) {\n          this._handleData(event.data);\n        } else if (event.signal) {\n          await this._handleSignal(event.signal);\n        }\n      });\n      this._params.stream.on(\"data\", async (data) => {\n        try {\n          await this._params.bridgeService.sendData({\n            proxyId: this._proxyId,\n            payload: data\n          });\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n            line: 63,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      });\n    }, (error) => log13.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  async _handleConnection(connectionEvent) {\n    if (connectionEvent.error) {\n      this.errors.raise(new Error(connectionEvent.error));\n    }\n    switch (connectionEvent.state) {\n      case ConnectionState3.CONNECTED: {\n        this.connected.emit();\n        break;\n      }\n      case ConnectionState3.CLOSED: {\n        await this.destroy();\n        break;\n      }\n    }\n  }\n  _handleData(dataEvent) {\n    this._params.stream.write(Buffer.from(dataEvent.payload));\n  }\n  async _handleSignal(signalEvent) {\n    await this._params.sendSignal(signalEvent.payload);\n  }\n  signal(signal) {\n    this._params.bridgeService.sendSignal({\n      proxyId: this._proxyId,\n      signal\n    }).catch((err) => this.errors.raise(err));\n  }\n  async destroy() {\n    if (this._closed) {\n      return;\n    }\n    this._serviceStream.close();\n    try {\n      await this._params.bridgeService.close({\n        proxyId: this._proxyId\n      });\n    } catch (err) {\n      log13.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n        line: 117,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    this._closed = true;\n  }\n  forceClose() {\n    this._serviceStream.close();\n    this.closed.emit();\n    this._closed = true;\n  }\n};\nvar WebRTCTransportProxyFactory = class {\n  constructor() {\n    this._connections = /* @__PURE__ */ new Set();\n  }\n  setBridgeService(bridgeService) {\n    this._bridgeService = bridgeService;\n    for (const connection of this._connections) {\n      connection.forceClose();\n    }\n    return this;\n  }\n  createTransport(options) {\n    assert13(this._bridgeService, \"WebRTCTransportProxyFactory is not ready to open connections\");\n    const transport = new WebRTCTransportProxy({\n      ...options,\n      bridgeService: this._bridgeService\n    });\n    this._connections.add(transport);\n    transport.closed.on(() => this._connections.delete(transport));\n    return transport;\n  }\n};\n\n// packages/core/mesh/network-manager/src/wire-protocol.ts\nimport { discoveryKey as discoveryKey2 } from \"@dxos/crypto\";\nimport { Teleport } from \"@dxos/teleport\";\nvar adaptProtocolProvider = (factory) => ({ initiator, localPeerId, remotePeerId, topic }) => {\n  const protocol = factory({\n    channel: discoveryKey2(topic),\n    initiator\n  });\n  return {\n    initialize: () => protocol.open(),\n    destroy: () => protocol.close(),\n    stream: protocol.stream,\n    protocol\n  };\n};\nvar createTeleportProtocolFactory = (onConnection) => {\n  return (params) => {\n    const teleport = new Teleport(params);\n    return {\n      stream: teleport.stream,\n      initialize: async () => {\n        await teleport.open();\n        await onConnection(teleport);\n      },\n      destroy: async () => {\n        await teleport.close();\n      }\n    };\n  };\n};\nexport {\n  Connection,\n  ConnectionLog,\n  ConnectionState,\n  EventType,\n  FullyConnectedTopology,\n  MMSTTopology,\n  MemoryTransport,\n  MemoryTransportFactory,\n  MessageRouter,\n  NetworkManager,\n  StarTopology,\n  Swarm,\n  SwarmMapper,\n  WebRTCTransport,\n  WebRTCTransportProxy,\n  WebRTCTransportProxyFactory,\n  WebRTCTransportService,\n  adaptProtocolProvider,\n  createProtocolFactory,\n  createTeleportProtocolFactory,\n  createWebRTCTransportFactory,\n  protocolFactory,\n  transportProtocolProvider\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465651,"end":1670465466249},{"name":"vite:react-babel","result":"var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nimport { Event as Event4 } from \"@dxos/async\";\nimport { raise } from \"@dxos/debug\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/swarm/connection.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { ErrorStream } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ConnectionState;\n(function(ConnectionState4) {\n  ConnectionState4[\"INITIAL\"] = \"INITIAL\";\n  ConnectionState4[\"CONNECTING\"] = \"CONNECTING\";\n  ConnectionState4[\"CONNECTED\"] = \"CONNECTED\";\n  ConnectionState4[\"CLOSED\"] = \"CLOSED\";\n})(ConnectionState || (ConnectionState = {}));\nvar Connection = class {\n  constructor(topic, ownId, remoteId, sessionId, initiator, _signalMessaging, _protocol, _transportFactory) {\n    this.topic = topic;\n    this.ownId = ownId;\n    this.remoteId = remoteId;\n    this.sessionId = sessionId;\n    this.initiator = initiator;\n    this._signalMessaging = _signalMessaging;\n    this._protocol = _protocol;\n    this._transportFactory = _transportFactory;\n    this._state = ConnectionState.INITIAL;\n    this._bufferedSignals = [];\n    this.stateChanged = new Event();\n    this.errors = new ErrorStream();\n  }\n  get state() {\n    return this._state;\n  }\n  get transport() {\n    return this._transport;\n  }\n  get protocol() {\n    return this._protocol;\n  }\n  openConnection() {\n    assert(this._state === ConnectionState.INITIAL, \"Invalid state.\");\n    this._changeState(ConnectionState.CONNECTING);\n    this._protocol.initialize().catch((err) => {\n      this.errors.raise(err);\n    });\n    assert(!this._transport);\n    this._transport = this._transportFactory.createTransport({\n      initiator: this.initiator,\n      stream: this._protocol.stream,\n      sendSignal: async (signal) => {\n        await this._signalMessaging.signal({\n          author: this.ownId,\n          recipient: this.remoteId,\n          sessionId: this.sessionId,\n          topic: this.topic,\n          data: {\n            signal\n          }\n        });\n      }\n    });\n    this._transport.connected.once(() => {\n      this._changeState(ConnectionState.CONNECTED);\n    });\n    this._transport.closed.once(() => {\n      this._transport = void 0;\n      this.close().catch((err) => this.errors.raise(err));\n    });\n    this._transport.errors.pipeTo(this.errors);\n    for (const signal of this._bufferedSignals) {\n      void this._transport.signal(signal);\n    }\n    this._bufferedSignals = [];\n  }\n  async close() {\n    var _a;\n    if (this._state === ConnectionState.CLOSED) {\n      return;\n    }\n    log(\"closing...\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 131,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this._protocol.destroy();\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    try {\n      await ((_a = this._transport) == null ? void 0 : _a.destroy());\n    } catch (err1) {\n      log.catch(err1, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 144,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    log(\"closed\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._changeState(ConnectionState.CLOSED);\n  }\n  async signal(msg) {\n    var _a, _b;\n    assert(msg.sessionId);\n    if (!msg.sessionId.equals(this.sessionId)) {\n      log(\"dropping signal for incorrect session id\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 154,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert(msg.data.signal);\n    assert((_a = msg.author) == null ? void 0 : _a.equals(this.remoteId));\n    assert((_b = msg.recipient) == null ? void 0 : _b.equals(this.ownId));\n    if (this._state === ConnectionState.INITIAL) {\n      log(\"buffered signal\", {\n        peerId: this.ownId,\n        remoteId: this.remoteId,\n        msg: msg.data\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 162,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._bufferedSignals.push(msg.data.signal);\n      return;\n    }\n    assert(this._transport, \"Connection not ready to accept signals.\");\n    log(\"received signal\", {\n      peerId: this.ownId,\n      remoteId: this.remoteId,\n      msg: msg.data\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 168,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._transport.signal(msg.data.signal);\n  }\n  _changeState(state) {\n    assert(state !== this._state, \"Already in this state.\");\n    this._state = state;\n    this.stateChanged.emit(state);\n  }\n};\n__decorate([\n  synchronized\n], Connection.prototype, \"close\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask, sleep } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { ErrorStream as ErrorStream2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4, logInfo } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2, isNotNullOrUndefined } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/signal/message-router.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap } from \"@dxos/util\";\nvar MessageRouter = class {\n  constructor({ sendMessage, onSignal, onOffer, topic }) {\n    this._offerRecords = new ComplexMap((key) => key.toHex());\n    this._sendMessage = sendMessage;\n    this._onSignal = onSignal;\n    this._onOffer = onOffer;\n    this._topic = topic;\n  }\n  async receiveMessage({ author, recipient, payload }) {\n    var _a, _b, _c;\n    if (payload.type_url !== \"dxos.mesh.swarm.SwarmMessage\") {\n      return;\n    }\n    const message = schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").decode(payload.value);\n    if (!this._topic.equals(message.topic)) {\n      return;\n    }\n    log2(\"received\", {\n      from: author,\n      to: recipient,\n      msg: message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if ((_a = message.data) == null ? void 0 : _a.offer) {\n      await this._handleOffer({\n        author,\n        recipient,\n        message\n      });\n    } else if ((_b = message.data) == null ? void 0 : _b.answer) {\n      await this._resolveAnswers(message);\n    } else if ((_c = message.data) == null ? void 0 : _c.signal) {\n      await this._handleSignal({\n        author,\n        recipient,\n        message\n      });\n    }\n  }\n  async signal(message) {\n    var _a;\n    assert2((_a = message.data) == null ? void 0 : _a.signal);\n    await this._sendReliableMessage({\n      author: message.author,\n      recipient: message.recipient,\n      message\n    });\n  }\n  async offer(message) {\n    const networkMessage = {\n      ...message,\n      messageId: PublicKey.random()\n    };\n    return new Promise((resolve, reject) => {\n      this._offerRecords.set(networkMessage.messageId, {\n        resolve,\n        reject\n      });\n      return this._sendReliableMessage({\n        author: message.author,\n        recipient: message.recipient,\n        message: networkMessage\n      });\n    });\n  }\n  async _sendReliableMessage({ author, recipient, message }) {\n    var _a;\n    const networkMessage = {\n      ...message,\n      messageId: (_a = message.messageId) != null ? _a : PublicKey.random()\n    };\n    log2(\"sending\", {\n      from: author,\n      to: recipient,\n      msg: networkMessage\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      message: networkMessage\n    });\n  }\n  async _encodeAndSend({ author, recipient, message }) {\n    await this._sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.swarm.SwarmMessage\",\n        value: schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").encode(message)\n      }\n    });\n  }\n  async _resolveAnswers(message) {\n    var _a, _b, _c;\n    assert2((_b = (_a = message.data) == null ? void 0 : _a.answer) == null ? void 0 : _b.offerMessageId, \"No offerMessageId\");\n    const offerRecord = this._offerRecords.get(message.data.answer.offerMessageId);\n    if (offerRecord) {\n      this._offerRecords.delete(message.data.answer.offerMessageId);\n      assert2((_c = message.data) == null ? void 0 : _c.answer, \"No answer\");\n      log2(\"resolving\", {\n        answer: message.data.answer\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      offerRecord.resolve(message.data.answer);\n    }\n  }\n  async _handleOffer({ author, recipient, message }) {\n    assert2(message.data.offer, \"No offer\");\n    const offerMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        offer: message.data.offer\n      }\n    };\n    const answer = await this._onOffer(offerMessage);\n    answer.offerMessageId = message.messageId;\n    await this._sendReliableMessage({\n      author: recipient,\n      recipient: author,\n      message: {\n        topic: message.topic,\n        sessionId: message.sessionId,\n        data: {\n          answer\n        }\n      }\n    });\n  }\n  async _handleSignal({ author, recipient, message }) {\n    assert2(message.messageId);\n    assert2(message.data.signal, \"No Signal\");\n    const signalMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        signal: message.data.signal\n      }\n    };\n    await this._onSignal(signalMessage);\n  }\n};\n\n// packages/core/mesh/network-manager/src/swarm/peer.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Peer = class {\n  constructor(id, topic, localPeerId, _signalMessaging, _protocolProvider, _transportFactory, _callbacks) {\n    this.id = id;\n    this.topic = topic;\n    this.localPeerId = localPeerId;\n    this._signalMessaging = _signalMessaging;\n    this._protocolProvider = _protocolProvider;\n    this._transportFactory = _transportFactory;\n    this._callbacks = _callbacks;\n    this.advertizing = false;\n    this.initiating = false;\n  }\n  async onOffer(message) {\n    const remoteId = message.author;\n    if (this.connection || this.initiating) {\n      if (remoteId.toHex() < this.localPeerId.toHex()) {\n        log3.info(\"closing local connection and accepting remote peer's offer\", {\n          id: this.id,\n          topic: this.topic,\n          peerId: this.localPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (this.connection) {\n          await this.closeConnection();\n        }\n      } else {\n        return {\n          accept: false\n        };\n      }\n    }\n    if (await this._callbacks.onOffer(remoteId)) {\n      if (!this.connection) {\n        assert3(message.sessionId);\n        const connection = this._createConnection(false, message.sessionId);\n        try {\n          connection.openConnection();\n        } catch (err) {\n          log3.warn(\"connection error\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 107,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await this.closeConnection();\n        }\n        return {\n          accept: true\n        };\n      }\n    }\n    return {\n      accept: false\n    };\n  }\n  async initiateConnection() {\n    assert3(!this.initiating, \"Initiation in progress.\");\n    assert3(!this.connection, \"Already connected.\");\n    const sessionId = PublicKey2.random();\n    log3(\"initiating...\", {\n      id: this.id,\n      topic: this.topic,\n      peerId: this.id,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const connection = this._createConnection(true, sessionId);\n    this.initiating = true;\n    try {\n      const answer = await this._signalMessaging.offer({\n        author: this.localPeerId,\n        recipient: this.id,\n        sessionId,\n        topic: this.topic,\n        data: {\n          offer: {}\n        }\n      });\n      log3(\"received\", {\n        answer,\n        topic: this.topic,\n        ownId: this.localPeerId,\n        remoteId: this.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (connection.state !== ConnectionState.INITIAL) {\n        log3(\"ignoring response\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 139,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      if (!answer.accept) {\n        this._callbacks.onRejected();\n        return;\n      }\n      connection.openConnection();\n      this._callbacks.onAccepted();\n    } catch (err) {\n      log3.warn(\"initiation error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 150,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.closeConnection();\n      throw err;\n    } finally {\n      this.initiating = false;\n    }\n  }\n  _createConnection(initiator, sessionId) {\n    log3(\"creating connection\", {\n      topic: this.topic,\n      peerId: this.localPeerId,\n      remoteId: this.id,\n      initiator,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 164,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this.connection, \"Already connected.\");\n    const connection = new Connection(\n      this.topic,\n      this.localPeerId,\n      this.id,\n      sessionId,\n      initiator,\n      this._signalMessaging,\n      this._protocolProvider({\n        initiator,\n        localPeerId: this.localPeerId,\n        remotePeerId: this.id,\n        topic: this.topic\n      }),\n      this._transportFactory\n    );\n    this._callbacks.onInitiated(connection);\n    connection.stateChanged.on((state) => {\n      switch (state) {\n        case ConnectionState.CONNECTED: {\n          this._callbacks.onConnected();\n          break;\n        }\n        case ConnectionState.CLOSED: {\n          log3(\"connection closed\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            initiator\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 193,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          assert3(this.connection === connection, \"Connection mismatch (race condition).\");\n          this.connection = void 0;\n          this._callbacks.onDisconnected();\n          break;\n        }\n      }\n    });\n    connection.errors.handle((err) => {\n      log3.warn(\"connection error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        initiator,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 203,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      void this.closeConnection().catch(() => {\n        log3.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 207,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    });\n    this.connection = connection;\n    return connection;\n  }\n  async closeConnection() {\n    if (!this.connection) {\n      return;\n    }\n    const connection = this.connection;\n    log3(\"closing...\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 221,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await connection.close();\n    log3(\"closed\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 227,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async onSignal(message) {\n    if (!this.connection) {\n      log3(\"dropping signal message for non-existent connection\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 232,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    await this.connection.signal(message);\n  }\n  async destroy() {\n    var _a;\n    log3(\"Destroying peer\", {\n      peerId: this.id,\n      topic: this.topic\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 240,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await ((_a = this == null ? void 0 : this.connection) == null ? void 0 : _a.close());\n  }\n};\n__decorate2([\n  synchronized2\n], Peer.prototype, \"destroy\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar INITIATION_DELAY = 100;\nvar getClassName = (obj) => Object.getPrototypeOf(obj).constructor.name;\nvar Swarm = class {\n  constructor(_topic, _ownPeerId, _topology, _protocolProvider, _messenger, _transportFactory, _label) {\n    this._topic = _topic;\n    this._ownPeerId = _ownPeerId;\n    this._topology = _topology;\n    this._protocolProvider = _protocolProvider;\n    this._messenger = _messenger;\n    this._transportFactory = _transportFactory;\n    this._label = _label;\n    this._peers = new ComplexMap2(PublicKey3.hash);\n    this._ctx = new Context();\n    this.connectionAdded = new Event2();\n    this.disconnected = new Event2();\n    this.connected = new Event2();\n    this.errors = new ErrorStream2();\n    this.instanceId = PublicKey3.random();\n    log4(\"creating swarm\", {\n      peerId: _ownPeerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 80,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    _topology.init(this._getSwarmController());\n    this._swarmMessenger = new MessageRouter({\n      sendMessage: async (msg) => await this._messenger.sendMessage(msg),\n      onSignal: async (msg) => await this.onSignal(msg),\n      onOffer: async (msg) => await this.onOffer(msg),\n      topic: this._topic\n    });\n    this._messenger.listen({\n      peerId: this._ownPeerId,\n      payloadType: \"dxos.mesh.swarm.SwarmMessage\",\n      onMessage: async (message) => await this._swarmMessenger.receiveMessage(message)\n    }).catch((error) => log4.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 96,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get connections() {\n    return Array.from(this._peers.values()).map((peer) => peer.connection).filter(isNotNullOrUndefined);\n  }\n  get ownPeerId() {\n    return this._ownPeerId;\n  }\n  get label() {\n    return this._label;\n  }\n  get topic() {\n    return this._topic;\n  }\n  async destroy() {\n    log4(\"destroying...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 124,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._ctx.dispose();\n    await this._topology.destroy();\n    await Promise.all(Array.from(this._peers.keys()).map((key) => this._destroyPeer(key)));\n    log4(\"destroyed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 128,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async setTopology(topology) {\n    if (topology === this._topology) {\n      return;\n    }\n    log4(\"setting topology\", {\n      previous: getClassName(this._topology),\n      topology: getClassName(topology)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 135,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._topology.destroy();\n    this._topology = topology;\n    this._topology.init(this._getSwarmController());\n    this._topology.update();\n  }\n  _getOrCreatePeer(peerId) {\n    let peer = this._peers.get(peerId);\n    if (!peer) {\n      peer = new Peer(peerId, this._topic, this._ownPeerId, this._swarmMessenger, this._protocolProvider, this._transportFactory, {\n        onInitiated: (connection) => {\n          this.connectionAdded.emit(connection);\n        },\n        onConnected: () => {\n          this.connected.emit(peerId);\n        },\n        onDisconnected: async () => {\n          if (!peer.advertizing) {\n            await this._destroyPeer(peer.id);\n          }\n          this.disconnected.emit(peerId);\n          this._topology.update();\n        },\n        onRejected: () => {\n          if (this._peers.has(peerId)) {\n            void this._destroyPeer(peerId);\n          }\n        },\n        onAccepted: () => {\n          this._topology.update();\n        },\n        onOffer: (remoteId) => {\n          return this._topology.onOffer(remoteId);\n        }\n      });\n      this._peers.set(peerId, peer);\n    }\n    return peer;\n  }\n  async _destroyPeer(peerId) {\n    assert4(this._peers.has(peerId));\n    await this._peers.get(peerId).destroy();\n    this._peers.delete(peerId);\n  }\n  onSwarmEvent(swarmEvent) {\n    log4(\"swarm event\", {\n      swarmEvent\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 199,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.warn(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (swarmEvent.peerAvailable) {\n      const peerId = PublicKey3.from(swarmEvent.peerAvailable.peer);\n      log4(\"new peer\", {\n        peerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 207,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!peerId.equals(this._ownPeerId)) {\n        const peer = this._getOrCreatePeer(peerId);\n        peer.advertizing = true;\n      }\n    } else if (swarmEvent.peerLeft) {\n      const peer1 = this._peers.get(PublicKey3.from(swarmEvent.peerLeft.peer));\n      if (peer1) {\n        peer1.advertizing = false;\n        if (!peer1.connection) {\n          void this._destroyPeer(peer1.id);\n        }\n      }\n    }\n    this._topology.update();\n  }\n  async onOffer(message) {\n    var _a, _b;\n    log4(\"offer\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 226,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 228,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    assert4(message.author);\n    if (!((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId))) {\n      log4(\"rejecting offer with incorrect peerId\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 235,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    if (!((_b = message.topic) == null ? void 0 : _b.equals(this._topic))) {\n      log4(\"rejecting offer with incorrect topic\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 239,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    const peer = this._getOrCreatePeer(message.author);\n    const answer = await peer.onOffer(message);\n    this._topology.update();\n    return answer;\n  }\n  async onSignal(message) {\n    var _a, _b;\n    log4(\"signal\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 250,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 252,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert4((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId), `Invalid signal peer id expected=${this.ownPeerId}, actual=${message.recipient}`);\n    assert4((_b = message.topic) == null ? void 0 : _b.equals(this._topic));\n    assert4(message.author);\n    const peer = this._getOrCreatePeer(message.author);\n    await peer.onSignal(message);\n  }\n  _getSwarmController() {\n    return {\n      getState: () => ({\n        ownPeerId: this._ownPeerId,\n        connected: Array.from(this._peers.values()).filter((peer) => peer.connection).map((peer) => peer.id),\n        candidates: Array.from(this._peers.values()).filter((peer) => !peer.connection && peer.advertizing).map((peer) => peer.id)\n      }),\n      connect: (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          try {\n            await this._initiateConnection(peer);\n          } catch (err) {\n            log4.warn(\"initiation error\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n              line: 287,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          }\n        });\n      },\n      disconnect: async (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          await this._closeConnection(peer);\n          this._topology.update();\n        });\n      }\n    };\n  }\n  async _initiateConnection(remoteId) {\n    if (remoteId.toHex() < this._ownPeerId.toHex()) {\n      log4(\"initiation delay\", {\n        remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 312,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await sleep(INITIATION_DELAY);\n    }\n    if (this._ctx.disposed) {\n      return;\n    }\n    const peer = this._getOrCreatePeer(remoteId);\n    if (peer.connection) {\n      return;\n    }\n    log4(\"initiating connection...\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 326,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await peer.initiateConnection();\n    this._topology.update();\n    log4(\"initiated\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 329,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _closeConnection(peerId) {\n    const peer = this._peers.get(peerId);\n    if (!peer) {\n      return;\n    }\n    await peer.closeConnection();\n  }\n};\n__decorate3([\n  logInfo\n], Swarm.prototype, \"instanceId\", void 0);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"ownPeerId\", null);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"topic\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\nvar SwarmMapper = class {\n  get peers() {\n    return Array.from(this._peers.values());\n  }\n  constructor(_swarm, _presence) {\n    this._swarm = _swarm;\n    this._presence = _presence;\n    this._subscriptions = new EventSubscriptions();\n    this._connectionSubscriptions = new ComplexMap3(PublicKey4.hash);\n    this._peers = new ComplexMap3(PublicKey4.hash);\n    this.mapUpdated = new Event3();\n    this._subscriptions.add(_swarm.connectionAdded.on((connection) => {\n      this._update();\n      this._connectionSubscriptions.set(connection.remoteId, connection.stateChanged.on(() => {\n        this._update();\n      }));\n    }));\n    this._subscriptions.add(_swarm.disconnected.on((peerId) => {\n      var _a;\n      (_a = this._connectionSubscriptions.get(peerId)) == null ? void 0 : _a();\n      this._connectionSubscriptions.delete(peerId);\n      this._update();\n    }));\n    if (_presence) {\n      this._subscriptions.add(_presence.graphUpdated.on(() => {\n        this._update();\n      }));\n    }\n    this._update();\n  }\n  _update() {\n    log5(\"updating swarm\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peers.clear();\n    this._peers.set(this._swarm.ownPeerId, {\n      id: this._swarm.ownPeerId,\n      state: \"ME\",\n      connections: []\n    });\n    for (const connection of this._swarm.connections) {\n      this._peers.set(connection.remoteId, {\n        id: connection.remoteId,\n        state: connection.state,\n        connections: [\n          this._swarm.ownPeerId\n        ]\n      });\n    }\n    if (this._presence) {\n      this._presence.graph.forEachNode((node) => {\n        const id = PublicKey4.fromHex(node.id);\n        if (this._peers.has(id)) {\n          return;\n        }\n        this._peers.set(id, {\n          id,\n          state: \"INDIRECTLY_CONNECTED\",\n          connections: []\n        });\n      });\n      this._presence.graph.forEachLink((link) => {\n        const from = PublicKey4.from(link.fromId);\n        const to = PublicKey4.from(link.toId);\n        if (!from.equals(this._swarm.ownPeerId) && !to.equals(this._swarm.ownPeerId)) {\n          this._peers.get(from).connections.push(to);\n        }\n      });\n    }\n    log5(\"graph changed\", {\n      directConnections: this._swarm.connections.length,\n      totalPeersInSwarm: this._peers.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 118,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.mapUpdated.emit(Array.from(this._peers.values()));\n  }\n  destroy() {\n    Array.from(this._connectionSubscriptions.values()).forEach((cb) => cb());\n    this._subscriptions.clear();\n  }\n};\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nvar EventType;\n(function(EventType2) {\n  EventType2[\"CONNECTION_STATE_CHANGED\"] = \"CONNECTION_STATE_CHANGED\";\n  EventType2[\"PROTOCOL_ERROR\"] = \"PROTOCOL_ERROR\";\n  EventType2[\"PROTOCOL_EXTENSIONS_INITIALIZED\"] = \"PROTOCOL_EXTENSIONS_INITIALIZED\";\n  EventType2[\"PROTOCOL_EXTENSIONS_HANDSHAKE\"] = \"PROTOCOL_EXTENSIONS_HANDSHAKE\";\n  EventType2[\"PROTOCOL_HANDSHAKE\"] = \"PROTOCOL_HANDSHAKE\";\n})(EventType || (EventType = {}));\nvar ConnectionLog = class {\n  constructor() {\n    this._swarms = new ComplexMap4(PublicKey5.hash);\n    this.update = new Event4();\n  }\n  getSwarmInfo(swarmId) {\n    var _a;\n    return (_a = this._swarms.get(swarmId)) != null ? _a : raise(new Error(`Swarm not found: ${swarmId}`));\n  }\n  get swarms() {\n    return Array.from(this._swarms.values());\n  }\n  swarmJoined(swarm) {\n    const info = {\n      id: swarm.instanceId,\n      topic: swarm.topic,\n      isActive: true,\n      label: swarm.label,\n      connections: []\n    };\n    this._swarms.set(swarm.instanceId, info);\n    this.update.emit();\n    swarm.connectionAdded.on((connection) => {\n      var _a, _b, _c, _d, _e;\n      const connectionInfo = {\n        state: ConnectionState.INITIAL,\n        remotePeerId: connection.remoteId,\n        sessionId: connection.sessionId,\n        transport: connection.transport && Object.getPrototypeOf(connection.transport).constructor.name,\n        protocolExtensions: (_a = connection.protocol.protocol) == null ? void 0 : _a.extensionNames,\n        events: []\n      };\n      info.connections.push(connectionInfo);\n      this.update.emit();\n      connection.stateChanged.on((state) => {\n        connectionInfo.state = state;\n        connectionInfo.events.push({\n          type: EventType.CONNECTION_STATE_CHANGED,\n          newState: state\n        });\n        this.update.emit();\n      });\n      (_b = connection.protocol.protocol) == null ? void 0 : _b.error.on((error) => {\n        var _a2;\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_ERROR,\n          error: (_a2 = error.stack) != null ? _a2 : error.message\n        });\n        this.update.emit();\n      });\n      (_c = connection.protocol.protocol) == null ? void 0 : _c.extensionsInitialized.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_INITIALIZED\n        });\n        this.update.emit();\n      });\n      (_d = connection.protocol.protocol) == null ? void 0 : _d.extensionsHandshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_HANDSHAKE\n        });\n        this.update.emit();\n      });\n      (_e = connection.protocol.protocol) == null ? void 0 : _e.handshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_HANDSHAKE\n        });\n        this.update.emit();\n      });\n    });\n  }\n  swarmLeft(swarm) {\n    this.getSwarmInfo(swarm.instanceId).isActive = false;\n    this.update.emit();\n  }\n};\n\n// packages/core/mesh/network-manager/src/network-manager.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Messenger } from \"@dxos/messaging\";\nimport { ComplexMap as ComplexMap5 } from \"@dxos/util\";\nvar NetworkManager = class {\n  constructor({ transportFactory, signalManager, log: log14 }) {\n    this._swarms = new ComplexMap5(PublicKey6.hash);\n    this._mappers = new ComplexMap5(PublicKey6.hash);\n    this.topicsUpdated = new Event5();\n    this._transportFactory = transportFactory;\n    this._signalManager = signalManager;\n    this._signalManager.swarmEvent.on(({ topic, swarmEvent: event }) => {\n      var _a;\n      return (_a = this._swarms.get(topic)) == null ? void 0 : _a.onSwarmEvent(event);\n    });\n    this._messenger = new Messenger({\n      signalManager: this._signalManager\n    });\n    this._signalConnection = {\n      join: (opts) => this._signalManager.join(opts),\n      leave: (opts) => this._signalManager.leave(opts)\n    };\n    if (log14) {\n      this._connectionLog = new ConnectionLog();\n    }\n  }\n  get connectionLog() {\n    return this._connectionLog;\n  }\n  get signalManager() {\n    return this._signalManager;\n  }\n  get topics() {\n    return Array.from(this._swarms.keys());\n  }\n  getSwarmMap(topic) {\n    return this._mappers.get(topic);\n  }\n  getSwarm(topic) {\n    return this._swarms.get(topic);\n  }\n  async close() {\n    for (const topic of this._swarms.keys()) {\n      await this.leaveSwarm(topic).catch((err) => {\n        log6(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n          line: 128,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    }\n    await this._signalManager.destroy();\n  }\n  async joinSwarm({ topic, peerId, topology, protocolProvider: protocol, presence, label }) {\n    var _a;\n    assert5(PublicKey6.isPublicKey(topic));\n    assert5(PublicKey6.isPublicKey(peerId));\n    assert5(topology);\n    assert5(typeof protocol === \"function\");\n    if (this._swarms.has(topic)) {\n      throw new Error(`Already connected to swarm: ${PublicKey6.from(topic)}`);\n    }\n    log6(\"joining\", {\n      topic: PublicKey6.from(topic),\n      peerId,\n      topology: topology.toString()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 155,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = new Swarm(topic, peerId, topology, protocol, this._messenger, this._transportFactory, label);\n    swarm.errors.handle((error) => {\n      log6(\"swarm error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 158,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._swarms.set(topic, swarm);\n    this._signalConnection.join({\n      topic,\n      peerId\n    }).catch((error) => log6.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 162,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n    this._mappers.set(topic, new SwarmMapper(swarm, presence));\n    this.topicsUpdated.emit();\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmJoined(swarm);\n    log6(\"joined\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 167,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return {\n      close: () => this.leaveSwarm(topic)\n    };\n  }\n  async leaveSwarm(topic) {\n    var _a;\n    if (!this._swarms.has(topic)) {\n      log6.warn(\"swarm not open\", {\n        topic: PublicKey6.from(topic)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    log6(\"leaving\", {\n      topic: PublicKey6.from(topic)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = this._swarms.get(topic);\n    await this._signalConnection.leave({\n      topic,\n      peerId: swarm.ownPeerId\n    });\n    const map = this._mappers.get(topic);\n    map.destroy();\n    this._mappers.delete(topic);\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmLeft(swarm);\n    await swarm.destroy();\n    this._swarms.delete(topic);\n    await this.topicsUpdated.emit();\n    log6(\"left\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 197,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/protocol-factory.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { discoveryKey } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey7 } from \"@dxos/keys\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nvar protocolFactory = ({ session = {}, plugins = [], getTopics }) => {\n  assert6(getTopics);\n  return ({ channel, initiator }) => {\n    log7(\"creating protocol\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/protocol-factory.ts\",\n      line: 41,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    const protocol = new Protocol({\n      streamOptions: {\n        live: true\n      },\n      discoveryToPublicKey: (dk) => {\n        const publicKey = getTopics().find((topic) => discoveryKey(topic).equals(dk));\n        if (publicKey) {\n          protocol.setContext({\n            topic: PublicKey7.stringify(publicKey)\n          });\n        }\n        assert6(publicKey, \"PublicKey not found in discovery.\");\n        return publicKey;\n      },\n      initiator,\n      userSession: session,\n      discoveryKey: channel\n    });\n    protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n    return protocol;\n  };\n};\nvar createProtocolFactory = (topic, peerId, plugins) => protocolFactory({\n  getTopics: () => [\n    topic.asBuffer()\n  ],\n  session: {\n    peerId: PublicKey7.stringify(peerId.asBuffer())\n  },\n  plugins\n});\nvar transportProtocolProvider = (rendezvousKey, peerId, protocolPlugin) => {\n  return protocolFactory({\n    getTopics: () => [\n      rendezvousKey\n    ],\n    session: {\n      peerId: PublicKey7.stringify(peerId)\n    },\n    plugins: [\n      protocolPlugin\n    ]\n  });\n};\n\n// packages/core/mesh/network-manager/src/topology/fully-connected-topology.ts\nimport assert7 from \"@dxos/node-std/assert\";\nvar FullyConnectedTopology = class {\n  toString() {\n    return \"FullyConnectedTopology\";\n  }\n  init(controller) {\n    assert7(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert7(this._controller, \"Not initialized\");\n    const { candidates: discovered } = this._controller.getState();\n    for (const peer of discovered) {\n      this._controller.connect(peer);\n    }\n  }\n  async onOffer(peer) {\n    return true;\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/topology/mmst-topology.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport distance from \"xor-distance\";\nimport { log as log8 } from \"@dxos/log\";\nvar MMSTTopology = class {\n  constructor({ originateConnections = 2, maxPeers = 4, sampleSize = 10 } = {}) {\n    this._sampleCollected = false;\n    this._originateConnections = originateConnections;\n    this._maxPeers = maxPeers;\n    this._sampleSize = sampleSize;\n  }\n  init(controller) {\n    assert8(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates } = this._controller.getState();\n    if (this._sampleCollected || connected.length > this._maxPeers || candidates.length > 0) {\n      log8(\"Running the algorithm.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._sampleCollected = true;\n      this._runAlgorithm();\n    }\n  }\n  async onOffer(peer) {\n    assert8(this._controller, \"Not initialized\");\n    const { connected } = this._controller.getState();\n    const accept = connected.length < this._maxPeers;\n    log8(`Offer ${peer} accept=${accept}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return accept;\n  }\n  async destroy() {\n  }\n  _runAlgorithm() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates, ownPeerId } = this._controller.getState();\n    if (connected.length > this._maxPeers) {\n      const sorted = sortByXorDistance(connected, ownPeerId).reverse().slice(0, this._maxPeers - connected.length);\n      for (const peer of sorted) {\n        log8(`Disconnect ${peer}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.disconnect(peer);\n      }\n    } else if (connected.length < this._originateConnections) {\n      const sample = candidates.sort(() => Math.random() - 0.5).slice(0, this._sampleSize);\n      const sorted1 = sortByXorDistance(sample, ownPeerId).slice(0, this._originateConnections - connected.length);\n      for (const peer1 of sorted1) {\n        log8(`Connect ${peer1}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  toString() {\n    return \"MMSTTopology\";\n  }\n};\nvar sortByXorDistance = (keys, reference) => keys.sort((a, b) => distance.gt(distance(a.asBuffer(), reference.asBuffer()), distance(b.asBuffer(), reference.asBuffer())));\n\n// packages/core/mesh/network-manager/src/topology/star-topology.ts\nimport assert9 from \"@dxos/node-std/assert\";\nimport { log as log9 } from \"@dxos/log\";\nvar StarTopology = class {\n  constructor(_centralPeer) {\n    this._centralPeer = _centralPeer;\n  }\n  toString() {\n    return `StarTopology(${this._centralPeer.truncate()})`;\n  }\n  init(controller) {\n    assert9(!this._controller, \"Already initialized.\");\n    this._controller = controller;\n  }\n  update() {\n    assert9(this._controller, \"Not initialized.\");\n    const { candidates, connected, ownPeerId } = this._controller.getState();\n    if (!ownPeerId.equals(this._centralPeer)) {\n      log9(\"leaf peer dropping all connections apart from central peer.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n        line: 33,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      for (const peer of connected) {\n        if (!peer.equals(this._centralPeer)) {\n          log9(\"dropping connection\", {\n            peer\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n            line: 38,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._controller.disconnect(peer);\n        }\n      }\n    }\n    for (const peer1 of candidates) {\n      if (peer1.equals(this._centralPeer) || ownPeerId.equals(this._centralPeer)) {\n        log9(\"connecting to peer\", {\n          peer: peer1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  async onOffer(peer) {\n    assert9(this._controller, \"Not initialized.\");\n    const { ownPeerId } = this._controller.getState();\n    log9(\"offer\", {\n      peer,\n      isCentral: peer.equals(this._centralPeer),\n      isSelfCentral: ownPeerId.equals(this._centralPeer)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n      line: 56,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return ownPeerId.equals(this._centralPeer) || peer.equals(this._centralPeer);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/memory-transport.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Transform } from \"@dxos/node-std/stream\";\nimport { Event as Event6, Trigger } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream3 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey8 } from \"@dxos/keys\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap6 } from \"@dxos/util\";\nvar MEMORY_TRANSPORT_DELAY = 1;\nvar createStreamDelay = (delay) => {\n  return new Transform({\n    objectMode: true,\n    transform: (chunk, _, cb) => {\n      setTimeout(() => cb(null, chunk), delay);\n    }\n  });\n};\nvar MemoryTransportFactory = {\n  createTransport: (params) => new MemoryTransport(params)\n};\nvar _MemoryTransport = class {\n  constructor(options) {\n    var _a;\n    this.options = options;\n    this.closed = new Event6();\n    this.connected = new Event6();\n    this.errors = new ErrorStream3();\n    this._id = PublicKey8.random();\n    this._remote = new Trigger();\n    this._outgoingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._incomingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._destroyed = false;\n    log10(\"creating\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 59,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert10(!_MemoryTransport._connections.has(this._id), \"Duplicate memory connection\");\n    _MemoryTransport._connections.set(this._id, this);\n    if (this.options.initiator) {\n      setTimeout(async () => {\n        log10(\"sending signal\", {\n          transportId: this._id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 68,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        void this.options.sendSignal({\n          payload: {\n            transportId: this._id.toHex()\n          }\n        });\n      });\n    } else {\n      this._remote.wait({\n        timeout: (_a = this.options.timeout) != null ? _a : 1e3\n      }).then((remoteId) => {\n        if (this._destroyed) {\n          return;\n        }\n        this._remoteId = remoteId;\n        this._remoteConnection = _MemoryTransport._connections.get(this._remoteId);\n        if (!this._remoteConnection) {\n          this._destroyed = true;\n          this.closed.emit();\n          return;\n        }\n        assert10(!this._remoteConnection._remoteConnection, new Error(`Remote already connected: ${this._remoteId}`));\n        this._remoteConnection._remoteConnection = this;\n        this._remoteConnection._remoteId = this._id;\n        log10(\"connected\", {\n          id: this._id,\n          remote: this._remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 94,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.options.stream.pipe(this._outgoingDelay).pipe(this._remoteConnection.options.stream).pipe(this._incomingDelay).pipe(this.options.stream);\n        this.connected.emit();\n        this._remoteConnection.connected.emit();\n      }).catch((err) => {\n        if (this._destroyed) {\n          return;\n        }\n        this.errors.raise(err);\n      });\n    }\n  }\n  async destroy() {\n    log10(\"closing\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._destroyed = true;\n    _MemoryTransport._connections.delete(this._id);\n    if (this._remoteConnection) {\n      log10(\"closing\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._remoteConnection._destroyed = true;\n      _MemoryTransport._connections.delete(this._remoteId);\n      this._outgoingDelay.unpipe();\n      this._incomingDelay.unpipe();\n      this._remoteConnection.closed.emit();\n      this._remoteConnection._remoteConnection = void 0;\n      this._remoteConnection = void 0;\n      log10(\"closed\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 138,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    log10(\"closed\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    const { payload: json } = signal;\n    if (json && json.transportId) {\n      const transportId = json.transportId;\n      if (transportId) {\n        const remoteId = PublicKey8.fromHex(transportId);\n        log10(\"received signal\", {\n          id: this._id,\n          remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 152,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._remote.wake(remoteId);\n      }\n    }\n  }\n};\nvar MemoryTransport = _MemoryTransport;\nMemoryTransport._connections = new ComplexMap6(PublicKey8.hash);\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport SimplePeerConstructor from \"simple-peer\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream4, raise as raise2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\n\n// packages/core/mesh/network-manager/src/transport/webrtc.ts\nvar wrtc = null;\ntry {\n  wrtc = __require(\"@koush/wrtc\");\n} catch (e) {\n}\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nvar WebRTCTransport = class {\n  constructor(params) {\n    var _a;\n    this.params = params;\n    this.closed = new Event7();\n    this.connected = new Event7();\n    this.errors = new ErrorStream4();\n    log11(\"created connection\", params, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 34,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peer = new SimplePeerConstructor({\n      initiator: this.params.initiator,\n      wrtc: SimplePeerConstructor.WEBRTC_SUPPORT ? void 0 : (_a = wrtc) != null ? _a : raise2(new Error(\"wrtc not available\")),\n      config: this.params.webrtcConfig\n    });\n    this._peer.on(\"signal\", async (data) => {\n      log11(\"signal\", data, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 42,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.params.sendSignal({\n        payload: {\n          data\n        }\n      });\n    });\n    this._peer.on(\"connect\", () => {\n      log11(\"connected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.params.stream.pipe(this._peer).pipe(this.params.stream);\n      this.connected.emit();\n    });\n    this._peer.on(\"close\", async () => {\n      log11(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 53,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._disconnectStreams();\n      this.closed.emit();\n    });\n    this._peer.on(\"error\", async (err) => {\n      this.errors.raise(err);\n      await this.destroy();\n    });\n  }\n  async destroy() {\n    log11(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._disconnectStreams();\n    this._peer.destroy();\n    this.closed.emit();\n    log11(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    assert11(this._peer, \"Connection not ready to accept signals.\");\n    assert11(signal.payload.data, \"Signal message must contain signal data.\");\n    this._peer.signal(signal.payload.data);\n  }\n  async _disconnectStreams() {\n    var _a, _b, _c, _d;\n    (_d = (_c = (_b = (_a = this.params.stream).unpipe) == null ? void 0 : _b.call(_a, this._peer)) == null ? void 0 : _c.unpipe) == null ? void 0 : _d.call(_c, this.params.stream);\n  }\n};\nvar createWebRTCTransportFactory = (webrtcConfig) => ({\n  createTransport: (params) => new WebRTCTransport({\n    ...params,\n    webrtcConfig\n  })\n});\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey9 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState2 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nimport { ComplexMap as ComplexMap7 } from \"@dxos/util\";\nvar WebRTCTransportService = class {\n  constructor(_webrtcConfig) {\n    this._webrtcConfig = _webrtcConfig;\n    this.transports = new ComplexMap7(PublicKey9.hash);\n  }\n  open(request) {\n    const rpcStream = new Stream(({ ready, next, close }) => {\n      const duplex = new Duplex({\n        read: () => {\n        },\n        write: function(chunk, _, callback) {\n          next({\n            data: {\n              payload: chunk\n            }\n          });\n          callback();\n        }\n      });\n      const transport = new WebRTCTransport({\n        initiator: request.initiator,\n        stream: duplex,\n        sendSignal: async (signal) => {\n          next({\n            signal: {\n              payload: signal\n            }\n          });\n        }\n      });\n      next({\n        connection: {\n          state: ConnectionState2.CONNECTING\n        }\n      });\n      transport.connected.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CONNECTED\n          }\n        });\n      });\n      transport.errors.handle((err) => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED,\n            error: err.toString()\n          }\n        });\n        close(err);\n      });\n      transport.closed.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED\n          }\n        });\n        close();\n      });\n      ready();\n      this.transports.set(request.proxyId, {\n        transport,\n        stream: duplex\n      });\n    });\n    return rpcStream;\n  }\n  async sendSignal({ proxyId, signal }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).transport.signal(signal);\n  }\n  async sendData({ proxyId, payload }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).stream.push(payload);\n  }\n  async close({ proxyId }) {\n    var _a, _b;\n    await ((_a = this.transports.get(proxyId)) == null ? void 0 : _a.transport.destroy());\n    await ((_b = this.transports.get(proxyId)) == null ? void 0 : _b.stream.end());\n    this.transports.delete(proxyId);\n    log12(\"Closed.\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\",\n      line: 108,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event8 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey10 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState3 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nvar WebRTCTransportProxy = class {\n  constructor(_params) {\n    this._params = _params;\n    this.closed = new Event8();\n    this._closed = false;\n    this.connected = new Event8();\n    this.errors = new ErrorStream5();\n    this._proxyId = PublicKey10.random();\n    this._serviceStream = this._params.bridgeService.open({\n      proxyId: this._proxyId,\n      initiator: this._params.initiator\n    });\n    this._serviceStream.waitUntilReady().then(() => {\n      this._serviceStream.subscribe(async (event) => {\n        log13(\"WebRTCTransportProxy: event\", event, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n          line: 46,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (event.connection) {\n          await this._handleConnection(event.connection);\n        } else if (event.data) {\n          this._handleData(event.data);\n        } else if (event.signal) {\n          await this._handleSignal(event.signal);\n        }\n      });\n      this._params.stream.on(\"data\", async (data) => {\n        try {\n          await this._params.bridgeService.sendData({\n            proxyId: this._proxyId,\n            payload: data\n          });\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n            line: 63,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      });\n    }, (error) => log13.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  async _handleConnection(connectionEvent) {\n    if (connectionEvent.error) {\n      this.errors.raise(new Error(connectionEvent.error));\n    }\n    switch (connectionEvent.state) {\n      case ConnectionState3.CONNECTED: {\n        this.connected.emit();\n        break;\n      }\n      case ConnectionState3.CLOSED: {\n        await this.destroy();\n        break;\n      }\n    }\n  }\n  _handleData(dataEvent) {\n    this._params.stream.write(Buffer.from(dataEvent.payload));\n  }\n  async _handleSignal(signalEvent) {\n    await this._params.sendSignal(signalEvent.payload);\n  }\n  signal(signal) {\n    this._params.bridgeService.sendSignal({\n      proxyId: this._proxyId,\n      signal\n    }).catch((err) => this.errors.raise(err));\n  }\n  async destroy() {\n    if (this._closed) {\n      return;\n    }\n    this._serviceStream.close();\n    try {\n      await this._params.bridgeService.close({\n        proxyId: this._proxyId\n      });\n    } catch (err) {\n      log13.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n        line: 117,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    this._closed = true;\n  }\n  forceClose() {\n    this._serviceStream.close();\n    this.closed.emit();\n    this._closed = true;\n  }\n};\nvar WebRTCTransportProxyFactory = class {\n  constructor() {\n    this._connections = /* @__PURE__ */ new Set();\n  }\n  setBridgeService(bridgeService) {\n    this._bridgeService = bridgeService;\n    for (const connection of this._connections) {\n      connection.forceClose();\n    }\n    return this;\n  }\n  createTransport(options) {\n    assert13(this._bridgeService, \"WebRTCTransportProxyFactory is not ready to open connections\");\n    const transport = new WebRTCTransportProxy({\n      ...options,\n      bridgeService: this._bridgeService\n    });\n    this._connections.add(transport);\n    transport.closed.on(() => this._connections.delete(transport));\n    return transport;\n  }\n};\n\n// packages/core/mesh/network-manager/src/wire-protocol.ts\nimport { discoveryKey as discoveryKey2 } from \"@dxos/crypto\";\nimport { Teleport } from \"@dxos/teleport\";\nvar adaptProtocolProvider = (factory) => ({ initiator, localPeerId, remotePeerId, topic }) => {\n  const protocol = factory({\n    channel: discoveryKey2(topic),\n    initiator\n  });\n  return {\n    initialize: () => protocol.open(),\n    destroy: () => protocol.close(),\n    stream: protocol.stream,\n    protocol\n  };\n};\nvar createTeleportProtocolFactory = (onConnection) => {\n  return (params) => {\n    const teleport = new Teleport(params);\n    return {\n      stream: teleport.stream,\n      initialize: async () => {\n        await teleport.open();\n        await onConnection(teleport);\n      },\n      destroy: async () => {\n        await teleport.close();\n      }\n    };\n  };\n};\nexport {\n  Connection,\n  ConnectionLog,\n  ConnectionState,\n  EventType,\n  FullyConnectedTopology,\n  MMSTTopology,\n  MemoryTransport,\n  MemoryTransportFactory,\n  MessageRouter,\n  NetworkManager,\n  StarTopology,\n  Swarm,\n  SwarmMapper,\n  WebRTCTransport,\n  WebRTCTransportProxy,\n  WebRTCTransportProxyFactory,\n  WebRTCTransportService,\n  adaptProtocolProvider,\n  createProtocolFactory,\n  createTeleportProtocolFactory,\n  createWebRTCTransportFactory,\n  protocolFactory,\n  transportProtocolProvider\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466249,"end":1670465466249,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nimport { Event as Event4 } from \"@dxos/async\";\nimport { raise } from \"@dxos/debug\";\nimport { PublicKey as PublicKey5 } from \"@dxos/keys\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/swarm/connection.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { ErrorStream } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar ConnectionState;\n(function(ConnectionState4) {\n  ConnectionState4[\"INITIAL\"] = \"INITIAL\";\n  ConnectionState4[\"CONNECTING\"] = \"CONNECTING\";\n  ConnectionState4[\"CONNECTED\"] = \"CONNECTED\";\n  ConnectionState4[\"CLOSED\"] = \"CLOSED\";\n})(ConnectionState || (ConnectionState = {}));\nvar Connection = class {\n  constructor(topic, ownId, remoteId, sessionId, initiator, _signalMessaging, _protocol, _transportFactory) {\n    this.topic = topic;\n    this.ownId = ownId;\n    this.remoteId = remoteId;\n    this.sessionId = sessionId;\n    this.initiator = initiator;\n    this._signalMessaging = _signalMessaging;\n    this._protocol = _protocol;\n    this._transportFactory = _transportFactory;\n    this._state = ConnectionState.INITIAL;\n    this._bufferedSignals = [];\n    this.stateChanged = new Event();\n    this.errors = new ErrorStream();\n  }\n  get state() {\n    return this._state;\n  }\n  get transport() {\n    return this._transport;\n  }\n  get protocol() {\n    return this._protocol;\n  }\n  openConnection() {\n    assert(this._state === ConnectionState.INITIAL, \"Invalid state.\");\n    this._changeState(ConnectionState.CONNECTING);\n    this._protocol.initialize().catch((err) => {\n      this.errors.raise(err);\n    });\n    assert(!this._transport);\n    this._transport = this._transportFactory.createTransport({\n      initiator: this.initiator,\n      stream: this._protocol.stream,\n      sendSignal: async (signal) => {\n        await this._signalMessaging.signal({\n          author: this.ownId,\n          recipient: this.remoteId,\n          sessionId: this.sessionId,\n          topic: this.topic,\n          data: {\n            signal\n          }\n        });\n      }\n    });\n    this._transport.connected.once(() => {\n      this._changeState(ConnectionState.CONNECTED);\n    });\n    this._transport.closed.once(() => {\n      this._transport = void 0;\n      this.close().catch((err) => this.errors.raise(err));\n    });\n    this._transport.errors.pipeTo(this.errors);\n    for (const signal of this._bufferedSignals) {\n      void this._transport.signal(signal);\n    }\n    this._bufferedSignals = [];\n  }\n  async close() {\n    var _a;\n    if (this._state === ConnectionState.CLOSED) {\n      return;\n    }\n    log(\"closing...\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 131,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    try {\n      await this._protocol.destroy();\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    try {\n      await ((_a = this._transport) == null ? void 0 : _a.destroy());\n    } catch (err1) {\n      log.catch(err1, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 144,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    log(\"closed\", {\n      peerId: this.ownId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 147,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._changeState(ConnectionState.CLOSED);\n  }\n  async signal(msg) {\n    var _a, _b;\n    assert(msg.sessionId);\n    if (!msg.sessionId.equals(this.sessionId)) {\n      log(\"dropping signal for incorrect session id\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 154,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert(msg.data.signal);\n    assert((_a = msg.author) == null ? void 0 : _a.equals(this.remoteId));\n    assert((_b = msg.recipient) == null ? void 0 : _b.equals(this.ownId));\n    if (this._state === ConnectionState.INITIAL) {\n      log(\"buffered signal\", {\n        peerId: this.ownId,\n        remoteId: this.remoteId,\n        msg: msg.data\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n        line: 162,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._bufferedSignals.push(msg.data.signal);\n      return;\n    }\n    assert(this._transport, \"Connection not ready to accept signals.\");\n    log(\"received signal\", {\n      peerId: this.ownId,\n      remoteId: this.remoteId,\n      msg: msg.data\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/connection.ts\",\n      line: 168,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._transport.signal(msg.data.signal);\n  }\n  _changeState(state) {\n    assert(state !== this._state, \"Already in this state.\");\n    this._state = state;\n    this.stateChanged.emit(state);\n  }\n};\n__decorate([\n  synchronized\n], Connection.prototype, \"close\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask, sleep } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { ErrorStream as ErrorStream2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4, logInfo } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2, isNotNullOrUndefined } from \"@dxos/util\";\n\n// packages/core/mesh/network-manager/src/signal/message-router.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap } from \"@dxos/util\";\nvar MessageRouter = class {\n  constructor({ sendMessage, onSignal, onOffer, topic }) {\n    this._offerRecords = new ComplexMap((key) => key.toHex());\n    this._sendMessage = sendMessage;\n    this._onSignal = onSignal;\n    this._onOffer = onOffer;\n    this._topic = topic;\n  }\n  async receiveMessage({ author, recipient, payload }) {\n    var _a, _b, _c;\n    if (payload.type_url !== \"dxos.mesh.swarm.SwarmMessage\") {\n      return;\n    }\n    const message = schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").decode(payload.value);\n    if (!this._topic.equals(message.topic)) {\n      return;\n    }\n    log2(\"received\", {\n      from: author,\n      to: recipient,\n      msg: message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if ((_a = message.data) == null ? void 0 : _a.offer) {\n      await this._handleOffer({\n        author,\n        recipient,\n        message\n      });\n    } else if ((_b = message.data) == null ? void 0 : _b.answer) {\n      await this._resolveAnswers(message);\n    } else if ((_c = message.data) == null ? void 0 : _c.signal) {\n      await this._handleSignal({\n        author,\n        recipient,\n        message\n      });\n    }\n  }\n  async signal(message) {\n    var _a;\n    assert2((_a = message.data) == null ? void 0 : _a.signal);\n    await this._sendReliableMessage({\n      author: message.author,\n      recipient: message.recipient,\n      message\n    });\n  }\n  async offer(message) {\n    const networkMessage = {\n      ...message,\n      messageId: PublicKey.random()\n    };\n    return new Promise((resolve, reject) => {\n      this._offerRecords.set(networkMessage.messageId, {\n        resolve,\n        reject\n      });\n      return this._sendReliableMessage({\n        author: message.author,\n        recipient: message.recipient,\n        message: networkMessage\n      });\n    });\n  }\n  async _sendReliableMessage({ author, recipient, message }) {\n    var _a;\n    const networkMessage = {\n      ...message,\n      messageId: (_a = message.messageId) != null ? _a : PublicKey.random()\n    };\n    log2(\"sending\", {\n      from: author,\n      to: recipient,\n      msg: networkMessage\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      message: networkMessage\n    });\n  }\n  async _encodeAndSend({ author, recipient, message }) {\n    await this._sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.swarm.SwarmMessage\",\n        value: schema.getCodecForType(\"dxos.mesh.swarm.SwarmMessage\").encode(message)\n      }\n    });\n  }\n  async _resolveAnswers(message) {\n    var _a, _b, _c;\n    assert2((_b = (_a = message.data) == null ? void 0 : _a.answer) == null ? void 0 : _b.offerMessageId, \"No offerMessageId\");\n    const offerRecord = this._offerRecords.get(message.data.answer.offerMessageId);\n    if (offerRecord) {\n      this._offerRecords.delete(message.data.answer.offerMessageId);\n      assert2((_c = message.data) == null ? void 0 : _c.answer, \"No answer\");\n      log2(\"resolving\", {\n        answer: message.data.answer\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/signal/message-router.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      offerRecord.resolve(message.data.answer);\n    }\n  }\n  async _handleOffer({ author, recipient, message }) {\n    assert2(message.data.offer, \"No offer\");\n    const offerMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        offer: message.data.offer\n      }\n    };\n    const answer = await this._onOffer(offerMessage);\n    answer.offerMessageId = message.messageId;\n    await this._sendReliableMessage({\n      author: recipient,\n      recipient: author,\n      message: {\n        topic: message.topic,\n        sessionId: message.sessionId,\n        data: {\n          answer\n        }\n      }\n    });\n  }\n  async _handleSignal({ author, recipient, message }) {\n    assert2(message.messageId);\n    assert2(message.data.signal, \"No Signal\");\n    const signalMessage = {\n      author,\n      recipient,\n      ...message,\n      data: {\n        signal: message.data.signal\n      }\n    };\n    await this._onSignal(signalMessage);\n  }\n};\n\n// packages/core/mesh/network-manager/src/swarm/peer.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log3 } from \"@dxos/log\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Peer = class {\n  constructor(id, topic, localPeerId, _signalMessaging, _protocolProvider, _transportFactory, _callbacks) {\n    this.id = id;\n    this.topic = topic;\n    this.localPeerId = localPeerId;\n    this._signalMessaging = _signalMessaging;\n    this._protocolProvider = _protocolProvider;\n    this._transportFactory = _transportFactory;\n    this._callbacks = _callbacks;\n    this.advertizing = false;\n    this.initiating = false;\n  }\n  async onOffer(message) {\n    const remoteId = message.author;\n    if (this.connection || this.initiating) {\n      if (remoteId.toHex() < this.localPeerId.toHex()) {\n        log3.info(\"closing local connection and accepting remote peer's offer\", {\n          id: this.id,\n          topic: this.topic,\n          peerId: this.localPeerId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (this.connection) {\n          await this.closeConnection();\n        }\n      } else {\n        return {\n          accept: false\n        };\n      }\n    }\n    if (await this._callbacks.onOffer(remoteId)) {\n      if (!this.connection) {\n        assert3(message.sessionId);\n        const connection = this._createConnection(false, message.sessionId);\n        try {\n          connection.openConnection();\n        } catch (err) {\n          log3.warn(\"connection error\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            err\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 107,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await this.closeConnection();\n        }\n        return {\n          accept: true\n        };\n      }\n    }\n    return {\n      accept: false\n    };\n  }\n  async initiateConnection() {\n    assert3(!this.initiating, \"Initiation in progress.\");\n    assert3(!this.connection, \"Already connected.\");\n    const sessionId = PublicKey2.random();\n    log3(\"initiating...\", {\n      id: this.id,\n      topic: this.topic,\n      peerId: this.id,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 125,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const connection = this._createConnection(true, sessionId);\n    this.initiating = true;\n    try {\n      const answer = await this._signalMessaging.offer({\n        author: this.localPeerId,\n        recipient: this.id,\n        sessionId,\n        topic: this.topic,\n        data: {\n          offer: {}\n        }\n      });\n      log3(\"received\", {\n        answer,\n        topic: this.topic,\n        ownId: this.localPeerId,\n        remoteId: this.id\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (connection.state !== ConnectionState.INITIAL) {\n        log3(\"ignoring response\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 139,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      if (!answer.accept) {\n        this._callbacks.onRejected();\n        return;\n      }\n      connection.openConnection();\n      this._callbacks.onAccepted();\n    } catch (err) {\n      log3.warn(\"initiation error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 150,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.closeConnection();\n      throw err;\n    } finally {\n      this.initiating = false;\n    }\n  }\n  _createConnection(initiator, sessionId) {\n    log3(\"creating connection\", {\n      topic: this.topic,\n      peerId: this.localPeerId,\n      remoteId: this.id,\n      initiator,\n      sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 164,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert3(!this.connection, \"Already connected.\");\n    const connection = new Connection(\n      this.topic,\n      this.localPeerId,\n      this.id,\n      sessionId,\n      initiator,\n      this._signalMessaging,\n      this._protocolProvider({\n        initiator,\n        localPeerId: this.localPeerId,\n        remotePeerId: this.id,\n        topic: this.topic\n      }),\n      this._transportFactory\n    );\n    this._callbacks.onInitiated(connection);\n    connection.stateChanged.on((state) => {\n      switch (state) {\n        case ConnectionState.CONNECTED: {\n          this._callbacks.onConnected();\n          break;\n        }\n        case ConnectionState.CLOSED: {\n          log3(\"connection closed\", {\n            topic: this.topic,\n            peerId: this.localPeerId,\n            remoteId: this.id,\n            initiator\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n            line: 193,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          assert3(this.connection === connection, \"Connection mismatch (race condition).\");\n          this.connection = void 0;\n          this._callbacks.onDisconnected();\n          break;\n        }\n      }\n    });\n    connection.errors.handle((err) => {\n      log3.warn(\"connection error\", {\n        topic: this.topic,\n        peerId: this.localPeerId,\n        remoteId: this.id,\n        initiator,\n        err\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 203,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      void this.closeConnection().catch(() => {\n        log3.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n          line: 207,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    });\n    this.connection = connection;\n    return connection;\n  }\n  async closeConnection() {\n    if (!this.connection) {\n      return;\n    }\n    const connection = this.connection;\n    log3(\"closing...\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 221,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await connection.close();\n    log3(\"closed\", {\n      peerId: this.id,\n      sessionId: connection.sessionId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 227,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async onSignal(message) {\n    if (!this.connection) {\n      log3(\"dropping signal message for non-existent connection\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n        line: 232,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    await this.connection.signal(message);\n  }\n  async destroy() {\n    var _a;\n    log3(\"Destroying peer\", {\n      peerId: this.id,\n      topic: this.topic\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/peer.ts\",\n      line: 240,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await ((_a = this == null ? void 0 : this.connection) == null ? void 0 : _a.close());\n  }\n};\n__decorate2([\n  synchronized2\n], Peer.prototype, \"destroy\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm.ts\nvar __decorate3 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar INITIATION_DELAY = 100;\nvar getClassName = (obj) => Object.getPrototypeOf(obj).constructor.name;\nvar Swarm = class {\n  constructor(_topic, _ownPeerId, _topology, _protocolProvider, _messenger, _transportFactory, _label) {\n    this._topic = _topic;\n    this._ownPeerId = _ownPeerId;\n    this._topology = _topology;\n    this._protocolProvider = _protocolProvider;\n    this._messenger = _messenger;\n    this._transportFactory = _transportFactory;\n    this._label = _label;\n    this._peers = new ComplexMap2(PublicKey3.hash);\n    this._ctx = new Context();\n    this.connectionAdded = new Event2();\n    this.disconnected = new Event2();\n    this.connected = new Event2();\n    this.errors = new ErrorStream2();\n    this.instanceId = PublicKey3.random();\n    log4(\"creating swarm\", {\n      peerId: _ownPeerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 80,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    _topology.init(this._getSwarmController());\n    this._swarmMessenger = new MessageRouter({\n      sendMessage: async (msg) => await this._messenger.sendMessage(msg),\n      onSignal: async (msg) => await this.onSignal(msg),\n      onOffer: async (msg) => await this.onOffer(msg),\n      topic: this._topic\n    });\n    this._messenger.listen({\n      peerId: this._ownPeerId,\n      payloadType: \"dxos.mesh.swarm.SwarmMessage\",\n      onMessage: async (message) => await this._swarmMessenger.receiveMessage(message)\n    }).catch((error) => log4.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 96,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get connections() {\n    return Array.from(this._peers.values()).map((peer) => peer.connection).filter(isNotNullOrUndefined);\n  }\n  get ownPeerId() {\n    return this._ownPeerId;\n  }\n  get label() {\n    return this._label;\n  }\n  get topic() {\n    return this._topic;\n  }\n  async destroy() {\n    log4(\"destroying...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 124,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._ctx.dispose();\n    await this._topology.destroy();\n    await Promise.all(Array.from(this._peers.keys()).map((key) => this._destroyPeer(key)));\n    log4(\"destroyed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 128,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async setTopology(topology) {\n    if (topology === this._topology) {\n      return;\n    }\n    log4(\"setting topology\", {\n      previous: getClassName(this._topology),\n      topology: getClassName(topology)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 135,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._topology.destroy();\n    this._topology = topology;\n    this._topology.init(this._getSwarmController());\n    this._topology.update();\n  }\n  _getOrCreatePeer(peerId) {\n    let peer = this._peers.get(peerId);\n    if (!peer) {\n      peer = new Peer(peerId, this._topic, this._ownPeerId, this._swarmMessenger, this._protocolProvider, this._transportFactory, {\n        onInitiated: (connection) => {\n          this.connectionAdded.emit(connection);\n        },\n        onConnected: () => {\n          this.connected.emit(peerId);\n        },\n        onDisconnected: async () => {\n          if (!peer.advertizing) {\n            await this._destroyPeer(peer.id);\n          }\n          this.disconnected.emit(peerId);\n          this._topology.update();\n        },\n        onRejected: () => {\n          if (this._peers.has(peerId)) {\n            void this._destroyPeer(peerId);\n          }\n        },\n        onAccepted: () => {\n          this._topology.update();\n        },\n        onOffer: (remoteId) => {\n          return this._topology.onOffer(remoteId);\n        }\n      });\n      this._peers.set(peerId, peer);\n    }\n    return peer;\n  }\n  async _destroyPeer(peerId) {\n    assert4(this._peers.has(peerId));\n    await this._peers.get(peerId).destroy();\n    this._peers.delete(peerId);\n  }\n  onSwarmEvent(swarmEvent) {\n    log4(\"swarm event\", {\n      swarmEvent\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 199,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.warn(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 201,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    if (swarmEvent.peerAvailable) {\n      const peerId = PublicKey3.from(swarmEvent.peerAvailable.peer);\n      log4(\"new peer\", {\n        peerId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 207,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (!peerId.equals(this._ownPeerId)) {\n        const peer = this._getOrCreatePeer(peerId);\n        peer.advertizing = true;\n      }\n    } else if (swarmEvent.peerLeft) {\n      const peer1 = this._peers.get(PublicKey3.from(swarmEvent.peerLeft.peer));\n      if (peer1) {\n        peer1.advertizing = false;\n        if (!peer1.connection) {\n          void this._destroyPeer(peer1.id);\n        }\n      }\n    }\n    this._topology.update();\n  }\n  async onOffer(message) {\n    var _a, _b;\n    log4(\"offer\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 226,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 228,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    assert4(message.author);\n    if (!((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId))) {\n      log4(\"rejecting offer with incorrect peerId\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 235,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    if (!((_b = message.topic) == null ? void 0 : _b.equals(this._topic))) {\n      log4(\"rejecting offer with incorrect topic\", {\n        message\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 239,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return {\n        accept: false\n      };\n    }\n    const peer = this._getOrCreatePeer(message.author);\n    const answer = await peer.onOffer(message);\n    this._topology.update();\n    return answer;\n  }\n  async onSignal(message) {\n    var _a, _b;\n    log4(\"signal\", {\n      message\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 250,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._ctx.disposed) {\n      log4.info(\"ignored for destroyed swarm\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 252,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    assert4((_a = message.recipient) == null ? void 0 : _a.equals(this._ownPeerId), `Invalid signal peer id expected=${this.ownPeerId}, actual=${message.recipient}`);\n    assert4((_b = message.topic) == null ? void 0 : _b.equals(this._topic));\n    assert4(message.author);\n    const peer = this._getOrCreatePeer(message.author);\n    await peer.onSignal(message);\n  }\n  _getSwarmController() {\n    return {\n      getState: () => ({\n        ownPeerId: this._ownPeerId,\n        connected: Array.from(this._peers.values()).filter((peer) => peer.connection).map((peer) => peer.id),\n        candidates: Array.from(this._peers.values()).filter((peer) => !peer.connection && peer.advertizing).map((peer) => peer.id)\n      }),\n      connect: (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          try {\n            await this._initiateConnection(peer);\n          } catch (err) {\n            log4.warn(\"initiation error\", err, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n              line: 287,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n          }\n        });\n      },\n      disconnect: async (peer) => {\n        if (this._ctx.disposed) {\n          return;\n        }\n        scheduleTask(this._ctx, async () => {\n          await this._closeConnection(peer);\n          this._topology.update();\n        });\n      }\n    };\n  }\n  async _initiateConnection(remoteId) {\n    if (remoteId.toHex() < this._ownPeerId.toHex()) {\n      log4(\"initiation delay\", {\n        remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n        line: 312,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await sleep(INITIATION_DELAY);\n    }\n    if (this._ctx.disposed) {\n      return;\n    }\n    const peer = this._getOrCreatePeer(remoteId);\n    if (peer.connection) {\n      return;\n    }\n    log4(\"initiating connection...\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 326,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await peer.initiateConnection();\n    this._topology.update();\n    log4(\"initiated\", {\n      remoteId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm.ts\",\n      line: 329,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async _closeConnection(peerId) {\n    const peer = this._peers.get(peerId);\n    if (!peer) {\n      return;\n    }\n    await peer.closeConnection();\n  }\n};\n__decorate3([\n  logInfo\n], Swarm.prototype, \"instanceId\", void 0);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"ownPeerId\", null);\n__decorate3([\n  logInfo\n], Swarm.prototype, \"topic\", null);\n\n// packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\nimport { Event as Event3, EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\nvar SwarmMapper = class {\n  get peers() {\n    return Array.from(this._peers.values());\n  }\n  constructor(_swarm, _presence) {\n    this._swarm = _swarm;\n    this._presence = _presence;\n    this._subscriptions = new EventSubscriptions();\n    this._connectionSubscriptions = new ComplexMap3(PublicKey4.hash);\n    this._peers = new ComplexMap3(PublicKey4.hash);\n    this.mapUpdated = new Event3();\n    this._subscriptions.add(_swarm.connectionAdded.on((connection) => {\n      this._update();\n      this._connectionSubscriptions.set(connection.remoteId, connection.stateChanged.on(() => {\n        this._update();\n      }));\n    }));\n    this._subscriptions.add(_swarm.disconnected.on((peerId) => {\n      var _a;\n      (_a = this._connectionSubscriptions.get(peerId)) == null ? void 0 : _a();\n      this._connectionSubscriptions.delete(peerId);\n      this._update();\n    }));\n    if (_presence) {\n      this._subscriptions.add(_presence.graphUpdated.on(() => {\n        this._update();\n      }));\n    }\n    this._update();\n  }\n  _update() {\n    log5(\"updating swarm\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 77,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peers.clear();\n    this._peers.set(this._swarm.ownPeerId, {\n      id: this._swarm.ownPeerId,\n      state: \"ME\",\n      connections: []\n    });\n    for (const connection of this._swarm.connections) {\n      this._peers.set(connection.remoteId, {\n        id: connection.remoteId,\n        state: connection.state,\n        connections: [\n          this._swarm.ownPeerId\n        ]\n      });\n    }\n    if (this._presence) {\n      this._presence.graph.forEachNode((node) => {\n        const id = PublicKey4.fromHex(node.id);\n        if (this._peers.has(id)) {\n          return;\n        }\n        this._peers.set(id, {\n          id,\n          state: \"INDIRECTLY_CONNECTED\",\n          connections: []\n        });\n      });\n      this._presence.graph.forEachLink((link) => {\n        const from = PublicKey4.from(link.fromId);\n        const to = PublicKey4.from(link.toId);\n        if (!from.equals(this._swarm.ownPeerId) && !to.equals(this._swarm.ownPeerId)) {\n          this._peers.get(from).connections.push(to);\n        }\n      });\n    }\n    log5(\"graph changed\", {\n      directConnections: this._swarm.connections.length,\n      totalPeersInSwarm: this._peers.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/swarm/swarm-mapper.ts\",\n      line: 118,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.mapUpdated.emit(Array.from(this._peers.values()));\n  }\n  destroy() {\n    Array.from(this._connectionSubscriptions.values()).forEach((cb) => cb());\n    this._subscriptions.clear();\n  }\n};\n\n// packages/core/mesh/network-manager/src/connection-log.ts\nvar EventType;\n(function(EventType2) {\n  EventType2[\"CONNECTION_STATE_CHANGED\"] = \"CONNECTION_STATE_CHANGED\";\n  EventType2[\"PROTOCOL_ERROR\"] = \"PROTOCOL_ERROR\";\n  EventType2[\"PROTOCOL_EXTENSIONS_INITIALIZED\"] = \"PROTOCOL_EXTENSIONS_INITIALIZED\";\n  EventType2[\"PROTOCOL_EXTENSIONS_HANDSHAKE\"] = \"PROTOCOL_EXTENSIONS_HANDSHAKE\";\n  EventType2[\"PROTOCOL_HANDSHAKE\"] = \"PROTOCOL_HANDSHAKE\";\n})(EventType || (EventType = {}));\nvar ConnectionLog = class {\n  constructor() {\n    this._swarms = new ComplexMap4(PublicKey5.hash);\n    this.update = new Event4();\n  }\n  getSwarmInfo(swarmId) {\n    var _a;\n    return (_a = this._swarms.get(swarmId)) != null ? _a : raise(new Error(`Swarm not found: ${swarmId}`));\n  }\n  get swarms() {\n    return Array.from(this._swarms.values());\n  }\n  swarmJoined(swarm) {\n    const info = {\n      id: swarm.instanceId,\n      topic: swarm.topic,\n      isActive: true,\n      label: swarm.label,\n      connections: []\n    };\n    this._swarms.set(swarm.instanceId, info);\n    this.update.emit();\n    swarm.connectionAdded.on((connection) => {\n      var _a, _b, _c, _d, _e;\n      const connectionInfo = {\n        state: ConnectionState.INITIAL,\n        remotePeerId: connection.remoteId,\n        sessionId: connection.sessionId,\n        transport: connection.transport && Object.getPrototypeOf(connection.transport).constructor.name,\n        protocolExtensions: (_a = connection.protocol.protocol) == null ? void 0 : _a.extensionNames,\n        events: []\n      };\n      info.connections.push(connectionInfo);\n      this.update.emit();\n      connection.stateChanged.on((state) => {\n        connectionInfo.state = state;\n        connectionInfo.events.push({\n          type: EventType.CONNECTION_STATE_CHANGED,\n          newState: state\n        });\n        this.update.emit();\n      });\n      (_b = connection.protocol.protocol) == null ? void 0 : _b.error.on((error) => {\n        var _a2;\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_ERROR,\n          error: (_a2 = error.stack) != null ? _a2 : error.message\n        });\n        this.update.emit();\n      });\n      (_c = connection.protocol.protocol) == null ? void 0 : _c.extensionsInitialized.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_INITIALIZED\n        });\n        this.update.emit();\n      });\n      (_d = connection.protocol.protocol) == null ? void 0 : _d.extensionsHandshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_EXTENSIONS_HANDSHAKE\n        });\n        this.update.emit();\n      });\n      (_e = connection.protocol.protocol) == null ? void 0 : _e.handshake.on(() => {\n        connectionInfo.events.push({\n          type: EventType.PROTOCOL_HANDSHAKE\n        });\n        this.update.emit();\n      });\n    });\n  }\n  swarmLeft(swarm) {\n    this.getSwarmInfo(swarm.instanceId).isActive = false;\n    this.update.emit();\n  }\n};\n\n// packages/core/mesh/network-manager/src/network-manager.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event5 } from \"@dxos/async\";\nimport { PublicKey as PublicKey6 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { Messenger } from \"@dxos/messaging\";\nimport { ComplexMap as ComplexMap5 } from \"@dxos/util\";\nvar NetworkManager = class {\n  constructor({ transportFactory, signalManager, log: log14 }) {\n    this._swarms = new ComplexMap5(PublicKey6.hash);\n    this._mappers = new ComplexMap5(PublicKey6.hash);\n    this.topicsUpdated = new Event5();\n    this._transportFactory = transportFactory;\n    this._signalManager = signalManager;\n    this._signalManager.swarmEvent.on(({ topic, swarmEvent: event }) => {\n      var _a;\n      return (_a = this._swarms.get(topic)) == null ? void 0 : _a.onSwarmEvent(event);\n    });\n    this._messenger = new Messenger({\n      signalManager: this._signalManager\n    });\n    this._signalConnection = {\n      join: (opts) => this._signalManager.join(opts),\n      leave: (opts) => this._signalManager.leave(opts)\n    };\n    if (log14) {\n      this._connectionLog = new ConnectionLog();\n    }\n  }\n  get connectionLog() {\n    return this._connectionLog;\n  }\n  get signalManager() {\n    return this._signalManager;\n  }\n  get topics() {\n    return Array.from(this._swarms.keys());\n  }\n  getSwarmMap(topic) {\n    return this._mappers.get(topic);\n  }\n  getSwarm(topic) {\n    return this._swarms.get(topic);\n  }\n  async close() {\n    for (const topic of this._swarms.keys()) {\n      await this.leaveSwarm(topic).catch((err) => {\n        log6(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n          line: 128,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      });\n    }\n    await this._signalManager.destroy();\n  }\n  async joinSwarm({ topic, peerId, topology, protocolProvider: protocol, presence, label }) {\n    var _a;\n    assert5(PublicKey6.isPublicKey(topic));\n    assert5(PublicKey6.isPublicKey(peerId));\n    assert5(topology);\n    assert5(typeof protocol === \"function\");\n    if (this._swarms.has(topic)) {\n      throw new Error(`Already connected to swarm: ${PublicKey6.from(topic)}`);\n    }\n    log6(\"joining\", {\n      topic: PublicKey6.from(topic),\n      peerId,\n      topology: topology.toString()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 155,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = new Swarm(topic, peerId, topology, protocol, this._messenger, this._transportFactory, label);\n    swarm.errors.handle((error) => {\n      log6(\"swarm error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 158,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._swarms.set(topic, swarm);\n    this._signalConnection.join({\n      topic,\n      peerId\n    }).catch((error) => log6.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 162,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n    this._mappers.set(topic, new SwarmMapper(swarm, presence));\n    this.topicsUpdated.emit();\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmJoined(swarm);\n    log6(\"joined\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 167,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return {\n      close: () => this.leaveSwarm(topic)\n    };\n  }\n  async leaveSwarm(topic) {\n    var _a;\n    if (!this._swarms.has(topic)) {\n      log6.warn(\"swarm not open\", {\n        topic: PublicKey6.from(topic)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n        line: 179,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    log6(\"leaving\", {\n      topic: PublicKey6.from(topic)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const swarm = this._swarms.get(topic);\n    await this._signalConnection.leave({\n      topic,\n      peerId: swarm.ownPeerId\n    });\n    const map = this._mappers.get(topic);\n    map.destroy();\n    this._mappers.delete(topic);\n    (_a = this._connectionLog) == null ? void 0 : _a.swarmLeft(swarm);\n    await swarm.destroy();\n    this._swarms.delete(topic);\n    await this.topicsUpdated.emit();\n    log6(\"left\", {\n      topic: PublicKey6.from(topic),\n      count: this._swarms.size\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/network-manager.ts\",\n      line: 197,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/protocol-factory.ts\nimport assert6 from \"@dxos/node-std/assert\";\nimport { discoveryKey } from \"@dxos/crypto\";\nimport { PublicKey as PublicKey7 } from \"@dxos/keys\";\nimport { log as log7 } from \"@dxos/log\";\nimport { Protocol } from \"@dxos/mesh-protocol\";\nvar protocolFactory = ({ session = {}, plugins = [], getTopics }) => {\n  assert6(getTopics);\n  return ({ channel, initiator }) => {\n    log7(\"creating protocol\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/protocol-factory.ts\",\n      line: 41,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    const protocol = new Protocol({\n      streamOptions: {\n        live: true\n      },\n      discoveryToPublicKey: (dk) => {\n        const publicKey = getTopics().find((topic) => discoveryKey(topic).equals(dk));\n        if (publicKey) {\n          protocol.setContext({\n            topic: PublicKey7.stringify(publicKey)\n          });\n        }\n        assert6(publicKey, \"PublicKey not found in discovery.\");\n        return publicKey;\n      },\n      initiator,\n      userSession: session,\n      discoveryKey: channel\n    });\n    protocol.setExtensions(plugins.map((plugin) => plugin.createExtension())).init();\n    return protocol;\n  };\n};\nvar createProtocolFactory = (topic, peerId, plugins) => protocolFactory({\n  getTopics: () => [\n    topic.asBuffer()\n  ],\n  session: {\n    peerId: PublicKey7.stringify(peerId.asBuffer())\n  },\n  plugins\n});\nvar transportProtocolProvider = (rendezvousKey, peerId, protocolPlugin) => {\n  return protocolFactory({\n    getTopics: () => [\n      rendezvousKey\n    ],\n    session: {\n      peerId: PublicKey7.stringify(peerId)\n    },\n    plugins: [\n      protocolPlugin\n    ]\n  });\n};\n\n// packages/core/mesh/network-manager/src/topology/fully-connected-topology.ts\nimport assert7 from \"@dxos/node-std/assert\";\nvar FullyConnectedTopology = class {\n  toString() {\n    return \"FullyConnectedTopology\";\n  }\n  init(controller) {\n    assert7(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert7(this._controller, \"Not initialized\");\n    const { candidates: discovered } = this._controller.getState();\n    for (const peer of discovered) {\n      this._controller.connect(peer);\n    }\n  }\n  async onOffer(peer) {\n    return true;\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/topology/mmst-topology.ts\nimport assert8 from \"@dxos/node-std/assert\";\nimport distance from \"xor-distance\";\nimport { log as log8 } from \"@dxos/log\";\nvar MMSTTopology = class {\n  constructor({ originateConnections = 2, maxPeers = 4, sampleSize = 10 } = {}) {\n    this._sampleCollected = false;\n    this._originateConnections = originateConnections;\n    this._maxPeers = maxPeers;\n    this._sampleSize = sampleSize;\n  }\n  init(controller) {\n    assert8(!this._controller, \"Already initialized\");\n    this._controller = controller;\n  }\n  update() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates } = this._controller.getState();\n    if (this._sampleCollected || connected.length > this._maxPeers || candidates.length > 0) {\n      log8(\"Running the algorithm.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._sampleCollected = true;\n      this._runAlgorithm();\n    }\n  }\n  async onOffer(peer) {\n    assert8(this._controller, \"Not initialized\");\n    const { connected } = this._controller.getState();\n    const accept = connected.length < this._maxPeers;\n    log8(`Offer ${peer} accept=${accept}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return accept;\n  }\n  async destroy() {\n  }\n  _runAlgorithm() {\n    assert8(this._controller, \"Not initialized\");\n    const { connected, candidates, ownPeerId } = this._controller.getState();\n    if (connected.length > this._maxPeers) {\n      const sorted = sortByXorDistance(connected, ownPeerId).reverse().slice(0, this._maxPeers - connected.length);\n      for (const peer of sorted) {\n        log8(`Disconnect ${peer}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 83,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.disconnect(peer);\n      }\n    } else if (connected.length < this._originateConnections) {\n      const sample = candidates.sort(() => Math.random() - 0.5).slice(0, this._sampleSize);\n      const sorted1 = sortByXorDistance(sample, ownPeerId).slice(0, this._originateConnections - connected.length);\n      for (const peer1 of sorted1) {\n        log8(`Connect ${peer1}.`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/mmst-topology.ts\",\n          line: 91,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  toString() {\n    return \"MMSTTopology\";\n  }\n};\nvar sortByXorDistance = (keys, reference) => keys.sort((a, b) => distance.gt(distance(a.asBuffer(), reference.asBuffer()), distance(b.asBuffer(), reference.asBuffer())));\n\n// packages/core/mesh/network-manager/src/topology/star-topology.ts\nimport assert9 from \"@dxos/node-std/assert\";\nimport { log as log9 } from \"@dxos/log\";\nvar StarTopology = class {\n  constructor(_centralPeer) {\n    this._centralPeer = _centralPeer;\n  }\n  toString() {\n    return `StarTopology(${this._centralPeer.truncate()})`;\n  }\n  init(controller) {\n    assert9(!this._controller, \"Already initialized.\");\n    this._controller = controller;\n  }\n  update() {\n    assert9(this._controller, \"Not initialized.\");\n    const { candidates, connected, ownPeerId } = this._controller.getState();\n    if (!ownPeerId.equals(this._centralPeer)) {\n      log9(\"leaf peer dropping all connections apart from central peer.\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n        line: 33,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      for (const peer of connected) {\n        if (!peer.equals(this._centralPeer)) {\n          log9(\"dropping connection\", {\n            peer\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n            line: 38,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._controller.disconnect(peer);\n        }\n      }\n    }\n    for (const peer1 of candidates) {\n      if (peer1.equals(this._centralPeer) || ownPeerId.equals(this._centralPeer)) {\n        log9(\"connecting to peer\", {\n          peer: peer1\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n          line: 47,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._controller.connect(peer1);\n      }\n    }\n  }\n  async onOffer(peer) {\n    assert9(this._controller, \"Not initialized.\");\n    const { ownPeerId } = this._controller.getState();\n    log9(\"offer\", {\n      peer,\n      isCentral: peer.equals(this._centralPeer),\n      isSelfCentral: ownPeerId.equals(this._centralPeer)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/topology/star-topology.ts\",\n      line: 56,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return ownPeerId.equals(this._centralPeer) || peer.equals(this._centralPeer);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/memory-transport.ts\nimport assert10 from \"@dxos/node-std/assert\";\nimport { Transform } from \"@dxos/node-std/stream\";\nimport { Event as Event6, Trigger } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream3 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey8 } from \"@dxos/keys\";\nimport { log as log10 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap6 } from \"@dxos/util\";\nvar MEMORY_TRANSPORT_DELAY = 1;\nvar createStreamDelay = (delay) => {\n  return new Transform({\n    objectMode: true,\n    transform: (chunk, _, cb) => {\n      setTimeout(() => cb(null, chunk), delay);\n    }\n  });\n};\nvar MemoryTransportFactory = {\n  createTransport: (params) => new MemoryTransport(params)\n};\nvar _MemoryTransport = class {\n  constructor(options) {\n    var _a;\n    this.options = options;\n    this.closed = new Event6();\n    this.connected = new Event6();\n    this.errors = new ErrorStream3();\n    this._id = PublicKey8.random();\n    this._remote = new Trigger();\n    this._outgoingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._incomingDelay = createStreamDelay(MEMORY_TRANSPORT_DELAY);\n    this._destroyed = false;\n    log10(\"creating\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 59,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert10(!_MemoryTransport._connections.has(this._id), \"Duplicate memory connection\");\n    _MemoryTransport._connections.set(this._id, this);\n    if (this.options.initiator) {\n      setTimeout(async () => {\n        log10(\"sending signal\", {\n          transportId: this._id\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 68,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        void this.options.sendSignal({\n          payload: {\n            transportId: this._id.toHex()\n          }\n        });\n      });\n    } else {\n      this._remote.wait({\n        timeout: (_a = this.options.timeout) != null ? _a : 1e3\n      }).then((remoteId) => {\n        if (this._destroyed) {\n          return;\n        }\n        this._remoteId = remoteId;\n        this._remoteConnection = _MemoryTransport._connections.get(this._remoteId);\n        if (!this._remoteConnection) {\n          this._destroyed = true;\n          this.closed.emit();\n          return;\n        }\n        assert10(!this._remoteConnection._remoteConnection, new Error(`Remote already connected: ${this._remoteId}`));\n        this._remoteConnection._remoteConnection = this;\n        this._remoteConnection._remoteId = this._id;\n        log10(\"connected\", {\n          id: this._id,\n          remote: this._remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 94,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.options.stream.pipe(this._outgoingDelay).pipe(this._remoteConnection.options.stream).pipe(this._incomingDelay).pipe(this.options.stream);\n        this.connected.emit();\n        this._remoteConnection.connected.emit();\n      }).catch((err) => {\n        if (this._destroyed) {\n          return;\n        }\n        this.errors.raise(err);\n      });\n    }\n  }\n  async destroy() {\n    log10(\"closing\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._destroyed = true;\n    _MemoryTransport._connections.delete(this._id);\n    if (this._remoteConnection) {\n      log10(\"closing\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 120,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._remoteConnection._destroyed = true;\n      _MemoryTransport._connections.delete(this._remoteId);\n      this._outgoingDelay.unpipe();\n      this._incomingDelay.unpipe();\n      this._remoteConnection.closed.emit();\n      this._remoteConnection._remoteConnection = void 0;\n      this._remoteConnection = void 0;\n      log10(\"closed\", {\n        id: this._remoteId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n        line: 138,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    log10(\"closed\", {\n      id: this._id\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    const { payload: json } = signal;\n    if (json && json.transportId) {\n      const transportId = json.transportId;\n      if (transportId) {\n        const remoteId = PublicKey8.fromHex(transportId);\n        log10(\"received signal\", {\n          id: this._id,\n          remoteId\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/memory-transport.ts\",\n          line: 152,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._remote.wake(remoteId);\n      }\n    }\n  }\n};\nvar MemoryTransport = _MemoryTransport;\nMemoryTransport._connections = new ComplexMap6(PublicKey8.hash);\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nimport assert11 from \"@dxos/node-std/assert\";\nimport SimplePeerConstructor from \"simple-peer\";\nimport { Event as Event7 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream4, raise as raise2 } from \"@dxos/debug\";\nimport { log as log11 } from \"@dxos/log\";\n\n// packages/core/mesh/network-manager/src/transport/webrtc.ts\nvar wrtc = null;\ntry {\n  wrtc = __require(\"@koush/wrtc\");\n} catch (e) {\n}\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\nvar WebRTCTransport = class {\n  constructor(params) {\n    var _a;\n    this.params = params;\n    this.closed = new Event7();\n    this.connected = new Event7();\n    this.errors = new ErrorStream4();\n    log11(\"created connection\", params, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 34,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._peer = new SimplePeerConstructor({\n      initiator: this.params.initiator,\n      wrtc: SimplePeerConstructor.WEBRTC_SUPPORT ? void 0 : (_a = wrtc) != null ? _a : raise2(new Error(\"wrtc not available\")),\n      config: this.params.webrtcConfig\n    });\n    this._peer.on(\"signal\", async (data) => {\n      log11(\"signal\", data, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 42,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.params.sendSignal({\n        payload: {\n          data\n        }\n      });\n    });\n    this._peer.on(\"connect\", () => {\n      log11(\"connected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.params.stream.pipe(this._peer).pipe(this.params.stream);\n      this.connected.emit();\n    });\n    this._peer.on(\"close\", async () => {\n      log11(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n        line: 53,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._disconnectStreams();\n      this.closed.emit();\n    });\n    this._peer.on(\"error\", async (err) => {\n      this.errors.raise(err);\n      await this.destroy();\n    });\n  }\n  async destroy() {\n    log11(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 65,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._disconnectStreams();\n    this._peer.destroy();\n    this.closed.emit();\n    log11(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport.ts\",\n      line: 69,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  signal(signal) {\n    assert11(this._peer, \"Connection not ready to accept signals.\");\n    assert11(signal.payload.data, \"Signal message must contain signal data.\");\n    this._peer.signal(signal.payload.data);\n  }\n  async _disconnectStreams() {\n    var _a, _b, _c, _d;\n    (_d = (_c = (_b = (_a = this.params.stream).unpipe) == null ? void 0 : _b.call(_a, this._peer)) == null ? void 0 : _c.unpipe) == null ? void 0 : _d.call(_c, this.params.stream);\n  }\n};\nvar createWebRTCTransportFactory = (webrtcConfig) => ({\n  createTransport: (params) => new WebRTCTransport({\n    ...params,\n    webrtcConfig\n  })\n});\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\nimport assert12 from \"@dxos/node-std/assert\";\nimport { Duplex } from \"@dxos/node-std/stream\";\nimport { Stream } from \"@dxos/codec-protobuf\";\nimport { PublicKey as PublicKey9 } from \"@dxos/keys\";\nimport { log as log12 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState2 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nimport { ComplexMap as ComplexMap7 } from \"@dxos/util\";\nvar WebRTCTransportService = class {\n  constructor(_webrtcConfig) {\n    this._webrtcConfig = _webrtcConfig;\n    this.transports = new ComplexMap7(PublicKey9.hash);\n  }\n  open(request) {\n    const rpcStream = new Stream(({ ready, next, close }) => {\n      const duplex = new Duplex({\n        read: () => {\n        },\n        write: function(chunk, _, callback) {\n          next({\n            data: {\n              payload: chunk\n            }\n          });\n          callback();\n        }\n      });\n      const transport = new WebRTCTransport({\n        initiator: request.initiator,\n        stream: duplex,\n        sendSignal: async (signal) => {\n          next({\n            signal: {\n              payload: signal\n            }\n          });\n        }\n      });\n      next({\n        connection: {\n          state: ConnectionState2.CONNECTING\n        }\n      });\n      transport.connected.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CONNECTED\n          }\n        });\n      });\n      transport.errors.handle((err) => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED,\n            error: err.toString()\n          }\n        });\n        close(err);\n      });\n      transport.closed.on(() => {\n        next({\n          connection: {\n            state: ConnectionState2.CLOSED\n          }\n        });\n        close();\n      });\n      ready();\n      this.transports.set(request.proxyId, {\n        transport,\n        stream: duplex\n      });\n    });\n    return rpcStream;\n  }\n  async sendSignal({ proxyId, signal }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).transport.signal(signal);\n  }\n  async sendData({ proxyId, payload }) {\n    assert12(this.transports.has(proxyId));\n    await this.transports.get(proxyId).stream.push(payload);\n  }\n  async close({ proxyId }) {\n    var _a, _b;\n    await ((_a = this.transports.get(proxyId)) == null ? void 0 : _a.transport.destroy());\n    await ((_b = this.transports.get(proxyId)) == null ? void 0 : _b.stream.end());\n    this.transports.delete(proxyId);\n    log12(\"Closed.\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-service.ts\",\n      line: 108,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\nimport assert13 from \"@dxos/node-std/assert\";\nimport { Event as Event8 } from \"@dxos/async\";\nimport { ErrorStream as ErrorStream5 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey10 } from \"@dxos/keys\";\nimport { log as log13 } from \"@dxos/log\";\nimport { ConnectionState as ConnectionState3 } from \"@dxos/protocols/proto/dxos/mesh/bridge\";\nvar WebRTCTransportProxy = class {\n  constructor(_params) {\n    this._params = _params;\n    this.closed = new Event8();\n    this._closed = false;\n    this.connected = new Event8();\n    this.errors = new ErrorStream5();\n    this._proxyId = PublicKey10.random();\n    this._serviceStream = this._params.bridgeService.open({\n      proxyId: this._proxyId,\n      initiator: this._params.initiator\n    });\n    this._serviceStream.waitUntilReady().then(() => {\n      this._serviceStream.subscribe(async (event) => {\n        log13(\"WebRTCTransportProxy: event\", event, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n          line: 46,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        if (event.connection) {\n          await this._handleConnection(event.connection);\n        } else if (event.data) {\n          this._handleData(event.data);\n        } else if (event.signal) {\n          await this._handleSignal(event.signal);\n        }\n      });\n      this._params.stream.on(\"data\", async (data) => {\n        try {\n          await this._params.bridgeService.sendData({\n            proxyId: this._proxyId,\n            payload: data\n          });\n        } catch (err) {\n          log13.catch(err, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n            line: 63,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      });\n    }, (error) => log13.catch(error, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n      line: 67,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  async _handleConnection(connectionEvent) {\n    if (connectionEvent.error) {\n      this.errors.raise(new Error(connectionEvent.error));\n    }\n    switch (connectionEvent.state) {\n      case ConnectionState3.CONNECTED: {\n        this.connected.emit();\n        break;\n      }\n      case ConnectionState3.CLOSED: {\n        await this.destroy();\n        break;\n      }\n    }\n  }\n  _handleData(dataEvent) {\n    this._params.stream.write(Buffer.from(dataEvent.payload));\n  }\n  async _handleSignal(signalEvent) {\n    await this._params.sendSignal(signalEvent.payload);\n  }\n  signal(signal) {\n    this._params.bridgeService.sendSignal({\n      proxyId: this._proxyId,\n      signal\n    }).catch((err) => this.errors.raise(err));\n  }\n  async destroy() {\n    if (this._closed) {\n      return;\n    }\n    this._serviceStream.close();\n    try {\n      await this._params.bridgeService.close({\n        proxyId: this._proxyId\n      });\n    } catch (err) {\n      log13.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/network-manager/src/transport/webrtc-transport-proxy.ts\",\n        line: 117,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n    this.closed.emit();\n    this._closed = true;\n  }\n  forceClose() {\n    this._serviceStream.close();\n    this.closed.emit();\n    this._closed = true;\n  }\n};\nvar WebRTCTransportProxyFactory = class {\n  constructor() {\n    this._connections = /* @__PURE__ */ new Set();\n  }\n  setBridgeService(bridgeService) {\n    this._bridgeService = bridgeService;\n    for (const connection of this._connections) {\n      connection.forceClose();\n    }\n    return this;\n  }\n  createTransport(options) {\n    assert13(this._bridgeService, \"WebRTCTransportProxyFactory is not ready to open connections\");\n    const transport = new WebRTCTransportProxy({\n      ...options,\n      bridgeService: this._bridgeService\n    });\n    this._connections.add(transport);\n    transport.closed.on(() => this._connections.delete(transport));\n    return transport;\n  }\n};\n\n// packages/core/mesh/network-manager/src/wire-protocol.ts\nimport { discoveryKey as discoveryKey2 } from \"@dxos/crypto\";\nimport { Teleport } from \"@dxos/teleport\";\nvar adaptProtocolProvider = (factory) => ({ initiator, localPeerId, remotePeerId, topic }) => {\n  const protocol = factory({\n    channel: discoveryKey2(topic),\n    initiator\n  });\n  return {\n    initialize: () => protocol.open(),\n    destroy: () => protocol.close(),\n    stream: protocol.stream,\n    protocol\n  };\n};\nvar createTeleportProtocolFactory = (onConnection) => {\n  return (params) => {\n    const teleport = new Teleport(params);\n    return {\n      stream: teleport.stream,\n      initialize: async () => {\n        await teleport.open();\n        await onConnection(teleport);\n      },\n      destroy: async () => {\n        await teleport.close();\n      }\n    };\n  };\n};\nexport {\n  Connection,\n  ConnectionLog,\n  ConnectionState,\n  EventType,\n  FullyConnectedTopology,\n  MMSTTopology,\n  MemoryTransport,\n  MemoryTransportFactory,\n  MessageRouter,\n  NetworkManager,\n  StarTopology,\n  Swarm,\n  SwarmMapper,\n  WebRTCTransport,\n  WebRTCTransportProxy,\n  WebRTCTransportProxyFactory,\n  WebRTCTransportService,\n  adaptProtocolProvider,\n  createProtocolFactory,\n  createTeleportProtocolFactory,\n  createWebRTCTransportFactory,\n  protocolFactory,\n  transportProtocolProvider\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466249,"end":1670465466272,"order":"normal"}]}
