{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/mesh-protocol/src/protocol.ts\nimport eos from \"end-of-stream\";\nimport ProtocolStream from \"hypercore-protocol\";\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\n\n// packages/core/mesh/mesh-protocol/src/errors.ts\nimport nanoerror from \"nanoerror\";\nvar ERR_PROTOCOL_STREAM_CLOSED = nanoerror(\"ERR_PROTOCOL_STREAM_CLOSED\", \"protocol closed\");\nvar ERR_PROTOCOL_INIT_INVALID = nanoerror(\"ERR_PROTOCOL_INIT_INVALID\", \"protocol initialization invalid\");\nvar ERR_PROTOCOL_HANDSHAKE_FAILED = nanoerror(\"ERR_PROTOCOL_HANDSHAKE_FAILED\", \"protocol handshake failed: %s\");\nvar ERR_PROTOCOL_CONNECTION_INVALID = nanoerror(\"ERR_PROTOCOL_CONNECTION_INVALID\", \"cannot establish connection: %s\");\nvar ERR_PROTOCOL_EXTENSION_MISSING = nanoerror(\"ERR_PROTOCOL_EXTENSION_MISSING\", \"extension missing: %s\");\nvar ERR_EXTENSION_INIT_FAILED = nanoerror(\"ERR_EXTENSION_INIT_FAILED\", \"extension init failed: %s\");\nvar ERR_EXTENSION_HANDSHAKE_FAILED = nanoerror(\"ERR_EXTENSION_HANDSHAKE_FAILED\", \"extension handshake failed: %s\");\nvar ERR_EXTENSION_FEED_FAILED = nanoerror(\"ERR_EXTENSION_FEED_FAILED\", \"extension feed failed: %s\");\nvar ERR_EXTENSION_CLOSE_FAILED = nanoerror(\"ERR_EXTENSION_CLOSE_FAILED\", \"extension close failed: %s\");\nvar ERR_EXTENSION_RESPONSE_TIMEOUT = nanoerror(\"ERR_EXTENSION_RESPONSE_TIMEOUT\", \"%s\");\nvar ERR_EXTENSION_RESPONSE_FAILED = class extends nanoerror(\"ERR_EXTENSION_RESPONSE_FAILED\", \"[extension: %s] [responseCode: %s] [message: %s]\") {\n  constructor(extension, responseCode, responseMessage) {\n    super(extension, responseCode, responseMessage);\n    this.extension = extension;\n    this.responseCode = responseCode;\n    this.responseMessage = responseMessage;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport Signal from \"signal-promise\";\nimport { Trigger } from \"@dxos/async\";\n\n// packages/core/mesh/mesh-protocol/src/extension.ts\nimport { Nanomessage, errors as nanomessageErrors } from \"nanomessage\";\nimport assert from \"@dxos/node-std/assert\";\nimport { patchBufferCodec } from \"@dxos/codec-protobuf\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar { NMSG_ERR_TIMEOUT } = nanomessageErrors;\nvar kCodec = Symbol(\"nanomessage.codec\");\nvar Extension = class extends Nanomessage {\n  constructor(name, { schema: userSchema, ...nmOptions } = {}) {\n    super(nmOptions);\n    this._protocol = null;\n    this._protocolExtension = null;\n    this._initHandler = null;\n    this._handshakeHandler = null;\n    this._closeHandler = null;\n    this._messageHandler = null;\n    this._feedHandler = null;\n    this._subscribeCb = null;\n    assert(name.length > 0, \"name is required.\");\n    this._name = name;\n    const codec = schema.getCodecForType(\"dxos.mesh.protocol.Message\");\n    if (userSchema) {\n      codec.addJson(userSchema);\n    }\n    this[kCodec] = patchBufferCodec(codec);\n    this.on(\"error\", (err) => log.warn(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get name() {\n    return this._name;\n  }\n  setInitHandler(initHandler) {\n    this._initHandler = initHandler;\n    return this;\n  }\n  setHandshakeHandler(handshakeHandler) {\n    this._handshakeHandler = handshakeHandler;\n    return this;\n  }\n  setCloseHandler(closeHandler) {\n    this._closeHandler = closeHandler;\n    return this;\n  }\n  setMessageHandler(messageHandler) {\n    this._messageHandler = messageHandler;\n    return this;\n  }\n  setFeedHandler(feedHandler) {\n    this._feedHandler = feedHandler;\n    return this;\n  }\n  async openWithProtocol(protocol) {\n    assert(!this._protocol);\n    log(\"open\", {\n      name: this._name,\n      id: PublicKey.from(protocol.id)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 157,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._protocol = protocol;\n    this._protocolExtension = this._protocol.stream.registerExtension(this.name, {\n      onmessage: async (msg) => {\n        var _a;\n        try {\n          await ((_a = this._subscribeCb) == null ? void 0 : _a.call(this, msg));\n        } catch (err) {\n          log.error(\"failed to execute subscribe callback on message\", {\n            name: this._name,\n            id: PublicKey.from(protocol.id)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n            line: 165,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this.open();\n  }\n  async onInit() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._initHandler) {\n        await this._initHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_INIT_FAILED.from(err);\n    }\n  }\n  async onHandshake() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._handshakeHandler) {\n        await this._handshakeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_HANDSHAKE_FAILED.from(err);\n    }\n  }\n  async onFeed(discoveryKey) {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._feedHandler) {\n        await this._feedHandler(this._protocol, discoveryKey);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_FEED_FAILED.from(err);\n    }\n  }\n  async send(message, options = {}) {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    const builtMessage = buildMessage(message);\n    if (options.oneway) {\n      return super.send(builtMessage);\n    }\n    try {\n      const response = await this.request(builtMessage);\n      if (response && response.code && response.message) {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, response.code, response.message);\n      }\n      return {\n        response\n      };\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      if (ERR_EXTENSION_RESPONSE_FAILED.equals(err)) {\n        throw err;\n      } else if (NMSG_ERR_TIMEOUT.equals(err)) {\n        throw ERR_EXTENSION_RESPONSE_TIMEOUT.from(err);\n      } else {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      }\n    }\n  }\n  _subscribe(next) {\n    this._subscribeCb = next;\n  }\n  async _open() {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    assert(this._protocol);\n    await super._open();\n  }\n  async _close() {\n    try {\n      await super._close();\n      if (this._closeHandler) {\n        assert(this._protocol);\n        await this._closeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_CLOSE_FAILED.from(err);\n    }\n  }\n  async _send(msg) {\n    assert(this._protocol);\n    assert(this._protocolExtension);\n    if (this._protocol.stream.destroyed) {\n      return;\n    }\n    this._protocolExtension.send(msg);\n  }\n  async _onMessage(msg) {\n    try {\n      await this.open();\n      if (this._messageHandler) {\n        assert(this._protocol);\n        const result = await this._messageHandler(this._protocol, msg);\n        return buildMessage(result);\n      }\n    } catch (err) {\n      this.emit(\"error\", err);\n      const responseError = new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      return {\n        \"@type\": \"dxos.mesh.protocol.Error\",\n        code: responseError.responseCode,\n        message: responseError.responseMessage\n      };\n    }\n  }\n};\nvar buildMessage = (message) => {\n  if (typeof message === \"string\") {\n    return buildMessage(Buffer.from(message));\n  } else if (Buffer.isBuffer(message)) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else if (message instanceof Uint8Array) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: Buffer.from(message)\n    };\n  } else if (message == null) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else {\n    assert(message[\"@type\"], \"Message does not have a type URL.\");\n    return message;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nvar ExtensionInit = class extends Extension {\n  constructor(options = {}) {\n    super(\"dxos.mesh.protocol.init\", options);\n    this._remoteInit = null;\n    this.userSession = null;\n    this.remoteUserSession = null;\n    this._sessionTrigger = new Trigger();\n    this._timeout = options.timeout;\n    this._remoteInit = null;\n    this._remoteSignal = new Signal();\n    this.setMessageHandler(async (protocol, message) => {\n      const { data } = message;\n      assert2(data);\n      const messageObj = JSON.parse(Buffer.from(data).toString());\n      switch (messageObj.command) {\n        case \"continue\":\n          this._remoteInit = true;\n          this._remoteSignal.notify();\n          break;\n        case \"break\":\n          this._remoteInit = false;\n          this._remoteSignal.notify();\n          break;\n        case \"session\":\n          this.remoteUserSession = messageObj.data;\n          this._sessionTrigger.wake();\n      }\n    });\n    this.setCloseHandler(async () => {\n      this._remoteInit = false;\n      this._remoteSignal.notify();\n    });\n  }\n  async sendCommand(command, data) {\n    if (data == null ? void 0 : data.peerId) {\n      assert2([\n        \"undefined\",\n        \"string\"\n      ].includes(typeof data.peerId), \"PeerId must be a string.\");\n    }\n    return this.send(Buffer.from(JSON.stringify({\n      command,\n      data\n    })));\n  }\n  async sendSession(userSession) {\n    void this.sendCommand(\"session\", userSession).catch((err) => {\n      this.emit(\"error\", err);\n    });\n    await this._sessionTrigger.wait();\n  }\n  async continue() {\n    try {\n      await this.sendCommand(\"continue\");\n      if (this._remoteInit !== null) {\n        if (this._remoteInit) {\n          return;\n        } else {\n          throw new Error(\"Connection closed during handshake.\");\n        }\n      }\n      await this._remoteSignal.wait(this._timeout);\n      if (!this._remoteInit) {\n        throw new Error(\"Connection closed during handshake.\");\n      }\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      throw new ERR_PROTOCOL_INIT_INVALID(err.message);\n    }\n  }\n  async break() {\n    try {\n      if (this._remoteInit === false) {\n        return;\n      }\n      await this.sendCommand(\"break\");\n    } catch (err) {\n    }\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/utils.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { humanize } from \"@dxos/util\";\nvar keyToHuman = (key, prefix) => {\n  assert3(Buffer.isBuffer(key));\n  const name = humanize(key.toString(\"hex\"));\n  if (prefix) {\n    return `${prefix}(${name})`;\n  }\n  return name;\n};\n\n// packages/core/mesh/mesh-protocol/src/protocol.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar kProtocol = Symbol(\"dxos.mesh.protocol\");\nvar getProtocolFromStream = (stream) => {\n  assert4(typeof stream === \"object\" && typeof stream.pipe === \"function\", \"stream is required\");\n  return stream[kProtocol];\n};\nvar Protocol = class {\n  constructor(options = {\n    initiator: false\n  }) {\n    this._isOpen = false;\n    this.error = new Event();\n    this.extensionsInitialized = new Event();\n    this.extensionsHandshake = new Event();\n    this.handshake = new Event();\n    this._extensionMap = /* @__PURE__ */ new Map();\n    this._init = false;\n    this._connected = false;\n    this._handshakes = [];\n    this._channel = void 0;\n    this._context = {};\n    this._extensionHandler = (name, message) => {\n      if (name === this._extensionInit.name) {\n        this._extensionInit.emit(\"extension-message\", message);\n        return;\n      }\n      const extension = this._extensionMap.get(name);\n      if (!extension) {\n        this._handleError(new ERR_PROTOCOL_EXTENSION_MISSING(name));\n        return;\n      }\n      extension.emit(\"extension-message\", message);\n    };\n    const { discoveryToPublicKey = (key) => key, streamOptions, initTimeout = 5 * 1e3 } = options;\n    this._discoveryToPublicKey = discoveryToPublicKey;\n    this._streamOptions = streamOptions;\n    this._initTimeout = initTimeout;\n    this._discoveryKey = options.discoveryKey;\n    this._initiator = !!options.initiator;\n    this._stream = new ProtocolStream(this._initiator, {\n      ...this._streamOptions,\n      onhandshake: async () => {\n        var _a, _b;\n        try {\n          await this.open();\n          await this._initExtensions(options.userSession);\n          this.extensionsInitialized.emit();\n          await ((_b = (_a = this.streamOptions) == null ? void 0 : _a.onhandshake) == null ? void 0 : _b.call(_a, this));\n          await this._handshakeExtensions();\n          this.extensionsHandshake.emit();\n        } catch (err) {\n          if (err.message.includes(\"NMSG_ERR_CLOSE\")) {\n            this._stream.destroy();\n            return;\n          }\n          this._handleError(err);\n        }\n      }\n    });\n    this._stream[kProtocol] = this;\n    this._stream.on(\"error\", (err) => this.error.emit(err));\n    this.error.on((err) => {\n      log2.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._extensionInit = new ExtensionInit({\n      timeout: this._initTimeout\n    });\n  }\n  toString() {\n    const meta = {\n      id: keyToHuman(this._stream.publicKey),\n      extensions: this.extensionNames\n    };\n    return `Protocol(${JSON.stringify(meta)})`;\n  }\n  get id() {\n    return this._stream.publicKey;\n  }\n  get stream() {\n    return this._stream;\n  }\n  get channel() {\n    return this._channel;\n  }\n  get extensions() {\n    return Array.from(this._extensionMap.values());\n  }\n  get extensionNames() {\n    return Array.from(this._extensionMap.keys());\n  }\n  get streamOptions() {\n    return Object.assign({}, this._streamOptions, {\n      id: this._stream.publicKey\n    });\n  }\n  get connected() {\n    return this._connected;\n  }\n  get initiator() {\n    return this._initiator;\n  }\n  getSession() {\n    try {\n      return this._extensionInit.remoteUserSession;\n    } catch (err) {\n      return null;\n    }\n  }\n  setContext(context) {\n    this._context = Object.assign({}, context);\n    return this;\n  }\n  getContext() {\n    return this._context;\n  }\n  setExtension(extension) {\n    assert4(extension);\n    this._extensionMap.set(extension.name, extension);\n    return this;\n  }\n  setExtensions(extensions) {\n    extensions.forEach((extension) => this.setExtension(extension));\n    return this;\n  }\n  getExtension(name) {\n    return this._extensionMap.get(name);\n  }\n  setHandshakeHandler(handler) {\n    this._handshakes.push(async (protocol) => {\n      try {\n        await handler(protocol);\n      } catch (err) {\n        throw new ERR_PROTOCOL_HANDSHAKE_FAILED(err.message);\n      }\n    });\n    return this;\n  }\n  init() {\n    assert4(!this._init);\n    this._init = true;\n    this.open().catch((err) => this._handleError(err));\n    log2(\"initialized\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 268,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return this;\n  }\n  async open() {\n    if (this._isOpen) {\n      return;\n    }\n    log2(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 278,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._openExtensions();\n    eos(this._stream, async () => {\n      await this.close();\n    });\n    log2(\"open\", {\n      key: PublicKey2.from(this._stream.publicKey)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 284,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._isOpen = true;\n  }\n  async close() {\n    if (!this._isOpen) {\n      return;\n    }\n    log2(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 294,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connected = false;\n    this._stream.finalize();\n    await this._extensionInit.close().catch((err) => {\n      this._handleError(err);\n    });\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"close extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 302,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.close().catch((err) => {\n        this._handleError(err);\n      });\n    }\n    this._isOpen = false;\n    log2(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 309,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async waitForHandshake() {\n    await Promise.race([\n      this.handshake.waitForCount(1),\n      this.error.waitForCount(1).then((err) => Promise.reject(err))\n    ]);\n  }\n  async _openExtensions() {\n    await this._extensionInit.openWithProtocol(this);\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"open extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 320,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.openWithProtocol(this);\n    }\n  }\n  async _initExtensions(userSession) {\n    try {\n      await this._extensionInit.sendSession(userSession);\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"init extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 331,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onInit();\n      }\n      await this._extensionInit.continue();\n    } catch (err) {\n      await this._extensionInit.break();\n      throw err;\n    }\n  }\n  async _handshakeExtensions() {\n    try {\n      for (const handshake of this._handshakes) {\n        await handshake(this);\n      }\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"handshake extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 353,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onHandshake();\n      }\n    } catch (err) {\n      if (this._stream.destroyed) {\n        log2.warn(\"handshake\", err, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 362,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      } else {\n        log2.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 364,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this.handshake.emit(this);\n    this._connected = true;\n    this._stream.on(\"feed\", async (discoveryKey) => {\n      try {\n        for (const [name, extension] of this._extensionMap) {\n          log2(\"handshake feed\", {\n            name,\n            key: PublicKey2.from(this._stream.publicKey),\n            remote: PublicKey2.from(this._stream.remotePublicKey)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n            line: 374,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await extension.onFeed(discoveryKey);\n        }\n      } catch (err) {\n        this._handleError(err);\n      }\n    });\n  }\n  _openConnection() {\n    let initialKey = null;\n    const openChannel = (discoveryKey) => {\n      var _a;\n      try {\n        initialKey = (_a = this._discoveryToPublicKey) == null ? void 0 : _a.call(this, discoveryKey);\n        if (!initialKey) {\n          throw new ERR_PROTOCOL_CONNECTION_INVALID(\"Key not found\");\n        }\n        this._channel = this._stream.open(initialKey, {\n          onextension: this._extensionHandler\n        });\n      } catch (err) {\n        let newErr = err;\n        if (!ERR_PROTOCOL_CONNECTION_INVALID.equals(newErr)) {\n          newErr = ERR_PROTOCOL_CONNECTION_INVALID.from(newErr);\n        }\n        this._handleError(newErr);\n      }\n    };\n    if (this._discoveryKey) {\n      openChannel(this._discoveryKey);\n    } else {\n      this._stream.once(\"feed\", openChannel);\n    }\n  }\n  _handleError(err) {\n    log2.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 440,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    process.nextTick(() => this._stream.destroy(err));\n  }\n};\n__decorate([\n  synchronized\n], Protocol.prototype, \"open\", null);\n__decorate([\n  synchronized\n], Protocol.prototype, \"close\", null);\n\n// packages/core/mesh/mesh-protocol/src/testing/util.ts\nimport pump from \"pump\";\nimport { createPromiseFromCallback } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nvar pipeProtocols = (a, b) => createPromiseFromCallback((cb) => pump(a.stream, b.stream, a.stream, cb));\nvar createTestProtocolPair = (extensions1, extensions2) => {\n  const discoveryKey = PublicKey3.random();\n  const protocol1 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: true,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user1\"\n    }\n  }).setExtensions(extensions1).init();\n  const protocol2 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: false,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user2\"\n    }\n  }).setExtensions(extensions2).init();\n  void pipeProtocols(protocol1, protocol2);\n};\nexport {\n  ERR_EXTENSION_CLOSE_FAILED,\n  ERR_EXTENSION_FEED_FAILED,\n  ERR_EXTENSION_HANDSHAKE_FAILED,\n  ERR_EXTENSION_INIT_FAILED,\n  ERR_EXTENSION_RESPONSE_FAILED,\n  ERR_EXTENSION_RESPONSE_TIMEOUT,\n  ERR_PROTOCOL_CONNECTION_INVALID,\n  ERR_PROTOCOL_EXTENSION_MISSING,\n  ERR_PROTOCOL_HANDSHAKE_FAILED,\n  ERR_PROTOCOL_INIT_INVALID,\n  ERR_PROTOCOL_STREAM_CLOSED,\n  Extension,\n  Protocol,\n  createTestProtocolPair,\n  getProtocolFromStream,\n  pipeProtocols\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466965,"end":1670465467012},{"name":"vite:react-babel","result":"// packages/core/mesh/mesh-protocol/src/protocol.ts\nimport eos from \"end-of-stream\";\nimport ProtocolStream from \"hypercore-protocol\";\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\n\n// packages/core/mesh/mesh-protocol/src/errors.ts\nimport nanoerror from \"nanoerror\";\nvar ERR_PROTOCOL_STREAM_CLOSED = nanoerror(\"ERR_PROTOCOL_STREAM_CLOSED\", \"protocol closed\");\nvar ERR_PROTOCOL_INIT_INVALID = nanoerror(\"ERR_PROTOCOL_INIT_INVALID\", \"protocol initialization invalid\");\nvar ERR_PROTOCOL_HANDSHAKE_FAILED = nanoerror(\"ERR_PROTOCOL_HANDSHAKE_FAILED\", \"protocol handshake failed: %s\");\nvar ERR_PROTOCOL_CONNECTION_INVALID = nanoerror(\"ERR_PROTOCOL_CONNECTION_INVALID\", \"cannot establish connection: %s\");\nvar ERR_PROTOCOL_EXTENSION_MISSING = nanoerror(\"ERR_PROTOCOL_EXTENSION_MISSING\", \"extension missing: %s\");\nvar ERR_EXTENSION_INIT_FAILED = nanoerror(\"ERR_EXTENSION_INIT_FAILED\", \"extension init failed: %s\");\nvar ERR_EXTENSION_HANDSHAKE_FAILED = nanoerror(\"ERR_EXTENSION_HANDSHAKE_FAILED\", \"extension handshake failed: %s\");\nvar ERR_EXTENSION_FEED_FAILED = nanoerror(\"ERR_EXTENSION_FEED_FAILED\", \"extension feed failed: %s\");\nvar ERR_EXTENSION_CLOSE_FAILED = nanoerror(\"ERR_EXTENSION_CLOSE_FAILED\", \"extension close failed: %s\");\nvar ERR_EXTENSION_RESPONSE_TIMEOUT = nanoerror(\"ERR_EXTENSION_RESPONSE_TIMEOUT\", \"%s\");\nvar ERR_EXTENSION_RESPONSE_FAILED = class extends nanoerror(\"ERR_EXTENSION_RESPONSE_FAILED\", \"[extension: %s] [responseCode: %s] [message: %s]\") {\n  constructor(extension, responseCode, responseMessage) {\n    super(extension, responseCode, responseMessage);\n    this.extension = extension;\n    this.responseCode = responseCode;\n    this.responseMessage = responseMessage;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport Signal from \"signal-promise\";\nimport { Trigger } from \"@dxos/async\";\n\n// packages/core/mesh/mesh-protocol/src/extension.ts\nimport { Nanomessage, errors as nanomessageErrors } from \"nanomessage\";\nimport assert from \"@dxos/node-std/assert\";\nimport { patchBufferCodec } from \"@dxos/codec-protobuf\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar { NMSG_ERR_TIMEOUT } = nanomessageErrors;\nvar kCodec = Symbol(\"nanomessage.codec\");\nvar Extension = class extends Nanomessage {\n  constructor(name, { schema: userSchema, ...nmOptions } = {}) {\n    super(nmOptions);\n    this._protocol = null;\n    this._protocolExtension = null;\n    this._initHandler = null;\n    this._handshakeHandler = null;\n    this._closeHandler = null;\n    this._messageHandler = null;\n    this._feedHandler = null;\n    this._subscribeCb = null;\n    assert(name.length > 0, \"name is required.\");\n    this._name = name;\n    const codec = schema.getCodecForType(\"dxos.mesh.protocol.Message\");\n    if (userSchema) {\n      codec.addJson(userSchema);\n    }\n    this[kCodec] = patchBufferCodec(codec);\n    this.on(\"error\", (err) => log.warn(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get name() {\n    return this._name;\n  }\n  setInitHandler(initHandler) {\n    this._initHandler = initHandler;\n    return this;\n  }\n  setHandshakeHandler(handshakeHandler) {\n    this._handshakeHandler = handshakeHandler;\n    return this;\n  }\n  setCloseHandler(closeHandler) {\n    this._closeHandler = closeHandler;\n    return this;\n  }\n  setMessageHandler(messageHandler) {\n    this._messageHandler = messageHandler;\n    return this;\n  }\n  setFeedHandler(feedHandler) {\n    this._feedHandler = feedHandler;\n    return this;\n  }\n  async openWithProtocol(protocol) {\n    assert(!this._protocol);\n    log(\"open\", {\n      name: this._name,\n      id: PublicKey.from(protocol.id)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 157,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._protocol = protocol;\n    this._protocolExtension = this._protocol.stream.registerExtension(this.name, {\n      onmessage: async (msg) => {\n        var _a;\n        try {\n          await ((_a = this._subscribeCb) == null ? void 0 : _a.call(this, msg));\n        } catch (err) {\n          log.error(\"failed to execute subscribe callback on message\", {\n            name: this._name,\n            id: PublicKey.from(protocol.id)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n            line: 165,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this.open();\n  }\n  async onInit() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._initHandler) {\n        await this._initHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_INIT_FAILED.from(err);\n    }\n  }\n  async onHandshake() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._handshakeHandler) {\n        await this._handshakeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_HANDSHAKE_FAILED.from(err);\n    }\n  }\n  async onFeed(discoveryKey) {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._feedHandler) {\n        await this._feedHandler(this._protocol, discoveryKey);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_FEED_FAILED.from(err);\n    }\n  }\n  async send(message, options = {}) {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    const builtMessage = buildMessage(message);\n    if (options.oneway) {\n      return super.send(builtMessage);\n    }\n    try {\n      const response = await this.request(builtMessage);\n      if (response && response.code && response.message) {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, response.code, response.message);\n      }\n      return {\n        response\n      };\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      if (ERR_EXTENSION_RESPONSE_FAILED.equals(err)) {\n        throw err;\n      } else if (NMSG_ERR_TIMEOUT.equals(err)) {\n        throw ERR_EXTENSION_RESPONSE_TIMEOUT.from(err);\n      } else {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      }\n    }\n  }\n  _subscribe(next) {\n    this._subscribeCb = next;\n  }\n  async _open() {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    assert(this._protocol);\n    await super._open();\n  }\n  async _close() {\n    try {\n      await super._close();\n      if (this._closeHandler) {\n        assert(this._protocol);\n        await this._closeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_CLOSE_FAILED.from(err);\n    }\n  }\n  async _send(msg) {\n    assert(this._protocol);\n    assert(this._protocolExtension);\n    if (this._protocol.stream.destroyed) {\n      return;\n    }\n    this._protocolExtension.send(msg);\n  }\n  async _onMessage(msg) {\n    try {\n      await this.open();\n      if (this._messageHandler) {\n        assert(this._protocol);\n        const result = await this._messageHandler(this._protocol, msg);\n        return buildMessage(result);\n      }\n    } catch (err) {\n      this.emit(\"error\", err);\n      const responseError = new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      return {\n        \"@type\": \"dxos.mesh.protocol.Error\",\n        code: responseError.responseCode,\n        message: responseError.responseMessage\n      };\n    }\n  }\n};\nvar buildMessage = (message) => {\n  if (typeof message === \"string\") {\n    return buildMessage(Buffer.from(message));\n  } else if (Buffer.isBuffer(message)) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else if (message instanceof Uint8Array) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: Buffer.from(message)\n    };\n  } else if (message == null) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else {\n    assert(message[\"@type\"], \"Message does not have a type URL.\");\n    return message;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nvar ExtensionInit = class extends Extension {\n  constructor(options = {}) {\n    super(\"dxos.mesh.protocol.init\", options);\n    this._remoteInit = null;\n    this.userSession = null;\n    this.remoteUserSession = null;\n    this._sessionTrigger = new Trigger();\n    this._timeout = options.timeout;\n    this._remoteInit = null;\n    this._remoteSignal = new Signal();\n    this.setMessageHandler(async (protocol, message) => {\n      const { data } = message;\n      assert2(data);\n      const messageObj = JSON.parse(Buffer.from(data).toString());\n      switch (messageObj.command) {\n        case \"continue\":\n          this._remoteInit = true;\n          this._remoteSignal.notify();\n          break;\n        case \"break\":\n          this._remoteInit = false;\n          this._remoteSignal.notify();\n          break;\n        case \"session\":\n          this.remoteUserSession = messageObj.data;\n          this._sessionTrigger.wake();\n      }\n    });\n    this.setCloseHandler(async () => {\n      this._remoteInit = false;\n      this._remoteSignal.notify();\n    });\n  }\n  async sendCommand(command, data) {\n    if (data == null ? void 0 : data.peerId) {\n      assert2([\n        \"undefined\",\n        \"string\"\n      ].includes(typeof data.peerId), \"PeerId must be a string.\");\n    }\n    return this.send(Buffer.from(JSON.stringify({\n      command,\n      data\n    })));\n  }\n  async sendSession(userSession) {\n    void this.sendCommand(\"session\", userSession).catch((err) => {\n      this.emit(\"error\", err);\n    });\n    await this._sessionTrigger.wait();\n  }\n  async continue() {\n    try {\n      await this.sendCommand(\"continue\");\n      if (this._remoteInit !== null) {\n        if (this._remoteInit) {\n          return;\n        } else {\n          throw new Error(\"Connection closed during handshake.\");\n        }\n      }\n      await this._remoteSignal.wait(this._timeout);\n      if (!this._remoteInit) {\n        throw new Error(\"Connection closed during handshake.\");\n      }\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      throw new ERR_PROTOCOL_INIT_INVALID(err.message);\n    }\n  }\n  async break() {\n    try {\n      if (this._remoteInit === false) {\n        return;\n      }\n      await this.sendCommand(\"break\");\n    } catch (err) {\n    }\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/utils.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { humanize } from \"@dxos/util\";\nvar keyToHuman = (key, prefix) => {\n  assert3(Buffer.isBuffer(key));\n  const name = humanize(key.toString(\"hex\"));\n  if (prefix) {\n    return `${prefix}(${name})`;\n  }\n  return name;\n};\n\n// packages/core/mesh/mesh-protocol/src/protocol.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar kProtocol = Symbol(\"dxos.mesh.protocol\");\nvar getProtocolFromStream = (stream) => {\n  assert4(typeof stream === \"object\" && typeof stream.pipe === \"function\", \"stream is required\");\n  return stream[kProtocol];\n};\nvar Protocol = class {\n  constructor(options = {\n    initiator: false\n  }) {\n    this._isOpen = false;\n    this.error = new Event();\n    this.extensionsInitialized = new Event();\n    this.extensionsHandshake = new Event();\n    this.handshake = new Event();\n    this._extensionMap = /* @__PURE__ */ new Map();\n    this._init = false;\n    this._connected = false;\n    this._handshakes = [];\n    this._channel = void 0;\n    this._context = {};\n    this._extensionHandler = (name, message) => {\n      if (name === this._extensionInit.name) {\n        this._extensionInit.emit(\"extension-message\", message);\n        return;\n      }\n      const extension = this._extensionMap.get(name);\n      if (!extension) {\n        this._handleError(new ERR_PROTOCOL_EXTENSION_MISSING(name));\n        return;\n      }\n      extension.emit(\"extension-message\", message);\n    };\n    const { discoveryToPublicKey = (key) => key, streamOptions, initTimeout = 5 * 1e3 } = options;\n    this._discoveryToPublicKey = discoveryToPublicKey;\n    this._streamOptions = streamOptions;\n    this._initTimeout = initTimeout;\n    this._discoveryKey = options.discoveryKey;\n    this._initiator = !!options.initiator;\n    this._stream = new ProtocolStream(this._initiator, {\n      ...this._streamOptions,\n      onhandshake: async () => {\n        var _a, _b;\n        try {\n          await this.open();\n          await this._initExtensions(options.userSession);\n          this.extensionsInitialized.emit();\n          await ((_b = (_a = this.streamOptions) == null ? void 0 : _a.onhandshake) == null ? void 0 : _b.call(_a, this));\n          await this._handshakeExtensions();\n          this.extensionsHandshake.emit();\n        } catch (err) {\n          if (err.message.includes(\"NMSG_ERR_CLOSE\")) {\n            this._stream.destroy();\n            return;\n          }\n          this._handleError(err);\n        }\n      }\n    });\n    this._stream[kProtocol] = this;\n    this._stream.on(\"error\", (err) => this.error.emit(err));\n    this.error.on((err) => {\n      log2.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._extensionInit = new ExtensionInit({\n      timeout: this._initTimeout\n    });\n  }\n  toString() {\n    const meta = {\n      id: keyToHuman(this._stream.publicKey),\n      extensions: this.extensionNames\n    };\n    return `Protocol(${JSON.stringify(meta)})`;\n  }\n  get id() {\n    return this._stream.publicKey;\n  }\n  get stream() {\n    return this._stream;\n  }\n  get channel() {\n    return this._channel;\n  }\n  get extensions() {\n    return Array.from(this._extensionMap.values());\n  }\n  get extensionNames() {\n    return Array.from(this._extensionMap.keys());\n  }\n  get streamOptions() {\n    return Object.assign({}, this._streamOptions, {\n      id: this._stream.publicKey\n    });\n  }\n  get connected() {\n    return this._connected;\n  }\n  get initiator() {\n    return this._initiator;\n  }\n  getSession() {\n    try {\n      return this._extensionInit.remoteUserSession;\n    } catch (err) {\n      return null;\n    }\n  }\n  setContext(context) {\n    this._context = Object.assign({}, context);\n    return this;\n  }\n  getContext() {\n    return this._context;\n  }\n  setExtension(extension) {\n    assert4(extension);\n    this._extensionMap.set(extension.name, extension);\n    return this;\n  }\n  setExtensions(extensions) {\n    extensions.forEach((extension) => this.setExtension(extension));\n    return this;\n  }\n  getExtension(name) {\n    return this._extensionMap.get(name);\n  }\n  setHandshakeHandler(handler) {\n    this._handshakes.push(async (protocol) => {\n      try {\n        await handler(protocol);\n      } catch (err) {\n        throw new ERR_PROTOCOL_HANDSHAKE_FAILED(err.message);\n      }\n    });\n    return this;\n  }\n  init() {\n    assert4(!this._init);\n    this._init = true;\n    this.open().catch((err) => this._handleError(err));\n    log2(\"initialized\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 268,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return this;\n  }\n  async open() {\n    if (this._isOpen) {\n      return;\n    }\n    log2(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 278,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._openExtensions();\n    eos(this._stream, async () => {\n      await this.close();\n    });\n    log2(\"open\", {\n      key: PublicKey2.from(this._stream.publicKey)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 284,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._isOpen = true;\n  }\n  async close() {\n    if (!this._isOpen) {\n      return;\n    }\n    log2(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 294,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connected = false;\n    this._stream.finalize();\n    await this._extensionInit.close().catch((err) => {\n      this._handleError(err);\n    });\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"close extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 302,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.close().catch((err) => {\n        this._handleError(err);\n      });\n    }\n    this._isOpen = false;\n    log2(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 309,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async waitForHandshake() {\n    await Promise.race([\n      this.handshake.waitForCount(1),\n      this.error.waitForCount(1).then((err) => Promise.reject(err))\n    ]);\n  }\n  async _openExtensions() {\n    await this._extensionInit.openWithProtocol(this);\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"open extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 320,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.openWithProtocol(this);\n    }\n  }\n  async _initExtensions(userSession) {\n    try {\n      await this._extensionInit.sendSession(userSession);\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"init extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 331,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onInit();\n      }\n      await this._extensionInit.continue();\n    } catch (err) {\n      await this._extensionInit.break();\n      throw err;\n    }\n  }\n  async _handshakeExtensions() {\n    try {\n      for (const handshake of this._handshakes) {\n        await handshake(this);\n      }\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"handshake extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 353,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onHandshake();\n      }\n    } catch (err) {\n      if (this._stream.destroyed) {\n        log2.warn(\"handshake\", err, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 362,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      } else {\n        log2.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 364,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this.handshake.emit(this);\n    this._connected = true;\n    this._stream.on(\"feed\", async (discoveryKey) => {\n      try {\n        for (const [name, extension] of this._extensionMap) {\n          log2(\"handshake feed\", {\n            name,\n            key: PublicKey2.from(this._stream.publicKey),\n            remote: PublicKey2.from(this._stream.remotePublicKey)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n            line: 374,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await extension.onFeed(discoveryKey);\n        }\n      } catch (err) {\n        this._handleError(err);\n      }\n    });\n  }\n  _openConnection() {\n    let initialKey = null;\n    const openChannel = (discoveryKey) => {\n      var _a;\n      try {\n        initialKey = (_a = this._discoveryToPublicKey) == null ? void 0 : _a.call(this, discoveryKey);\n        if (!initialKey) {\n          throw new ERR_PROTOCOL_CONNECTION_INVALID(\"Key not found\");\n        }\n        this._channel = this._stream.open(initialKey, {\n          onextension: this._extensionHandler\n        });\n      } catch (err) {\n        let newErr = err;\n        if (!ERR_PROTOCOL_CONNECTION_INVALID.equals(newErr)) {\n          newErr = ERR_PROTOCOL_CONNECTION_INVALID.from(newErr);\n        }\n        this._handleError(newErr);\n      }\n    };\n    if (this._discoveryKey) {\n      openChannel(this._discoveryKey);\n    } else {\n      this._stream.once(\"feed\", openChannel);\n    }\n  }\n  _handleError(err) {\n    log2.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 440,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    process.nextTick(() => this._stream.destroy(err));\n  }\n};\n__decorate([\n  synchronized\n], Protocol.prototype, \"open\", null);\n__decorate([\n  synchronized\n], Protocol.prototype, \"close\", null);\n\n// packages/core/mesh/mesh-protocol/src/testing/util.ts\nimport pump from \"pump\";\nimport { createPromiseFromCallback } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nvar pipeProtocols = (a, b) => createPromiseFromCallback((cb) => pump(a.stream, b.stream, a.stream, cb));\nvar createTestProtocolPair = (extensions1, extensions2) => {\n  const discoveryKey = PublicKey3.random();\n  const protocol1 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: true,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user1\"\n    }\n  }).setExtensions(extensions1).init();\n  const protocol2 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: false,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user2\"\n    }\n  }).setExtensions(extensions2).init();\n  void pipeProtocols(protocol1, protocol2);\n};\nexport {\n  ERR_EXTENSION_CLOSE_FAILED,\n  ERR_EXTENSION_FEED_FAILED,\n  ERR_EXTENSION_HANDSHAKE_FAILED,\n  ERR_EXTENSION_INIT_FAILED,\n  ERR_EXTENSION_RESPONSE_FAILED,\n  ERR_EXTENSION_RESPONSE_TIMEOUT,\n  ERR_PROTOCOL_CONNECTION_INVALID,\n  ERR_PROTOCOL_EXTENSION_MISSING,\n  ERR_PROTOCOL_HANDSHAKE_FAILED,\n  ERR_PROTOCOL_INIT_INVALID,\n  ERR_PROTOCOL_STREAM_CLOSED,\n  Extension,\n  Protocol,\n  createTestProtocolPair,\n  getProtocolFromStream,\n  pipeProtocols\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467012,"end":1670465467012,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport { default as process } from '\u0000polyfill-node.process';\n\n// packages/core/mesh/mesh-protocol/src/protocol.ts\nimport eos from \"end-of-stream\";\nimport ProtocolStream from \"hypercore-protocol\";\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\n\n// packages/core/mesh/mesh-protocol/src/errors.ts\nimport nanoerror from \"nanoerror\";\nvar ERR_PROTOCOL_STREAM_CLOSED = nanoerror(\"ERR_PROTOCOL_STREAM_CLOSED\", \"protocol closed\");\nvar ERR_PROTOCOL_INIT_INVALID = nanoerror(\"ERR_PROTOCOL_INIT_INVALID\", \"protocol initialization invalid\");\nvar ERR_PROTOCOL_HANDSHAKE_FAILED = nanoerror(\"ERR_PROTOCOL_HANDSHAKE_FAILED\", \"protocol handshake failed: %s\");\nvar ERR_PROTOCOL_CONNECTION_INVALID = nanoerror(\"ERR_PROTOCOL_CONNECTION_INVALID\", \"cannot establish connection: %s\");\nvar ERR_PROTOCOL_EXTENSION_MISSING = nanoerror(\"ERR_PROTOCOL_EXTENSION_MISSING\", \"extension missing: %s\");\nvar ERR_EXTENSION_INIT_FAILED = nanoerror(\"ERR_EXTENSION_INIT_FAILED\", \"extension init failed: %s\");\nvar ERR_EXTENSION_HANDSHAKE_FAILED = nanoerror(\"ERR_EXTENSION_HANDSHAKE_FAILED\", \"extension handshake failed: %s\");\nvar ERR_EXTENSION_FEED_FAILED = nanoerror(\"ERR_EXTENSION_FEED_FAILED\", \"extension feed failed: %s\");\nvar ERR_EXTENSION_CLOSE_FAILED = nanoerror(\"ERR_EXTENSION_CLOSE_FAILED\", \"extension close failed: %s\");\nvar ERR_EXTENSION_RESPONSE_TIMEOUT = nanoerror(\"ERR_EXTENSION_RESPONSE_TIMEOUT\", \"%s\");\nvar ERR_EXTENSION_RESPONSE_FAILED = class extends nanoerror(\"ERR_EXTENSION_RESPONSE_FAILED\", \"[extension: %s] [responseCode: %s] [message: %s]\") {\n  constructor(extension, responseCode, responseMessage) {\n    super(extension, responseCode, responseMessage);\n    this.extension = extension;\n    this.responseCode = responseCode;\n    this.responseMessage = responseMessage;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport Signal from \"signal-promise\";\nimport { Trigger } from \"@dxos/async\";\n\n// packages/core/mesh/mesh-protocol/src/extension.ts\nimport { Nanomessage, errors as nanomessageErrors } from \"nanomessage\";\nimport assert from \"@dxos/node-std/assert\";\nimport { patchBufferCodec } from \"@dxos/codec-protobuf\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nvar { NMSG_ERR_TIMEOUT } = nanomessageErrors;\nvar kCodec = Symbol(\"nanomessage.codec\");\nvar Extension = class extends Nanomessage {\n  constructor(name, { schema: userSchema, ...nmOptions } = {}) {\n    super(nmOptions);\n    this._protocol = null;\n    this._protocolExtension = null;\n    this._initHandler = null;\n    this._handshakeHandler = null;\n    this._closeHandler = null;\n    this._messageHandler = null;\n    this._feedHandler = null;\n    this._subscribeCb = null;\n    assert(name.length > 0, \"name is required.\");\n    this._name = name;\n    const codec = schema.getCodecForType(\"dxos.mesh.protocol.Message\");\n    if (userSchema) {\n      codec.addJson(userSchema);\n    }\n    this[kCodec] = patchBufferCodec(codec);\n    this.on(\"error\", (err) => log.warn(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 100,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }));\n  }\n  get name() {\n    return this._name;\n  }\n  setInitHandler(initHandler) {\n    this._initHandler = initHandler;\n    return this;\n  }\n  setHandshakeHandler(handshakeHandler) {\n    this._handshakeHandler = handshakeHandler;\n    return this;\n  }\n  setCloseHandler(closeHandler) {\n    this._closeHandler = closeHandler;\n    return this;\n  }\n  setMessageHandler(messageHandler) {\n    this._messageHandler = messageHandler;\n    return this;\n  }\n  setFeedHandler(feedHandler) {\n    this._feedHandler = feedHandler;\n    return this;\n  }\n  async openWithProtocol(protocol) {\n    assert(!this._protocol);\n    log(\"open\", {\n      name: this._name,\n      id: PublicKey.from(protocol.id)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n      line: 157,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._protocol = protocol;\n    this._protocolExtension = this._protocol.stream.registerExtension(this.name, {\n      onmessage: async (msg) => {\n        var _a;\n        try {\n          await ((_a = this._subscribeCb) == null ? void 0 : _a.call(this, msg));\n        } catch (err) {\n          log.error(\"failed to execute subscribe callback on message\", {\n            name: this._name,\n            id: PublicKey.from(protocol.id)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/extension.ts\",\n            line: 165,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      }\n    });\n    await this.open();\n  }\n  async onInit() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._initHandler) {\n        await this._initHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_INIT_FAILED.from(err);\n    }\n  }\n  async onHandshake() {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._handshakeHandler) {\n        await this._handshakeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_HANDSHAKE_FAILED.from(err);\n    }\n  }\n  async onFeed(discoveryKey) {\n    try {\n      await this.open();\n      assert(this._protocol);\n      if (this._protocol.stream.destroyed) {\n        throw new ERR_PROTOCOL_STREAM_CLOSED();\n      }\n      if (this._feedHandler) {\n        await this._feedHandler(this._protocol, discoveryKey);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_FEED_FAILED.from(err);\n    }\n  }\n  async send(message, options = {}) {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    const builtMessage = buildMessage(message);\n    if (options.oneway) {\n      return super.send(builtMessage);\n    }\n    try {\n      const response = await this.request(builtMessage);\n      if (response && response.code && response.message) {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, response.code, response.message);\n      }\n      return {\n        response\n      };\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      if (ERR_EXTENSION_RESPONSE_FAILED.equals(err)) {\n        throw err;\n      } else if (NMSG_ERR_TIMEOUT.equals(err)) {\n        throw ERR_EXTENSION_RESPONSE_TIMEOUT.from(err);\n      } else {\n        throw new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      }\n    }\n  }\n  _subscribe(next) {\n    this._subscribeCb = next;\n  }\n  async _open() {\n    assert(this._protocol);\n    if (this._protocol.stream.destroyed) {\n      throw new ERR_PROTOCOL_STREAM_CLOSED();\n    }\n    assert(this._protocol);\n    await super._open();\n  }\n  async _close() {\n    try {\n      await super._close();\n      if (this._closeHandler) {\n        assert(this._protocol);\n        await this._closeHandler(this._protocol);\n      }\n    } catch (err) {\n      throw ERR_EXTENSION_CLOSE_FAILED.from(err);\n    }\n  }\n  async _send(msg) {\n    assert(this._protocol);\n    assert(this._protocolExtension);\n    if (this._protocol.stream.destroyed) {\n      return;\n    }\n    this._protocolExtension.send(msg);\n  }\n  async _onMessage(msg) {\n    try {\n      await this.open();\n      if (this._messageHandler) {\n        assert(this._protocol);\n        const result = await this._messageHandler(this._protocol, msg);\n        return buildMessage(result);\n      }\n    } catch (err) {\n      this.emit(\"error\", err);\n      const responseError = new ERR_EXTENSION_RESPONSE_FAILED(this._name, err.code || \"Error\", err.message);\n      return {\n        \"@type\": \"dxos.mesh.protocol.Error\",\n        code: responseError.responseCode,\n        message: responseError.responseMessage\n      };\n    }\n  }\n};\nvar buildMessage = (message) => {\n  if (typeof message === \"string\") {\n    return buildMessage(Buffer.from(message));\n  } else if (Buffer.isBuffer(message)) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else if (message instanceof Uint8Array) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: Buffer.from(message)\n    };\n  } else if (message == null) {\n    return {\n      \"@type\": \"dxos.mesh.protocol.Buffer\",\n      data: message\n    };\n  } else {\n    assert(message[\"@type\"], \"Message does not have a type URL.\");\n    return message;\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/extension-init.ts\nvar ExtensionInit = class extends Extension {\n  constructor(options = {}) {\n    super(\"dxos.mesh.protocol.init\", options);\n    this._remoteInit = null;\n    this.userSession = null;\n    this.remoteUserSession = null;\n    this._sessionTrigger = new Trigger();\n    this._timeout = options.timeout;\n    this._remoteInit = null;\n    this._remoteSignal = new Signal();\n    this.setMessageHandler(async (protocol, message) => {\n      const { data } = message;\n      assert2(data);\n      const messageObj = JSON.parse(Buffer.from(data).toString());\n      switch (messageObj.command) {\n        case \"continue\":\n          this._remoteInit = true;\n          this._remoteSignal.notify();\n          break;\n        case \"break\":\n          this._remoteInit = false;\n          this._remoteSignal.notify();\n          break;\n        case \"session\":\n          this.remoteUserSession = messageObj.data;\n          this._sessionTrigger.wake();\n      }\n    });\n    this.setCloseHandler(async () => {\n      this._remoteInit = false;\n      this._remoteSignal.notify();\n    });\n  }\n  async sendCommand(command, data) {\n    if (data == null ? void 0 : data.peerId) {\n      assert2([\n        \"undefined\",\n        \"string\"\n      ].includes(typeof data.peerId), \"PeerId must be a string.\");\n    }\n    return this.send(Buffer.from(JSON.stringify({\n      command,\n      data\n    })));\n  }\n  async sendSession(userSession) {\n    void this.sendCommand(\"session\", userSession).catch((err) => {\n      this.emit(\"error\", err);\n    });\n    await this._sessionTrigger.wait();\n  }\n  async continue() {\n    try {\n      await this.sendCommand(\"continue\");\n      if (this._remoteInit !== null) {\n        if (this._remoteInit) {\n          return;\n        } else {\n          throw new Error(\"Connection closed during handshake.\");\n        }\n      }\n      await this._remoteSignal.wait(this._timeout);\n      if (!this._remoteInit) {\n        throw new Error(\"Connection closed during handshake.\");\n      }\n    } catch (err) {\n      if (this.closing) {\n        return;\n      }\n      throw new ERR_PROTOCOL_INIT_INVALID(err.message);\n    }\n  }\n  async break() {\n    try {\n      if (this._remoteInit === false) {\n        return;\n      }\n      await this.sendCommand(\"break\");\n    } catch (err) {\n    }\n  }\n};\n\n// packages/core/mesh/mesh-protocol/src/utils.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { humanize } from \"@dxos/util\";\nvar keyToHuman = (key, prefix) => {\n  assert3(Buffer.isBuffer(key));\n  const name = humanize(key.toString(\"hex\"));\n  if (prefix) {\n    return `${prefix}(${name})`;\n  }\n  return name;\n};\n\n// packages/core/mesh/mesh-protocol/src/protocol.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar kProtocol = Symbol(\"dxos.mesh.protocol\");\nvar getProtocolFromStream = (stream) => {\n  assert4(typeof stream === \"object\" && typeof stream.pipe === \"function\", \"stream is required\");\n  return stream[kProtocol];\n};\nvar Protocol = class {\n  constructor(options = {\n    initiator: false\n  }) {\n    this._isOpen = false;\n    this.error = new Event();\n    this.extensionsInitialized = new Event();\n    this.extensionsHandshake = new Event();\n    this.handshake = new Event();\n    this._extensionMap = /* @__PURE__ */ new Map();\n    this._init = false;\n    this._connected = false;\n    this._handshakes = [];\n    this._channel = void 0;\n    this._context = {};\n    this._extensionHandler = (name, message) => {\n      if (name === this._extensionInit.name) {\n        this._extensionInit.emit(\"extension-message\", message);\n        return;\n      }\n      const extension = this._extensionMap.get(name);\n      if (!extension) {\n        this._handleError(new ERR_PROTOCOL_EXTENSION_MISSING(name));\n        return;\n      }\n      extension.emit(\"extension-message\", message);\n    };\n    const { discoveryToPublicKey = (key) => key, streamOptions, initTimeout = 5 * 1e3 } = options;\n    this._discoveryToPublicKey = discoveryToPublicKey;\n    this._streamOptions = streamOptions;\n    this._initTimeout = initTimeout;\n    this._discoveryKey = options.discoveryKey;\n    this._initiator = !!options.initiator;\n    this._stream = new ProtocolStream(this._initiator, {\n      ...this._streamOptions,\n      onhandshake: async () => {\n        var _a, _b;\n        try {\n          await this.open();\n          await this._initExtensions(options.userSession);\n          this.extensionsInitialized.emit();\n          await ((_b = (_a = this.streamOptions) == null ? void 0 : _a.onhandshake) == null ? void 0 : _b.call(_a, this));\n          await this._handshakeExtensions();\n          this.extensionsHandshake.emit();\n        } catch (err) {\n          if (err.message.includes(\"NMSG_ERR_CLOSE\")) {\n            this._stream.destroy();\n            return;\n          }\n          this._handleError(err);\n        }\n      }\n    });\n    this._stream[kProtocol] = this;\n    this._stream.on(\"error\", (err) => this.error.emit(err));\n    this.error.on((err) => {\n      log2.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 146,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    });\n    this._extensionInit = new ExtensionInit({\n      timeout: this._initTimeout\n    });\n  }\n  toString() {\n    const meta = {\n      id: keyToHuman(this._stream.publicKey),\n      extensions: this.extensionNames\n    };\n    return `Protocol(${JSON.stringify(meta)})`;\n  }\n  get id() {\n    return this._stream.publicKey;\n  }\n  get stream() {\n    return this._stream;\n  }\n  get channel() {\n    return this._channel;\n  }\n  get extensions() {\n    return Array.from(this._extensionMap.values());\n  }\n  get extensionNames() {\n    return Array.from(this._extensionMap.keys());\n  }\n  get streamOptions() {\n    return Object.assign({}, this._streamOptions, {\n      id: this._stream.publicKey\n    });\n  }\n  get connected() {\n    return this._connected;\n  }\n  get initiator() {\n    return this._initiator;\n  }\n  getSession() {\n    try {\n      return this._extensionInit.remoteUserSession;\n    } catch (err) {\n      return null;\n    }\n  }\n  setContext(context) {\n    this._context = Object.assign({}, context);\n    return this;\n  }\n  getContext() {\n    return this._context;\n  }\n  setExtension(extension) {\n    assert4(extension);\n    this._extensionMap.set(extension.name, extension);\n    return this;\n  }\n  setExtensions(extensions) {\n    extensions.forEach((extension) => this.setExtension(extension));\n    return this;\n  }\n  getExtension(name) {\n    return this._extensionMap.get(name);\n  }\n  setHandshakeHandler(handler) {\n    this._handshakes.push(async (protocol) => {\n      try {\n        await handler(protocol);\n      } catch (err) {\n        throw new ERR_PROTOCOL_HANDSHAKE_FAILED(err.message);\n      }\n    });\n    return this;\n  }\n  init() {\n    assert4(!this._init);\n    this._init = true;\n    this.open().catch((err) => this._handleError(err));\n    log2(\"initialized\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 268,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return this;\n  }\n  async open() {\n    if (this._isOpen) {\n      return;\n    }\n    log2(\"opening...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 278,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._openExtensions();\n    eos(this._stream, async () => {\n      await this.close();\n    });\n    log2(\"open\", {\n      key: PublicKey2.from(this._stream.publicKey)\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 284,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._isOpen = true;\n  }\n  async close() {\n    if (!this._isOpen) {\n      return;\n    }\n    log2(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 294,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._connected = false;\n    this._stream.finalize();\n    await this._extensionInit.close().catch((err) => {\n      this._handleError(err);\n    });\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"close extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 302,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.close().catch((err) => {\n        this._handleError(err);\n      });\n    }\n    this._isOpen = false;\n    log2(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 309,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async waitForHandshake() {\n    await Promise.race([\n      this.handshake.waitForCount(1),\n      this.error.waitForCount(1).then((err) => Promise.reject(err))\n    ]);\n  }\n  async _openExtensions() {\n    await this._extensionInit.openWithProtocol(this);\n    for (const [name, extension] of this._extensionMap) {\n      log2(\"open extension\", {\n        name,\n        key: PublicKey2.from(this._stream.publicKey)\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n        line: 320,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await extension.openWithProtocol(this);\n    }\n  }\n  async _initExtensions(userSession) {\n    try {\n      await this._extensionInit.sendSession(userSession);\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"init extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 331,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onInit();\n      }\n      await this._extensionInit.continue();\n    } catch (err) {\n      await this._extensionInit.break();\n      throw err;\n    }\n  }\n  async _handshakeExtensions() {\n    try {\n      for (const handshake of this._handshakes) {\n        await handshake(this);\n      }\n      for (const [name, extension] of this._extensionMap) {\n        log2(\"handshake extension\", {\n          name,\n          key: PublicKey2.from(this._stream.publicKey),\n          remote: PublicKey2.from(this._stream.remotePublicKey)\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 353,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        await extension.onHandshake();\n      }\n    } catch (err) {\n      if (this._stream.destroyed) {\n        log2.warn(\"handshake\", err, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 362,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      } else {\n        log2.catch(err, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n          line: 364,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }\n    this.handshake.emit(this);\n    this._connected = true;\n    this._stream.on(\"feed\", async (discoveryKey) => {\n      try {\n        for (const [name, extension] of this._extensionMap) {\n          log2(\"handshake feed\", {\n            name,\n            key: PublicKey2.from(this._stream.publicKey),\n            remote: PublicKey2.from(this._stream.remotePublicKey)\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n            line: 374,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          await extension.onFeed(discoveryKey);\n        }\n      } catch (err) {\n        this._handleError(err);\n      }\n    });\n  }\n  _openConnection() {\n    let initialKey = null;\n    const openChannel = (discoveryKey) => {\n      var _a;\n      try {\n        initialKey = (_a = this._discoveryToPublicKey) == null ? void 0 : _a.call(this, discoveryKey);\n        if (!initialKey) {\n          throw new ERR_PROTOCOL_CONNECTION_INVALID(\"Key not found\");\n        }\n        this._channel = this._stream.open(initialKey, {\n          onextension: this._extensionHandler\n        });\n      } catch (err) {\n        let newErr = err;\n        if (!ERR_PROTOCOL_CONNECTION_INVALID.equals(newErr)) {\n          newErr = ERR_PROTOCOL_CONNECTION_INVALID.from(newErr);\n        }\n        this._handleError(newErr);\n      }\n    };\n    if (this._discoveryKey) {\n      openChannel(this._discoveryKey);\n    } else {\n      this._stream.once(\"feed\", openChannel);\n    }\n  }\n  _handleError(err) {\n    log2.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/mesh-protocol/src/protocol.ts\",\n      line: 440,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    process.nextTick(() => this._stream.destroy(err));\n  }\n};\n__decorate([\n  synchronized\n], Protocol.prototype, \"open\", null);\n__decorate([\n  synchronized\n], Protocol.prototype, \"close\", null);\n\n// packages/core/mesh/mesh-protocol/src/testing/util.ts\nimport pump from \"pump\";\nimport { createPromiseFromCallback } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nvar pipeProtocols = (a, b) => createPromiseFromCallback((cb) => pump(a.stream, b.stream, a.stream, cb));\nvar createTestProtocolPair = (extensions1, extensions2) => {\n  const discoveryKey = PublicKey3.random();\n  const protocol1 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: true,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user1\"\n    }\n  }).setExtensions(extensions1).init();\n  const protocol2 = new Protocol({\n    discoveryKey: discoveryKey.asBuffer(),\n    initiator: false,\n    streamOptions: {\n      live: true\n    },\n    userSession: {\n      peerId: \"user2\"\n    }\n  }).setExtensions(extensions2).init();\n  void pipeProtocols(protocol1, protocol2);\n};\nexport {\n  ERR_EXTENSION_CLOSE_FAILED,\n  ERR_EXTENSION_FEED_FAILED,\n  ERR_EXTENSION_HANDSHAKE_FAILED,\n  ERR_EXTENSION_INIT_FAILED,\n  ERR_EXTENSION_RESPONSE_FAILED,\n  ERR_EXTENSION_RESPONSE_TIMEOUT,\n  ERR_PROTOCOL_CONNECTION_INVALID,\n  ERR_PROTOCOL_EXTENSION_MISSING,\n  ERR_PROTOCOL_HANDSHAKE_FAILED,\n  ERR_PROTOCOL_INIT_INVALID,\n  ERR_PROTOCOL_STREAM_CLOSED,\n  Extension,\n  Protocol,\n  createTestProtocolPair,\n  getProtocolFromStream,\n  pipeProtocols\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467012,"end":1670465467022,"order":"normal"}]}
