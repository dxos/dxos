{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js","transforms":[{"name":"vite:load-fallback","result":"module.exports = codecs\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  name: 'binary',\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string'\n      ? Buffer.from(obj, 'utf-8')\n      : Buffer.isBuffer(obj)\n        ? obj\n        : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n  },\n  decode: function decodeBinary (buf) {\n    return Buffer.isBuffer(buf)\n      ? buf\n      : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n}\n\nfunction codecs (fmt, fallback) {\n  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return fallback !== undefined ? fallback : codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    name: newline ? 'ndjson' : 'json',\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(buf.toString())\n    }\n  }\n\n  function encodeJSON (val) {\n    return Buffer.from(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return Buffer.from(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    name: type,\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return Buffer.from(val, type)\n    },\n    decode: function decodeString (buf) {\n      return buf.toString(type)\n    }\n  }\n}\n","start":1670465469191,"end":1670465469281},{"name":"vite:react-babel","result":"module.exports = codecs\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  name: 'binary',\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string'\n      ? Buffer.from(obj, 'utf-8')\n      : Buffer.isBuffer(obj)\n        ? obj\n        : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n  },\n  decode: function decodeBinary (buf) {\n    return Buffer.isBuffer(buf)\n      ? buf\n      : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n}\n\nfunction codecs (fmt, fallback) {\n  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return fallback !== undefined ? fallback : codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    name: newline ? 'ndjson' : 'json',\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(buf.toString())\n    }\n  }\n\n  function encodeJSON (val) {\n    return Buffer.from(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return Buffer.from(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    name: type,\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return Buffer.from(val, type)\n    },\n    decode: function decodeString (buf) {\n      return buf.toString(type)\n    }\n  }\n}\n","start":1670465469281,"end":1670465469281,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nvar codecs_1 = codecs\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  name: 'binary',\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string'\n      ? Buffer.from(obj, 'utf-8')\n      : Buffer.isBuffer(obj)\n        ? obj\n        : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n  },\n  decode: function decodeBinary (buf) {\n    return Buffer.isBuffer(buf)\n      ? buf\n      : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n}\n\nfunction codecs (fmt, fallback) {\n  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return fallback !== undefined ? fallback : codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    name: newline ? 'ndjson' : 'json',\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(buf.toString())\n    }\n  }\n\n  function encodeJSON (val) {\n    return Buffer.from(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return Buffer.from(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    name: type,\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return Buffer.from(val, type)\n    },\n    decode: function decodeString (buf) {\n      return buf.toString(type)\n    }\n  }\n}\n\nexport default codecs_1;\nexport { codecs_1 as __moduleExports };","start":1670465469281,"end":1670465469282,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nvar codecs_1 = codecs\n\ncodecs.ascii = createString('ascii')\ncodecs.utf8 = createString('utf-8')\ncodecs.hex = createString('hex')\ncodecs.base64 = createString('base64')\ncodecs.ucs2 = createString('ucs2')\ncodecs.utf16le = createString('utf16le')\ncodecs.ndjson = createJSON(true)\ncodecs.json = createJSON(false)\ncodecs.binary = {\n  name: 'binary',\n  encode: function encodeBinary (obj) {\n    return typeof obj === 'string'\n      ? Buffer.from(obj, 'utf-8')\n      : Buffer.isBuffer(obj)\n        ? obj\n        : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n  },\n  decode: function decodeBinary (buf) {\n    return Buffer.isBuffer(buf)\n      ? buf\n      : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n}\n\nfunction codecs (fmt, fallback) {\n  if (typeof fmt === 'object' && fmt && fmt.encode && fmt.decode) return fmt\n\n  switch (fmt) {\n    case 'ndjson': return codecs.ndjson\n    case 'json': return codecs.json\n    case 'ascii': return codecs.ascii\n    case 'utf-8':\n    case 'utf8': return codecs.utf8\n    case 'hex': return codecs.hex\n    case 'base64': return codecs.base64\n    case 'ucs-2':\n    case 'ucs2': return codecs.ucs2\n    case 'utf16-le':\n    case 'utf16le': return codecs.utf16le\n  }\n\n  return fallback !== undefined ? fallback : codecs.binary\n}\n\nfunction createJSON (newline) {\n  return {\n    name: newline ? 'ndjson' : 'json',\n    encode: newline ? encodeNDJSON : encodeJSON,\n    decode: function decodeJSON (buf) {\n      return JSON.parse(buf.toString())\n    }\n  }\n\n  function encodeJSON (val) {\n    return Buffer.from(JSON.stringify(val))\n  }\n\n  function encodeNDJSON (val) {\n    return Buffer.from(JSON.stringify(val) + '\\n')\n  }\n}\n\nfunction createString (type) {\n  return {\n    name: type,\n    encode: function encodeString (val) {\n      if (typeof val !== 'string') val = val.toString()\n      return Buffer.from(val, type)\n    },\n    decode: function decodeString (buf) {\n      return buf.toString(type)\n    }\n  }\n}\n\nexport default codecs_1;\nexport { codecs_1 as __moduleExports };","start":1670465469283,"end":1670465469284,"order":"normal"}]}
