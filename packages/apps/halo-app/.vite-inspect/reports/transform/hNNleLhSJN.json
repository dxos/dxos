{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-streams@1.0.1/node_modules/hypercore-streams/index.js","transforms":[{"name":"vite:load-fallback","result":"const { Writable, Readable } = require('streamx')\n\nclass WriteStream extends Writable {\n  constructor (feed, opts) {\n    super()\n\n    this.feed = feed\n    this.maxBlockSize = (opts && opts.maxBlockSize) || 0\n  }\n\n  _writev (batch, cb) {\n    this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb)\n  }\n\n  _ensureMaxSize (batch) {\n    for (let i = 0; i < batch.length; i++) {\n      let blk = batch[i]\n      if (blk.length > this.maxBlockSize) {\n        const chunked = []\n        while (blk.length > this.maxBlockSize) {\n          chunked.push(blk.slice(0, this.maxBlockSize))\n          blk = blk.slice(this.maxBlockSize)\n        }\n        if (blk.length) chunked.push(blk)\n        batch.splice(i, 1, ...chunked)\n        i += chunked.length - 1\n      }\n    }\n    return batch\n  }\n}\n\nclass ReadStream extends Readable {\n  constructor (feed, opts = {}) {\n    super()\n\n    this.feed = feed\n    this.start = opts.start || 0\n    this.end = typeof opts.end === 'number' ? opts.end : -1\n    this.live = !!opts.live\n    this.snapshot = opts.snapshot !== false\n    this.tail = !!opts.tail\n    this.index = this.start\n    this.options = { wait: opts.wait !== false, ifAvailable: !!opts.ifAvailable, valueEncoding: opts.valueEncoding }\n  }\n\n  _open (cb) {\n    this.feed.ready((err) => {\n      if (err) return cb(err)\n      if (this.end === -1) {\n        if (this.live) this.end = Infinity\n        else if (this.snapshot) this.end = this.feed.length\n        if (this.start > this.end) this.push(null)\n      }\n      if (this.tail) this.start = this.feed.length\n      this.index = this.start\n      cb(null)\n    })\n  }\n\n  _read (cb) {\n    if (this.index === this.end || (this.end === -1 && this.index >= this.feed.length)) {\n      this.push(null)\n      return cb(null)\n    }\n    this.feed.get(this.index++, this.options, (err, block) => {\n      if (err) return cb(err)\n      this.push(block)\n      cb(null)\n    })\n  }\n}\n\nmodule.exports = { WriteStream, ReadStream }\n","start":1670465469236,"end":1670465469388},{"name":"vite:react-babel","result":"const { Writable, Readable } = require('streamx')\n\nclass WriteStream extends Writable {\n  constructor (feed, opts) {\n    super()\n\n    this.feed = feed\n    this.maxBlockSize = (opts && opts.maxBlockSize) || 0\n  }\n\n  _writev (batch, cb) {\n    this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb)\n  }\n\n  _ensureMaxSize (batch) {\n    for (let i = 0; i < batch.length; i++) {\n      let blk = batch[i]\n      if (blk.length > this.maxBlockSize) {\n        const chunked = []\n        while (blk.length > this.maxBlockSize) {\n          chunked.push(blk.slice(0, this.maxBlockSize))\n          blk = blk.slice(this.maxBlockSize)\n        }\n        if (blk.length) chunked.push(blk)\n        batch.splice(i, 1, ...chunked)\n        i += chunked.length - 1\n      }\n    }\n    return batch\n  }\n}\n\nclass ReadStream extends Readable {\n  constructor (feed, opts = {}) {\n    super()\n\n    this.feed = feed\n    this.start = opts.start || 0\n    this.end = typeof opts.end === 'number' ? opts.end : -1\n    this.live = !!opts.live\n    this.snapshot = opts.snapshot !== false\n    this.tail = !!opts.tail\n    this.index = this.start\n    this.options = { wait: opts.wait !== false, ifAvailable: !!opts.ifAvailable, valueEncoding: opts.valueEncoding }\n  }\n\n  _open (cb) {\n    this.feed.ready((err) => {\n      if (err) return cb(err)\n      if (this.end === -1) {\n        if (this.live) this.end = Infinity\n        else if (this.snapshot) this.end = this.feed.length\n        if (this.start > this.end) this.push(null)\n      }\n      if (this.tail) this.start = this.feed.length\n      this.index = this.start\n      cb(null)\n    })\n  }\n\n  _read (cb) {\n    if (this.index === this.end || (this.end === -1 && this.index >= this.feed.length)) {\n      this.push(null)\n      return cb(null)\n    }\n    this.feed.get(this.index++, this.options, (err, block) => {\n      if (err) return cb(err)\n      this.push(block)\n      cb(null)\n    })\n  }\n}\n\nmodule.exports = { WriteStream, ReadStream }\n","start":1670465469389,"end":1670465469389,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/streamx@2.12.5/node_modules/streamx/index.js?commonjs-proxy\";\n\nconst { Writable, Readable } = require$$0\n\nclass WriteStream extends Writable {\n  constructor (feed, opts) {\n    super()\n\n    this.feed = feed\n    this.maxBlockSize = (opts && opts.maxBlockSize) || 0\n  }\n\n  _writev (batch, cb) {\n    this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb)\n  }\n\n  _ensureMaxSize (batch) {\n    for (let i = 0; i < batch.length; i++) {\n      let blk = batch[i]\n      if (blk.length > this.maxBlockSize) {\n        const chunked = []\n        while (blk.length > this.maxBlockSize) {\n          chunked.push(blk.slice(0, this.maxBlockSize))\n          blk = blk.slice(this.maxBlockSize)\n        }\n        if (blk.length) chunked.push(blk)\n        batch.splice(i, 1, ...chunked)\n        i += chunked.length - 1\n      }\n    }\n    return batch\n  }\n}\n\nclass ReadStream extends Readable {\n  constructor (feed, opts = {}) {\n    super()\n\n    this.feed = feed\n    this.start = opts.start || 0\n    this.end = typeof opts.end === 'number' ? opts.end : -1\n    this.live = !!opts.live\n    this.snapshot = opts.snapshot !== false\n    this.tail = !!opts.tail\n    this.index = this.start\n    this.options = { wait: opts.wait !== false, ifAvailable: !!opts.ifAvailable, valueEncoding: opts.valueEncoding }\n  }\n\n  _open (cb) {\n    this.feed.ready((err) => {\n      if (err) return cb(err)\n      if (this.end === -1) {\n        if (this.live) this.end = Infinity\n        else if (this.snapshot) this.end = this.feed.length\n        if (this.start > this.end) this.push(null)\n      }\n      if (this.tail) this.start = this.feed.length\n      this.index = this.start\n      cb(null)\n    })\n  }\n\n  _read (cb) {\n    if (this.index === this.end || (this.end === -1 && this.index >= this.feed.length)) {\n      this.push(null)\n      return cb(null)\n    }\n    this.feed.get(this.index++, this.options, (err, block) => {\n      if (err) return cb(err)\n      this.push(block)\n      cb(null)\n    })\n  }\n}\n\nvar hypercoreStreams = { WriteStream, ReadStream }\n\nexport default hypercoreStreams;\nexport { hypercoreStreams as __moduleExports };","start":1670465469389,"end":1670465470341,"order":"normal"}]}
