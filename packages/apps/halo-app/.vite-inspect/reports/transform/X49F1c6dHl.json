{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-protocol@8.0.7/node_modules/hypercore-protocol/index.js","transforms":[{"name":"vite:load-fallback","result":"const SHP = require('simple-hypercore-protocol')\nconst crypto = require('hypercore-crypto')\nconst timeout = require('timeout-refresh')\nconst inspect = require('inspect-custom-symbol')\nconst Nanoguard = require('nanoguard')\nconst pretty = require('pretty-hash')\nconst Message = require('abstract-extension')\nconst { Duplex } = require('streamx')\nconst debug = require('debug')('hypercore-protocol')\n\nclass StreamExtension extends Message {\n  send (message) {\n    const stream = this.local.handlers\n    if (stream._changes !== this.local.changes) {\n      stream._changes = this.local.changes\n      stream.state.options(0, { extensions: this.local.names() })\n    }\n    return stream.state.extension(0, this.id, this.encode(message))\n  }\n}\n\nclass Channelizer {\n  constructor (stream, { encrypted, noise, keyPair }) {\n    this.stream = stream\n    this.created = new Map()\n    this.local = [null]\n    this.remote = [null]\n    this.noise = !(noise === false && encrypted === false)\n    this.encrypted = encrypted !== false\n    this.keyPair = keyPair\n  }\n\n  allocLocal () {\n    const id = this.local.indexOf(null)\n    if (id > 0) return id\n    this.local.push(null)\n    return this.local.length - 1\n  }\n\n  attachLocal (ch) {\n    const id = this.allocLocal()\n    this.local[id] = ch\n    ch.localId = id\n  }\n\n  attachRemote (ch, id) {\n    if (this.remote.length === id) this.remote.push(null)\n    this.remote[id] = ch\n    ch.remoteId = id\n  }\n\n  detachChannel (ch) {\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n    if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {\n      this.remote[ch.remoteId] = null\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n  }\n\n  getChannel (dk) {\n    return this.created.get(dk.toString('hex'))\n  }\n\n  createChannel (dk) {\n    const hex = dk.toString('hex')\n\n    const old = this.created.get(hex)\n    if (old) return old\n\n    const fresh = new Channel(this.stream.state, this.stream, dk)\n    this.created.set(hex, fresh)\n    return fresh\n  }\n\n  onauthenticate (key, done) {\n    if (this.stream.handlers && this.stream.handlers.onauthenticate) this.stream.handlers.onauthenticate(key, done)\n    else done(null)\n  }\n\n  onhandshake () {\n    debug('recv handshake')\n    if (this.stream.handlers && this.stream.handlers.onhandshake) this.stream.handlers.onhandshake()\n    this.stream.emit('handshake')\n  }\n\n  onopen (channelId, message) {\n    debug('recv open', channelId, message)\n    const ch = this.createChannel(message.discoveryKey)\n    ch.remoteCapability = message.capability\n    this.attachRemote(ch, channelId)\n    if (ch.localId === -1) {\n      if (this.stream.handlers.ondiscoverykey) this.stream.handlers.ondiscoverykey(ch.discoveryKey)\n      this.stream.emit('discovery-key', ch.discoveryKey)\n    } else {\n      if (this.noise && !ch.remoteVerified) {\n        // We are leaking metadata here that the remote cap was bad which means the remote prob can figure\n        // out that we indeed had the key. Since we were the one to initialise the channel that's ok, as\n        // that already kinda leaks that.\n        this.stream.destroy(new Error('Invalid remote channel capability'))\n        return\n      }\n      this.stream.emit('duplex-channel', ch)\n    }\n    if (ch.handlers && ch.handlers.onopen) ch.handlers.onopen()\n\n    if (this.stream.handlers.onremoteopen) this.stream.handlers.onremoteopen(ch.discoveryKey)\n    this.stream.emit('remote-open', ch.discoveryKey)\n  }\n\n  onoptions (channelId, message) {\n    debug('recv options', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onoptions) ch.handlers.onoptions(message)\n    else if (channelId === 0 && !ch) this.stream._updateExtensions(message.extensions)\n  }\n\n  onstatus (channelId, message) {\n    debug('recv status', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onstatus) ch.handlers.onstatus(message)\n  }\n\n  onhave (channelId, message) {\n    debug('recv have', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onhave) ch.handlers.onhave(message)\n  }\n\n  onunhave (channelId, message) {\n    debug('recv unhave', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunhave) ch.handlers.onunhave(message)\n  }\n\n  onwant (channelId, message) {\n    debug('recv want', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onwant) ch.handlers.onwant(message)\n  }\n\n  onunwant (channelId, message) {\n    debug('recv unwant', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunwant) ch.handlers.onunwant(message)\n  }\n\n  onrequest (channelId, message) {\n    debug('recv request', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onrequest) ch.handlers.onrequest(message)\n  }\n\n  oncancel (channelId, message) {\n    debug('recv cancel', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.oncancel) ch.handlers.oncancel(message)\n  }\n\n  ondata (channelId, message) {\n    debug('recv data', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.ondata) ch.handlers.ondata(message)\n  }\n\n  onextension (channelId, id, buf) {\n    debug('recv extension', channelId, id)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onextension) ch.handlers.onextension(id, buf)\n    else if (channelId === 0 && !ch) this.stream.remoteExtensions.onmessage(id, buf)\n  }\n\n  onclose (channelId, message) {\n    debug('recv close', channelId, message)\n    let ch = channelId < this.remote.length ? this.remote[channelId] : null\n\n    if (ch) {\n      this.remote[channelId] = null\n    } else if (message.discoveryKey) {\n      ch = this.getChannel(message.discoveryKey)\n    }\n\n    if (!ch) return\n\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.state.close(ch.localId, {})\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n\n    if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n      this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n    this.stream._prefinalize()\n  }\n\n  onmissing (bytes) {\n    if (this.stream._utp === null) return\n    this.stream._utp.setContentSize(bytes)\n  }\n\n  // called by the state machine\n  send (data) {\n    if (this.stream.keepAlive !== null) this.stream.keepAlive.refresh()\n    this.stream.bytesSent += data.length\n    return this.stream.push(data)\n  }\n\n  // called by the state machine\n  destroy (err) {\n    this.stream.destroy(err)\n    this.local = []\n    this.remote = []\n    for (const ch of this.created.values()) {\n      const closed = ch.localId === -1\n      ch.localId = ch.remoteId = -1\n      if (!closed && ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n\n      if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n        this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n      }\n    }\n    this.created.clear()\n  }\n}\n\nclass Channel {\n  constructor (state, stream, dk) {\n    this.key = null\n    this.discoveryKey = dk\n    this.localId = -1\n    this.remoteId = -1\n    this.remoteCapability = null\n    this.handlers = null\n    this.state = state\n    this.stream = stream\n  }\n\n  get opened () {\n    return this.localId > -1\n  }\n\n  get closed () {\n    return this.localId === -1\n  }\n\n  get remoteOpened () {\n    return this.remoteId > -1\n  }\n\n  get remoteVerified () {\n    return this.localId > -1 &&\n      this.remoteId > -1 &&\n      !!this.remoteCapability &&\n      this.remoteCapability.equals(this.state.remoteCapability(this.key))\n  }\n\n  options (message) {\n    debug('send options', message)\n    return this.state.options(this.localId, message)\n  }\n\n  status (message) {\n    debug('send status', message)\n    return this.state.status(this.localId, message)\n  }\n\n  have (message) {\n    debug('send have', message)\n    return this.state.have(this.localId, message)\n  }\n\n  unhave (message) {\n    debug('send unhave', message)\n    return this.state.unhave(this.localId, message)\n  }\n\n  want (message) {\n    debug('send want', message)\n    return this.state.want(this.localId, message)\n  }\n\n  unwant (message) {\n    debug('send unwant', message)\n    return this.state.unwant(this.localId, message)\n  }\n\n  request (message) {\n    debug('send request', message)\n    return this.state.request(this.localId, message)\n  }\n\n  cancel (message) {\n    debug('send cancel', message)\n    return this.state.cancel(this.localId, message)\n  }\n\n  data (message) {\n    debug('send data', message)\n    return this.state.data(this.localId, message)\n  }\n\n  extension (id, buf) {\n    debug('send extension', id)\n    return this.state.extension(this.localId, id, buf)\n  }\n\n  close () {\n    debug('send close')\n    if (this.closed) return\n\n    const localId = this.localId\n    this.stream.channelizer.detachChannel(this)\n    this.state.close(localId, {})\n    this.stream._prefinalize()\n  }\n\n  destroy (err) {\n    this.stream.destroy(err)\n  }\n}\n\nmodule.exports = class ProtocolStream extends Duplex {\n  constructor (initiator, handlers = {}) {\n    super()\n\n    if (typeof initiator !== 'boolean') throw new Error('Must specify initiator boolean in replication stream')\n\n    this.initiator = initiator\n    this.handlers = handlers\n    this.channelizer = new Channelizer(this, {\n      encrypted: handlers.encrypted,\n      noise: handlers.noise,\n      keyPair: handlers.keyPair\n    })\n    this.state = new SHP(initiator, this.channelizer)\n    this.live = !!handlers.live\n    this.timeout = null\n    this.keepAlive = null\n    this.prefinalize = new Nanoguard()\n    this.bytesSent = 0\n    this.bytesReceived = 0\n    this.extensions = StreamExtension.createLocal(this)\n    this.remoteExtensions = this.extensions.remote()\n\n    this._utp = null\n    this._changes = 0\n\n    this.once('finish', this.push.bind(this, null))\n    this.on('pipe', this._onpipe)\n\n    if (handlers.timeout !== false && handlers.timeout !== 0) {\n      const timeout = handlers.timeout || 20000\n      this.setTimeout(timeout, () => this.destroy(new Error('ETIMEDOUT')))\n      this.setKeepAlive(Math.ceil(timeout / 2))\n    }\n  }\n\n  registerExtension (name, handlers) {\n    return this.extensions.add(name, handlers)\n  }\n\n  [inspect] (depth, opts) {\n    let indent = ''\n    if (typeof opts.indentationLvl === 'number') {\n      while (indent.length < opts.indentationLvl) indent += ' '\n    }\n\n    return 'HypercoreProtocolStream(\\n' +\n      indent + '  publicKey: ' + opts.stylize((this.publicKey && pretty(this.publicKey)), 'string') + '\\n' +\n      indent + '  remotePublicKey: ' + opts.stylize((this.remotePublicKey && pretty(this.remotePublicKey)), 'string') + '\\n' +\n      indent + '  remoteAddress: ' + opts.stylize(this.remoteAddress, 'string') + '\\n' +\n      indent + '  remoteType: ' + opts.stylize(this.remoteType, 'string') + '\\n' +\n      indent + '  live: ' + opts.stylize(this.live, 'boolean') + '\\n' +\n      indent + '  initiator: ' + opts.stylize(this.initiator, 'boolean') + '\\n' +\n      indent + '  channelCount: ' + opts.stylize(this.channelCount, 'number') + '\\n' +\n      indent + '  destroyed: ' + opts.stylize(this.destroyed, 'boolean') + '\\n' +\n      indent + '  prefinalized: ' + opts.stylize(!this.prefinalize.waiting, 'boolean') + '\\n' +\n      indent + '  bytesSent: ' + opts.stylize(this.bytesSent, 'number') + '\\n' +\n      indent + '  bytesReceived: ' + opts.stylize(this.bytesReceived, 'number') + '\\n' +\n      indent + ')'\n  }\n\n  static isProtocolStream (s) {\n    return !!(s && typeof s.initiator === 'boolean' && typeof s.pipe === 'function' && s.state)\n  }\n\n  static keyPair (seed) {\n    return SHP.keyPair(seed)\n  }\n\n  get remoteAddress () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (ProtocolStream.isProtocolStream(to)) return null\n    return to.remoteAddress\n  }\n\n  get remoteType () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (to._utp) return 'utp'\n    if (to.remoteAddress) return 'tcp'\n    return 'unknown'\n  }\n\n  get publicKey () {\n    return this.state.publicKey\n  }\n\n  get remotePublicKey () {\n    return this.state.remotePublicKey\n  }\n\n  _onpipe (dest) {\n    if (typeof dest.setContentSize === 'function') this._utp = dest\n  }\n\n  _write (data, cb) {\n    if (this.timeout !== null) this.timeout.refresh()\n    this.bytesReceived += data.length\n    this.state.recv(data)\n    cb(null)\n  }\n\n  _destroy (cb) {\n    this._predestroy() // make sure this always runs\n    this.channelizer.destroy()\n    this.state.destroy()\n    cb(null)\n  }\n\n  _predestroy () {\n    if (this.timeout !== null) {\n      this.timeout.destroy()\n      this.timeout = null\n    }\n    if (this.keepAlive !== null) {\n      this.keepAlive.destroy()\n      this.keepAlive = null\n    }\n    this.prefinalize.destroy()\n  }\n\n  _prefinalize () {\n    this.emit('prefinalize')\n    this.prefinalize.ready(() => {\n      if (this.destroyed) return\n      if (this.channelCount) return\n      if (this.live) return\n      this.finalize()\n    })\n  }\n\n  _updateExtensions (names) {\n    this.remoteExtensions.update(names)\n    if (this.handlers.onextensions) this.handlers.onextensions(names)\n    this.emit('extensions', names)\n  }\n\n  remoteOpened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.remoteId > -1)\n  }\n\n  remoteVerified (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key))\n  }\n\n  opened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.localId > -1)\n  }\n\n  ping () {\n    return this.state.ping()\n  }\n\n  setKeepAlive (ms) {\n    if (this.keepAlive) this.keepAlive.destroy()\n    if (!ms) {\n      this.keepAlive = null\n      return\n    }\n    this.keepAlive = timeout(ms, ping, this)\n\n    function ping () {\n      this.ping()\n      this.keepAlive = timeout(ms, ping, this)\n    }\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (this.timeout) this.timeout.destroy()\n    if (!ms) {\n      this.timeout = null\n      return\n    }\n    this.timeout = timeout(ms, this.emit.bind(this, 'timeout'))\n    if (ontimeout) this.once('timeout', ontimeout)\n  }\n\n  get channelCount () {\n    return this.channelizer.created.size\n  }\n\n  get channels () {\n    return this.channelizer.created.values()\n  }\n\n  open (key, handlers) {\n    const discoveryKey = crypto.discoveryKey(key)\n    const ch = this.channelizer.createChannel(discoveryKey)\n\n    if (ch.key === null) {\n      ch.key = key\n      this.channelizer.attachLocal(ch)\n      this.state.open(ch.localId, { key, discoveryKey })\n    }\n\n    if (handlers) ch.handlers = handlers\n\n    if (ch.remoteId > -1) this.emit('duplex-channel', ch)\n\n    return ch\n  }\n\n  close (discoveryKey) {\n    const ch = this.channelizer.getChannel(discoveryKey)\n\n    if (ch && ch.localId > -1) {\n      ch.close()\n      return\n    }\n\n    this.state.close(this.channelizer.allocLocal(), { discoveryKey })\n  }\n\n  finalize () {\n    this.push(null)\n  }\n}\n","start":1670465468203,"end":1670465468256},{"name":"vite:react-babel","result":"const SHP = require('simple-hypercore-protocol')\nconst crypto = require('hypercore-crypto')\nconst timeout = require('timeout-refresh')\nconst inspect = require('inspect-custom-symbol')\nconst Nanoguard = require('nanoguard')\nconst pretty = require('pretty-hash')\nconst Message = require('abstract-extension')\nconst { Duplex } = require('streamx')\nconst debug = require('debug')('hypercore-protocol')\n\nclass StreamExtension extends Message {\n  send (message) {\n    const stream = this.local.handlers\n    if (stream._changes !== this.local.changes) {\n      stream._changes = this.local.changes\n      stream.state.options(0, { extensions: this.local.names() })\n    }\n    return stream.state.extension(0, this.id, this.encode(message))\n  }\n}\n\nclass Channelizer {\n  constructor (stream, { encrypted, noise, keyPair }) {\n    this.stream = stream\n    this.created = new Map()\n    this.local = [null]\n    this.remote = [null]\n    this.noise = !(noise === false && encrypted === false)\n    this.encrypted = encrypted !== false\n    this.keyPair = keyPair\n  }\n\n  allocLocal () {\n    const id = this.local.indexOf(null)\n    if (id > 0) return id\n    this.local.push(null)\n    return this.local.length - 1\n  }\n\n  attachLocal (ch) {\n    const id = this.allocLocal()\n    this.local[id] = ch\n    ch.localId = id\n  }\n\n  attachRemote (ch, id) {\n    if (this.remote.length === id) this.remote.push(null)\n    this.remote[id] = ch\n    ch.remoteId = id\n  }\n\n  detachChannel (ch) {\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n    if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {\n      this.remote[ch.remoteId] = null\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n  }\n\n  getChannel (dk) {\n    return this.created.get(dk.toString('hex'))\n  }\n\n  createChannel (dk) {\n    const hex = dk.toString('hex')\n\n    const old = this.created.get(hex)\n    if (old) return old\n\n    const fresh = new Channel(this.stream.state, this.stream, dk)\n    this.created.set(hex, fresh)\n    return fresh\n  }\n\n  onauthenticate (key, done) {\n    if (this.stream.handlers && this.stream.handlers.onauthenticate) this.stream.handlers.onauthenticate(key, done)\n    else done(null)\n  }\n\n  onhandshake () {\n    debug('recv handshake')\n    if (this.stream.handlers && this.stream.handlers.onhandshake) this.stream.handlers.onhandshake()\n    this.stream.emit('handshake')\n  }\n\n  onopen (channelId, message) {\n    debug('recv open', channelId, message)\n    const ch = this.createChannel(message.discoveryKey)\n    ch.remoteCapability = message.capability\n    this.attachRemote(ch, channelId)\n    if (ch.localId === -1) {\n      if (this.stream.handlers.ondiscoverykey) this.stream.handlers.ondiscoverykey(ch.discoveryKey)\n      this.stream.emit('discovery-key', ch.discoveryKey)\n    } else {\n      if (this.noise && !ch.remoteVerified) {\n        // We are leaking metadata here that the remote cap was bad which means the remote prob can figure\n        // out that we indeed had the key. Since we were the one to initialise the channel that's ok, as\n        // that already kinda leaks that.\n        this.stream.destroy(new Error('Invalid remote channel capability'))\n        return\n      }\n      this.stream.emit('duplex-channel', ch)\n    }\n    if (ch.handlers && ch.handlers.onopen) ch.handlers.onopen()\n\n    if (this.stream.handlers.onremoteopen) this.stream.handlers.onremoteopen(ch.discoveryKey)\n    this.stream.emit('remote-open', ch.discoveryKey)\n  }\n\n  onoptions (channelId, message) {\n    debug('recv options', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onoptions) ch.handlers.onoptions(message)\n    else if (channelId === 0 && !ch) this.stream._updateExtensions(message.extensions)\n  }\n\n  onstatus (channelId, message) {\n    debug('recv status', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onstatus) ch.handlers.onstatus(message)\n  }\n\n  onhave (channelId, message) {\n    debug('recv have', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onhave) ch.handlers.onhave(message)\n  }\n\n  onunhave (channelId, message) {\n    debug('recv unhave', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunhave) ch.handlers.onunhave(message)\n  }\n\n  onwant (channelId, message) {\n    debug('recv want', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onwant) ch.handlers.onwant(message)\n  }\n\n  onunwant (channelId, message) {\n    debug('recv unwant', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunwant) ch.handlers.onunwant(message)\n  }\n\n  onrequest (channelId, message) {\n    debug('recv request', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onrequest) ch.handlers.onrequest(message)\n  }\n\n  oncancel (channelId, message) {\n    debug('recv cancel', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.oncancel) ch.handlers.oncancel(message)\n  }\n\n  ondata (channelId, message) {\n    debug('recv data', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.ondata) ch.handlers.ondata(message)\n  }\n\n  onextension (channelId, id, buf) {\n    debug('recv extension', channelId, id)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onextension) ch.handlers.onextension(id, buf)\n    else if (channelId === 0 && !ch) this.stream.remoteExtensions.onmessage(id, buf)\n  }\n\n  onclose (channelId, message) {\n    debug('recv close', channelId, message)\n    let ch = channelId < this.remote.length ? this.remote[channelId] : null\n\n    if (ch) {\n      this.remote[channelId] = null\n    } else if (message.discoveryKey) {\n      ch = this.getChannel(message.discoveryKey)\n    }\n\n    if (!ch) return\n\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.state.close(ch.localId, {})\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n\n    if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n      this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n    this.stream._prefinalize()\n  }\n\n  onmissing (bytes) {\n    if (this.stream._utp === null) return\n    this.stream._utp.setContentSize(bytes)\n  }\n\n  // called by the state machine\n  send (data) {\n    if (this.stream.keepAlive !== null) this.stream.keepAlive.refresh()\n    this.stream.bytesSent += data.length\n    return this.stream.push(data)\n  }\n\n  // called by the state machine\n  destroy (err) {\n    this.stream.destroy(err)\n    this.local = []\n    this.remote = []\n    for (const ch of this.created.values()) {\n      const closed = ch.localId === -1\n      ch.localId = ch.remoteId = -1\n      if (!closed && ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n\n      if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n        this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n      }\n    }\n    this.created.clear()\n  }\n}\n\nclass Channel {\n  constructor (state, stream, dk) {\n    this.key = null\n    this.discoveryKey = dk\n    this.localId = -1\n    this.remoteId = -1\n    this.remoteCapability = null\n    this.handlers = null\n    this.state = state\n    this.stream = stream\n  }\n\n  get opened () {\n    return this.localId > -1\n  }\n\n  get closed () {\n    return this.localId === -1\n  }\n\n  get remoteOpened () {\n    return this.remoteId > -1\n  }\n\n  get remoteVerified () {\n    return this.localId > -1 &&\n      this.remoteId > -1 &&\n      !!this.remoteCapability &&\n      this.remoteCapability.equals(this.state.remoteCapability(this.key))\n  }\n\n  options (message) {\n    debug('send options', message)\n    return this.state.options(this.localId, message)\n  }\n\n  status (message) {\n    debug('send status', message)\n    return this.state.status(this.localId, message)\n  }\n\n  have (message) {\n    debug('send have', message)\n    return this.state.have(this.localId, message)\n  }\n\n  unhave (message) {\n    debug('send unhave', message)\n    return this.state.unhave(this.localId, message)\n  }\n\n  want (message) {\n    debug('send want', message)\n    return this.state.want(this.localId, message)\n  }\n\n  unwant (message) {\n    debug('send unwant', message)\n    return this.state.unwant(this.localId, message)\n  }\n\n  request (message) {\n    debug('send request', message)\n    return this.state.request(this.localId, message)\n  }\n\n  cancel (message) {\n    debug('send cancel', message)\n    return this.state.cancel(this.localId, message)\n  }\n\n  data (message) {\n    debug('send data', message)\n    return this.state.data(this.localId, message)\n  }\n\n  extension (id, buf) {\n    debug('send extension', id)\n    return this.state.extension(this.localId, id, buf)\n  }\n\n  close () {\n    debug('send close')\n    if (this.closed) return\n\n    const localId = this.localId\n    this.stream.channelizer.detachChannel(this)\n    this.state.close(localId, {})\n    this.stream._prefinalize()\n  }\n\n  destroy (err) {\n    this.stream.destroy(err)\n  }\n}\n\nmodule.exports = class ProtocolStream extends Duplex {\n  constructor (initiator, handlers = {}) {\n    super()\n\n    if (typeof initiator !== 'boolean') throw new Error('Must specify initiator boolean in replication stream')\n\n    this.initiator = initiator\n    this.handlers = handlers\n    this.channelizer = new Channelizer(this, {\n      encrypted: handlers.encrypted,\n      noise: handlers.noise,\n      keyPair: handlers.keyPair\n    })\n    this.state = new SHP(initiator, this.channelizer)\n    this.live = !!handlers.live\n    this.timeout = null\n    this.keepAlive = null\n    this.prefinalize = new Nanoguard()\n    this.bytesSent = 0\n    this.bytesReceived = 0\n    this.extensions = StreamExtension.createLocal(this)\n    this.remoteExtensions = this.extensions.remote()\n\n    this._utp = null\n    this._changes = 0\n\n    this.once('finish', this.push.bind(this, null))\n    this.on('pipe', this._onpipe)\n\n    if (handlers.timeout !== false && handlers.timeout !== 0) {\n      const timeout = handlers.timeout || 20000\n      this.setTimeout(timeout, () => this.destroy(new Error('ETIMEDOUT')))\n      this.setKeepAlive(Math.ceil(timeout / 2))\n    }\n  }\n\n  registerExtension (name, handlers) {\n    return this.extensions.add(name, handlers)\n  }\n\n  [inspect] (depth, opts) {\n    let indent = ''\n    if (typeof opts.indentationLvl === 'number') {\n      while (indent.length < opts.indentationLvl) indent += ' '\n    }\n\n    return 'HypercoreProtocolStream(\\n' +\n      indent + '  publicKey: ' + opts.stylize((this.publicKey && pretty(this.publicKey)), 'string') + '\\n' +\n      indent + '  remotePublicKey: ' + opts.stylize((this.remotePublicKey && pretty(this.remotePublicKey)), 'string') + '\\n' +\n      indent + '  remoteAddress: ' + opts.stylize(this.remoteAddress, 'string') + '\\n' +\n      indent + '  remoteType: ' + opts.stylize(this.remoteType, 'string') + '\\n' +\n      indent + '  live: ' + opts.stylize(this.live, 'boolean') + '\\n' +\n      indent + '  initiator: ' + opts.stylize(this.initiator, 'boolean') + '\\n' +\n      indent + '  channelCount: ' + opts.stylize(this.channelCount, 'number') + '\\n' +\n      indent + '  destroyed: ' + opts.stylize(this.destroyed, 'boolean') + '\\n' +\n      indent + '  prefinalized: ' + opts.stylize(!this.prefinalize.waiting, 'boolean') + '\\n' +\n      indent + '  bytesSent: ' + opts.stylize(this.bytesSent, 'number') + '\\n' +\n      indent + '  bytesReceived: ' + opts.stylize(this.bytesReceived, 'number') + '\\n' +\n      indent + ')'\n  }\n\n  static isProtocolStream (s) {\n    return !!(s && typeof s.initiator === 'boolean' && typeof s.pipe === 'function' && s.state)\n  }\n\n  static keyPair (seed) {\n    return SHP.keyPair(seed)\n  }\n\n  get remoteAddress () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (ProtocolStream.isProtocolStream(to)) return null\n    return to.remoteAddress\n  }\n\n  get remoteType () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (to._utp) return 'utp'\n    if (to.remoteAddress) return 'tcp'\n    return 'unknown'\n  }\n\n  get publicKey () {\n    return this.state.publicKey\n  }\n\n  get remotePublicKey () {\n    return this.state.remotePublicKey\n  }\n\n  _onpipe (dest) {\n    if (typeof dest.setContentSize === 'function') this._utp = dest\n  }\n\n  _write (data, cb) {\n    if (this.timeout !== null) this.timeout.refresh()\n    this.bytesReceived += data.length\n    this.state.recv(data)\n    cb(null)\n  }\n\n  _destroy (cb) {\n    this._predestroy() // make sure this always runs\n    this.channelizer.destroy()\n    this.state.destroy()\n    cb(null)\n  }\n\n  _predestroy () {\n    if (this.timeout !== null) {\n      this.timeout.destroy()\n      this.timeout = null\n    }\n    if (this.keepAlive !== null) {\n      this.keepAlive.destroy()\n      this.keepAlive = null\n    }\n    this.prefinalize.destroy()\n  }\n\n  _prefinalize () {\n    this.emit('prefinalize')\n    this.prefinalize.ready(() => {\n      if (this.destroyed) return\n      if (this.channelCount) return\n      if (this.live) return\n      this.finalize()\n    })\n  }\n\n  _updateExtensions (names) {\n    this.remoteExtensions.update(names)\n    if (this.handlers.onextensions) this.handlers.onextensions(names)\n    this.emit('extensions', names)\n  }\n\n  remoteOpened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.remoteId > -1)\n  }\n\n  remoteVerified (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key))\n  }\n\n  opened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.localId > -1)\n  }\n\n  ping () {\n    return this.state.ping()\n  }\n\n  setKeepAlive (ms) {\n    if (this.keepAlive) this.keepAlive.destroy()\n    if (!ms) {\n      this.keepAlive = null\n      return\n    }\n    this.keepAlive = timeout(ms, ping, this)\n\n    function ping () {\n      this.ping()\n      this.keepAlive = timeout(ms, ping, this)\n    }\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (this.timeout) this.timeout.destroy()\n    if (!ms) {\n      this.timeout = null\n      return\n    }\n    this.timeout = timeout(ms, this.emit.bind(this, 'timeout'))\n    if (ontimeout) this.once('timeout', ontimeout)\n  }\n\n  get channelCount () {\n    return this.channelizer.created.size\n  }\n\n  get channels () {\n    return this.channelizer.created.values()\n  }\n\n  open (key, handlers) {\n    const discoveryKey = crypto.discoveryKey(key)\n    const ch = this.channelizer.createChannel(discoveryKey)\n\n    if (ch.key === null) {\n      ch.key = key\n      this.channelizer.attachLocal(ch)\n      this.state.open(ch.localId, { key, discoveryKey })\n    }\n\n    if (handlers) ch.handlers = handlers\n\n    if (ch.remoteId > -1) this.emit('duplex-channel', ch)\n\n    return ch\n  }\n\n  close (discoveryKey) {\n    const ch = this.channelizer.getChannel(discoveryKey)\n\n    if (ch && ch.localId > -1) {\n      ch.close()\n      return\n    }\n\n    this.state.close(this.channelizer.allocLocal(), { discoveryKey })\n  }\n\n  finalize () {\n    this.push(null)\n  }\n}\n","start":1670465468256,"end":1670465468256,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/timeout-refresh@1.0.3/node_modules/timeout-refresh/browser.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inspect-custom-symbol@1.1.1/node_modules/inspect-custom-symbol/browser.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/pretty-hash@1.0.1/node_modules/pretty-hash/index.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/streamx@2.12.5/node_modules/streamx/index.js?commonjs-proxy\";\nimport require$$8 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js?commonjs-proxy\";\n\nconst SHP = require$$0\nconst crypto = require$$1\nconst timeout = require$$2\nconst inspect = require$$3\nconst Nanoguard = require$$4\nconst pretty = require$$5\nconst Message = require$$6\nconst { Duplex } = require$$7\nconst debug = require$$8('hypercore-protocol')\n\nclass StreamExtension extends Message {\n  send (message) {\n    const stream = this.local.handlers\n    if (stream._changes !== this.local.changes) {\n      stream._changes = this.local.changes\n      stream.state.options(0, { extensions: this.local.names() })\n    }\n    return stream.state.extension(0, this.id, this.encode(message))\n  }\n}\n\nclass Channelizer {\n  constructor (stream, { encrypted, noise, keyPair }) {\n    this.stream = stream\n    this.created = new Map()\n    this.local = [null]\n    this.remote = [null]\n    this.noise = !(noise === false && encrypted === false)\n    this.encrypted = encrypted !== false\n    this.keyPair = keyPair\n  }\n\n  allocLocal () {\n    const id = this.local.indexOf(null)\n    if (id > 0) return id\n    this.local.push(null)\n    return this.local.length - 1\n  }\n\n  attachLocal (ch) {\n    const id = this.allocLocal()\n    this.local[id] = ch\n    ch.localId = id\n  }\n\n  attachRemote (ch, id) {\n    if (this.remote.length === id) this.remote.push(null)\n    this.remote[id] = ch\n    ch.remoteId = id\n  }\n\n  detachChannel (ch) {\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n    if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {\n      this.remote[ch.remoteId] = null\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n  }\n\n  getChannel (dk) {\n    return this.created.get(dk.toString('hex'))\n  }\n\n  createChannel (dk) {\n    const hex = dk.toString('hex')\n\n    const old = this.created.get(hex)\n    if (old) return old\n\n    const fresh = new Channel(this.stream.state, this.stream, dk)\n    this.created.set(hex, fresh)\n    return fresh\n  }\n\n  onauthenticate (key, done) {\n    if (this.stream.handlers && this.stream.handlers.onauthenticate) this.stream.handlers.onauthenticate(key, done)\n    else done(null)\n  }\n\n  onhandshake () {\n    debug('recv handshake')\n    if (this.stream.handlers && this.stream.handlers.onhandshake) this.stream.handlers.onhandshake()\n    this.stream.emit('handshake')\n  }\n\n  onopen (channelId, message) {\n    debug('recv open', channelId, message)\n    const ch = this.createChannel(message.discoveryKey)\n    ch.remoteCapability = message.capability\n    this.attachRemote(ch, channelId)\n    if (ch.localId === -1) {\n      if (this.stream.handlers.ondiscoverykey) this.stream.handlers.ondiscoverykey(ch.discoveryKey)\n      this.stream.emit('discovery-key', ch.discoveryKey)\n    } else {\n      if (this.noise && !ch.remoteVerified) {\n        // We are leaking metadata here that the remote cap was bad which means the remote prob can figure\n        // out that we indeed had the key. Since we were the one to initialise the channel that's ok, as\n        // that already kinda leaks that.\n        this.stream.destroy(new Error('Invalid remote channel capability'))\n        return\n      }\n      this.stream.emit('duplex-channel', ch)\n    }\n    if (ch.handlers && ch.handlers.onopen) ch.handlers.onopen()\n\n    if (this.stream.handlers.onremoteopen) this.stream.handlers.onremoteopen(ch.discoveryKey)\n    this.stream.emit('remote-open', ch.discoveryKey)\n  }\n\n  onoptions (channelId, message) {\n    debug('recv options', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onoptions) ch.handlers.onoptions(message)\n    else if (channelId === 0 && !ch) this.stream._updateExtensions(message.extensions)\n  }\n\n  onstatus (channelId, message) {\n    debug('recv status', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onstatus) ch.handlers.onstatus(message)\n  }\n\n  onhave (channelId, message) {\n    debug('recv have', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onhave) ch.handlers.onhave(message)\n  }\n\n  onunhave (channelId, message) {\n    debug('recv unhave', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunhave) ch.handlers.onunhave(message)\n  }\n\n  onwant (channelId, message) {\n    debug('recv want', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onwant) ch.handlers.onwant(message)\n  }\n\n  onunwant (channelId, message) {\n    debug('recv unwant', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onunwant) ch.handlers.onunwant(message)\n  }\n\n  onrequest (channelId, message) {\n    debug('recv request', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onrequest) ch.handlers.onrequest(message)\n  }\n\n  oncancel (channelId, message) {\n    debug('recv cancel', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.oncancel) ch.handlers.oncancel(message)\n  }\n\n  ondata (channelId, message) {\n    debug('recv data', channelId, message)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.ondata) ch.handlers.ondata(message)\n  }\n\n  onextension (channelId, id, buf) {\n    debug('recv extension', channelId, id)\n    const ch = this.remote[channelId]\n    if (ch && ch.handlers && ch.handlers.onextension) ch.handlers.onextension(id, buf)\n    else if (channelId === 0 && !ch) this.stream.remoteExtensions.onmessage(id, buf)\n  }\n\n  onclose (channelId, message) {\n    debug('recv close', channelId, message)\n    let ch = channelId < this.remote.length ? this.remote[channelId] : null\n\n    if (ch) {\n      this.remote[channelId] = null\n    } else if (message.discoveryKey) {\n      ch = this.getChannel(message.discoveryKey)\n    }\n\n    if (!ch) return\n\n    if (ch.localId > -1 && this.local[ch.localId] === ch) {\n      this.local[ch.localId] = null\n      ch.state.close(ch.localId, {})\n      ch.localId = -1\n      if (ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n    }\n\n    if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n      this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n    }\n\n    const hex = ch.discoveryKey.toString('hex')\n    if (this.created.get(hex) === ch) this.created.delete(hex)\n    this.stream._prefinalize()\n  }\n\n  onmissing (bytes) {\n    if (this.stream._utp === null) return\n    this.stream._utp.setContentSize(bytes)\n  }\n\n  // called by the state machine\n  send (data) {\n    if (this.stream.keepAlive !== null) this.stream.keepAlive.refresh()\n    this.stream.bytesSent += data.length\n    return this.stream.push(data)\n  }\n\n  // called by the state machine\n  destroy (err) {\n    this.stream.destroy(err)\n    this.local = []\n    this.remote = []\n    for (const ch of this.created.values()) {\n      const closed = ch.localId === -1\n      ch.localId = ch.remoteId = -1\n      if (!closed && ch.handlers && ch.handlers.onclose) ch.handlers.onclose()\n\n      if (this.stream.handlers && this.stream.handlers.onchannelclose) {\n        this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key)\n      }\n    }\n    this.created.clear()\n  }\n}\n\nclass Channel {\n  constructor (state, stream, dk) {\n    this.key = null\n    this.discoveryKey = dk\n    this.localId = -1\n    this.remoteId = -1\n    this.remoteCapability = null\n    this.handlers = null\n    this.state = state\n    this.stream = stream\n  }\n\n  get opened () {\n    return this.localId > -1\n  }\n\n  get closed () {\n    return this.localId === -1\n  }\n\n  get remoteOpened () {\n    return this.remoteId > -1\n  }\n\n  get remoteVerified () {\n    return this.localId > -1 &&\n      this.remoteId > -1 &&\n      !!this.remoteCapability &&\n      this.remoteCapability.equals(this.state.remoteCapability(this.key))\n  }\n\n  options (message) {\n    debug('send options', message)\n    return this.state.options(this.localId, message)\n  }\n\n  status (message) {\n    debug('send status', message)\n    return this.state.status(this.localId, message)\n  }\n\n  have (message) {\n    debug('send have', message)\n    return this.state.have(this.localId, message)\n  }\n\n  unhave (message) {\n    debug('send unhave', message)\n    return this.state.unhave(this.localId, message)\n  }\n\n  want (message) {\n    debug('send want', message)\n    return this.state.want(this.localId, message)\n  }\n\n  unwant (message) {\n    debug('send unwant', message)\n    return this.state.unwant(this.localId, message)\n  }\n\n  request (message) {\n    debug('send request', message)\n    return this.state.request(this.localId, message)\n  }\n\n  cancel (message) {\n    debug('send cancel', message)\n    return this.state.cancel(this.localId, message)\n  }\n\n  data (message) {\n    debug('send data', message)\n    return this.state.data(this.localId, message)\n  }\n\n  extension (id, buf) {\n    debug('send extension', id)\n    return this.state.extension(this.localId, id, buf)\n  }\n\n  close () {\n    debug('send close')\n    if (this.closed) return\n\n    const localId = this.localId\n    this.stream.channelizer.detachChannel(this)\n    this.state.close(localId, {})\n    this.stream._prefinalize()\n  }\n\n  destroy (err) {\n    this.stream.destroy(err)\n  }\n}\n\nvar hypercoreProtocol = class ProtocolStream extends Duplex {\n  constructor (initiator, handlers = {}) {\n    super()\n\n    if (typeof initiator !== 'boolean') throw new Error('Must specify initiator boolean in replication stream')\n\n    this.initiator = initiator\n    this.handlers = handlers\n    this.channelizer = new Channelizer(this, {\n      encrypted: handlers.encrypted,\n      noise: handlers.noise,\n      keyPair: handlers.keyPair\n    })\n    this.state = new SHP(initiator, this.channelizer)\n    this.live = !!handlers.live\n    this.timeout = null\n    this.keepAlive = null\n    this.prefinalize = new Nanoguard()\n    this.bytesSent = 0\n    this.bytesReceived = 0\n    this.extensions = StreamExtension.createLocal(this)\n    this.remoteExtensions = this.extensions.remote()\n\n    this._utp = null\n    this._changes = 0\n\n    this.once('finish', this.push.bind(this, null))\n    this.on('pipe', this._onpipe)\n\n    if (handlers.timeout !== false && handlers.timeout !== 0) {\n      const timeout = handlers.timeout || 20000\n      this.setTimeout(timeout, () => this.destroy(new Error('ETIMEDOUT')))\n      this.setKeepAlive(Math.ceil(timeout / 2))\n    }\n  }\n\n  registerExtension (name, handlers) {\n    return this.extensions.add(name, handlers)\n  }\n\n  [inspect] (depth, opts) {\n    let indent = ''\n    if (typeof opts.indentationLvl === 'number') {\n      while (indent.length < opts.indentationLvl) indent += ' '\n    }\n\n    return 'HypercoreProtocolStream(\\n' +\n      indent + '  publicKey: ' + opts.stylize((this.publicKey && pretty(this.publicKey)), 'string') + '\\n' +\n      indent + '  remotePublicKey: ' + opts.stylize((this.remotePublicKey && pretty(this.remotePublicKey)), 'string') + '\\n' +\n      indent + '  remoteAddress: ' + opts.stylize(this.remoteAddress, 'string') + '\\n' +\n      indent + '  remoteType: ' + opts.stylize(this.remoteType, 'string') + '\\n' +\n      indent + '  live: ' + opts.stylize(this.live, 'boolean') + '\\n' +\n      indent + '  initiator: ' + opts.stylize(this.initiator, 'boolean') + '\\n' +\n      indent + '  channelCount: ' + opts.stylize(this.channelCount, 'number') + '\\n' +\n      indent + '  destroyed: ' + opts.stylize(this.destroyed, 'boolean') + '\\n' +\n      indent + '  prefinalized: ' + opts.stylize(!this.prefinalize.waiting, 'boolean') + '\\n' +\n      indent + '  bytesSent: ' + opts.stylize(this.bytesSent, 'number') + '\\n' +\n      indent + '  bytesReceived: ' + opts.stylize(this.bytesReceived, 'number') + '\\n' +\n      indent + ')'\n  }\n\n  static isProtocolStream (s) {\n    return !!(s && typeof s.initiator === 'boolean' && typeof s.pipe === 'function' && s.state)\n  }\n\n  static keyPair (seed) {\n    return SHP.keyPair(seed)\n  }\n\n  get remoteAddress () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (ProtocolStream.isProtocolStream(to)) return null\n    return to.remoteAddress\n  }\n\n  get remoteType () {\n    const to = this._readableState.pipeTo\n    if (!to) return null\n    if (to._utp) return 'utp'\n    if (to.remoteAddress) return 'tcp'\n    return 'unknown'\n  }\n\n  get publicKey () {\n    return this.state.publicKey\n  }\n\n  get remotePublicKey () {\n    return this.state.remotePublicKey\n  }\n\n  _onpipe (dest) {\n    if (typeof dest.setContentSize === 'function') this._utp = dest\n  }\n\n  _write (data, cb) {\n    if (this.timeout !== null) this.timeout.refresh()\n    this.bytesReceived += data.length\n    this.state.recv(data)\n    cb(null)\n  }\n\n  _destroy (cb) {\n    this._predestroy() // make sure this always runs\n    this.channelizer.destroy()\n    this.state.destroy()\n    cb(null)\n  }\n\n  _predestroy () {\n    if (this.timeout !== null) {\n      this.timeout.destroy()\n      this.timeout = null\n    }\n    if (this.keepAlive !== null) {\n      this.keepAlive.destroy()\n      this.keepAlive = null\n    }\n    this.prefinalize.destroy()\n  }\n\n  _prefinalize () {\n    this.emit('prefinalize')\n    this.prefinalize.ready(() => {\n      if (this.destroyed) return\n      if (this.channelCount) return\n      if (this.live) return\n      this.finalize()\n    })\n  }\n\n  _updateExtensions (names) {\n    this.remoteExtensions.update(names)\n    if (this.handlers.onextensions) this.handlers.onextensions(names)\n    this.emit('extensions', names)\n  }\n\n  remoteOpened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.remoteId > -1)\n  }\n\n  remoteVerified (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key))\n  }\n\n  opened (key) {\n    const ch = this.channelizer.getChannel(crypto.discoveryKey(key))\n    return !!(ch && ch.localId > -1)\n  }\n\n  ping () {\n    return this.state.ping()\n  }\n\n  setKeepAlive (ms) {\n    if (this.keepAlive) this.keepAlive.destroy()\n    if (!ms) {\n      this.keepAlive = null\n      return\n    }\n    this.keepAlive = timeout(ms, ping, this)\n\n    function ping () {\n      this.ping()\n      this.keepAlive = timeout(ms, ping, this)\n    }\n  }\n\n  setTimeout (ms, ontimeout) {\n    if (this.timeout) this.timeout.destroy()\n    if (!ms) {\n      this.timeout = null\n      return\n    }\n    this.timeout = timeout(ms, this.emit.bind(this, 'timeout'))\n    if (ontimeout) this.once('timeout', ontimeout)\n  }\n\n  get channelCount () {\n    return this.channelizer.created.size\n  }\n\n  get channels () {\n    return this.channelizer.created.values()\n  }\n\n  open (key, handlers) {\n    const discoveryKey = crypto.discoveryKey(key)\n    const ch = this.channelizer.createChannel(discoveryKey)\n\n    if (ch.key === null) {\n      ch.key = key\n      this.channelizer.attachLocal(ch)\n      this.state.open(ch.localId, { key, discoveryKey })\n    }\n\n    if (handlers) ch.handlers = handlers\n\n    if (ch.remoteId > -1) this.emit('duplex-channel', ch)\n\n    return ch\n  }\n\n  close (discoveryKey) {\n    const ch = this.channelizer.getChannel(discoveryKey)\n\n    if (ch && ch.localId > -1) {\n      ch.close()\n      return\n    }\n\n    this.state.close(this.channelizer.allocLocal(), { discoveryKey })\n  }\n\n  finalize () {\n    this.push(null)\n  }\n}\n\nexport default hypercoreProtocol;\nexport { hypercoreProtocol as __moduleExports };","start":1670465468256,"end":1670465471833,"order":"normal"}]}
