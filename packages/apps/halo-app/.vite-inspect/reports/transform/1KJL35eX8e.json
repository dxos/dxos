{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-cache@1.0.2/node_modules/hypercore-cache/index.js","transforms":[{"name":"vite:load-fallback","result":"const DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16\n\nclass NamespacedCache {\n  constructor (parent, name) {\n    this.name = name\n    this.parent = parent\n  }\n\n  get _info () {\n    return this.parent._info\n  }\n\n  set (key, value) {\n    return this.parent._set(this.name, key, value)\n  }\n\n  del (key) {\n    return this.parent._del(this.name, key)\n  }\n\n  get (key) {\n    return this.parent._get(this.name, key)\n  }\n}\n\nmodule.exports = class HypercoreCache {\n  constructor (opts = {}) {\n    this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE\n    this.onEvict = opts.onEvict\n    this.estimateSize = opts.estimateSize || defaultSize\n\n    this._nextNamespace = 0\n    this.defaultCache = new NamespacedCache(this, this._nextNamespace++)\n\n    this._stale = null\n    this._fresh = new Map()\n    this._freshByteSize = 0\n    this._staleByteSize = 0\n  }\n\n  get _info () {\n    return {\n      freshByteSize: this._freshByteSize,\n      staleByteSize: this._staleByteSize,\n      staleEntries: this._stale ? this._stale.size : 0,\n      freshEntries: this._fresh.size,\n      byteSize: this.byteSize\n    }\n  }\n\n  _prefix (namespace, key) {\n    return namespace + ':' + key\n  }\n\n  _gc () {\n    if (this.onEvict && this._staleByteSize > 0) this.onEvict(this._stale)\n    this._stale = this._fresh\n    this._fresh = new Map()\n    this._staleByteSize = this._freshByteSize\n    this._freshByteSize = 0\n  }\n\n  _get (namespace, key, prefixedKey) {\n    if (!prefixedKey) prefixedKey = this._prefix(namespace, key)\n    return this._fresh.get(prefixedKey) || (this._stale && this._stale.get(prefixedKey))\n  }\n\n  _set (namespace, key, value) {\n    const valueSize = this.estimateSize(value)\n    const prefixedKey = this._prefix(namespace, key)\n    if (this._freshByteSize + valueSize > this.maxByteSize) {\n      this._gc()\n    }\n    this._fresh.set(prefixedKey, value)\n    this._freshByteSize += valueSize\n  }\n\n  _del (namespace, key) {\n    const prefixedKey = this._prefix(namespace, key)\n    let val = this._stale && this._stale.get(prefixedKey)\n    if (val) {\n      this._stale.delete(prefixedKey)\n      this._staleByteSize -= this.estimateSize(val)\n    }\n    val = this._fresh.get(prefixedKey)\n    if (val) {\n      this._fresh.delete(prefixedKey)\n      this._freshByteSize -= this.estimateSize(val)\n    }\n  }\n\n  get byteSize () {\n    return this._freshByteSize + this._staleByteSize\n  }\n\n  namespace () {\n    const cache = new NamespacedCache(this, this._nextNamespace++)\n    return cache\n  }\n\n  set (key, value) {\n    return this.defaultCache.set(key, value)\n  }\n\n  del (key) {\n    return this.defaultCache.del(key)\n  }\n\n  get (key) {\n    return this.defaultCache.get(key)\n  }\n}\n\nfunction defaultSize () {\n  // Return an estimate of the object overhead, without being clever here.\n  // (You should pass in a size estimator)\n  return 1024\n}\n","start":1670465470826,"end":1670465470879},{"name":"vite:react-babel","result":"const DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16\n\nclass NamespacedCache {\n  constructor (parent, name) {\n    this.name = name\n    this.parent = parent\n  }\n\n  get _info () {\n    return this.parent._info\n  }\n\n  set (key, value) {\n    return this.parent._set(this.name, key, value)\n  }\n\n  del (key) {\n    return this.parent._del(this.name, key)\n  }\n\n  get (key) {\n    return this.parent._get(this.name, key)\n  }\n}\n\nmodule.exports = class HypercoreCache {\n  constructor (opts = {}) {\n    this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE\n    this.onEvict = opts.onEvict\n    this.estimateSize = opts.estimateSize || defaultSize\n\n    this._nextNamespace = 0\n    this.defaultCache = new NamespacedCache(this, this._nextNamespace++)\n\n    this._stale = null\n    this._fresh = new Map()\n    this._freshByteSize = 0\n    this._staleByteSize = 0\n  }\n\n  get _info () {\n    return {\n      freshByteSize: this._freshByteSize,\n      staleByteSize: this._staleByteSize,\n      staleEntries: this._stale ? this._stale.size : 0,\n      freshEntries: this._fresh.size,\n      byteSize: this.byteSize\n    }\n  }\n\n  _prefix (namespace, key) {\n    return namespace + ':' + key\n  }\n\n  _gc () {\n    if (this.onEvict && this._staleByteSize > 0) this.onEvict(this._stale)\n    this._stale = this._fresh\n    this._fresh = new Map()\n    this._staleByteSize = this._freshByteSize\n    this._freshByteSize = 0\n  }\n\n  _get (namespace, key, prefixedKey) {\n    if (!prefixedKey) prefixedKey = this._prefix(namespace, key)\n    return this._fresh.get(prefixedKey) || (this._stale && this._stale.get(prefixedKey))\n  }\n\n  _set (namespace, key, value) {\n    const valueSize = this.estimateSize(value)\n    const prefixedKey = this._prefix(namespace, key)\n    if (this._freshByteSize + valueSize > this.maxByteSize) {\n      this._gc()\n    }\n    this._fresh.set(prefixedKey, value)\n    this._freshByteSize += valueSize\n  }\n\n  _del (namespace, key) {\n    const prefixedKey = this._prefix(namespace, key)\n    let val = this._stale && this._stale.get(prefixedKey)\n    if (val) {\n      this._stale.delete(prefixedKey)\n      this._staleByteSize -= this.estimateSize(val)\n    }\n    val = this._fresh.get(prefixedKey)\n    if (val) {\n      this._fresh.delete(prefixedKey)\n      this._freshByteSize -= this.estimateSize(val)\n    }\n  }\n\n  get byteSize () {\n    return this._freshByteSize + this._staleByteSize\n  }\n\n  namespace () {\n    const cache = new NamespacedCache(this, this._nextNamespace++)\n    return cache\n  }\n\n  set (key, value) {\n    return this.defaultCache.set(key, value)\n  }\n\n  del (key) {\n    return this.defaultCache.del(key)\n  }\n\n  get (key) {\n    return this.defaultCache.get(key)\n  }\n}\n\nfunction defaultSize () {\n  // Return an estimate of the object overhead, without being clever here.\n  // (You should pass in a size estimator)\n  return 1024\n}\n","start":1670465470879,"end":1670465470879,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nconst DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16\n\nclass NamespacedCache {\n  constructor (parent, name) {\n    this.name = name\n    this.parent = parent\n  }\n\n  get _info () {\n    return this.parent._info\n  }\n\n  set (key, value) {\n    return this.parent._set(this.name, key, value)\n  }\n\n  del (key) {\n    return this.parent._del(this.name, key)\n  }\n\n  get (key) {\n    return this.parent._get(this.name, key)\n  }\n}\n\nvar hypercoreCache = class HypercoreCache {\n  constructor (opts = {}) {\n    this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE\n    this.onEvict = opts.onEvict\n    this.estimateSize = opts.estimateSize || defaultSize\n\n    this._nextNamespace = 0\n    this.defaultCache = new NamespacedCache(this, this._nextNamespace++)\n\n    this._stale = null\n    this._fresh = new Map()\n    this._freshByteSize = 0\n    this._staleByteSize = 0\n  }\n\n  get _info () {\n    return {\n      freshByteSize: this._freshByteSize,\n      staleByteSize: this._staleByteSize,\n      staleEntries: this._stale ? this._stale.size : 0,\n      freshEntries: this._fresh.size,\n      byteSize: this.byteSize\n    }\n  }\n\n  _prefix (namespace, key) {\n    return namespace + ':' + key\n  }\n\n  _gc () {\n    if (this.onEvict && this._staleByteSize > 0) this.onEvict(this._stale)\n    this._stale = this._fresh\n    this._fresh = new Map()\n    this._staleByteSize = this._freshByteSize\n    this._freshByteSize = 0\n  }\n\n  _get (namespace, key, prefixedKey) {\n    if (!prefixedKey) prefixedKey = this._prefix(namespace, key)\n    return this._fresh.get(prefixedKey) || (this._stale && this._stale.get(prefixedKey))\n  }\n\n  _set (namespace, key, value) {\n    const valueSize = this.estimateSize(value)\n    const prefixedKey = this._prefix(namespace, key)\n    if (this._freshByteSize + valueSize > this.maxByteSize) {\n      this._gc()\n    }\n    this._fresh.set(prefixedKey, value)\n    this._freshByteSize += valueSize\n  }\n\n  _del (namespace, key) {\n    const prefixedKey = this._prefix(namespace, key)\n    let val = this._stale && this._stale.get(prefixedKey)\n    if (val) {\n      this._stale.delete(prefixedKey)\n      this._staleByteSize -= this.estimateSize(val)\n    }\n    val = this._fresh.get(prefixedKey)\n    if (val) {\n      this._fresh.delete(prefixedKey)\n      this._freshByteSize -= this.estimateSize(val)\n    }\n  }\n\n  get byteSize () {\n    return this._freshByteSize + this._staleByteSize\n  }\n\n  namespace () {\n    const cache = new NamespacedCache(this, this._nextNamespace++)\n    return cache\n  }\n\n  set (key, value) {\n    return this.defaultCache.set(key, value)\n  }\n\n  del (key) {\n    return this.defaultCache.del(key)\n  }\n\n  get (key) {\n    return this.defaultCache.get(key)\n  }\n}\n\nfunction defaultSize () {\n  // Return an estimate of the object overhead, without being clever here.\n  // (You should pass in a size estimator)\n  return 1024\n}\n\nexport default hypercoreCache;\nexport { hypercoreCache as __moduleExports };","start":1670465470879,"end":1670465470881,"order":"normal"}]}
