{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/async/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/async/src/callback.ts\nvar createPromiseFromCallback = (run) => new Promise((resolve, reject) => {\n  run((error, value) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(value);\n    }\n  });\n});\n\n// packages/common/async/src/chain.ts\nvar asyncChain = (chain) => async (elements) => {\n  let result = await Promise.resolve(elements);\n  for (const part of chain) {\n    result = await Promise.all(result.map(async (element) => await part(element)));\n  }\n  return result;\n};\n\n// packages/common/async/src/errors.ts\nvar toError = (err) => err === void 0 || typeof err === \"string\" ? new Error(err) : err;\nvar TimeoutError = class extends Error {\n  constructor(timeout, label) {\n    super(timeout ? `Timeout [${timeout}ms]${label === void 0 ? \"\" : ` :${label}`}` : \"Timeout\");\n  }\n};\nvar observableError = (observable, err) => {\n  var _a, _b;\n  if (err instanceof TimeoutError) {\n    (_b = (_a = observable.callback).onTimeout) == null ? void 0 : _b.call(_a, err);\n  } else {\n    observable.callback.onError(toError(err));\n  }\n};\n\n// packages/common/async/src/timeout.ts\nvar sleep = (ms) => {\n  return new Promise((resolve) => {\n    const finish = Date.now() + ms;\n    const sleeper = () => {\n      const delta = finish - Date.now();\n      if (delta > 0) {\n        setTimeout(sleeper, delta);\n      } else {\n        resolve();\n      }\n    };\n    sleeper();\n  });\n};\nvar asyncTimeout = (promise, timeout, err) => {\n  const throwable = err === void 0 || typeof err === \"string\" ? new TimeoutError(timeout, err) : err;\n  const conditionTimeout = typeof promise === \"function\" ? createPromiseFromCallback(promise) : promise;\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(throwable);\n    }, timeout);\n    if (typeof timeoutId === \"object\" && \"unref\" in timeoutId) {\n      timeoutId.unref();\n    }\n  });\n  return Promise.race([\n    conditionTimeout,\n    timeoutPromise\n  ]).finally(() => {\n    clearTimeout(timeoutId);\n  });\n};\n\n// packages/common/async/src/event-emitter.ts\nvar onEvent = (eventEmitter, eventName, callback) => {\n  eventEmitter.on(eventName, callback);\n  return () => eventEmitter.off(eventName, callback);\n};\nvar addListener = (eventEmitter, eventName, callback) => {\n  const off = onEvent(eventEmitter, eventName, callback);\n  return {\n    remove: () => off()\n  };\n};\nvar waitForEvent = (eventEmitter, eventName, test, timeout, error) => {\n  let off;\n  const promise = new Promise((resolve) => {\n    off = onEvent(eventEmitter, eventName, (...args) => {\n      if (!test || test(...args)) {\n        resolve(...args);\n      }\n    });\n  });\n  return timeout ? asyncTimeout(promise, timeout, error != null ? error : new Error()).finally(off) : promise.finally(off);\n};\n\n// packages/common/async/src/events.ts\nimport { Context } from \"@dxos/context\";\n\n// packages/common/async/src/task-scheduling.ts\nvar DeferredTask = class {\n  constructor(_ctx, _callback) {\n    this._ctx = _ctx;\n    this._callback = _callback;\n    this._scheduled = false;\n    this._promise = null;\n  }\n  schedule() {\n    if (this._scheduled) {\n      return;\n    }\n    scheduleTask(this._ctx, async () => {\n      await this._promise;\n      this._scheduled = false;\n      this._promise = runInContextAsync(this._ctx, () => this._callback());\n    });\n    this._scheduled = true;\n  }\n};\nvar runInContext = (ctx, fn) => {\n  try {\n    fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar runInContextAsync = async (ctx, fn) => {\n  try {\n    await fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar scheduleTask = (ctx, fn, afterMs) => {\n  const timeout = setTimeout(async () => {\n    await runInContextAsync(ctx, fn);\n  }, afterMs);\n  ctx.onDispose(() => {\n    clearTimeout(timeout);\n  });\n};\nvar scheduleTaskInterval = (ctx, task, interval) => {\n  const run = async () => {\n    await task();\n    scheduleTask(ctx, run, interval);\n  };\n  scheduleTask(ctx, run, interval);\n};\n\n// packages/common/async/src/events.ts\nvar EventSubscriptions = class {\n  constructor() {\n    this._listeners = [];\n  }\n  add(cb) {\n    this._listeners.push(cb);\n  }\n  clear() {\n    this._listeners.forEach((cb) => cb());\n    this._listeners.length = 0;\n  }\n};\nvar Event = class {\n  constructor() {\n    this._listeners = /* @__PURE__ */ new Map();\n    this._onceListeners = /* @__PURE__ */ new Map();\n    this._effects = /* @__PURE__ */ new Set();\n  }\n  static wrap(emitter, eventName) {\n    const event = new Event();\n    event.addEffect(() => {\n      const onEvent2 = (data) => event.emit(data);\n      emitter.on(eventName, onEvent2);\n      return () => emitter.off(eventName, onEvent2);\n    });\n    return event;\n  }\n  emit(data) {\n    for (const [_key, listener] of this._listeners) {\n      listener(data);\n    }\n    for (const [_key1, listener1] of this._onceListeners) {\n      listener1(data);\n      this._onceListeners.delete(_key1);\n    }\n  }\n  on(_ctx, _callback) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    const runCallback = (data) => runInContextAsync(ctx, () => callback(data));\n    this._listeners.set(callback, runCallback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    ctx.onDispose(() => this.off(callback));\n    return () => this.off(callback);\n  }\n  off(callback) {\n    this._listeners.delete(callback);\n    this._onceListeners.delete(callback);\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  once(_ctx, _callback) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    if (this._listeners.has(callback)) {\n      return () => {\n      };\n    }\n    const runCallback = (data) => runInContextAsync(ctx, () => callback(data));\n    this._onceListeners.set(callback, runCallback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    return () => {\n      this._onceListeners.delete(callback);\n      if (this.listenerCount() === 0) {\n        this._runEffects();\n      }\n    };\n  }\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      yield await new Promise((resolve) => {\n        this.once(resolve);\n      });\n    }\n  }\n  waitFor(predicate) {\n    return new Promise((resolve) => {\n      const unsubscribe = this.on((data) => {\n        if (predicate(data)) {\n          unsubscribe();\n          resolve(data);\n        }\n      });\n    });\n  }\n  waitForCount(expectedCount) {\n    let count = 0;\n    return this.waitFor(() => ++count === expectedCount);\n  }\n  async waitForCondition(predicate) {\n    if (!predicate()) {\n      await this.waitFor(predicate);\n    }\n  }\n  listenerCount() {\n    return this._listeners.size + this._onceListeners.size;\n  }\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: void 0\n    };\n    if (this.listenerCount() > 0) {\n      handle.cleanup = handle.effect();\n    }\n    this._effects.add(handle);\n    return () => {\n      var _a;\n      (_a = handle.cleanup) == null ? void 0 : _a.call(handle);\n      this._effects.delete(handle);\n    };\n  }\n  debounce(timeout = 0) {\n    const debouncedEvent = new Event();\n    let firing = false;\n    debouncedEvent.addEffect(() => this.on(() => {\n      if (!firing) {\n        firing = true;\n        setTimeout(() => {\n          firing = false;\n          debouncedEvent.emit();\n        }, timeout);\n      }\n    }));\n    return debouncedEvent;\n  }\n  discardParameter() {\n    return this;\n  }\n  toJSON() {\n    return {\n      listenerCount: this.listenerCount()\n    };\n  }\n  _runEffects() {\n    for (const handle of this._effects) {\n      handle.cleanup = handle.effect();\n    }\n  }\n  _cleanupEffects() {\n    var _a;\n    for (const handle of this._effects) {\n      (_a = handle.cleanup) == null ? void 0 : _a.call(handle);\n      handle.cleanup = void 0;\n    }\n  }\n};\n\n// packages/common/async/src/latch.ts\nimport assert from \"@dxos/node-std/assert\";\nvar latch = ({ count = 1, timeout } = {}) => {\n  assert(count >= 0);\n  let t;\n  let doResolve;\n  let doReject;\n  const promise = new Promise((resolve, reject) => {\n    doResolve = (value) => {\n      clearTimeout(t);\n      resolve(value);\n    };\n    doReject = (err) => {\n      clearTimeout(t);\n      reject(err);\n    };\n  });\n  if (count === 0) {\n    setTimeout(() => {\n      doResolve(0);\n    });\n  } else {\n    if (timeout) {\n      t = setTimeout(() => {\n        doReject(new Error(`Timed out after ${timeout}ms`));\n      }, timeout);\n    }\n  }\n  let i = 0;\n  return [\n    async () => await promise,\n    () => {\n      if (++i === count) {\n        doResolve(i);\n      }\n      return i;\n    },\n    (err) => doReject(err)\n  ];\n};\n\n// packages/common/async/src/observable.ts\nimport { createSetDispatch } from \"@dxos/util\";\nvar ObservableProvider = class {\n  constructor() {\n    this._handlers = /* @__PURE__ */ new Set();\n    this._proxy = createSetDispatch({\n      handlers: this._handlers\n    });\n  }\n  get callback() {\n    return this._proxy;\n  }\n  subscribe(handler) {\n    this._handlers.add(handler);\n    return () => {\n      this._handlers.delete(handler);\n    };\n  }\n};\nvar CancellableObservableProvider = class extends ObservableProvider {\n  constructor(_handleCancel) {\n    super();\n    this._handleCancel = _handleCancel;\n    this._cancelled = false;\n  }\n  get cancelled() {\n    return this._cancelled;\n  }\n  async cancel() {\n    var _a, _b, _c;\n    if (this._cancelled) {\n      return;\n    }\n    this._cancelled = true;\n    await ((_a = this._handleCancel) == null ? void 0 : _a.call(this));\n    (_c = (_b = this.callback).onCancelled) == null ? void 0 : _c.call(_b);\n  }\n};\n\n// packages/common/async/src/trigger.ts\nvar trigger = (timeout) => {\n  let callback;\n  const promise = new Promise((resolve, reject) => {\n    if (timeout) {\n      setTimeout(() => reject(new Error(`Timed out after ${timeout}ms`)), timeout);\n    }\n    callback = resolve;\n  });\n  const provider = () => promise;\n  const resolver = (value) => callback(value);\n  return [\n    provider,\n    resolver\n  ];\n};\nvar Trigger = class {\n  constructor(_options = {\n    autoReset: false\n  }) {\n    this._options = _options;\n    this.reset();\n  }\n  async wait({ timeout } = {}) {\n    if (timeout) {\n      return asyncTimeout(this._promise, timeout, new Error(`Timed out after ${timeout}ms.`));\n    } else {\n      return this._promise;\n    }\n  }\n  wake(value) {\n    this._wake(value);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n    return this;\n  }\n  reset() {\n    this._promise = new Promise((resolve) => {\n      this._wake = resolve;\n    });\n    return this;\n  }\n};\n\n// packages/common/async/src/lock.ts\nvar Lock = class {\n  constructor() {\n    this._lastPromise = Promise.resolve();\n  }\n  async executeSynchronized(fun) {\n    const prevPromise = this._lastPromise;\n    const [getPromise, resolve] = trigger();\n    this._lastPromise = getPromise();\n    await prevPromise;\n    try {\n      return await fun();\n    } finally {\n      resolve();\n    }\n  }\n};\nvar classLockSymbol = Symbol(\"class-lock\");\nvar synchronized = (target, propertyName, descriptor) => {\n  const method = descriptor.value;\n  descriptor.value = function(...args) {\n    var _a;\n    const lock = (_a = this[classLockSymbol]) != null ? _a : this[classLockSymbol] = new Lock();\n    return lock.executeSynchronized(() => method.apply(this, args));\n  };\n};\n\n// packages/common/async/src/sink.ts\nvar sink = (emitter, event, count = 1) => {\n  const [getPromise, resolve] = trigger();\n  let counter = 0;\n  const listener = () => {\n    if (++counter === count) {\n      emitter.off(event, listener);\n      resolve();\n    }\n  };\n  emitter.on(event, listener);\n  return getPromise();\n};\n\n// packages/common/async/src/testing.ts\nvar waitForCondition = (condition, timeout = 0, interval = 10) => {\n  const stopTime = timeout ? Date.now() + timeout : 0;\n  const [provider, resolver] = trigger();\n  const waiter = async () => {\n    while (!stopTime || Date.now() < stopTime) {\n      try {\n        const value = await condition();\n        if (value) {\n          resolver(value);\n          break;\n        }\n      } catch (err) {\n      }\n      await sleep(interval);\n    }\n  };\n  setTimeout(waiter, 0);\n  return timeout ? asyncTimeout(provider(), timeout, new Error(\"Timeout\")) : provider();\n};\n\n// packages/common/async/src/stream-to-array.ts\nvar streamToArray = (stream) => {\n  let deferred;\n  if (!stream.readable) {\n    deferred = Promise.resolve([]);\n  } else {\n    deferred = new Promise((resolve, reject) => {\n      if (!stream.readable) {\n        return resolve([]);\n      }\n      let arr = [];\n      const onData = (doc) => {\n        arr == null ? void 0 : arr.push(doc);\n      };\n      const onEnd = (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(arr);\n        }\n        cleanup();\n      };\n      const onClose = () => {\n        resolve(arr);\n        cleanup();\n      };\n      const cleanup = () => {\n        arr = [];\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"error\", onEnd);\n        stream.removeListener(\"close\", onClose);\n      };\n      stream.on(\"data\", onData);\n      stream.on(\"end\", onEnd);\n      stream.on(\"error\", onEnd);\n      stream.on(\"close\", onClose);\n    });\n  }\n  return deferred;\n};\n\n// packages/common/async/src/until.ts\nvar until = (cb, timeout) => {\n  return new Promise((resolve, reject) => {\n    const t = timeout && setTimeout(() => {\n      reject(new Error(`Timeout after ${t}ms`));\n    }, timeout);\n    setTimeout(async () => {\n      try {\n        await cb((value) => {\n          t && clearTimeout(t);\n          resolve(value);\n        }, (error) => {\n          t && clearTimeout(t);\n          reject(error);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\nvar untilPromise = (cb) => cb();\nvar untilError = (cb) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(async () => {\n      try {\n        await cb();\n        reject(new Error(\"No error was thrown.\"));\n      } catch (err) {\n        resolve(err);\n      }\n    });\n  });\n};\nexport {\n  CancellableObservableProvider,\n  DeferredTask,\n  Event,\n  EventSubscriptions,\n  Lock,\n  ObservableProvider,\n  TimeoutError,\n  Trigger,\n  addListener,\n  asyncChain,\n  asyncTimeout,\n  createPromiseFromCallback,\n  latch,\n  observableError,\n  onEvent,\n  runInContext,\n  runInContextAsync,\n  scheduleTask,\n  scheduleTaskInterval,\n  sink,\n  sleep,\n  streamToArray,\n  synchronized,\n  toError,\n  trigger,\n  until,\n  untilError,\n  untilPromise,\n  waitForCondition,\n  waitForEvent\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465048,"end":1670465465327},{"name":"vite:react-babel","result":"// packages/common/async/src/callback.ts\nvar createPromiseFromCallback = (run) => new Promise((resolve, reject) => {\n  run((error, value) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(value);\n    }\n  });\n});\n\n// packages/common/async/src/chain.ts\nvar asyncChain = (chain) => async (elements) => {\n  let result = await Promise.resolve(elements);\n  for (const part of chain) {\n    result = await Promise.all(result.map(async (element) => await part(element)));\n  }\n  return result;\n};\n\n// packages/common/async/src/errors.ts\nvar toError = (err) => err === void 0 || typeof err === \"string\" ? new Error(err) : err;\nvar TimeoutError = class extends Error {\n  constructor(timeout, label) {\n    super(timeout ? `Timeout [${timeout}ms]${label === void 0 ? \"\" : ` :${label}`}` : \"Timeout\");\n  }\n};\nvar observableError = (observable, err) => {\n  var _a, _b;\n  if (err instanceof TimeoutError) {\n    (_b = (_a = observable.callback).onTimeout) == null ? void 0 : _b.call(_a, err);\n  } else {\n    observable.callback.onError(toError(err));\n  }\n};\n\n// packages/common/async/src/timeout.ts\nvar sleep = (ms) => {\n  return new Promise((resolve) => {\n    const finish = Date.now() + ms;\n    const sleeper = () => {\n      const delta = finish - Date.now();\n      if (delta > 0) {\n        setTimeout(sleeper, delta);\n      } else {\n        resolve();\n      }\n    };\n    sleeper();\n  });\n};\nvar asyncTimeout = (promise, timeout, err) => {\n  const throwable = err === void 0 || typeof err === \"string\" ? new TimeoutError(timeout, err) : err;\n  const conditionTimeout = typeof promise === \"function\" ? createPromiseFromCallback(promise) : promise;\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      reject(throwable);\n    }, timeout);\n    if (typeof timeoutId === \"object\" && \"unref\" in timeoutId) {\n      timeoutId.unref();\n    }\n  });\n  return Promise.race([\n    conditionTimeout,\n    timeoutPromise\n  ]).finally(() => {\n    clearTimeout(timeoutId);\n  });\n};\n\n// packages/common/async/src/event-emitter.ts\nvar onEvent = (eventEmitter, eventName, callback) => {\n  eventEmitter.on(eventName, callback);\n  return () => eventEmitter.off(eventName, callback);\n};\nvar addListener = (eventEmitter, eventName, callback) => {\n  const off = onEvent(eventEmitter, eventName, callback);\n  return {\n    remove: () => off()\n  };\n};\nvar waitForEvent = (eventEmitter, eventName, test, timeout, error) => {\n  let off;\n  const promise = new Promise((resolve) => {\n    off = onEvent(eventEmitter, eventName, (...args) => {\n      if (!test || test(...args)) {\n        resolve(...args);\n      }\n    });\n  });\n  return timeout ? asyncTimeout(promise, timeout, error != null ? error : new Error()).finally(off) : promise.finally(off);\n};\n\n// packages/common/async/src/events.ts\nimport { Context } from \"@dxos/context\";\n\n// packages/common/async/src/task-scheduling.ts\nvar DeferredTask = class {\n  constructor(_ctx, _callback) {\n    this._ctx = _ctx;\n    this._callback = _callback;\n    this._scheduled = false;\n    this._promise = null;\n  }\n  schedule() {\n    if (this._scheduled) {\n      return;\n    }\n    scheduleTask(this._ctx, async () => {\n      await this._promise;\n      this._scheduled = false;\n      this._promise = runInContextAsync(this._ctx, () => this._callback());\n    });\n    this._scheduled = true;\n  }\n};\nvar runInContext = (ctx, fn) => {\n  try {\n    fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar runInContextAsync = async (ctx, fn) => {\n  try {\n    await fn();\n  } catch (err) {\n    ctx.raise(err);\n  }\n};\nvar scheduleTask = (ctx, fn, afterMs) => {\n  const timeout = setTimeout(async () => {\n    await runInContextAsync(ctx, fn);\n  }, afterMs);\n  ctx.onDispose(() => {\n    clearTimeout(timeout);\n  });\n};\nvar scheduleTaskInterval = (ctx, task, interval) => {\n  const run = async () => {\n    await task();\n    scheduleTask(ctx, run, interval);\n  };\n  scheduleTask(ctx, run, interval);\n};\n\n// packages/common/async/src/events.ts\nvar EventSubscriptions = class {\n  constructor() {\n    this._listeners = [];\n  }\n  add(cb) {\n    this._listeners.push(cb);\n  }\n  clear() {\n    this._listeners.forEach((cb) => cb());\n    this._listeners.length = 0;\n  }\n};\nvar Event = class {\n  constructor() {\n    this._listeners = /* @__PURE__ */ new Map();\n    this._onceListeners = /* @__PURE__ */ new Map();\n    this._effects = /* @__PURE__ */ new Set();\n  }\n  static wrap(emitter, eventName) {\n    const event = new Event();\n    event.addEffect(() => {\n      const onEvent2 = (data) => event.emit(data);\n      emitter.on(eventName, onEvent2);\n      return () => emitter.off(eventName, onEvent2);\n    });\n    return event;\n  }\n  emit(data) {\n    for (const [_key, listener] of this._listeners) {\n      listener(data);\n    }\n    for (const [_key1, listener1] of this._onceListeners) {\n      listener1(data);\n      this._onceListeners.delete(_key1);\n    }\n  }\n  on(_ctx, _callback) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    const runCallback = (data) => runInContextAsync(ctx, () => callback(data));\n    this._listeners.set(callback, runCallback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    ctx.onDispose(() => this.off(callback));\n    return () => this.off(callback);\n  }\n  off(callback) {\n    this._listeners.delete(callback);\n    this._onceListeners.delete(callback);\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  once(_ctx, _callback) {\n    const [ctx, callback] = _ctx instanceof Context ? [\n      _ctx,\n      _callback\n    ] : [\n      new Context(),\n      _ctx\n    ];\n    if (this._listeners.has(callback)) {\n      return () => {\n      };\n    }\n    const runCallback = (data) => runInContextAsync(ctx, () => callback(data));\n    this._onceListeners.set(callback, runCallback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    return () => {\n      this._onceListeners.delete(callback);\n      if (this.listenerCount() === 0) {\n        this._runEffects();\n      }\n    };\n  }\n  async *[Symbol.asyncIterator]() {\n    while (true) {\n      yield await new Promise((resolve) => {\n        this.once(resolve);\n      });\n    }\n  }\n  waitFor(predicate) {\n    return new Promise((resolve) => {\n      const unsubscribe = this.on((data) => {\n        if (predicate(data)) {\n          unsubscribe();\n          resolve(data);\n        }\n      });\n    });\n  }\n  waitForCount(expectedCount) {\n    let count = 0;\n    return this.waitFor(() => ++count === expectedCount);\n  }\n  async waitForCondition(predicate) {\n    if (!predicate()) {\n      await this.waitFor(predicate);\n    }\n  }\n  listenerCount() {\n    return this._listeners.size + this._onceListeners.size;\n  }\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: void 0\n    };\n    if (this.listenerCount() > 0) {\n      handle.cleanup = handle.effect();\n    }\n    this._effects.add(handle);\n    return () => {\n      var _a;\n      (_a = handle.cleanup) == null ? void 0 : _a.call(handle);\n      this._effects.delete(handle);\n    };\n  }\n  debounce(timeout = 0) {\n    const debouncedEvent = new Event();\n    let firing = false;\n    debouncedEvent.addEffect(() => this.on(() => {\n      if (!firing) {\n        firing = true;\n        setTimeout(() => {\n          firing = false;\n          debouncedEvent.emit();\n        }, timeout);\n      }\n    }));\n    return debouncedEvent;\n  }\n  discardParameter() {\n    return this;\n  }\n  toJSON() {\n    return {\n      listenerCount: this.listenerCount()\n    };\n  }\n  _runEffects() {\n    for (const handle of this._effects) {\n      handle.cleanup = handle.effect();\n    }\n  }\n  _cleanupEffects() {\n    var _a;\n    for (const handle of this._effects) {\n      (_a = handle.cleanup) == null ? void 0 : _a.call(handle);\n      handle.cleanup = void 0;\n    }\n  }\n};\n\n// packages/common/async/src/latch.ts\nimport assert from \"@dxos/node-std/assert\";\nvar latch = ({ count = 1, timeout } = {}) => {\n  assert(count >= 0);\n  let t;\n  let doResolve;\n  let doReject;\n  const promise = new Promise((resolve, reject) => {\n    doResolve = (value) => {\n      clearTimeout(t);\n      resolve(value);\n    };\n    doReject = (err) => {\n      clearTimeout(t);\n      reject(err);\n    };\n  });\n  if (count === 0) {\n    setTimeout(() => {\n      doResolve(0);\n    });\n  } else {\n    if (timeout) {\n      t = setTimeout(() => {\n        doReject(new Error(`Timed out after ${timeout}ms`));\n      }, timeout);\n    }\n  }\n  let i = 0;\n  return [\n    async () => await promise,\n    () => {\n      if (++i === count) {\n        doResolve(i);\n      }\n      return i;\n    },\n    (err) => doReject(err)\n  ];\n};\n\n// packages/common/async/src/observable.ts\nimport { createSetDispatch } from \"@dxos/util\";\nvar ObservableProvider = class {\n  constructor() {\n    this._handlers = /* @__PURE__ */ new Set();\n    this._proxy = createSetDispatch({\n      handlers: this._handlers\n    });\n  }\n  get callback() {\n    return this._proxy;\n  }\n  subscribe(handler) {\n    this._handlers.add(handler);\n    return () => {\n      this._handlers.delete(handler);\n    };\n  }\n};\nvar CancellableObservableProvider = class extends ObservableProvider {\n  constructor(_handleCancel) {\n    super();\n    this._handleCancel = _handleCancel;\n    this._cancelled = false;\n  }\n  get cancelled() {\n    return this._cancelled;\n  }\n  async cancel() {\n    var _a, _b, _c;\n    if (this._cancelled) {\n      return;\n    }\n    this._cancelled = true;\n    await ((_a = this._handleCancel) == null ? void 0 : _a.call(this));\n    (_c = (_b = this.callback).onCancelled) == null ? void 0 : _c.call(_b);\n  }\n};\n\n// packages/common/async/src/trigger.ts\nvar trigger = (timeout) => {\n  let callback;\n  const promise = new Promise((resolve, reject) => {\n    if (timeout) {\n      setTimeout(() => reject(new Error(`Timed out after ${timeout}ms`)), timeout);\n    }\n    callback = resolve;\n  });\n  const provider = () => promise;\n  const resolver = (value) => callback(value);\n  return [\n    provider,\n    resolver\n  ];\n};\nvar Trigger = class {\n  constructor(_options = {\n    autoReset: false\n  }) {\n    this._options = _options;\n    this.reset();\n  }\n  async wait({ timeout } = {}) {\n    if (timeout) {\n      return asyncTimeout(this._promise, timeout, new Error(`Timed out after ${timeout}ms.`));\n    } else {\n      return this._promise;\n    }\n  }\n  wake(value) {\n    this._wake(value);\n    if (this._options.autoReset) {\n      return this.reset();\n    }\n    return this;\n  }\n  reset() {\n    this._promise = new Promise((resolve) => {\n      this._wake = resolve;\n    });\n    return this;\n  }\n};\n\n// packages/common/async/src/lock.ts\nvar Lock = class {\n  constructor() {\n    this._lastPromise = Promise.resolve();\n  }\n  async executeSynchronized(fun) {\n    const prevPromise = this._lastPromise;\n    const [getPromise, resolve] = trigger();\n    this._lastPromise = getPromise();\n    await prevPromise;\n    try {\n      return await fun();\n    } finally {\n      resolve();\n    }\n  }\n};\nvar classLockSymbol = Symbol(\"class-lock\");\nvar synchronized = (target, propertyName, descriptor) => {\n  const method = descriptor.value;\n  descriptor.value = function(...args) {\n    var _a;\n    const lock = (_a = this[classLockSymbol]) != null ? _a : this[classLockSymbol] = new Lock();\n    return lock.executeSynchronized(() => method.apply(this, args));\n  };\n};\n\n// packages/common/async/src/sink.ts\nvar sink = (emitter, event, count = 1) => {\n  const [getPromise, resolve] = trigger();\n  let counter = 0;\n  const listener = () => {\n    if (++counter === count) {\n      emitter.off(event, listener);\n      resolve();\n    }\n  };\n  emitter.on(event, listener);\n  return getPromise();\n};\n\n// packages/common/async/src/testing.ts\nvar waitForCondition = (condition, timeout = 0, interval = 10) => {\n  const stopTime = timeout ? Date.now() + timeout : 0;\n  const [provider, resolver] = trigger();\n  const waiter = async () => {\n    while (!stopTime || Date.now() < stopTime) {\n      try {\n        const value = await condition();\n        if (value) {\n          resolver(value);\n          break;\n        }\n      } catch (err) {\n      }\n      await sleep(interval);\n    }\n  };\n  setTimeout(waiter, 0);\n  return timeout ? asyncTimeout(provider(), timeout, new Error(\"Timeout\")) : provider();\n};\n\n// packages/common/async/src/stream-to-array.ts\nvar streamToArray = (stream) => {\n  let deferred;\n  if (!stream.readable) {\n    deferred = Promise.resolve([]);\n  } else {\n    deferred = new Promise((resolve, reject) => {\n      if (!stream.readable) {\n        return resolve([]);\n      }\n      let arr = [];\n      const onData = (doc) => {\n        arr == null ? void 0 : arr.push(doc);\n      };\n      const onEnd = (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(arr);\n        }\n        cleanup();\n      };\n      const onClose = () => {\n        resolve(arr);\n        cleanup();\n      };\n      const cleanup = () => {\n        arr = [];\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"error\", onEnd);\n        stream.removeListener(\"close\", onClose);\n      };\n      stream.on(\"data\", onData);\n      stream.on(\"end\", onEnd);\n      stream.on(\"error\", onEnd);\n      stream.on(\"close\", onClose);\n    });\n  }\n  return deferred;\n};\n\n// packages/common/async/src/until.ts\nvar until = (cb, timeout) => {\n  return new Promise((resolve, reject) => {\n    const t = timeout && setTimeout(() => {\n      reject(new Error(`Timeout after ${t}ms`));\n    }, timeout);\n    setTimeout(async () => {\n      try {\n        await cb((value) => {\n          t && clearTimeout(t);\n          resolve(value);\n        }, (error) => {\n          t && clearTimeout(t);\n          reject(error);\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\nvar untilPromise = (cb) => cb();\nvar untilError = (cb) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(async () => {\n      try {\n        await cb();\n        reject(new Error(\"No error was thrown.\"));\n      } catch (err) {\n        resolve(err);\n      }\n    });\n  });\n};\nexport {\n  CancellableObservableProvider,\n  DeferredTask,\n  Event,\n  EventSubscriptions,\n  Lock,\n  ObservableProvider,\n  TimeoutError,\n  Trigger,\n  addListener,\n  asyncChain,\n  asyncTimeout,\n  createPromiseFromCallback,\n  latch,\n  observableError,\n  onEvent,\n  runInContext,\n  runInContextAsync,\n  scheduleTask,\n  scheduleTaskInterval,\n  sink,\n  sleep,\n  streamToArray,\n  synchronized,\n  toError,\n  trigger,\n  until,\n  untilError,\n  untilPromise,\n  waitForCondition,\n  waitForEvent\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465327,"end":1670465465327,"order":"pre"}]}
