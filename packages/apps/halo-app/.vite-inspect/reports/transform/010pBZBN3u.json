{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/async_iterator.js","transforms":[{"name":"vite:load-fallback","result":"'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","start":1670465470090,"end":1670465470176},{"name":"vite:react-babel","result":"'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","start":1670465470176,"end":1670465470176,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?commonjs-proxy\";\n\nvar async_iterator;\nvar hasRequiredAsync_iterator;\n\nfunction requireAsync_iterator () {\n\tif (hasRequiredAsync_iterator) return async_iterator;\n\thasRequiredAsync_iterator = 1;\n\t'use strict';\n\n\tvar _Object$setPrototypeO;\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar finished = require$$0;\n\n\tvar kLastResolve = Symbol('lastResolve');\n\tvar kLastReject = Symbol('lastReject');\n\tvar kError = Symbol('error');\n\tvar kEnded = Symbol('ended');\n\tvar kLastPromise = Symbol('lastPromise');\n\tvar kHandlePromise = Symbol('handlePromise');\n\tvar kStream = Symbol('stream');\n\n\tfunction createIterResult(value, done) {\n\t  return {\n\t    value: value,\n\t    done: done\n\t  };\n\t}\n\n\tfunction readAndResolve(iter) {\n\t  var resolve = iter[kLastResolve];\n\n\t  if (resolve !== null) {\n\t    var data = iter[kStream].read(); // we defer if data is null\n\t    // we can be expecting either 'end' or\n\t    // 'error'\n\n\t    if (data !== null) {\n\t      iter[kLastPromise] = null;\n\t      iter[kLastResolve] = null;\n\t      iter[kLastReject] = null;\n\t      resolve(createIterResult(data, false));\n\t    }\n\t  }\n\t}\n\n\tfunction onReadable(iter) {\n\t  // we wait for the next tick, because it might\n\t  // emit an error with process.nextTick\n\t  process.nextTick(readAndResolve, iter);\n\t}\n\n\tfunction wrapForNext(lastPromise, iter) {\n\t  return function (resolve, reject) {\n\t    lastPromise.then(function () {\n\t      if (iter[kEnded]) {\n\t        resolve(createIterResult(undefined, true));\n\t        return;\n\t      }\n\n\t      iter[kHandlePromise](resolve, reject);\n\t    }, reject);\n\t  };\n\t}\n\n\tvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\n\tvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n\t  get stream() {\n\t    return this[kStream];\n\t  },\n\n\t  next: function next() {\n\t    var _this = this;\n\n\t    // if we have detected an error in the meanwhile\n\t    // reject straight away\n\t    var error = this[kError];\n\n\t    if (error !== null) {\n\t      return Promise.reject(error);\n\t    }\n\n\t    if (this[kEnded]) {\n\t      return Promise.resolve(createIterResult(undefined, true));\n\t    }\n\n\t    if (this[kStream].destroyed) {\n\t      // We need to defer via nextTick because if .destroy(err) is\n\t      // called, the error will be emitted via nextTick, and\n\t      // we cannot guarantee that there is no error lingering around\n\t      // waiting to be emitted.\n\t      return new Promise(function (resolve, reject) {\n\t        process.nextTick(function () {\n\t          if (_this[kError]) {\n\t            reject(_this[kError]);\n\t          } else {\n\t            resolve(createIterResult(undefined, true));\n\t          }\n\t        });\n\t      });\n\t    } // if we have multiple next() calls\n\t    // we will wait for the previous Promise to finish\n\t    // this logic is optimized to support for await loops,\n\t    // where next() is only called once at a time\n\n\n\t    var lastPromise = this[kLastPromise];\n\t    var promise;\n\n\t    if (lastPromise) {\n\t      promise = new Promise(wrapForNext(lastPromise, this));\n\t    } else {\n\t      // fast path needed to support multiple this.push()\n\t      // without triggering the next() queue\n\t      var data = this[kStream].read();\n\n\t      if (data !== null) {\n\t        return Promise.resolve(createIterResult(data, false));\n\t      }\n\n\t      promise = new Promise(this[kHandlePromise]);\n\t    }\n\n\t    this[kLastPromise] = promise;\n\t    return promise;\n\t  }\n\t}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n\t  return this;\n\t}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n\t  var _this2 = this;\n\n\t  // destroy(err, cb) is a private API\n\t  // we can guarantee we have that here, because we control the\n\t  // Readable class this is attached to\n\t  return new Promise(function (resolve, reject) {\n\t    _this2[kStream].destroy(null, function (err) {\n\t      if (err) {\n\t        reject(err);\n\t        return;\n\t      }\n\n\t      resolve(createIterResult(undefined, true));\n\t    });\n\t  });\n\t}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\n\tvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n\t  var _Object$create;\n\n\t  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n\t    value: stream,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kLastResolve, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kLastReject, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kError, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kEnded, {\n\t    value: stream._readableState.endEmitted,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kHandlePromise, {\n\t    value: function value(resolve, reject) {\n\t      var data = iterator[kStream].read();\n\n\t      if (data) {\n\t        iterator[kLastPromise] = null;\n\t        iterator[kLastResolve] = null;\n\t        iterator[kLastReject] = null;\n\t        resolve(createIterResult(data, false));\n\t      } else {\n\t        iterator[kLastResolve] = resolve;\n\t        iterator[kLastReject] = reject;\n\t      }\n\t    },\n\t    writable: true\n\t  }), _Object$create));\n\t  iterator[kLastPromise] = null;\n\t  finished(stream, function (err) {\n\t    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n\t      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n\t      // returned by next() and store the error\n\n\t      if (reject !== null) {\n\t        iterator[kLastPromise] = null;\n\t        iterator[kLastResolve] = null;\n\t        iterator[kLastReject] = null;\n\t        reject(err);\n\t      }\n\n\t      iterator[kError] = err;\n\t      return;\n\t    }\n\n\t    var resolve = iterator[kLastResolve];\n\n\t    if (resolve !== null) {\n\t      iterator[kLastPromise] = null;\n\t      iterator[kLastResolve] = null;\n\t      iterator[kLastReject] = null;\n\t      resolve(createIterResult(undefined, true));\n\t    }\n\n\t    iterator[kEnded] = true;\n\t  });\n\t  stream.on('readable', onReadable.bind(null, iterator));\n\t  return iterator;\n\t};\n\n\tasync_iterator = createReadableStreamAsyncIterator;\n\treturn async_iterator;\n}\n\nexport { requireAsync_iterator as __require };","start":1670465470176,"end":1670465470179,"order":"normal"},{"name":"polyfill-node","result":"import { default as process } from '\u0000polyfill-node.process';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?commonjs-proxy\";\n\nvar async_iterator;\nvar hasRequiredAsync_iterator;\n\nfunction requireAsync_iterator () {\n\tif (hasRequiredAsync_iterator) return async_iterator;\n\thasRequiredAsync_iterator = 1;\n\t'use strict';\n\n\tvar _Object$setPrototypeO;\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar finished = require$$0;\n\n\tvar kLastResolve = Symbol('lastResolve');\n\tvar kLastReject = Symbol('lastReject');\n\tvar kError = Symbol('error');\n\tvar kEnded = Symbol('ended');\n\tvar kLastPromise = Symbol('lastPromise');\n\tvar kHandlePromise = Symbol('handlePromise');\n\tvar kStream = Symbol('stream');\n\n\tfunction createIterResult(value, done) {\n\t  return {\n\t    value: value,\n\t    done: done\n\t  };\n\t}\n\n\tfunction readAndResolve(iter) {\n\t  var resolve = iter[kLastResolve];\n\n\t  if (resolve !== null) {\n\t    var data = iter[kStream].read(); // we defer if data is null\n\t    // we can be expecting either 'end' or\n\t    // 'error'\n\n\t    if (data !== null) {\n\t      iter[kLastPromise] = null;\n\t      iter[kLastResolve] = null;\n\t      iter[kLastReject] = null;\n\t      resolve(createIterResult(data, false));\n\t    }\n\t  }\n\t}\n\n\tfunction onReadable(iter) {\n\t  // we wait for the next tick, because it might\n\t  // emit an error with process.nextTick\n\t  process.nextTick(readAndResolve, iter);\n\t}\n\n\tfunction wrapForNext(lastPromise, iter) {\n\t  return function (resolve, reject) {\n\t    lastPromise.then(function () {\n\t      if (iter[kEnded]) {\n\t        resolve(createIterResult(undefined, true));\n\t        return;\n\t      }\n\n\t      iter[kHandlePromise](resolve, reject);\n\t    }, reject);\n\t  };\n\t}\n\n\tvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\n\tvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n\t  get stream() {\n\t    return this[kStream];\n\t  },\n\n\t  next: function next() {\n\t    var _this = this;\n\n\t    // if we have detected an error in the meanwhile\n\t    // reject straight away\n\t    var error = this[kError];\n\n\t    if (error !== null) {\n\t      return Promise.reject(error);\n\t    }\n\n\t    if (this[kEnded]) {\n\t      return Promise.resolve(createIterResult(undefined, true));\n\t    }\n\n\t    if (this[kStream].destroyed) {\n\t      // We need to defer via nextTick because if .destroy(err) is\n\t      // called, the error will be emitted via nextTick, and\n\t      // we cannot guarantee that there is no error lingering around\n\t      // waiting to be emitted.\n\t      return new Promise(function (resolve, reject) {\n\t        process.nextTick(function () {\n\t          if (_this[kError]) {\n\t            reject(_this[kError]);\n\t          } else {\n\t            resolve(createIterResult(undefined, true));\n\t          }\n\t        });\n\t      });\n\t    } // if we have multiple next() calls\n\t    // we will wait for the previous Promise to finish\n\t    // this logic is optimized to support for await loops,\n\t    // where next() is only called once at a time\n\n\n\t    var lastPromise = this[kLastPromise];\n\t    var promise;\n\n\t    if (lastPromise) {\n\t      promise = new Promise(wrapForNext(lastPromise, this));\n\t    } else {\n\t      // fast path needed to support multiple this.push()\n\t      // without triggering the next() queue\n\t      var data = this[kStream].read();\n\n\t      if (data !== null) {\n\t        return Promise.resolve(createIterResult(data, false));\n\t      }\n\n\t      promise = new Promise(this[kHandlePromise]);\n\t    }\n\n\t    this[kLastPromise] = promise;\n\t    return promise;\n\t  }\n\t}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n\t  return this;\n\t}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n\t  var _this2 = this;\n\n\t  // destroy(err, cb) is a private API\n\t  // we can guarantee we have that here, because we control the\n\t  // Readable class this is attached to\n\t  return new Promise(function (resolve, reject) {\n\t    _this2[kStream].destroy(null, function (err) {\n\t      if (err) {\n\t        reject(err);\n\t        return;\n\t      }\n\n\t      resolve(createIterResult(undefined, true));\n\t    });\n\t  });\n\t}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\n\tvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n\t  var _Object$create;\n\n\t  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n\t    value: stream,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kLastResolve, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kLastReject, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kError, {\n\t    value: null,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kEnded, {\n\t    value: stream._readableState.endEmitted,\n\t    writable: true\n\t  }), _defineProperty(_Object$create, kHandlePromise, {\n\t    value: function value(resolve, reject) {\n\t      var data = iterator[kStream].read();\n\n\t      if (data) {\n\t        iterator[kLastPromise] = null;\n\t        iterator[kLastResolve] = null;\n\t        iterator[kLastReject] = null;\n\t        resolve(createIterResult(data, false));\n\t      } else {\n\t        iterator[kLastResolve] = resolve;\n\t        iterator[kLastReject] = reject;\n\t      }\n\t    },\n\t    writable: true\n\t  }), _Object$create));\n\t  iterator[kLastPromise] = null;\n\t  finished(stream, function (err) {\n\t    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n\t      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n\t      // returned by next() and store the error\n\n\t      if (reject !== null) {\n\t        iterator[kLastPromise] = null;\n\t        iterator[kLastResolve] = null;\n\t        iterator[kLastReject] = null;\n\t        reject(err);\n\t      }\n\n\t      iterator[kError] = err;\n\t      return;\n\t    }\n\n\t    var resolve = iterator[kLastResolve];\n\n\t    if (resolve !== null) {\n\t      iterator[kLastPromise] = null;\n\t      iterator[kLastResolve] = null;\n\t      iterator[kLastReject] = null;\n\t      resolve(createIterResult(undefined, true));\n\t    }\n\n\t    iterator[kEnded] = true;\n\t  });\n\t  stream.on('readable', onReadable.bind(null, iterator));\n\t  return iterator;\n\t};\n\n\tasync_iterator = createReadableStreamAsyncIterator;\n\treturn async_iterator;\n}\n\nexport { requireAsync_iterator as __require };","start":1670465470179,"end":1670465470180,"order":"normal"}]}
