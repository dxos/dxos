{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/messaging/src/memory-signal-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { ComplexMap, ComplexSet } from \"@dxos/util\";\nvar MemorySignalManagerContext = class {\n  constructor() {\n    this.swarmEvent = new Event();\n    this.swarms = new ComplexMap(PublicKey.hash);\n    this.connections = new ComplexMap(PublicKey.hash);\n  }\n};\nvar MemorySignalManager = class {\n  constructor(_context) {\n    this._context = _context;\n    this.statusChanged = new Event();\n    this.commandTrace = new Event();\n    this.swarmEvent = new Event();\n    this.onMessage = new Event();\n    this._context.swarmEvent.on((data) => this.swarmEvent.emit(data));\n  }\n  getStatus() {\n    return [];\n  }\n  async join({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).add(peerId);\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent: {\n        peerAvailable: {\n          peer: peerId.asUint8Array(),\n          since: new Date()\n        }\n      }\n    });\n    for (const [topic1, peerIds] of this._context.swarms) {\n      Array.from(peerIds).forEach((peerId2) => {\n        this.swarmEvent.emit({\n          topic: topic1,\n          swarmEvent: {\n            peerAvailable: {\n              peer: peerId2.asUint8Array(),\n              since: new Date()\n            }\n          }\n        });\n      });\n    }\n  }\n  async leave({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).delete(peerId);\n    const swarmEvent = {\n      peerLeft: {\n        peer: peerId.asUint8Array()\n      }\n    };\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent\n    });\n  }\n  async sendMessage({ author, recipient, payload }) {\n    assert(recipient);\n    if (!this._context.connections.has(recipient)) {\n      log.warn(\"recipient is not subscribed for messages\", {\n        author,\n        recipient\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n        line: 113,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    this._context.connections.get(recipient).onMessage.emit({\n      author,\n      recipient,\n      payload\n    });\n  }\n  async subscribeMessages(peerId) {\n    log(\"subscribing\", {\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._context.connections.set(peerId, this);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/messaging/src/messenger.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap as ComplexMap2, ComplexSet as ComplexSet2, exponentialBackoffInterval } from \"@dxos/util\";\nvar Messenger = class {\n  constructor({ signalManager, retryDelay = 100, timeout = 3e3 }) {\n    this._listeners = new ComplexMap2(({ peerId, payloadType }) => peerId.toHex() + payloadType);\n    this._defaultListeners = new ComplexMap2(PublicKey2.hash);\n    this._onAckCallbacks = new ComplexMap2(PublicKey2.hash);\n    this._receivedMessages = new ComplexSet2((key) => key.toHex());\n    this._subscriptions = new EventSubscriptions();\n    this._signalManager = signalManager;\n    this._signalManager.onMessage.on(async (message) => {\n      log2(\"received message\", {\n        from: message.author\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._handleMessage(message);\n    });\n    this._retryDelay = retryDelay;\n    this._timeout = timeout;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    const reliablePayload = {\n      messageId: PublicKey2.random(),\n      payload\n    };\n    log2(\"sent message\", {\n      messageId: reliablePayload.messageId,\n      author,\n      recipient\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 61,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const cancelRetry = exponentialBackoffInterval(async () => {\n      log2(\"retrying message\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      try {\n        await this._encodeAndSend({\n          author,\n          recipient,\n          reliablePayload\n        });\n      } catch (error) {\n        log2.error(\"failed to send message\", {\n          error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n          line: 69,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }, this._retryDelay);\n    const timeout = setTimeout(() => {\n      log2(\"message not delivered\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 74,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n    }, this._timeout);\n    assert2(!this._onAckCallbacks.has(reliablePayload.messageId));\n    this._onAckCallbacks.set(reliablePayload.messageId, () => {\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    this._subscriptions.add(() => {\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      reliablePayload\n    });\n  }\n  async listen({ peerId, payloadType, onMessage }) {\n    await this._signalManager.subscribeMessages(peerId);\n    let listeners;\n    if (!payloadType) {\n      listeners = this._defaultListeners.get(peerId);\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._defaultListeners.set(peerId, listeners);\n      }\n    } else {\n      listeners = this._listeners.get({\n        peerId,\n        payloadType\n      });\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._listeners.set({\n          peerId,\n          payloadType\n        }, listeners);\n      }\n    }\n    listeners.add(onMessage);\n    return {\n      unsubscribe: async () => {\n        listeners.delete(onMessage);\n      }\n    };\n  }\n  async _encodeAndSend({ author, recipient, reliablePayload }) {\n    await this._signalManager.sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.messaging.ReliablePayload\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").encode(reliablePayload, {\n          preserveAny: true\n        })\n      }\n    });\n  }\n  async _handleMessage(message) {\n    switch (message.payload.type_url) {\n      case \"dxos.mesh.messaging.ReliablePayload\": {\n        await this._handleReliablePayload(message);\n        break;\n      }\n      case \"dxos.mesh.messaging.Acknowledgement\": {\n        await this._handleAcknowledgement({\n          payload: message.payload\n        });\n        break;\n      }\n    }\n  }\n  async _handleReliablePayload({ author, recipient, payload }) {\n    assert2(payload.type_url === \"dxos.mesh.messaging.ReliablePayload\");\n    const reliablePayload = schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").decode(payload.value, {\n      preserveAny: true\n    });\n    log2(\"handling message\", {\n      messageId: reliablePayload.messageId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 173,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._receivedMessages.has(reliablePayload.messageId)) {\n      return;\n    }\n    this._receivedMessages.add(reliablePayload.messageId);\n    await this._sendAcknowledgement({\n      author,\n      recipient,\n      messageId: reliablePayload.messageId\n    });\n    await this._callListeners({\n      author,\n      recipient,\n      payload: reliablePayload.payload\n    });\n  }\n  async _handleAcknowledgement({ payload }) {\n    var _a;\n    assert2(payload.type_url === \"dxos.mesh.messaging.Acknowledgement\");\n    (_a = this._onAckCallbacks.get(schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").decode(payload.value).messageId)) == null ? void 0 : _a();\n  }\n  async _sendAcknowledgement({ author, recipient, messageId }) {\n    log2(\"sending ACK\", {\n      messageId,\n      from: recipient,\n      to: author\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 208,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._signalManager.sendMessage({\n      author: recipient,\n      recipient: author,\n      payload: {\n        type_url: \"dxos.mesh.messaging.Acknowledgement\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").encode({\n          messageId\n        })\n      }\n    });\n  }\n  async _callListeners(message) {\n    {\n      const defaultListenerMap = this._defaultListeners.get(message.recipient);\n      if (defaultListenerMap) {\n        for (const listener of defaultListenerMap) {\n          await listener(message);\n        }\n      }\n    }\n    {\n      const listenerMap = this._listeners.get({\n        peerId: message.recipient,\n        payloadType: message.payload.type_url\n      });\n      if (listenerMap) {\n        for (const listener1 of listenerMap) {\n          await listener1(message);\n        }\n      }\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, EventSubscriptions as EventSubscriptions2, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/mesh/messaging/src/signal-rpc-client.ts\nimport WebSocket from \"isomorphic-ws\";\nimport { Trigger, Event as Event2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar SignalRPCClient = class {\n  constructor(_url) {\n    this._url = _url;\n    this._connectTrigger = new Trigger();\n    this.connected = new Event2();\n    this.disconnected = new Event2();\n    this.error = new Event2();\n    this._socket = new WebSocket(this._url);\n    this._socket.onopen = async () => {\n      try {\n        await this._rpc.open();\n        log3(`RPC open ${this._url}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n          line: 36,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.connected.emit();\n        this._connectTrigger.wake();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onclose = async () => {\n      log3(`Disconnected ${this._url}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.disconnected.emit();\n      try {\n        await this._rpc.close();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onerror = (event) => {\n      var _a;\n      log3.error(event.message, {\n        url: this._url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.error.emit((_a = event.error) != null ? _a : new Error(event.message));\n    };\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Signal: schema2.getService(\"dxos.mesh.signal.Signal\")\n      },\n      noHandshake: true,\n      port: {\n        send: (msg) => {\n          this._socket.send(msg);\n        },\n        subscribe: (cb) => {\n          this._socket.onmessage = async (msg) => {\n            if (typeof Blob !== \"undefined\" && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data);\n            }\n          };\n        }\n      },\n      encodingOptions: {\n        preserveAny: true\n      }\n    });\n  }\n  async join({ topic, peerId }) {\n    log3(\"join\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 85,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    const swarmStream = this._rpc.rpc.Signal.join({\n      swarm: topic.asUint8Array(),\n      peer: peerId.asUint8Array()\n    });\n    await swarmStream.waitUntilReady();\n    return swarmStream;\n  }\n  async receiveMessages(peerId) {\n    await this._connectTrigger.wait();\n    const messageStream = this._rpc.rpc.Signal.receiveMessages({\n      peer: peerId.asUint8Array()\n    });\n    await messageStream.waitUntilReady();\n    return messageStream;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log3(\"sendMessage\", {\n      author,\n      recipient,\n      payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 105,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    await this._rpc.rpc.Signal.sendMessage({\n      author: author.asUint8Array(),\n      recipient: recipient.asUint8Array(),\n      payload\n    });\n  }\n  async close() {\n    try {\n      await this._rpc.close();\n    } finally {\n      this._socket.close();\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_RECONNECT_TIMEOUT = 1e3;\nvar SignalState;\n(function(SignalState2) {\n  SignalState2[\"CONNECTING\"] = \"CONNECTING\";\n  SignalState2[\"RE_CONNECTING\"] = \"RE_CONNECTING\";\n  SignalState2[\"CONNECTED\"] = \"CONNECTED\";\n  SignalState2[\"DISCONNECTED\"] = \"DISCONNECTED\";\n  SignalState2[\"CLOSED\"] = \"CLOSED\";\n})(SignalState || (SignalState = {}));\nvar SignalClient = class {\n  constructor(_host, _onMessage) {\n    this._host = _host;\n    this._onMessage = _onMessage;\n    this._state = SignalState.CONNECTING;\n    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n    this._connectionStarted = Date.now();\n    this._lastStateChange = Date.now();\n    this._subscriptions = new EventSubscriptions2();\n    this.statusChanged = new Event3();\n    this.commandTrace = new Event3();\n    this.swarmEvent = new Event3();\n    this._swarmStreams = new ComplexMap3((key) => key.toHex());\n    this._messageStreams = new ComplexMap3((key) => key.toHex());\n    this._setState(SignalState.CONNECTING);\n    this._createClient();\n  }\n  async close() {\n    log4(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._subscriptions.clear();\n    if (this._reconnectIntervalId !== void 0) {\n      clearTimeout(this._reconnectIntervalId);\n    }\n    await this._client.close();\n    this._setState(SignalState.CLOSED);\n    log4(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  getStatus() {\n    var _a;\n    return {\n      host: this._host,\n      state: this._state,\n      error: (_a = this._lastError) == null ? void 0 : _a.message,\n      reconnectIn: this._reconnectAfter,\n      connectionStarted: this._connectionStarted,\n      lastStateChange: this._lastStateChange\n    };\n  }\n  async join({ topic, peerId }) {\n    log4(\"joining\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.subscribeMessages(peerId);\n    await this._subscribeSwarmEvents(topic, peerId);\n  }\n  async leave({ topic, peerId }) {\n    var _a, _b;\n    log4(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 148,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    (_a = this._swarmStreams.get(topic)) == null ? void 0 : _a.close();\n    this._swarmStreams.delete(topic);\n    (_b = this._messageStreams.get(topic)) == null ? void 0 : _b.close();\n    this._messageStreams.delete(topic);\n  }\n  async sendMessage(msg) {\n    await this._client.sendMessage(msg);\n  }\n  async subscribeMessages(peerId) {\n    if (this._messageStreams.has(peerId)) {\n      return;\n    }\n    const messageStream = await this._client.receiveMessages(peerId);\n    messageStream.subscribe(async (message) => {\n      await this._onMessage({\n        author: PublicKey3.from(message.author),\n        recipient: PublicKey3.from(message.recipient),\n        payload: message.payload\n      });\n    });\n    if (!this._messageStreams.has(peerId)) {\n      this._messageStreams.set(peerId, messageStream);\n    }\n    this._subscriptions.add(() => {\n      messageStream.close();\n      this._messageStreams.delete(peerId);\n    });\n  }\n  _setState(newState) {\n    this._state = newState;\n    this._lastStateChange = Date.now();\n    log4(\"signal state changed\", {\n      status: this.getStatus()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 191,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.statusChanged.emit(this.getStatus());\n  }\n  _createClient() {\n    this._connectionStarted = Date.now();\n    try {\n      this._client = new SignalRPCClient(this._host);\n    } catch (err) {\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = err;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }\n    this._subscriptions.add(this._client.connected.on(() => {\n      this._lastError = void 0;\n      this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n      this._setState(SignalState.CONNECTED);\n    }));\n    this._subscriptions.add(this._client.error.on((error) => {\n      log4(\"socket error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 219,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state === SignalState.CLOSED) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = error;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n    this._subscriptions.add(this._client.disconnected.on(() => {\n      log4(\"socket disconnected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 237,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state !== SignalState.CONNECTING && this._state !== SignalState.RE_CONNECTING) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n  }\n  _reconnect() {\n    log4(`reconnecting in ${this._reconnectAfter}ms`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 254,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._reconnectIntervalId !== void 0) {\n      console.error(\"Signal api already reconnecting.\");\n      return;\n    }\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    this._reconnectIntervalId = setTimeout(() => {\n      this._reconnectIntervalId = void 0;\n      this._subscriptions.clear();\n      this._client.close().catch(() => {\n      });\n      this._setState(SignalState.RE_CONNECTING);\n      this._createClient();\n    }, this._reconnectAfter);\n  }\n  async _subscribeSwarmEvents(topic, peerId) {\n    assert3(!this._swarmStreams.has(topic), \"Already subscribed to swarm events.\");\n    const swarmStream = await this._client.join({\n      topic,\n      peerId\n    });\n    swarmStream.subscribe((swarmEvent) => {\n      this.swarmEvent.emit({\n        topic,\n        swarmEvent\n      });\n    });\n    this._swarmStreams.set(topic, swarmStream);\n    this._subscriptions.add(() => {\n      swarmStream.close();\n      this._swarmStreams.delete(topic);\n    });\n  }\n};\n__decorate([\n  synchronized\n], SignalClient.prototype, \"_subscribeSwarmEvents\", null);\n\n// packages/core/mesh/messaging/src/websocket-signal-manager.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4, synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WebsocketSignalManager = class {\n  constructor(_hosts) {\n    this._hosts = _hosts;\n    this._servers = /* @__PURE__ */ new Map();\n    this._topicsJoined = new ComplexMap4((topic) => topic.toHex());\n    this._topicsJoinedPerSignal = /* @__PURE__ */ new Map();\n    this._reconciling = false;\n    this._destroyed = false;\n    this.statusChanged = new Event4();\n    this.commandTrace = new Event4();\n    this.swarmEvent = new Event4();\n    this.onMessage = new Event4();\n    log5(`Created WebsocketSignalManager with signal servers: ${_hosts}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 48,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert4(_hosts.length === 1, \"Only a single signaling server connection is supported\");\n    for (const host of this._hosts) {\n      const server = new SignalClient(host, async (message) => this.onMessage.emit(message));\n      server.swarmEvent.on((data) => this.swarmEvent.emit(data));\n      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));\n      this._servers.set(host, server);\n      server.commandTrace.on((trace) => this.commandTrace.emit(trace));\n      this._topicsJoinedPerSignal.set(host, new ComplexMap4(PublicKey4.hash));\n    }\n  }\n  getStatus() {\n    return Array.from(this._servers.values()).map((server) => server.getStatus());\n  }\n  async join({ topic, peerId }) {\n    assert4(!this._topicsJoined.has(topic), `Topic ${topic} is already joined`);\n    log5(`Join ${topic} ${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 68,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.set(topic, peerId);\n    this._scheduleReconcile();\n  }\n  async leave({ topic, peerId }) {\n    assert4(!!this._topicsJoined.has(topic), `Topic ${topic} was not joined`);\n    log5(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 75,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.delete(topic);\n    this._scheduleReconcile();\n  }\n  _scheduleReconcile() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconciling) {\n      this._reconciling = true;\n      this._reconcileJoinedTopics().then(() => {\n        this._reconciling = false;\n      }, (err) => {\n        this._reconciling = false;\n        log5.error(`Error while reconciling: ${err}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n          line: 93,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._reconcileLater();\n      });\n    } else {\n      this._reconcileLater();\n    }\n  }\n  _reconcileLater() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconcileTimeoutId) {\n      this._reconcileTimeoutId = setTimeout(async () => this._scheduleReconcile(), 3e3);\n    }\n  }\n  async _reconcileJoinedTopics() {\n    log5(\"Reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    for (const [host, server] of this._servers) {\n      const actualJoinedTopics = this._topicsJoinedPerSignal.get(host);\n      for (const [topic, actualPeerId] of actualJoinedTopics) {\n        try {\n          const desiredPeerId = this._topicsJoined.get(topic);\n          if (!desiredPeerId || !desiredPeerId.equals(actualPeerId)) {\n            await server.leave({\n              topic,\n              peerId: actualPeerId\n            });\n            actualJoinedTopics.delete(topic);\n          }\n        } catch (err) {\n          log5.error(`Error leaving swarm: ${err}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 128,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n      for (const [topic1, desiredPeerId1] of this._topicsJoined) {\n        try {\n          const actualPeerId1 = actualJoinedTopics.get(topic1);\n          if (!actualPeerId1) {\n            await server.join({\n              topic: topic1,\n              peerId: desiredPeerId1\n            });\n            actualJoinedTopics.set(topic1, desiredPeerId1);\n          } else {\n            if (!actualPeerId1.equals(desiredPeerId1)) {\n              throw new Error(`Joined with peerId different from desired: ${JSON.stringify({\n                actualPeerId: actualPeerId1,\n                desiredPeerId: desiredPeerId1\n              })}`);\n            }\n          }\n        } catch (err1) {\n          log5.error(`Error joining swarm: ${err1}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 151,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n    }\n    log5(\"Done reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 156,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._reconciling = false;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log5(`Signal ${recipient}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 169,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((server) => server.sendMessage({\n      author,\n      recipient,\n      payload\n    }).catch((err) => log5(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 172,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async subscribeMessages(peerId) {\n    log5(`Subscribed for message stream peerId=${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 178,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((signalClient) => signalClient.subscribeMessages(peerId)));\n  }\n  async destroy() {\n    this._destroyed = true;\n    if (this._reconcileTimeoutId) {\n      clearTimeout(this._reconcileTimeoutId);\n    }\n    await Promise.all(Array.from(this._servers.values()).map((server) => server.close()));\n  }\n};\n__decorate2([\n  synchronized2\n], WebsocketSignalManager.prototype, \"_reconcileJoinedTopics\", null);\nexport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  Messenger,\n  SignalClient,\n  SignalState,\n  WebsocketSignalManager\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465563,"end":1670465466221},{"name":"vite:react-babel","result":"// packages/core/mesh/messaging/src/memory-signal-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { ComplexMap, ComplexSet } from \"@dxos/util\";\nvar MemorySignalManagerContext = class {\n  constructor() {\n    this.swarmEvent = new Event();\n    this.swarms = new ComplexMap(PublicKey.hash);\n    this.connections = new ComplexMap(PublicKey.hash);\n  }\n};\nvar MemorySignalManager = class {\n  constructor(_context) {\n    this._context = _context;\n    this.statusChanged = new Event();\n    this.commandTrace = new Event();\n    this.swarmEvent = new Event();\n    this.onMessage = new Event();\n    this._context.swarmEvent.on((data) => this.swarmEvent.emit(data));\n  }\n  getStatus() {\n    return [];\n  }\n  async join({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).add(peerId);\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent: {\n        peerAvailable: {\n          peer: peerId.asUint8Array(),\n          since: new Date()\n        }\n      }\n    });\n    for (const [topic1, peerIds] of this._context.swarms) {\n      Array.from(peerIds).forEach((peerId2) => {\n        this.swarmEvent.emit({\n          topic: topic1,\n          swarmEvent: {\n            peerAvailable: {\n              peer: peerId2.asUint8Array(),\n              since: new Date()\n            }\n          }\n        });\n      });\n    }\n  }\n  async leave({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).delete(peerId);\n    const swarmEvent = {\n      peerLeft: {\n        peer: peerId.asUint8Array()\n      }\n    };\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent\n    });\n  }\n  async sendMessage({ author, recipient, payload }) {\n    assert(recipient);\n    if (!this._context.connections.has(recipient)) {\n      log.warn(\"recipient is not subscribed for messages\", {\n        author,\n        recipient\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n        line: 113,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    this._context.connections.get(recipient).onMessage.emit({\n      author,\n      recipient,\n      payload\n    });\n  }\n  async subscribeMessages(peerId) {\n    log(\"subscribing\", {\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._context.connections.set(peerId, this);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/messaging/src/messenger.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap as ComplexMap2, ComplexSet as ComplexSet2, exponentialBackoffInterval } from \"@dxos/util\";\nvar Messenger = class {\n  constructor({ signalManager, retryDelay = 100, timeout = 3e3 }) {\n    this._listeners = new ComplexMap2(({ peerId, payloadType }) => peerId.toHex() + payloadType);\n    this._defaultListeners = new ComplexMap2(PublicKey2.hash);\n    this._onAckCallbacks = new ComplexMap2(PublicKey2.hash);\n    this._receivedMessages = new ComplexSet2((key) => key.toHex());\n    this._subscriptions = new EventSubscriptions();\n    this._signalManager = signalManager;\n    this._signalManager.onMessage.on(async (message) => {\n      log2(\"received message\", {\n        from: message.author\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._handleMessage(message);\n    });\n    this._retryDelay = retryDelay;\n    this._timeout = timeout;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    const reliablePayload = {\n      messageId: PublicKey2.random(),\n      payload\n    };\n    log2(\"sent message\", {\n      messageId: reliablePayload.messageId,\n      author,\n      recipient\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 61,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const cancelRetry = exponentialBackoffInterval(async () => {\n      log2(\"retrying message\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      try {\n        await this._encodeAndSend({\n          author,\n          recipient,\n          reliablePayload\n        });\n      } catch (error) {\n        log2.error(\"failed to send message\", {\n          error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n          line: 69,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }, this._retryDelay);\n    const timeout = setTimeout(() => {\n      log2(\"message not delivered\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 74,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n    }, this._timeout);\n    assert2(!this._onAckCallbacks.has(reliablePayload.messageId));\n    this._onAckCallbacks.set(reliablePayload.messageId, () => {\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    this._subscriptions.add(() => {\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      reliablePayload\n    });\n  }\n  async listen({ peerId, payloadType, onMessage }) {\n    await this._signalManager.subscribeMessages(peerId);\n    let listeners;\n    if (!payloadType) {\n      listeners = this._defaultListeners.get(peerId);\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._defaultListeners.set(peerId, listeners);\n      }\n    } else {\n      listeners = this._listeners.get({\n        peerId,\n        payloadType\n      });\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._listeners.set({\n          peerId,\n          payloadType\n        }, listeners);\n      }\n    }\n    listeners.add(onMessage);\n    return {\n      unsubscribe: async () => {\n        listeners.delete(onMessage);\n      }\n    };\n  }\n  async _encodeAndSend({ author, recipient, reliablePayload }) {\n    await this._signalManager.sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.messaging.ReliablePayload\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").encode(reliablePayload, {\n          preserveAny: true\n        })\n      }\n    });\n  }\n  async _handleMessage(message) {\n    switch (message.payload.type_url) {\n      case \"dxos.mesh.messaging.ReliablePayload\": {\n        await this._handleReliablePayload(message);\n        break;\n      }\n      case \"dxos.mesh.messaging.Acknowledgement\": {\n        await this._handleAcknowledgement({\n          payload: message.payload\n        });\n        break;\n      }\n    }\n  }\n  async _handleReliablePayload({ author, recipient, payload }) {\n    assert2(payload.type_url === \"dxos.mesh.messaging.ReliablePayload\");\n    const reliablePayload = schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").decode(payload.value, {\n      preserveAny: true\n    });\n    log2(\"handling message\", {\n      messageId: reliablePayload.messageId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 173,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._receivedMessages.has(reliablePayload.messageId)) {\n      return;\n    }\n    this._receivedMessages.add(reliablePayload.messageId);\n    await this._sendAcknowledgement({\n      author,\n      recipient,\n      messageId: reliablePayload.messageId\n    });\n    await this._callListeners({\n      author,\n      recipient,\n      payload: reliablePayload.payload\n    });\n  }\n  async _handleAcknowledgement({ payload }) {\n    var _a;\n    assert2(payload.type_url === \"dxos.mesh.messaging.Acknowledgement\");\n    (_a = this._onAckCallbacks.get(schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").decode(payload.value).messageId)) == null ? void 0 : _a();\n  }\n  async _sendAcknowledgement({ author, recipient, messageId }) {\n    log2(\"sending ACK\", {\n      messageId,\n      from: recipient,\n      to: author\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 208,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._signalManager.sendMessage({\n      author: recipient,\n      recipient: author,\n      payload: {\n        type_url: \"dxos.mesh.messaging.Acknowledgement\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").encode({\n          messageId\n        })\n      }\n    });\n  }\n  async _callListeners(message) {\n    {\n      const defaultListenerMap = this._defaultListeners.get(message.recipient);\n      if (defaultListenerMap) {\n        for (const listener of defaultListenerMap) {\n          await listener(message);\n        }\n      }\n    }\n    {\n      const listenerMap = this._listeners.get({\n        peerId: message.recipient,\n        payloadType: message.payload.type_url\n      });\n      if (listenerMap) {\n        for (const listener1 of listenerMap) {\n          await listener1(message);\n        }\n      }\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, EventSubscriptions as EventSubscriptions2, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/mesh/messaging/src/signal-rpc-client.ts\nimport WebSocket from \"isomorphic-ws\";\nimport { Trigger, Event as Event2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar SignalRPCClient = class {\n  constructor(_url) {\n    this._url = _url;\n    this._connectTrigger = new Trigger();\n    this.connected = new Event2();\n    this.disconnected = new Event2();\n    this.error = new Event2();\n    this._socket = new WebSocket(this._url);\n    this._socket.onopen = async () => {\n      try {\n        await this._rpc.open();\n        log3(`RPC open ${this._url}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n          line: 36,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.connected.emit();\n        this._connectTrigger.wake();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onclose = async () => {\n      log3(`Disconnected ${this._url}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.disconnected.emit();\n      try {\n        await this._rpc.close();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onerror = (event) => {\n      var _a;\n      log3.error(event.message, {\n        url: this._url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.error.emit((_a = event.error) != null ? _a : new Error(event.message));\n    };\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Signal: schema2.getService(\"dxos.mesh.signal.Signal\")\n      },\n      noHandshake: true,\n      port: {\n        send: (msg) => {\n          this._socket.send(msg);\n        },\n        subscribe: (cb) => {\n          this._socket.onmessage = async (msg) => {\n            if (typeof Blob !== \"undefined\" && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data);\n            }\n          };\n        }\n      },\n      encodingOptions: {\n        preserveAny: true\n      }\n    });\n  }\n  async join({ topic, peerId }) {\n    log3(\"join\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 85,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    const swarmStream = this._rpc.rpc.Signal.join({\n      swarm: topic.asUint8Array(),\n      peer: peerId.asUint8Array()\n    });\n    await swarmStream.waitUntilReady();\n    return swarmStream;\n  }\n  async receiveMessages(peerId) {\n    await this._connectTrigger.wait();\n    const messageStream = this._rpc.rpc.Signal.receiveMessages({\n      peer: peerId.asUint8Array()\n    });\n    await messageStream.waitUntilReady();\n    return messageStream;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log3(\"sendMessage\", {\n      author,\n      recipient,\n      payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 105,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    await this._rpc.rpc.Signal.sendMessage({\n      author: author.asUint8Array(),\n      recipient: recipient.asUint8Array(),\n      payload\n    });\n  }\n  async close() {\n    try {\n      await this._rpc.close();\n    } finally {\n      this._socket.close();\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_RECONNECT_TIMEOUT = 1e3;\nvar SignalState;\n(function(SignalState2) {\n  SignalState2[\"CONNECTING\"] = \"CONNECTING\";\n  SignalState2[\"RE_CONNECTING\"] = \"RE_CONNECTING\";\n  SignalState2[\"CONNECTED\"] = \"CONNECTED\";\n  SignalState2[\"DISCONNECTED\"] = \"DISCONNECTED\";\n  SignalState2[\"CLOSED\"] = \"CLOSED\";\n})(SignalState || (SignalState = {}));\nvar SignalClient = class {\n  constructor(_host, _onMessage) {\n    this._host = _host;\n    this._onMessage = _onMessage;\n    this._state = SignalState.CONNECTING;\n    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n    this._connectionStarted = Date.now();\n    this._lastStateChange = Date.now();\n    this._subscriptions = new EventSubscriptions2();\n    this.statusChanged = new Event3();\n    this.commandTrace = new Event3();\n    this.swarmEvent = new Event3();\n    this._swarmStreams = new ComplexMap3((key) => key.toHex());\n    this._messageStreams = new ComplexMap3((key) => key.toHex());\n    this._setState(SignalState.CONNECTING);\n    this._createClient();\n  }\n  async close() {\n    log4(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._subscriptions.clear();\n    if (this._reconnectIntervalId !== void 0) {\n      clearTimeout(this._reconnectIntervalId);\n    }\n    await this._client.close();\n    this._setState(SignalState.CLOSED);\n    log4(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  getStatus() {\n    var _a;\n    return {\n      host: this._host,\n      state: this._state,\n      error: (_a = this._lastError) == null ? void 0 : _a.message,\n      reconnectIn: this._reconnectAfter,\n      connectionStarted: this._connectionStarted,\n      lastStateChange: this._lastStateChange\n    };\n  }\n  async join({ topic, peerId }) {\n    log4(\"joining\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.subscribeMessages(peerId);\n    await this._subscribeSwarmEvents(topic, peerId);\n  }\n  async leave({ topic, peerId }) {\n    var _a, _b;\n    log4(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 148,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    (_a = this._swarmStreams.get(topic)) == null ? void 0 : _a.close();\n    this._swarmStreams.delete(topic);\n    (_b = this._messageStreams.get(topic)) == null ? void 0 : _b.close();\n    this._messageStreams.delete(topic);\n  }\n  async sendMessage(msg) {\n    await this._client.sendMessage(msg);\n  }\n  async subscribeMessages(peerId) {\n    if (this._messageStreams.has(peerId)) {\n      return;\n    }\n    const messageStream = await this._client.receiveMessages(peerId);\n    messageStream.subscribe(async (message) => {\n      await this._onMessage({\n        author: PublicKey3.from(message.author),\n        recipient: PublicKey3.from(message.recipient),\n        payload: message.payload\n      });\n    });\n    if (!this._messageStreams.has(peerId)) {\n      this._messageStreams.set(peerId, messageStream);\n    }\n    this._subscriptions.add(() => {\n      messageStream.close();\n      this._messageStreams.delete(peerId);\n    });\n  }\n  _setState(newState) {\n    this._state = newState;\n    this._lastStateChange = Date.now();\n    log4(\"signal state changed\", {\n      status: this.getStatus()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 191,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.statusChanged.emit(this.getStatus());\n  }\n  _createClient() {\n    this._connectionStarted = Date.now();\n    try {\n      this._client = new SignalRPCClient(this._host);\n    } catch (err) {\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = err;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }\n    this._subscriptions.add(this._client.connected.on(() => {\n      this._lastError = void 0;\n      this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n      this._setState(SignalState.CONNECTED);\n    }));\n    this._subscriptions.add(this._client.error.on((error) => {\n      log4(\"socket error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 219,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state === SignalState.CLOSED) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = error;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n    this._subscriptions.add(this._client.disconnected.on(() => {\n      log4(\"socket disconnected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 237,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state !== SignalState.CONNECTING && this._state !== SignalState.RE_CONNECTING) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n  }\n  _reconnect() {\n    log4(`reconnecting in ${this._reconnectAfter}ms`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 254,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._reconnectIntervalId !== void 0) {\n      console.error(\"Signal api already reconnecting.\");\n      return;\n    }\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    this._reconnectIntervalId = setTimeout(() => {\n      this._reconnectIntervalId = void 0;\n      this._subscriptions.clear();\n      this._client.close().catch(() => {\n      });\n      this._setState(SignalState.RE_CONNECTING);\n      this._createClient();\n    }, this._reconnectAfter);\n  }\n  async _subscribeSwarmEvents(topic, peerId) {\n    assert3(!this._swarmStreams.has(topic), \"Already subscribed to swarm events.\");\n    const swarmStream = await this._client.join({\n      topic,\n      peerId\n    });\n    swarmStream.subscribe((swarmEvent) => {\n      this.swarmEvent.emit({\n        topic,\n        swarmEvent\n      });\n    });\n    this._swarmStreams.set(topic, swarmStream);\n    this._subscriptions.add(() => {\n      swarmStream.close();\n      this._swarmStreams.delete(topic);\n    });\n  }\n};\n__decorate([\n  synchronized\n], SignalClient.prototype, \"_subscribeSwarmEvents\", null);\n\n// packages/core/mesh/messaging/src/websocket-signal-manager.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4, synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WebsocketSignalManager = class {\n  constructor(_hosts) {\n    this._hosts = _hosts;\n    this._servers = /* @__PURE__ */ new Map();\n    this._topicsJoined = new ComplexMap4((topic) => topic.toHex());\n    this._topicsJoinedPerSignal = /* @__PURE__ */ new Map();\n    this._reconciling = false;\n    this._destroyed = false;\n    this.statusChanged = new Event4();\n    this.commandTrace = new Event4();\n    this.swarmEvent = new Event4();\n    this.onMessage = new Event4();\n    log5(`Created WebsocketSignalManager with signal servers: ${_hosts}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 48,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert4(_hosts.length === 1, \"Only a single signaling server connection is supported\");\n    for (const host of this._hosts) {\n      const server = new SignalClient(host, async (message) => this.onMessage.emit(message));\n      server.swarmEvent.on((data) => this.swarmEvent.emit(data));\n      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));\n      this._servers.set(host, server);\n      server.commandTrace.on((trace) => this.commandTrace.emit(trace));\n      this._topicsJoinedPerSignal.set(host, new ComplexMap4(PublicKey4.hash));\n    }\n  }\n  getStatus() {\n    return Array.from(this._servers.values()).map((server) => server.getStatus());\n  }\n  async join({ topic, peerId }) {\n    assert4(!this._topicsJoined.has(topic), `Topic ${topic} is already joined`);\n    log5(`Join ${topic} ${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 68,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.set(topic, peerId);\n    this._scheduleReconcile();\n  }\n  async leave({ topic, peerId }) {\n    assert4(!!this._topicsJoined.has(topic), `Topic ${topic} was not joined`);\n    log5(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 75,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.delete(topic);\n    this._scheduleReconcile();\n  }\n  _scheduleReconcile() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconciling) {\n      this._reconciling = true;\n      this._reconcileJoinedTopics().then(() => {\n        this._reconciling = false;\n      }, (err) => {\n        this._reconciling = false;\n        log5.error(`Error while reconciling: ${err}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n          line: 93,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._reconcileLater();\n      });\n    } else {\n      this._reconcileLater();\n    }\n  }\n  _reconcileLater() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconcileTimeoutId) {\n      this._reconcileTimeoutId = setTimeout(async () => this._scheduleReconcile(), 3e3);\n    }\n  }\n  async _reconcileJoinedTopics() {\n    log5(\"Reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    for (const [host, server] of this._servers) {\n      const actualJoinedTopics = this._topicsJoinedPerSignal.get(host);\n      for (const [topic, actualPeerId] of actualJoinedTopics) {\n        try {\n          const desiredPeerId = this._topicsJoined.get(topic);\n          if (!desiredPeerId || !desiredPeerId.equals(actualPeerId)) {\n            await server.leave({\n              topic,\n              peerId: actualPeerId\n            });\n            actualJoinedTopics.delete(topic);\n          }\n        } catch (err) {\n          log5.error(`Error leaving swarm: ${err}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 128,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n      for (const [topic1, desiredPeerId1] of this._topicsJoined) {\n        try {\n          const actualPeerId1 = actualJoinedTopics.get(topic1);\n          if (!actualPeerId1) {\n            await server.join({\n              topic: topic1,\n              peerId: desiredPeerId1\n            });\n            actualJoinedTopics.set(topic1, desiredPeerId1);\n          } else {\n            if (!actualPeerId1.equals(desiredPeerId1)) {\n              throw new Error(`Joined with peerId different from desired: ${JSON.stringify({\n                actualPeerId: actualPeerId1,\n                desiredPeerId: desiredPeerId1\n              })}`);\n            }\n          }\n        } catch (err1) {\n          log5.error(`Error joining swarm: ${err1}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 151,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n    }\n    log5(\"Done reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 156,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._reconciling = false;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log5(`Signal ${recipient}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 169,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((server) => server.sendMessage({\n      author,\n      recipient,\n      payload\n    }).catch((err) => log5(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 172,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async subscribeMessages(peerId) {\n    log5(`Subscribed for message stream peerId=${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 178,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((signalClient) => signalClient.subscribeMessages(peerId)));\n  }\n  async destroy() {\n    this._destroyed = true;\n    if (this._reconcileTimeoutId) {\n      clearTimeout(this._reconcileTimeoutId);\n    }\n    await Promise.all(Array.from(this._servers.values()).map((server) => server.close()));\n  }\n};\n__decorate2([\n  synchronized2\n], WebsocketSignalManager.prototype, \"_reconcileJoinedTopics\", null);\nexport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  Messenger,\n  SignalClient,\n  SignalState,\n  WebsocketSignalManager\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466221,"end":1670465466221,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/mesh/messaging/src/memory-signal-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\nimport { ComplexMap, ComplexSet } from \"@dxos/util\";\nvar MemorySignalManagerContext = class {\n  constructor() {\n    this.swarmEvent = new Event();\n    this.swarms = new ComplexMap(PublicKey.hash);\n    this.connections = new ComplexMap(PublicKey.hash);\n  }\n};\nvar MemorySignalManager = class {\n  constructor(_context) {\n    this._context = _context;\n    this.statusChanged = new Event();\n    this.commandTrace = new Event();\n    this.swarmEvent = new Event();\n    this.onMessage = new Event();\n    this._context.swarmEvent.on((data) => this.swarmEvent.emit(data));\n  }\n  getStatus() {\n    return [];\n  }\n  async join({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).add(peerId);\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent: {\n        peerAvailable: {\n          peer: peerId.asUint8Array(),\n          since: new Date()\n        }\n      }\n    });\n    for (const [topic1, peerIds] of this._context.swarms) {\n      Array.from(peerIds).forEach((peerId2) => {\n        this.swarmEvent.emit({\n          topic: topic1,\n          swarmEvent: {\n            peerAvailable: {\n              peer: peerId2.asUint8Array(),\n              since: new Date()\n            }\n          }\n        });\n      });\n    }\n  }\n  async leave({ topic, peerId }) {\n    if (!this._context.swarms.has(topic)) {\n      this._context.swarms.set(topic, new ComplexSet(PublicKey.hash));\n    }\n    this._context.swarms.get(topic).delete(peerId);\n    const swarmEvent = {\n      peerLeft: {\n        peer: peerId.asUint8Array()\n      }\n    };\n    this._context.swarmEvent.emit({\n      topic,\n      swarmEvent\n    });\n  }\n  async sendMessage({ author, recipient, payload }) {\n    assert(recipient);\n    if (!this._context.connections.has(recipient)) {\n      log.warn(\"recipient is not subscribed for messages\", {\n        author,\n        recipient\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n        line: 113,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    this._context.connections.get(recipient).onMessage.emit({\n      author,\n      recipient,\n      payload\n    });\n  }\n  async subscribeMessages(peerId) {\n    log(\"subscribing\", {\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/memory-signal-manager.ts\",\n      line: 121,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._context.connections.set(peerId, this);\n  }\n  async destroy() {\n  }\n};\n\n// packages/core/mesh/messaging/src/messenger.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { EventSubscriptions } from \"@dxos/async\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log2 } from \"@dxos/log\";\nimport { schema } from \"@dxos/protocols\";\nimport { ComplexMap as ComplexMap2, ComplexSet as ComplexSet2, exponentialBackoffInterval } from \"@dxos/util\";\nvar Messenger = class {\n  constructor({ signalManager, retryDelay = 100, timeout = 3e3 }) {\n    this._listeners = new ComplexMap2(({ peerId, payloadType }) => peerId.toHex() + payloadType);\n    this._defaultListeners = new ComplexMap2(PublicKey2.hash);\n    this._onAckCallbacks = new ComplexMap2(PublicKey2.hash);\n    this._receivedMessages = new ComplexSet2((key) => key.toHex());\n    this._subscriptions = new EventSubscriptions();\n    this._signalManager = signalManager;\n    this._signalManager.onMessage.on(async (message) => {\n      log2(\"received message\", {\n        from: message.author\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 47,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._handleMessage(message);\n    });\n    this._retryDelay = retryDelay;\n    this._timeout = timeout;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    const reliablePayload = {\n      messageId: PublicKey2.random(),\n      payload\n    };\n    log2(\"sent message\", {\n      messageId: reliablePayload.messageId,\n      author,\n      recipient\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 61,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const cancelRetry = exponentialBackoffInterval(async () => {\n      log2(\"retrying message\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      try {\n        await this._encodeAndSend({\n          author,\n          recipient,\n          reliablePayload\n        });\n      } catch (error) {\n        log2.error(\"failed to send message\", {\n          error\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n          line: 69,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    }, this._retryDelay);\n    const timeout = setTimeout(() => {\n      log2(\"message not delivered\", {\n        messageId: reliablePayload.messageId\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n        line: 74,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n    }, this._timeout);\n    assert2(!this._onAckCallbacks.has(reliablePayload.messageId));\n    this._onAckCallbacks.set(reliablePayload.messageId, () => {\n      this._onAckCallbacks.delete(reliablePayload.messageId);\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    this._subscriptions.add(() => {\n      cancelRetry();\n      clearTimeout(timeout);\n    });\n    await this._encodeAndSend({\n      author,\n      recipient,\n      reliablePayload\n    });\n  }\n  async listen({ peerId, payloadType, onMessage }) {\n    await this._signalManager.subscribeMessages(peerId);\n    let listeners;\n    if (!payloadType) {\n      listeners = this._defaultListeners.get(peerId);\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._defaultListeners.set(peerId, listeners);\n      }\n    } else {\n      listeners = this._listeners.get({\n        peerId,\n        payloadType\n      });\n      if (!listeners) {\n        listeners = /* @__PURE__ */ new Set();\n        this._listeners.set({\n          peerId,\n          payloadType\n        }, listeners);\n      }\n    }\n    listeners.add(onMessage);\n    return {\n      unsubscribe: async () => {\n        listeners.delete(onMessage);\n      }\n    };\n  }\n  async _encodeAndSend({ author, recipient, reliablePayload }) {\n    await this._signalManager.sendMessage({\n      author,\n      recipient,\n      payload: {\n        type_url: \"dxos.mesh.messaging.ReliablePayload\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").encode(reliablePayload, {\n          preserveAny: true\n        })\n      }\n    });\n  }\n  async _handleMessage(message) {\n    switch (message.payload.type_url) {\n      case \"dxos.mesh.messaging.ReliablePayload\": {\n        await this._handleReliablePayload(message);\n        break;\n      }\n      case \"dxos.mesh.messaging.Acknowledgement\": {\n        await this._handleAcknowledgement({\n          payload: message.payload\n        });\n        break;\n      }\n    }\n  }\n  async _handleReliablePayload({ author, recipient, payload }) {\n    assert2(payload.type_url === \"dxos.mesh.messaging.ReliablePayload\");\n    const reliablePayload = schema.getCodecForType(\"dxos.mesh.messaging.ReliablePayload\").decode(payload.value, {\n      preserveAny: true\n    });\n    log2(\"handling message\", {\n      messageId: reliablePayload.messageId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 173,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._receivedMessages.has(reliablePayload.messageId)) {\n      return;\n    }\n    this._receivedMessages.add(reliablePayload.messageId);\n    await this._sendAcknowledgement({\n      author,\n      recipient,\n      messageId: reliablePayload.messageId\n    });\n    await this._callListeners({\n      author,\n      recipient,\n      payload: reliablePayload.payload\n    });\n  }\n  async _handleAcknowledgement({ payload }) {\n    var _a;\n    assert2(payload.type_url === \"dxos.mesh.messaging.Acknowledgement\");\n    (_a = this._onAckCallbacks.get(schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").decode(payload.value).messageId)) == null ? void 0 : _a();\n  }\n  async _sendAcknowledgement({ author, recipient, messageId }) {\n    log2(\"sending ACK\", {\n      messageId,\n      from: recipient,\n      to: author\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/messenger.ts\",\n      line: 208,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._signalManager.sendMessage({\n      author: recipient,\n      recipient: author,\n      payload: {\n        type_url: \"dxos.mesh.messaging.Acknowledgement\",\n        value: schema.getCodecForType(\"dxos.mesh.messaging.Acknowledgement\").encode({\n          messageId\n        })\n      }\n    });\n  }\n  async _callListeners(message) {\n    {\n      const defaultListenerMap = this._defaultListeners.get(message.recipient);\n      if (defaultListenerMap) {\n        for (const listener of defaultListenerMap) {\n          await listener(message);\n        }\n      }\n    }\n    {\n      const listenerMap = this._listeners.get({\n        peerId: message.recipient,\n        payloadType: message.payload.type_url\n      });\n      if (listenerMap) {\n        for (const listener1 of listenerMap) {\n          await listener1(message);\n        }\n      }\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, EventSubscriptions as EventSubscriptions2, synchronized } from \"@dxos/async\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap3 } from \"@dxos/util\";\n\n// packages/core/mesh/messaging/src/signal-rpc-client.ts\nimport WebSocket from \"isomorphic-ws\";\nimport { Trigger, Event as Event2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nimport { createProtoRpcPeer } from \"@dxos/rpc\";\nvar SignalRPCClient = class {\n  constructor(_url) {\n    this._url = _url;\n    this._connectTrigger = new Trigger();\n    this.connected = new Event2();\n    this.disconnected = new Event2();\n    this.error = new Event2();\n    this._socket = new WebSocket(this._url);\n    this._socket.onopen = async () => {\n      try {\n        await this._rpc.open();\n        log3(`RPC open ${this._url}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n          line: 36,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this.connected.emit();\n        this._connectTrigger.wake();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onclose = async () => {\n      log3(`Disconnected ${this._url}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.disconnected.emit();\n      try {\n        await this._rpc.close();\n      } catch (err) {\n        this.error.emit(err);\n      }\n    };\n    this._socket.onerror = (event) => {\n      var _a;\n      log3.error(event.message, {\n        url: this._url\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n        line: 55,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this.error.emit((_a = event.error) != null ? _a : new Error(event.message));\n    };\n    this._rpc = createProtoRpcPeer({\n      requested: {\n        Signal: schema2.getService(\"dxos.mesh.signal.Signal\")\n      },\n      noHandshake: true,\n      port: {\n        send: (msg) => {\n          this._socket.send(msg);\n        },\n        subscribe: (cb) => {\n          this._socket.onmessage = async (msg) => {\n            if (typeof Blob !== \"undefined\" && msg.data instanceof Blob) {\n              cb(Buffer.from(await msg.data.arrayBuffer()));\n            } else {\n              cb(msg.data);\n            }\n          };\n        }\n      },\n      encodingOptions: {\n        preserveAny: true\n      }\n    });\n  }\n  async join({ topic, peerId }) {\n    log3(\"join\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 85,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    const swarmStream = this._rpc.rpc.Signal.join({\n      swarm: topic.asUint8Array(),\n      peer: peerId.asUint8Array()\n    });\n    await swarmStream.waitUntilReady();\n    return swarmStream;\n  }\n  async receiveMessages(peerId) {\n    await this._connectTrigger.wait();\n    const messageStream = this._rpc.rpc.Signal.receiveMessages({\n      peer: peerId.asUint8Array()\n    });\n    await messageStream.waitUntilReady();\n    return messageStream;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log3(\"sendMessage\", {\n      author,\n      recipient,\n      payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-rpc-client.ts\",\n      line: 105,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this._connectTrigger.wait();\n    await this._rpc.rpc.Signal.sendMessage({\n      author: author.asUint8Array(),\n      recipient: recipient.asUint8Array(),\n      payload\n    });\n  }\n  async close() {\n    try {\n      await this._rpc.close();\n    } finally {\n      this._socket.close();\n    }\n  }\n};\n\n// packages/core/mesh/messaging/src/signal-client.ts\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar DEFAULT_RECONNECT_TIMEOUT = 1e3;\nvar SignalState;\n(function(SignalState2) {\n  SignalState2[\"CONNECTING\"] = \"CONNECTING\";\n  SignalState2[\"RE_CONNECTING\"] = \"RE_CONNECTING\";\n  SignalState2[\"CONNECTED\"] = \"CONNECTED\";\n  SignalState2[\"DISCONNECTED\"] = \"DISCONNECTED\";\n  SignalState2[\"CLOSED\"] = \"CLOSED\";\n})(SignalState || (SignalState = {}));\nvar SignalClient = class {\n  constructor(_host, _onMessage) {\n    this._host = _host;\n    this._onMessage = _onMessage;\n    this._state = SignalState.CONNECTING;\n    this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n    this._connectionStarted = Date.now();\n    this._lastStateChange = Date.now();\n    this._subscriptions = new EventSubscriptions2();\n    this.statusChanged = new Event3();\n    this.commandTrace = new Event3();\n    this.swarmEvent = new Event3();\n    this._swarmStreams = new ComplexMap3((key) => key.toHex());\n    this._messageStreams = new ComplexMap3((key) => key.toHex());\n    this._setState(SignalState.CONNECTING);\n    this._createClient();\n  }\n  async close() {\n    log4(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 117,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._subscriptions.clear();\n    if (this._reconnectIntervalId !== void 0) {\n      clearTimeout(this._reconnectIntervalId);\n    }\n    await this._client.close();\n    this._setState(SignalState.CLOSED);\n    log4(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 126,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  getStatus() {\n    var _a;\n    return {\n      host: this._host,\n      state: this._state,\n      error: (_a = this._lastError) == null ? void 0 : _a.message,\n      reconnectIn: this._reconnectAfter,\n      connectionStarted: this._connectionStarted,\n      lastStateChange: this._lastStateChange\n    };\n  }\n  async join({ topic, peerId }) {\n    log4(\"joining\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 141,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await this.subscribeMessages(peerId);\n    await this._subscribeSwarmEvents(topic, peerId);\n  }\n  async leave({ topic, peerId }) {\n    var _a, _b;\n    log4(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 148,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    (_a = this._swarmStreams.get(topic)) == null ? void 0 : _a.close();\n    this._swarmStreams.delete(topic);\n    (_b = this._messageStreams.get(topic)) == null ? void 0 : _b.close();\n    this._messageStreams.delete(topic);\n  }\n  async sendMessage(msg) {\n    await this._client.sendMessage(msg);\n  }\n  async subscribeMessages(peerId) {\n    if (this._messageStreams.has(peerId)) {\n      return;\n    }\n    const messageStream = await this._client.receiveMessages(peerId);\n    messageStream.subscribe(async (message) => {\n      await this._onMessage({\n        author: PublicKey3.from(message.author),\n        recipient: PublicKey3.from(message.recipient),\n        payload: message.payload\n      });\n    });\n    if (!this._messageStreams.has(peerId)) {\n      this._messageStreams.set(peerId, messageStream);\n    }\n    this._subscriptions.add(() => {\n      messageStream.close();\n      this._messageStreams.delete(peerId);\n    });\n  }\n  _setState(newState) {\n    this._state = newState;\n    this._lastStateChange = Date.now();\n    log4(\"signal state changed\", {\n      status: this.getStatus()\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 191,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this.statusChanged.emit(this.getStatus());\n  }\n  _createClient() {\n    this._connectionStarted = Date.now();\n    try {\n      this._client = new SignalRPCClient(this._host);\n    } catch (err) {\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = err;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }\n    this._subscriptions.add(this._client.connected.on(() => {\n      this._lastError = void 0;\n      this._reconnectAfter = DEFAULT_RECONNECT_TIMEOUT;\n      this._setState(SignalState.CONNECTED);\n    }));\n    this._subscriptions.add(this._client.error.on((error) => {\n      log4(\"socket error\", {\n        error\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 219,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state === SignalState.CLOSED) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._lastError = error;\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n    this._subscriptions.add(this._client.disconnected.on(() => {\n      log4(\"socket disconnected\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n        line: 237,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      if (this._state !== SignalState.CONNECTING && this._state !== SignalState.RE_CONNECTING) {\n        return;\n      }\n      if (this._state === SignalState.RE_CONNECTING) {\n        this._reconnectAfter *= 2;\n      }\n      this._setState(SignalState.DISCONNECTED);\n      this._reconnect();\n    }));\n  }\n  _reconnect() {\n    log4(`reconnecting in ${this._reconnectAfter}ms`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/signal-client.ts\",\n      line: 254,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this._reconnectIntervalId !== void 0) {\n      console.error(\"Signal api already reconnecting.\");\n      return;\n    }\n    if (this._state === SignalState.CLOSED) {\n      return;\n    }\n    this._reconnectIntervalId = setTimeout(() => {\n      this._reconnectIntervalId = void 0;\n      this._subscriptions.clear();\n      this._client.close().catch(() => {\n      });\n      this._setState(SignalState.RE_CONNECTING);\n      this._createClient();\n    }, this._reconnectAfter);\n  }\n  async _subscribeSwarmEvents(topic, peerId) {\n    assert3(!this._swarmStreams.has(topic), \"Already subscribed to swarm events.\");\n    const swarmStream = await this._client.join({\n      topic,\n      peerId\n    });\n    swarmStream.subscribe((swarmEvent) => {\n      this.swarmEvent.emit({\n        topic,\n        swarmEvent\n      });\n    });\n    this._swarmStreams.set(topic, swarmStream);\n    this._subscriptions.add(() => {\n      swarmStream.close();\n      this._swarmStreams.delete(topic);\n    });\n  }\n};\n__decorate([\n  synchronized\n], SignalClient.prototype, \"_subscribeSwarmEvents\", null);\n\n// packages/core/mesh/messaging/src/websocket-signal-manager.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { Event as Event4, synchronized as synchronized2 } from \"@dxos/async\";\nimport { PublicKey as PublicKey4 } from \"@dxos/keys\";\nimport { log as log5 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap4 } from \"@dxos/util\";\nvar __decorate2 = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar WebsocketSignalManager = class {\n  constructor(_hosts) {\n    this._hosts = _hosts;\n    this._servers = /* @__PURE__ */ new Map();\n    this._topicsJoined = new ComplexMap4((topic) => topic.toHex());\n    this._topicsJoinedPerSignal = /* @__PURE__ */ new Map();\n    this._reconciling = false;\n    this._destroyed = false;\n    this.statusChanged = new Event4();\n    this.commandTrace = new Event4();\n    this.swarmEvent = new Event4();\n    this.onMessage = new Event4();\n    log5(`Created WebsocketSignalManager with signal servers: ${_hosts}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 48,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    assert4(_hosts.length === 1, \"Only a single signaling server connection is supported\");\n    for (const host of this._hosts) {\n      const server = new SignalClient(host, async (message) => this.onMessage.emit(message));\n      server.swarmEvent.on((data) => this.swarmEvent.emit(data));\n      server.statusChanged.on(() => this.statusChanged.emit(this.getStatus()));\n      this._servers.set(host, server);\n      server.commandTrace.on((trace) => this.commandTrace.emit(trace));\n      this._topicsJoinedPerSignal.set(host, new ComplexMap4(PublicKey4.hash));\n    }\n  }\n  getStatus() {\n    return Array.from(this._servers.values()).map((server) => server.getStatus());\n  }\n  async join({ topic, peerId }) {\n    assert4(!this._topicsJoined.has(topic), `Topic ${topic} is already joined`);\n    log5(`Join ${topic} ${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 68,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.set(topic, peerId);\n    this._scheduleReconcile();\n  }\n  async leave({ topic, peerId }) {\n    assert4(!!this._topicsJoined.has(topic), `Topic ${topic} was not joined`);\n    log5(\"leaving\", {\n      topic,\n      peerId\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 75,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._topicsJoined.delete(topic);\n    this._scheduleReconcile();\n  }\n  _scheduleReconcile() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconciling) {\n      this._reconciling = true;\n      this._reconcileJoinedTopics().then(() => {\n        this._reconciling = false;\n      }, (err) => {\n        this._reconciling = false;\n        log5.error(`Error while reconciling: ${err}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n          line: 93,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._reconcileLater();\n      });\n    } else {\n      this._reconcileLater();\n    }\n  }\n  _reconcileLater() {\n    if (this._destroyed) {\n      return;\n    }\n    if (!this._reconcileTimeoutId) {\n      this._reconcileTimeoutId = setTimeout(async () => this._scheduleReconcile(), 3e3);\n    }\n  }\n  async _reconcileJoinedTopics() {\n    log5(\"Reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 115,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    for (const [host, server] of this._servers) {\n      const actualJoinedTopics = this._topicsJoinedPerSignal.get(host);\n      for (const [topic, actualPeerId] of actualJoinedTopics) {\n        try {\n          const desiredPeerId = this._topicsJoined.get(topic);\n          if (!desiredPeerId || !desiredPeerId.equals(actualPeerId)) {\n            await server.leave({\n              topic,\n              peerId: actualPeerId\n            });\n            actualJoinedTopics.delete(topic);\n          }\n        } catch (err) {\n          log5.error(`Error leaving swarm: ${err}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 128,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n      for (const [topic1, desiredPeerId1] of this._topicsJoined) {\n        try {\n          const actualPeerId1 = actualJoinedTopics.get(topic1);\n          if (!actualPeerId1) {\n            await server.join({\n              topic: topic1,\n              peerId: desiredPeerId1\n            });\n            actualJoinedTopics.set(topic1, desiredPeerId1);\n          } else {\n            if (!actualPeerId1.equals(desiredPeerId1)) {\n              throw new Error(`Joined with peerId different from desired: ${JSON.stringify({\n                actualPeerId: actualPeerId1,\n                desiredPeerId: desiredPeerId1\n              })}`);\n            }\n          }\n        } catch (err1) {\n          log5.error(`Error joining swarm: ${err1}`, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n            line: 151,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          this._scheduleReconcile();\n        }\n      }\n    }\n    log5(\"Done reconciling..\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 156,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._reconciling = false;\n  }\n  async sendMessage({ author, recipient, payload }) {\n    log5(`Signal ${recipient}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 169,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((server) => server.sendMessage({\n      author,\n      recipient,\n      payload\n    }).catch((err) => log5(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 172,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async subscribeMessages(peerId) {\n    log5(`Subscribed for message stream peerId=${peerId}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/messaging/src/websocket-signal-manager.ts\",\n      line: 178,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all([\n      ...this._servers.values()\n    ].map((signalClient) => signalClient.subscribeMessages(peerId)));\n  }\n  async destroy() {\n    this._destroyed = true;\n    if (this._reconcileTimeoutId) {\n      clearTimeout(this._reconcileTimeoutId);\n    }\n    await Promise.all(Array.from(this._servers.values()).map((server) => server.close()));\n  }\n};\n__decorate2([\n  synchronized2\n], WebsocketSignalManager.prototype, \"_reconcileJoinedTopics\", null);\nexport {\n  MemorySignalManager,\n  MemorySignalManagerContext,\n  Messenger,\n  SignalClient,\n  SignalState,\n  WebsocketSignalManager\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466221,"end":1670465466229,"order":"normal"}]}
