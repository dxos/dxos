{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/bitfield-rle@2.2.1/node_modules/bitfield-rle/index.js","transforms":[{"name":"vite:load-fallback","result":"var varint = require('varint')\nvar alloc = require('buffer-alloc-unsafe')\n\nmodule.exports = align(1)\n\nfunction align (n) {\n  var exports = {}\n\n  exports.align = align\n\n  exports.encode = encode\n  exports.encode.bytes = 0\n  exports.encodingLength = encodingLength\n\n  exports.decode = decode\n  exports.decode.bytes = 0\n  exports.decodingLength = decodingLength\n\n  return exports\n\n  function State (input, output, offset) {\n    this.inputOffset = 0\n    this.inputLength = input.length\n    this.input = input\n    this.outputOffset = offset\n    this.output = output\n  }\n\n  function encode (bitfield, buffer, offset) {\n    if (!offset) offset = 0\n    if (!buffer) buffer = alloc(encodingLength(bitfield))\n    var state = new State(bitfield, buffer, offset)\n    rle(state)\n    encode.bytes = state.outputOffset - offset\n    return buffer\n  }\n\n  function encodingLength (bitfield) {\n    var state = new State(bitfield, null, 0)\n    rle(state)\n    return state.outputOffset\n  }\n\n  function decode (buffer, offset) {\n    if (!offset) offset = 0\n\n    var bitfield = alloc(decodingLength(buffer, offset))\n    var ptr = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      var repeat = next & 1\n      var len = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      offset += varint.decode.bytes\n\n      if (repeat) {\n        bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)\n      } else {\n        buffer.copy(bitfield, ptr, offset, offset + len)\n        offset += len\n      }\n\n      ptr += len\n    }\n\n    bitfield.fill(0, ptr)\n    decode.bytes = buffer.length - offset\n\n    return bitfield\n  }\n\n  function decodingLength (buffer, offset) {\n    if (!offset) offset = 0\n\n    var len = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      offset += varint.decode.bytes\n\n      var repeat = next & 1\n      var slice = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      len += slice\n      if (!repeat) offset += slice\n    }\n\n    if (offset > buffer.length) throw new Error('Invalid RLE bitfield')\n\n    if (len & (n - 1)) return len + (n - (len & (n - 1)))\n\n    return len\n  }\n\n  function rle (state) {\n    var len = 0\n    var bits = 0\n    var input = state.input\n\n    while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--\n\n    for (var i = 0; i < state.inputLength; i++) {\n      if (input[i] === bits) {\n        len++\n        continue\n      }\n\n      if (len) encodeUpdate(state, i, len, bits)\n\n      if (input[i] === 0 || input[i] === 255) {\n        bits = input[i]\n        len = 1\n      } else {\n        len = 0\n      }\n    }\n\n    if (len) encodeUpdate(state, state.inputLength, len, bits)\n    encodeFinal(state)\n  }\n\n  function encodeHead (state, end) {\n    var headLength = end - state.inputOffset\n    varint.encode(2 * headLength, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.input.copy(state.output, state.outputOffset, state.inputOffset, end)\n    state.outputOffset += headLength\n  }\n\n  function encodeFinal (state) {\n    var headLength = state.inputLength - state.inputOffset\n    if (!headLength) return\n\n    if (!state.output) {\n      state.outputOffset += (headLength + varint.encodingLength(2 * headLength))\n    } else {\n      encodeHead(state, state.inputLength)\n    }\n\n    state.inputOffset = state.inputLength\n  }\n\n  function encodeUpdate (state, i, len, bit) {\n    var headLength = i - len - state.inputOffset\n    var headCost = (headLength ? varint.encodingLength(2 * headLength) + headLength : 0)\n    var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1\n    var encCost = headCost + varint.encodingLength(enc)\n    var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset\n\n    if (encCost >= baseCost) return\n\n    if (!state.output) {\n      state.outputOffset += encCost\n      state.inputOffset = i\n      return\n    }\n\n    if (headLength) encodeHead(state, i - len)\n\n    varint.encode(enc, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.inputOffset = i\n  }\n}\n","start":1670465470031,"end":1670465470118},{"name":"vite:react-babel","result":"var varint = require('varint')\nvar alloc = require('buffer-alloc-unsafe')\n\nmodule.exports = align(1)\n\nfunction align (n) {\n  var exports = {}\n\n  exports.align = align\n\n  exports.encode = encode\n  exports.encode.bytes = 0\n  exports.encodingLength = encodingLength\n\n  exports.decode = decode\n  exports.decode.bytes = 0\n  exports.decodingLength = decodingLength\n\n  return exports\n\n  function State (input, output, offset) {\n    this.inputOffset = 0\n    this.inputLength = input.length\n    this.input = input\n    this.outputOffset = offset\n    this.output = output\n  }\n\n  function encode (bitfield, buffer, offset) {\n    if (!offset) offset = 0\n    if (!buffer) buffer = alloc(encodingLength(bitfield))\n    var state = new State(bitfield, buffer, offset)\n    rle(state)\n    encode.bytes = state.outputOffset - offset\n    return buffer\n  }\n\n  function encodingLength (bitfield) {\n    var state = new State(bitfield, null, 0)\n    rle(state)\n    return state.outputOffset\n  }\n\n  function decode (buffer, offset) {\n    if (!offset) offset = 0\n\n    var bitfield = alloc(decodingLength(buffer, offset))\n    var ptr = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      var repeat = next & 1\n      var len = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      offset += varint.decode.bytes\n\n      if (repeat) {\n        bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)\n      } else {\n        buffer.copy(bitfield, ptr, offset, offset + len)\n        offset += len\n      }\n\n      ptr += len\n    }\n\n    bitfield.fill(0, ptr)\n    decode.bytes = buffer.length - offset\n\n    return bitfield\n  }\n\n  function decodingLength (buffer, offset) {\n    if (!offset) offset = 0\n\n    var len = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      offset += varint.decode.bytes\n\n      var repeat = next & 1\n      var slice = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      len += slice\n      if (!repeat) offset += slice\n    }\n\n    if (offset > buffer.length) throw new Error('Invalid RLE bitfield')\n\n    if (len & (n - 1)) return len + (n - (len & (n - 1)))\n\n    return len\n  }\n\n  function rle (state) {\n    var len = 0\n    var bits = 0\n    var input = state.input\n\n    while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--\n\n    for (var i = 0; i < state.inputLength; i++) {\n      if (input[i] === bits) {\n        len++\n        continue\n      }\n\n      if (len) encodeUpdate(state, i, len, bits)\n\n      if (input[i] === 0 || input[i] === 255) {\n        bits = input[i]\n        len = 1\n      } else {\n        len = 0\n      }\n    }\n\n    if (len) encodeUpdate(state, state.inputLength, len, bits)\n    encodeFinal(state)\n  }\n\n  function encodeHead (state, end) {\n    var headLength = end - state.inputOffset\n    varint.encode(2 * headLength, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.input.copy(state.output, state.outputOffset, state.inputOffset, end)\n    state.outputOffset += headLength\n  }\n\n  function encodeFinal (state) {\n    var headLength = state.inputLength - state.inputOffset\n    if (!headLength) return\n\n    if (!state.output) {\n      state.outputOffset += (headLength + varint.encodingLength(2 * headLength))\n    } else {\n      encodeHead(state, state.inputLength)\n    }\n\n    state.inputOffset = state.inputLength\n  }\n\n  function encodeUpdate (state, i, len, bit) {\n    var headLength = i - len - state.inputOffset\n    var headCost = (headLength ? varint.encodingLength(2 * headLength) + headLength : 0)\n    var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1\n    var encCost = headCost + varint.encodingLength(enc)\n    var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset\n\n    if (encCost >= baseCost) return\n\n    if (!state.output) {\n      state.outputOffset += encCost\n      state.inputOffset = i\n      return\n    }\n\n    if (headLength) encodeHead(state, i - len)\n\n    varint.encode(enc, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.inputOffset = i\n  }\n}\n","start":1670465470118,"end":1670465470118,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@4.0.1/node_modules/varint/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer-alloc-unsafe@1.1.0/node_modules/buffer-alloc-unsafe/index.js?commonjs-proxy\";\n\nvar varint = require$$0\nvar alloc = require$$1\n\nvar bitfieldRle = align(1)\n\nfunction align (n) {\n  var exports = {}\n\n  exports.align = align\n\n  exports.encode = encode\n  exports.encode.bytes = 0\n  exports.encodingLength = encodingLength\n\n  exports.decode = decode\n  exports.decode.bytes = 0\n  exports.decodingLength = decodingLength\n\n  return exports\n\n  function State (input, output, offset) {\n    this.inputOffset = 0\n    this.inputLength = input.length\n    this.input = input\n    this.outputOffset = offset\n    this.output = output\n  }\n\n  function encode (bitfield, buffer, offset) {\n    if (!offset) offset = 0\n    if (!buffer) buffer = alloc(encodingLength(bitfield))\n    var state = new State(bitfield, buffer, offset)\n    rle(state)\n    encode.bytes = state.outputOffset - offset\n    return buffer\n  }\n\n  function encodingLength (bitfield) {\n    var state = new State(bitfield, null, 0)\n    rle(state)\n    return state.outputOffset\n  }\n\n  function decode (buffer, offset) {\n    if (!offset) offset = 0\n\n    var bitfield = alloc(decodingLength(buffer, offset))\n    var ptr = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      var repeat = next & 1\n      var len = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      offset += varint.decode.bytes\n\n      if (repeat) {\n        bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len)\n      } else {\n        buffer.copy(bitfield, ptr, offset, offset + len)\n        offset += len\n      }\n\n      ptr += len\n    }\n\n    bitfield.fill(0, ptr)\n    decode.bytes = buffer.length - offset\n\n    return bitfield\n  }\n\n  function decodingLength (buffer, offset) {\n    if (!offset) offset = 0\n\n    var len = 0\n\n    while (offset < buffer.length) {\n      var next = varint.decode(buffer, offset)\n      offset += varint.decode.bytes\n\n      var repeat = next & 1\n      var slice = repeat ? (next - (next & 3)) / 4 : next / 2\n\n      len += slice\n      if (!repeat) offset += slice\n    }\n\n    if (offset > buffer.length) throw new Error('Invalid RLE bitfield')\n\n    if (len & (n - 1)) return len + (n - (len & (n - 1)))\n\n    return len\n  }\n\n  function rle (state) {\n    var len = 0\n    var bits = 0\n    var input = state.input\n\n    while (state.inputLength > 0 && !input[state.inputLength - 1]) state.inputLength--\n\n    for (var i = 0; i < state.inputLength; i++) {\n      if (input[i] === bits) {\n        len++\n        continue\n      }\n\n      if (len) encodeUpdate(state, i, len, bits)\n\n      if (input[i] === 0 || input[i] === 255) {\n        bits = input[i]\n        len = 1\n      } else {\n        len = 0\n      }\n    }\n\n    if (len) encodeUpdate(state, state.inputLength, len, bits)\n    encodeFinal(state)\n  }\n\n  function encodeHead (state, end) {\n    var headLength = end - state.inputOffset\n    varint.encode(2 * headLength, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.input.copy(state.output, state.outputOffset, state.inputOffset, end)\n    state.outputOffset += headLength\n  }\n\n  function encodeFinal (state) {\n    var headLength = state.inputLength - state.inputOffset\n    if (!headLength) return\n\n    if (!state.output) {\n      state.outputOffset += (headLength + varint.encodingLength(2 * headLength))\n    } else {\n      encodeHead(state, state.inputLength)\n    }\n\n    state.inputOffset = state.inputLength\n  }\n\n  function encodeUpdate (state, i, len, bit) {\n    var headLength = i - len - state.inputOffset\n    var headCost = (headLength ? varint.encodingLength(2 * headLength) + headLength : 0)\n    var enc = 4 * len + (bit ? 2 : 0) + 1 // len << 2 | bit << 1 | 1\n    var encCost = headCost + varint.encodingLength(enc)\n    var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset\n\n    if (encCost >= baseCost) return\n\n    if (!state.output) {\n      state.outputOffset += encCost\n      state.inputOffset = i\n      return\n    }\n\n    if (headLength) encodeHead(state, i - len)\n\n    varint.encode(enc, state.output, state.outputOffset)\n    state.outputOffset += varint.encode.bytes\n    state.inputOffset = i\n  }\n}\n\nexport default bitfieldRle;\nexport { bitfieldRle as __moduleExports };","start":1670465470118,"end":1670465471161,"order":"normal"}]}
