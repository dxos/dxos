{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(\"./namespace\"),\n    util = require(\"./util\");\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n */\nfunction Enum(name, values, options, comment, comments) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"  , this.options,\n        \"values\"   , this.values,\n        \"reserved\" , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"  , keepComments ? this.comment : undefined,\n        \"comments\" , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","start":1670465470597,"end":1670465470651},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(\"./namespace\"),\n    util = require(\"./util\");\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n */\nfunction Enum(name, values, options, comment, comments) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"  , this.options,\n        \"values\"   , this.values,\n        \"reserved\" , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"  , keepComments ? this.comment : undefined,\n        \"comments\" , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","start":1670465470651,"end":1670465470651,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/object.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/namespace.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar _enum;\nvar hasRequired_enum;\n\nfunction require_enum () {\n\tif (hasRequired_enum) return _enum;\n\thasRequired_enum = 1;\n\t\"use strict\";\n\t_enum = Enum;\n\n\t// extends ReflectionObject\n\tvar ReflectionObject = require$$0();\n\t((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\n\tvar Namespace = require$$1(),\n\t    util = require$$2();\n\n\t/**\n\t * Constructs a new enum instance.\n\t * @classdesc Reflected enum.\n\t * @extends ReflectionObject\n\t * @constructor\n\t * @param {string} name Unique name within its namespace\n\t * @param {Object.<string,number>} [values] Enum values as an object, by name\n\t * @param {Object.<string,*>} [options] Declared options\n\t * @param {string} [comment] The comment for this enum\n\t * @param {Object.<string,string>} [comments] The value comments for this enum\n\t */\n\tfunction Enum(name, values, options, comment, comments) {\n\t    ReflectionObject.call(this, name, options);\n\n\t    if (values && typeof values !== \"object\")\n\t        throw TypeError(\"values must be an object\");\n\n\t    /**\n\t     * Enum values by id.\n\t     * @type {Object.<number,string>}\n\t     */\n\t    this.valuesById = {};\n\n\t    /**\n\t     * Enum values by name.\n\t     * @type {Object.<string,number>}\n\t     */\n\t    this.values = Object.create(this.valuesById); // toJSON, marker\n\n\t    /**\n\t     * Enum comment text.\n\t     * @type {string|null}\n\t     */\n\t    this.comment = comment;\n\n\t    /**\n\t     * Value comment texts, if any.\n\t     * @type {Object.<string,string>}\n\t     */\n\t    this.comments = comments || {};\n\n\t    /**\n\t     * Reserved ranges, if any.\n\t     * @type {Array.<number[]|string>}\n\t     */\n\t    this.reserved = undefined; // toJSON\n\n\t    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n\t    // compatible enum. This is used by pbts to write actual enum definitions that work for\n\t    // static and reflection code alike instead of emitting generic object definitions.\n\n\t    if (values)\n\t        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n\t            if (typeof values[keys[i]] === \"number\") // use forward entries only\n\t                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n\t}\n\n\t/**\n\t * Enum descriptor.\n\t * @interface IEnum\n\t * @property {Object.<string,number>} values Enum values\n\t * @property {Object.<string,*>} [options] Enum options\n\t */\n\n\t/**\n\t * Constructs an enum from an enum descriptor.\n\t * @param {string} name Enum name\n\t * @param {IEnum} json Enum descriptor\n\t * @returns {Enum} Created enum\n\t * @throws {TypeError} If arguments are invalid\n\t */\n\tEnum.fromJSON = function fromJSON(name, json) {\n\t    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n\t    enm.reserved = json.reserved;\n\t    return enm;\n\t};\n\n\t/**\n\t * Converts this enum to an enum descriptor.\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {IEnum} Enum descriptor\n\t */\n\tEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n\t    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n\t    return util.toObject([\n\t        \"options\"  , this.options,\n\t        \"values\"   , this.values,\n\t        \"reserved\" , this.reserved && this.reserved.length ? this.reserved : undefined,\n\t        \"comment\"  , keepComments ? this.comment : undefined,\n\t        \"comments\" , keepComments ? this.comments : undefined\n\t    ]);\n\t};\n\n\t/**\n\t * Adds a value to this enum.\n\t * @param {string} name Value name\n\t * @param {number} id Value id\n\t * @param {string} [comment] Comment, if any\n\t * @returns {Enum} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If there is already a value with this name or id\n\t */\n\tEnum.prototype.add = function add(name, id, comment) {\n\t    // utilized by the parser but not by .fromJSON\n\n\t    if (!util.isString(name))\n\t        throw TypeError(\"name must be a string\");\n\n\t    if (!util.isInteger(id))\n\t        throw TypeError(\"id must be an integer\");\n\n\t    if (this.values[name] !== undefined)\n\t        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n\t    if (this.isReservedId(id))\n\t        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n\t    if (this.isReservedName(name))\n\t        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n\t    if (this.valuesById[id] !== undefined) {\n\t        if (!(this.options && this.options.allow_alias))\n\t            throw Error(\"duplicate id \" + id + \" in \" + this);\n\t        this.values[name] = id;\n\t    } else\n\t        this.valuesById[this.values[name] = id] = name;\n\n\t    this.comments[name] = comment || null;\n\t    return this;\n\t};\n\n\t/**\n\t * Removes a value from this enum\n\t * @param {string} name Value name\n\t * @returns {Enum} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If `name` is not a name of this enum\n\t */\n\tEnum.prototype.remove = function remove(name) {\n\n\t    if (!util.isString(name))\n\t        throw TypeError(\"name must be a string\");\n\n\t    var val = this.values[name];\n\t    if (val == null)\n\t        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n\t    delete this.valuesById[val];\n\t    delete this.values[name];\n\t    delete this.comments[name];\n\n\t    return this;\n\t};\n\n\t/**\n\t * Tests if the specified id is reserved.\n\t * @param {number} id Id to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tEnum.prototype.isReservedId = function isReservedId(id) {\n\t    return Namespace.isReservedId(this.reserved, id);\n\t};\n\n\t/**\n\t * Tests if the specified name is reserved.\n\t * @param {string} name Name to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tEnum.prototype.isReservedName = function isReservedName(name) {\n\t    return Namespace.isReservedName(this.reserved, name);\n\t};\n\treturn _enum;\n}\n\nexport { require_enum as __require };","start":1670465470652,"end":1670465471397,"order":"normal"}]}
