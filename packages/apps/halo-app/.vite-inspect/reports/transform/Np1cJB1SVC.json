{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js","transforms":[{"name":"vite:load-fallback","result":"const ascii = require('./lib/ascii')\nconst base64 = require('./lib/base64')\nconst hex = require('./lib/hex')\nconst utf8 = require('./lib/utf8')\nconst utf16le = require('./lib/utf16le')\n\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\nfunction codecFor (encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii\n    case 'base64':\n      return base64\n    case 'hex':\n      return hex\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`)\n  }\n}\n\nfunction isBuffer (value) {\n  return value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  try {\n    codecFor(encoding)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  const buffer = new Uint8Array(size)\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n  return buffer\n}\n\nfunction allocUnsafe (size) {\n  return new Uint8Array(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return new Uint8Array(size)\n}\n\nfunction byteLength (string, encoding) {\n  return codecFor(encoding).byteLength(string)\n}\n\nfunction compare (a, b) {\n  if (a === b) return 0\n\n  const len = Math.min(a.byteLength, b.byteLength)\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    const x = a.getUint32(i, LE)\n    const y = b.getUint32(i, LE)\n    if (x !== y) break\n  }\n\n  for (; i < len; i++) {\n    const x = a.getUint8(i)\n    const y = b.getUint8(i)\n    if (x < y) return -1\n    if (x > y) return 1\n  }\n\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n}\n\nfunction concat (buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n  }\n\n  const result = new Uint8Array(totalLength)\n\n  buffers.reduce(\n    (offset, buffer) => {\n      result.set(buffer, offset)\n      return offset + buffer.byteLength\n    },\n    0\n  )\n\n  return result\n}\n\nfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n  if (end > 0 && end < start) return 0\n  if (end === start) return 0\n  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n  if (targetStart >= target.byteLength) targetStart = target.byteLength\n  if (end > source.byteLength) end = source.byteLength\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (source === target) {\n    target.copyWithin(targetStart, start, end)\n  } else {\n    target.set(source.subarray(start, end), targetStart)\n  }\n\n  return len\n}\n\nfunction equals (a, b) {\n  if (a === b) return true\n  if (a.byteLength !== b.byteLength) return false\n\n  const len = a.byteLength\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n  }\n\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false\n  }\n\n  return true\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset\n      offset = 0\n      end = buffer.byteLength\n\n    // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.byteLength\n    }\n  } else if (typeof val === 'number') {\n    value = value & 0xff\n  } else if (typeof val === 'boolean') {\n    value = +value\n  }\n\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (offset === undefined) offset = 0\n  if (end === undefined) end = buffer.byteLength\n\n  if (end <= offset) return buffer\n\n  if (!value) value = 0\n\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding)\n\n    const len = value.byteLength\n\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len]\n    }\n  }\n\n  return buffer\n}\n\nfunction from (value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value)\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length)\n}\n\nfunction fromString (string, encoding) {\n  const codec = codecFor(encoding)\n  const buffer = new Uint8Array(codec.byteLength(string))\n  codec.write(buffer, string, 0, buffer.byteLength)\n  return buffer\n}\n\nfunction fromArray (array) {\n  const buffer = new Uint8Array(array.length)\n  buffer.set(array)\n  return buffer\n}\n\nfunction fromBuffer (buffer) {\n  const copy = new Uint8Array(buffer.byteLength)\n  copy.set(buffer)\n  return copy\n}\n\nfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1\n}\n\nfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : (buffer.length - 1)\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength\n  }\n\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1\n    else byteOffset = buffer.byteLength - 1\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof value === 'string') {\n    value = from(value, encoding)\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n\n    if (first) {\n      return buffer.indexOf(value, byteOffset)\n    } else {\n      return buffer.lastIndexOf(value, byteOffset)\n    }\n  }\n\n  if (value.byteLength === 0) return -1\n\n  if (first) {\n    let foundIndex = -1\n\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength\n    }\n\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true\n\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false\n          break\n        }\n      }\n\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nfunction indexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n}\n\nfunction swap (buffer, n, m) {\n  const i = buffer[n]\n  buffer[n] = buffer[m]\n  buffer[m] = i\n}\n\nfunction swap16 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n  return buffer\n}\n\nfunction swap32 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3)\n    swap(buffer, i + 1, i + 2)\n  }\n\n  return buffer\n}\n\nfunction swap64 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7)\n    swap(buffer, i + 1, i + 6)\n    swap(buffer, i + 2, i + 5)\n    swap(buffer, i + 3, i + 4)\n  }\n\n  return buffer\n}\n\nfunction toBuffer (buffer) {\n  return buffer\n}\n\nfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n  const len = buffer.byteLength\n\n  if (start >= len) return ''\n  if (end <= start) return ''\n  if (start < 0) start = 0\n  if (end > len) end = len\n\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n  return codecFor(encoding).toString(buffer)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n\n  // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n\n  // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length\n    length = undefined\n  }\n\n  return codecFor(encoding).write(buffer, string, offset, length)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat64(offset, value, true)\n\n  return offset + 8\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setUint32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setInt32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction readDoubleLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat64(offset, true)\n}\n\nfunction readFloatLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat32(offset, true)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getUint32(offset, true)\n}\n\nfunction readInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getInt32(offset, true)\n}\n\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n}\n","start":1670465469537,"end":1670465469818},{"name":"vite:react-babel","result":"const ascii = require('./lib/ascii')\nconst base64 = require('./lib/base64')\nconst hex = require('./lib/hex')\nconst utf8 = require('./lib/utf8')\nconst utf16le = require('./lib/utf16le')\n\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\nfunction codecFor (encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii\n    case 'base64':\n      return base64\n    case 'hex':\n      return hex\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`)\n  }\n}\n\nfunction isBuffer (value) {\n  return value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  try {\n    codecFor(encoding)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  const buffer = new Uint8Array(size)\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n  return buffer\n}\n\nfunction allocUnsafe (size) {\n  return new Uint8Array(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return new Uint8Array(size)\n}\n\nfunction byteLength (string, encoding) {\n  return codecFor(encoding).byteLength(string)\n}\n\nfunction compare (a, b) {\n  if (a === b) return 0\n\n  const len = Math.min(a.byteLength, b.byteLength)\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    const x = a.getUint32(i, LE)\n    const y = b.getUint32(i, LE)\n    if (x !== y) break\n  }\n\n  for (; i < len; i++) {\n    const x = a.getUint8(i)\n    const y = b.getUint8(i)\n    if (x < y) return -1\n    if (x > y) return 1\n  }\n\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n}\n\nfunction concat (buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n  }\n\n  const result = new Uint8Array(totalLength)\n\n  buffers.reduce(\n    (offset, buffer) => {\n      result.set(buffer, offset)\n      return offset + buffer.byteLength\n    },\n    0\n  )\n\n  return result\n}\n\nfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n  if (end > 0 && end < start) return 0\n  if (end === start) return 0\n  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n  if (targetStart >= target.byteLength) targetStart = target.byteLength\n  if (end > source.byteLength) end = source.byteLength\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (source === target) {\n    target.copyWithin(targetStart, start, end)\n  } else {\n    target.set(source.subarray(start, end), targetStart)\n  }\n\n  return len\n}\n\nfunction equals (a, b) {\n  if (a === b) return true\n  if (a.byteLength !== b.byteLength) return false\n\n  const len = a.byteLength\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n  }\n\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false\n  }\n\n  return true\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset\n      offset = 0\n      end = buffer.byteLength\n\n    // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.byteLength\n    }\n  } else if (typeof val === 'number') {\n    value = value & 0xff\n  } else if (typeof val === 'boolean') {\n    value = +value\n  }\n\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (offset === undefined) offset = 0\n  if (end === undefined) end = buffer.byteLength\n\n  if (end <= offset) return buffer\n\n  if (!value) value = 0\n\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding)\n\n    const len = value.byteLength\n\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len]\n    }\n  }\n\n  return buffer\n}\n\nfunction from (value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value)\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length)\n}\n\nfunction fromString (string, encoding) {\n  const codec = codecFor(encoding)\n  const buffer = new Uint8Array(codec.byteLength(string))\n  codec.write(buffer, string, 0, buffer.byteLength)\n  return buffer\n}\n\nfunction fromArray (array) {\n  const buffer = new Uint8Array(array.length)\n  buffer.set(array)\n  return buffer\n}\n\nfunction fromBuffer (buffer) {\n  const copy = new Uint8Array(buffer.byteLength)\n  copy.set(buffer)\n  return copy\n}\n\nfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1\n}\n\nfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : (buffer.length - 1)\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength\n  }\n\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1\n    else byteOffset = buffer.byteLength - 1\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof value === 'string') {\n    value = from(value, encoding)\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n\n    if (first) {\n      return buffer.indexOf(value, byteOffset)\n    } else {\n      return buffer.lastIndexOf(value, byteOffset)\n    }\n  }\n\n  if (value.byteLength === 0) return -1\n\n  if (first) {\n    let foundIndex = -1\n\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength\n    }\n\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true\n\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false\n          break\n        }\n      }\n\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nfunction indexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n}\n\nfunction swap (buffer, n, m) {\n  const i = buffer[n]\n  buffer[n] = buffer[m]\n  buffer[m] = i\n}\n\nfunction swap16 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n  return buffer\n}\n\nfunction swap32 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3)\n    swap(buffer, i + 1, i + 2)\n  }\n\n  return buffer\n}\n\nfunction swap64 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7)\n    swap(buffer, i + 1, i + 6)\n    swap(buffer, i + 2, i + 5)\n    swap(buffer, i + 3, i + 4)\n  }\n\n  return buffer\n}\n\nfunction toBuffer (buffer) {\n  return buffer\n}\n\nfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n  const len = buffer.byteLength\n\n  if (start >= len) return ''\n  if (end <= start) return ''\n  if (start < 0) start = 0\n  if (end > len) end = len\n\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n  return codecFor(encoding).toString(buffer)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n\n  // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n\n  // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length\n    length = undefined\n  }\n\n  return codecFor(encoding).write(buffer, string, offset, length)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat64(offset, value, true)\n\n  return offset + 8\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setUint32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setInt32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction readDoubleLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat64(offset, true)\n}\n\nfunction readFloatLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat32(offset, true)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getUint32(offset, true)\n}\n\nfunction readInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getInt32(offset, true)\n}\n\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n}\n","start":1670465469818,"end":1670465469818,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as browserModule, exports as browser } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-module\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/ascii.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/base64.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/hex.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/utf8.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/utf16le.js?commonjs-proxy\";\n\n(function (module, exports) {\n\tconst ascii = require$$0\n\tconst base64 = require$$1\n\tconst hex = require$$2\n\tconst utf8 = require$$3\n\tconst utf16le = require$$4\n\n\tconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\n\tfunction codecFor (encoding) {\n\t  switch (encoding) {\n\t    case 'ascii':\n\t      return ascii\n\t    case 'base64':\n\t      return base64\n\t    case 'hex':\n\t      return hex\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case undefined:\n\t      return utf8\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return utf16le\n\t    default:\n\t      throw new Error(`Unknown encoding: ${encoding}`)\n\t  }\n\t}\n\n\tfunction isBuffer (value) {\n\t  return value instanceof Uint8Array\n\t}\n\n\tfunction isEncoding (encoding) {\n\t  try {\n\t    codecFor(encoding)\n\t    return true\n\t  } catch {\n\t    return false\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  const buffer = new Uint8Array(size)\n\t  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n\t  return buffer\n\t}\n\n\tfunction allocUnsafe (size) {\n\t  return new Uint8Array(size)\n\t}\n\n\tfunction allocUnsafeSlow (size) {\n\t  return new Uint8Array(size)\n\t}\n\n\tfunction byteLength (string, encoding) {\n\t  return codecFor(encoding).byteLength(string)\n\t}\n\n\tfunction compare (a, b) {\n\t  if (a === b) return 0\n\n\t  const len = Math.min(a.byteLength, b.byteLength)\n\n\t  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n\t  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n\t  let i = 0\n\n\t  for (let n = len - (len % 4); i < n; i += 4) {\n\t    const x = a.getUint32(i, LE)\n\t    const y = b.getUint32(i, LE)\n\t    if (x !== y) break\n\t  }\n\n\t  for (; i < len; i++) {\n\t    const x = a.getUint8(i)\n\t    const y = b.getUint8(i)\n\t    if (x < y) return -1\n\t    if (x > y) return 1\n\t  }\n\n\t  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n\t}\n\n\tfunction concat (buffers, totalLength) {\n\t  if (totalLength === undefined) {\n\t    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n\t  }\n\n\t  const result = new Uint8Array(totalLength)\n\n\t  buffers.reduce(\n\t    (offset, buffer) => {\n\t      result.set(buffer, offset)\n\t      return offset + buffer.byteLength\n\t    },\n\t    0\n\t  )\n\n\t  return result\n\t}\n\n\tfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n\t  if (end > 0 && end < start) return 0\n\t  if (end === start) return 0\n\t  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n\t  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n\t  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n\t  if (targetStart >= target.byteLength) targetStart = target.byteLength\n\t  if (end > source.byteLength) end = source.byteLength\n\t  if (target.byteLength - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\n\t  const len = end - start\n\n\t  if (source === target) {\n\t    target.copyWithin(targetStart, start, end)\n\t  } else {\n\t    target.set(source.subarray(start, end), targetStart)\n\t  }\n\n\t  return len\n\t}\n\n\tfunction equals (a, b) {\n\t  if (a === b) return true\n\t  if (a.byteLength !== b.byteLength) return false\n\n\t  const len = a.byteLength\n\n\t  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n\t  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n\t  let i = 0\n\n\t  for (let n = len - (len % 4); i < n; i += 4) {\n\t    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n\t  }\n\n\t  for (; i < len; i++) {\n\t    if (a.getUint8(i) !== b.getUint8(i)) return false\n\t  }\n\n\t  return true\n\t}\n\n\tfunction fill (buffer, value, offset, end, encoding) {\n\t  if (typeof value === 'string') {\n\t    // fill(buffer, string, encoding)\n\t    if (typeof offset === 'string') {\n\t      encoding = offset\n\t      offset = 0\n\t      end = buffer.byteLength\n\n\t    // fill(buffer, string, offset, encoding)\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = buffer.byteLength\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    value = value & 0xff\n\t  } else if (typeof val === 'boolean') {\n\t    value = +value\n\t  }\n\n\t  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (offset === undefined) offset = 0\n\t  if (end === undefined) end = buffer.byteLength\n\n\t  if (end <= offset) return buffer\n\n\t  if (!value) value = 0\n\n\t  if (typeof value === 'number') {\n\t    for (let i = offset; i < end; ++i) {\n\t      buffer[i] = value\n\t    }\n\t  } else {\n\t    value = isBuffer(value) ? value : from(value, encoding)\n\n\t    const len = value.byteLength\n\n\t    for (let i = 0; i < end - offset; ++i) {\n\t      buffer[i + offset] = value[i % len]\n\t    }\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  // from(string, encoding)\n\t  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n\t  // from(array)\n\t  if (Array.isArray(value)) return fromArray(value)\n\n\t  // from(buffer)\n\t  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n\t  // from(arrayBuffer[, byteOffset[, length]])\n\t  return fromArrayBuffer(value, encodingOrOffset, length)\n\t}\n\n\tfunction fromString (string, encoding) {\n\t  const codec = codecFor(encoding)\n\t  const buffer = new Uint8Array(codec.byteLength(string))\n\t  codec.write(buffer, string, 0, buffer.byteLength)\n\t  return buffer\n\t}\n\n\tfunction fromArray (array) {\n\t  const buffer = new Uint8Array(array.length)\n\t  buffer.set(array)\n\t  return buffer\n\t}\n\n\tfunction fromBuffer (buffer) {\n\t  const copy = new Uint8Array(buffer.byteLength)\n\t  copy.set(buffer)\n\t  return copy\n\t}\n\n\tfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n\t  return new Uint8Array(arrayBuffer, byteOffset, length)\n\t}\n\n\tfunction includes (buffer, value, byteOffset, encoding) {\n\t  return indexOf(buffer, value, byteOffset, encoding) !== -1\n\t}\n\n\tfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n\t  if (buffer.byteLength === 0) return -1\n\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset === undefined) {\n\t    byteOffset = first ? 0 : (buffer.length - 1)\n\t  } else if (byteOffset < 0) {\n\t    byteOffset += buffer.byteLength\n\t  }\n\n\t  if (byteOffset >= buffer.byteLength) {\n\t    if (first) return -1\n\t    else byteOffset = buffer.byteLength - 1\n\t  } else if (byteOffset < 0) {\n\t    if (first) byteOffset = 0\n\t    else return -1\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    value = from(value, encoding)\n\t  } else if (typeof value === 'number') {\n\t    value = value & 0xff\n\n\t    if (first) {\n\t      return buffer.indexOf(value, byteOffset)\n\t    } else {\n\t      return buffer.lastIndexOf(value, byteOffset)\n\t    }\n\t  }\n\n\t  if (value.byteLength === 0) return -1\n\n\t  if (first) {\n\t    let foundIndex = -1\n\n\t    for (let i = byteOffset; i < buffer.byteLength; i++) {\n\t      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + value.byteLength > buffer.byteLength) {\n\t      byteOffset = buffer.byteLength - value.byteLength\n\t    }\n\n\t    for (let i = byteOffset; i >= 0; i--) {\n\t      let found = true\n\n\t      for (let j = 0; j < value.byteLength; j++) {\n\t        if (buffer[i + j] !== value[j]) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tfunction indexOf (buffer, value, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n\t}\n\n\tfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n\t}\n\n\tfunction swap (buffer, n, m) {\n\t  const i = buffer[n]\n\t  buffer[n] = buffer[m]\n\t  buffer[m] = i\n\t}\n\n\tfunction swap16 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n\t  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n\t  return buffer\n\t}\n\n\tfunction swap32 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(buffer, i, i + 3)\n\t    swap(buffer, i + 1, i + 2)\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction swap64 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(buffer, i, i + 7)\n\t    swap(buffer, i + 1, i + 6)\n\t    swap(buffer, i + 2, i + 5)\n\t    swap(buffer, i + 3, i + 4)\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction toBuffer (buffer) {\n\t  return buffer\n\t}\n\n\tfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n\t  const len = buffer.byteLength\n\n\t  if (start >= len) return ''\n\t  if (end <= start) return ''\n\t  if (start < 0) start = 0\n\t  if (end > len) end = len\n\n\t  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n\t  return codecFor(encoding).toString(buffer)\n\t}\n\n\tfunction write (buffer, string, offset, length, encoding) {\n\t  // write(buffer, string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\n\t  // write(buffer, string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    offset = undefined\n\n\t  // write(buffer, string, offset, encoding)\n\t  } else if (encoding === undefined && typeof length === 'string') {\n\t    encoding = length\n\t    length = undefined\n\t  }\n\n\t  return codecFor(encoding).write(buffer, string, offset, length)\n\t}\n\n\tfunction writeDoubleLE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setFloat64(offset, value, true)\n\n\t  return offset + 8\n\t}\n\n\tfunction writeFloatLE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setFloat32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction writeUInt32LE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setUint32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction writeInt32LE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setInt32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction readDoubleLE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getFloat64(offset, true)\n\t}\n\n\tfunction readFloatLE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getFloat32(offset, true)\n\t}\n\n\tfunction readUInt32LE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getUint32(offset, true)\n\t}\n\n\tfunction readInt32LE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getInt32(offset, true)\n\t}\n\n\tmodule.exports = exports = {\n\t  isBuffer,\n\t  isEncoding,\n\t  alloc,\n\t  allocUnsafe,\n\t  allocUnsafeSlow,\n\t  byteLength,\n\t  compare,\n\t  concat,\n\t  copy,\n\t  equals,\n\t  fill,\n\t  from,\n\t  includes,\n\t  indexOf,\n\t  lastIndexOf,\n\t  swap16,\n\t  swap32,\n\t  swap64,\n\t  toBuffer,\n\t  toString,\n\t  write,\n\t  writeDoubleLE,\n\t  writeFloatLE,\n\t  writeUInt32LE,\n\t  writeInt32LE,\n\t  readDoubleLE,\n\t  readFloatLE,\n\t  readUInt32LE,\n\t  readInt32LE\n\t}\n} (browserModule, browser));\n\nexport default browser;\nexport { browser as __moduleExports };","start":1670465469819,"end":1670465470376,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as browserModule, exports as browser } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/browser.js?commonjs-module\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/ascii.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/base64.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/hex.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/utf8.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/b4a@1.6.1/node_modules/b4a/lib/utf16le.js?commonjs-proxy\";\n\n(function (module, exports) {\n\tconst ascii = require$$0\n\tconst base64 = require$$1\n\tconst hex = require$$2\n\tconst utf8 = require$$3\n\tconst utf16le = require$$4\n\n\tconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\n\tfunction codecFor (encoding) {\n\t  switch (encoding) {\n\t    case 'ascii':\n\t      return ascii\n\t    case 'base64':\n\t      return base64\n\t    case 'hex':\n\t      return hex\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case undefined:\n\t      return utf8\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return utf16le\n\t    default:\n\t      throw new Error(`Unknown encoding: ${encoding}`)\n\t  }\n\t}\n\n\tfunction isBuffer (value) {\n\t  return value instanceof Uint8Array\n\t}\n\n\tfunction isEncoding (encoding) {\n\t  try {\n\t    codecFor(encoding)\n\t    return true\n\t  } catch {\n\t    return false\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  const buffer = new Uint8Array(size)\n\t  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n\t  return buffer\n\t}\n\n\tfunction allocUnsafe (size) {\n\t  return new Uint8Array(size)\n\t}\n\n\tfunction allocUnsafeSlow (size) {\n\t  return new Uint8Array(size)\n\t}\n\n\tfunction byteLength (string, encoding) {\n\t  return codecFor(encoding).byteLength(string)\n\t}\n\n\tfunction compare (a, b) {\n\t  if (a === b) return 0\n\n\t  const len = Math.min(a.byteLength, b.byteLength)\n\n\t  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n\t  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n\t  let i = 0\n\n\t  for (let n = len - (len % 4); i < n; i += 4) {\n\t    const x = a.getUint32(i, LE)\n\t    const y = b.getUint32(i, LE)\n\t    if (x !== y) break\n\t  }\n\n\t  for (; i < len; i++) {\n\t    const x = a.getUint8(i)\n\t    const y = b.getUint8(i)\n\t    if (x < y) return -1\n\t    if (x > y) return 1\n\t  }\n\n\t  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n\t}\n\n\tfunction concat (buffers, totalLength) {\n\t  if (totalLength === undefined) {\n\t    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n\t  }\n\n\t  const result = new Uint8Array(totalLength)\n\n\t  buffers.reduce(\n\t    (offset, buffer) => {\n\t      result.set(buffer, offset)\n\t      return offset + buffer.byteLength\n\t    },\n\t    0\n\t  )\n\n\t  return result\n\t}\n\n\tfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n\t  if (end > 0 && end < start) return 0\n\t  if (end === start) return 0\n\t  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n\t  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n\t  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n\t  if (targetStart >= target.byteLength) targetStart = target.byteLength\n\t  if (end > source.byteLength) end = source.byteLength\n\t  if (target.byteLength - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\n\t  const len = end - start\n\n\t  if (source === target) {\n\t    target.copyWithin(targetStart, start, end)\n\t  } else {\n\t    target.set(source.subarray(start, end), targetStart)\n\t  }\n\n\t  return len\n\t}\n\n\tfunction equals (a, b) {\n\t  if (a === b) return true\n\t  if (a.byteLength !== b.byteLength) return false\n\n\t  const len = a.byteLength\n\n\t  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n\t  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n\t  let i = 0\n\n\t  for (let n = len - (len % 4); i < n; i += 4) {\n\t    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n\t  }\n\n\t  for (; i < len; i++) {\n\t    if (a.getUint8(i) !== b.getUint8(i)) return false\n\t  }\n\n\t  return true\n\t}\n\n\tfunction fill (buffer, value, offset, end, encoding) {\n\t  if (typeof value === 'string') {\n\t    // fill(buffer, string, encoding)\n\t    if (typeof offset === 'string') {\n\t      encoding = offset\n\t      offset = 0\n\t      end = buffer.byteLength\n\n\t    // fill(buffer, string, offset, encoding)\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = buffer.byteLength\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    value = value & 0xff\n\t  } else if (typeof val === 'boolean') {\n\t    value = +value\n\t  }\n\n\t  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (offset === undefined) offset = 0\n\t  if (end === undefined) end = buffer.byteLength\n\n\t  if (end <= offset) return buffer\n\n\t  if (!value) value = 0\n\n\t  if (typeof value === 'number') {\n\t    for (let i = offset; i < end; ++i) {\n\t      buffer[i] = value\n\t    }\n\t  } else {\n\t    value = isBuffer(value) ? value : from(value, encoding)\n\n\t    const len = value.byteLength\n\n\t    for (let i = 0; i < end - offset; ++i) {\n\t      buffer[i + offset] = value[i % len]\n\t    }\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  // from(string, encoding)\n\t  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n\t  // from(array)\n\t  if (Array.isArray(value)) return fromArray(value)\n\n\t  // from(buffer)\n\t  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n\t  // from(arrayBuffer[, byteOffset[, length]])\n\t  return fromArrayBuffer(value, encodingOrOffset, length)\n\t}\n\n\tfunction fromString (string, encoding) {\n\t  const codec = codecFor(encoding)\n\t  const buffer = new Uint8Array(codec.byteLength(string))\n\t  codec.write(buffer, string, 0, buffer.byteLength)\n\t  return buffer\n\t}\n\n\tfunction fromArray (array) {\n\t  const buffer = new Uint8Array(array.length)\n\t  buffer.set(array)\n\t  return buffer\n\t}\n\n\tfunction fromBuffer (buffer) {\n\t  const copy = new Uint8Array(buffer.byteLength)\n\t  copy.set(buffer)\n\t  return copy\n\t}\n\n\tfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n\t  return new Uint8Array(arrayBuffer, byteOffset, length)\n\t}\n\n\tfunction includes (buffer, value, byteOffset, encoding) {\n\t  return indexOf(buffer, value, byteOffset, encoding) !== -1\n\t}\n\n\tfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n\t  if (buffer.byteLength === 0) return -1\n\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset === undefined) {\n\t    byteOffset = first ? 0 : (buffer.length - 1)\n\t  } else if (byteOffset < 0) {\n\t    byteOffset += buffer.byteLength\n\t  }\n\n\t  if (byteOffset >= buffer.byteLength) {\n\t    if (first) return -1\n\t    else byteOffset = buffer.byteLength - 1\n\t  } else if (byteOffset < 0) {\n\t    if (first) byteOffset = 0\n\t    else return -1\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    value = from(value, encoding)\n\t  } else if (typeof value === 'number') {\n\t    value = value & 0xff\n\n\t    if (first) {\n\t      return buffer.indexOf(value, byteOffset)\n\t    } else {\n\t      return buffer.lastIndexOf(value, byteOffset)\n\t    }\n\t  }\n\n\t  if (value.byteLength === 0) return -1\n\n\t  if (first) {\n\t    let foundIndex = -1\n\n\t    for (let i = byteOffset; i < buffer.byteLength; i++) {\n\t      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + value.byteLength > buffer.byteLength) {\n\t      byteOffset = buffer.byteLength - value.byteLength\n\t    }\n\n\t    for (let i = byteOffset; i >= 0; i--) {\n\t      let found = true\n\n\t      for (let j = 0; j < value.byteLength; j++) {\n\t        if (buffer[i + j] !== value[j]) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tfunction indexOf (buffer, value, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n\t}\n\n\tfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n\t}\n\n\tfunction swap (buffer, n, m) {\n\t  const i = buffer[n]\n\t  buffer[n] = buffer[m]\n\t  buffer[m] = i\n\t}\n\n\tfunction swap16 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n\t  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n\t  return buffer\n\t}\n\n\tfunction swap32 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(buffer, i, i + 3)\n\t    swap(buffer, i + 1, i + 2)\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction swap64 (buffer) {\n\t  const len = buffer.byteLength\n\n\t  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(buffer, i, i + 7)\n\t    swap(buffer, i + 1, i + 6)\n\t    swap(buffer, i + 2, i + 5)\n\t    swap(buffer, i + 3, i + 4)\n\t  }\n\n\t  return buffer\n\t}\n\n\tfunction toBuffer (buffer) {\n\t  return buffer\n\t}\n\n\tfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n\t  const len = buffer.byteLength\n\n\t  if (start >= len) return ''\n\t  if (end <= start) return ''\n\t  if (start < 0) start = 0\n\t  if (end > len) end = len\n\n\t  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n\t  return codecFor(encoding).toString(buffer)\n\t}\n\n\tfunction write (buffer, string, offset, length, encoding) {\n\t  // write(buffer, string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\n\t  // write(buffer, string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    offset = undefined\n\n\t  // write(buffer, string, offset, encoding)\n\t  } else if (encoding === undefined && typeof length === 'string') {\n\t    encoding = length\n\t    length = undefined\n\t  }\n\n\t  return codecFor(encoding).write(buffer, string, offset, length)\n\t}\n\n\tfunction writeDoubleLE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setFloat64(offset, value, true)\n\n\t  return offset + 8\n\t}\n\n\tfunction writeFloatLE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setFloat32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction writeUInt32LE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setUint32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction writeInt32LE (buffer, value, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t  view.setInt32(offset, value, true)\n\n\t  return offset + 4\n\t}\n\n\tfunction readDoubleLE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getFloat64(offset, true)\n\t}\n\n\tfunction readFloatLE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getFloat32(offset, true)\n\t}\n\n\tfunction readUInt32LE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getUint32(offset, true)\n\t}\n\n\tfunction readInt32LE (buffer, offset) {\n\t  if (offset === undefined) offset = 0\n\n\t  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n\t  return view.getInt32(offset, true)\n\t}\n\n\tmodule.exports = exports = {\n\t  isBuffer,\n\t  isEncoding,\n\t  alloc,\n\t  allocUnsafe,\n\t  allocUnsafeSlow,\n\t  byteLength,\n\t  compare,\n\t  concat,\n\t  copy,\n\t  equals,\n\t  fill,\n\t  from,\n\t  includes,\n\t  indexOf,\n\t  lastIndexOf,\n\t  swap16,\n\t  swap32,\n\t  swap64,\n\t  toBuffer,\n\t  toString,\n\t  write,\n\t  writeDoubleLE,\n\t  writeFloatLE,\n\t  writeUInt32LE,\n\t  writeInt32LE,\n\t  readDoubleLE,\n\t  readFloatLE,\n\t  readUInt32LE,\n\t  readInt32LE\n\t}\n} (browserModule, browser));\n\nexport default browser;\nexport { browser as __moduleExports };","start":1670465470376,"end":1670465470380,"order":"normal"}]}
