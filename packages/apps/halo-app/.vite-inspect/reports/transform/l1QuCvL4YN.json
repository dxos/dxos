{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/index.js","transforms":[{"name":"vite:load-fallback","result":"const Handshake = require('./lib/handshake')\nconst messages = require('./messages')\nconst XOR = require('./lib/xor')\nconst SMC = require('simple-message-channels')\nconst crypto = require('hypercore-crypto')\nconst varint = require('varint')\n\nmodule.exports = class SimpleProtocol {\n  constructor (initiator, handlers) {\n    const payload = { nonce: XOR.nonce() }\n\n    this.handlers = handlers || {}\n    this.remotePayload = null\n    this.remotePublicKey = null\n    this.publicKey = null\n    this.handshakeHash = null\n    this.destroyed = false\n\n    this._initiator = initiator\n    this._payload = payload\n    this._pending = []\n    this._handshake = null\n    this._split = null\n    this._encryption = null\n    this._noise = !(handlers.encrypted === false && handlers.noise === false)\n    this._buffering = null\n    this._handshaking = false\n\n    this._messages = new SMC({\n      onmessage,\n      onmissing,\n      context: this,\n      types: [\n        { context: this, onmessage: onopen, encoding: messages.Open },\n        { context: this, onmessage: onoptions, encoding: messages.Options },\n        { context: this, onmessage: onstatus, encoding: messages.Status },\n        { context: this, onmessage: onhave, encoding: messages.Have },\n        { context: this, onmessage: onunhave, encoding: messages.Unhave },\n        { context: this, onmessage: onwant, encoding: messages.Want },\n        { context: this, onmessage: onunwant, encoding: messages.Unwant },\n        { context: this, onmessage: onrequest, encoding: messages.Request },\n        { context: this, onmessage: oncancel, encoding: messages.Cancel },\n        { context: this, onmessage: ondata, encoding: messages.Data },\n        { context: this, onmessage: onclose, encoding: messages.Close }\n      ]\n    })\n\n    if (handlers.encrypted !== false || handlers.noise !== false) {\n      this._handshaking = true\n      if (typeof this.handlers.keyPair !== 'function') {\n        this._onkeypair(null, this.handlers.keyPair || null)\n      } else {\n        this._buffering = []\n        this.handlers.keyPair(this._onkeypair.bind(this))\n      }\n    }\n  }\n\n  _onkeypair (err, keyPair) {\n    if (err) return this.destroy(err)\n    if (this._handshake !== null) return\n\n    this.handlers.keyPair = keyPair\n    const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this))\n\n    this.publicKey = handshake.keyPair.publicKey\n    this._handshake = handshake\n\n    if (this._buffering) {\n      while (this._buffering.length) this._recv(this._buffering.shift())\n    }\n\n    this._buffering = null\n  }\n\n  open (ch, message) {\n    return this._send(ch, 0, message)\n  }\n\n  options (ch, message) {\n    return this._send(ch, 1, message)\n  }\n\n  status (ch, message) {\n    return this._send(ch, 2, message)\n  }\n\n  have (ch, message) {\n    return this._send(ch, 3, message)\n  }\n\n  unhave (ch, message) {\n    return this._send(ch, 4, message)\n  }\n\n  want (ch, message) {\n    return this._send(ch, 5, message)\n  }\n\n  unwant (ch, message) {\n    return this._send(ch, 6, message)\n  }\n\n  request (ch, message) {\n    return this._send(ch, 7, message)\n  }\n\n  cancel (ch, message) {\n    return this._send(ch, 8, message)\n  }\n\n  data (ch, message) {\n    return this._send(ch, 9, message)\n  }\n\n  close (ch, message) {\n    return this._send(ch, 10, message || {})\n  }\n\n  extension (ch, id, message) {\n    const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length)\n\n    varint.encode(id, buf, 0)\n    message.copy(buf, varint.encode.bytes)\n\n    return this._send(ch, 15, buf)\n  }\n\n  ping () {\n    if (this._handshaking || this._pending.length) return\n\n    let ping = Buffer.from([0])\n    if (this._encryption !== null) {\n      ping = this._encryption.encrypt(ping)\n    }\n\n    return this.handlers.send(ping)\n  }\n\n  _onhandshake (err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {\n    if (err) return this.destroy(new Error('Noise handshake error')) // workaround for https://github.com/emilbayes/noise-protocol/issues/5\n    if (!remotePayload) return this.destroy(new Error('Remote did not include a handshake payload'))\n\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    try {\n      remotePayload = messages.NoisePayload.decode(remotePayload)\n    } catch (_) {\n      return this.destroy(new Error('Could not parse remote payload'))\n    }\n\n    this._handshake = null\n    this._handshaking = false\n    this._split = split\n    this._encryption = this.handlers.encrypted === false\n      ? null\n      : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split)\n\n    this.remotePayload = remotePayload\n\n    if (this.handlers.onhandshake) this.handlers.onhandshake()\n    if (this.destroyed) return\n\n    if (overflow) this.recv(overflow)\n    while (this._pending.length && !this.destroyed) {\n      this._sendNow(...this._pending.shift())\n    }\n  }\n\n  _send (channel, type, message) {\n    if (this._handshaking || this._pending.length) {\n      this._pending.push([channel, type, message])\n      return false\n    }\n\n    return this._sendNow(channel, type, message)\n  }\n\n  _sendNow (channel, type, message) {\n    if (type === 0 && message.key && !message.capability) {\n      message.capability = this.capability(message.key)\n      message.key = null\n    }\n\n    let data = this._messages.send(channel, type, message)\n\n    if (this._encryption !== null) {\n      data = this._encryption.encrypt(data)\n    }\n\n    return this.handlers.send(data)\n  }\n\n  capability (key) {\n    return crypto.capability(key, this._split)\n  }\n\n  remoteCapability (key) {\n    return crypto.remoteCapability(key, this._split)\n  }\n\n  recv (data) {\n    if (this._buffering !== null) this._buffering.push(data)\n    else this._recv(data)\n  }\n\n  _recv (data) {\n    if (this.destroyed) return\n\n    if (this._handshaking) {\n      this._handshake.recv(data)\n      return\n    }\n\n    if (this._encryption !== null) {\n      data = this._encryption.decrypt(data)\n    }\n\n    if (!this._messages.recv(data)) {\n      this.destroy(this._messages.error)\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (this._handshake) this._handshake.destroy()\n    if (this._encryption) this._encryption.destroy()\n    if (this.handlers.destroy) this.handlers.destroy(err)\n  }\n\n  static keyPair (seed) {\n    return Handshake.keyPair(seed)\n  }\n}\n\nfunction onopen (ch, message, self) {\n  if (self.handlers.onopen) self.handlers.onopen(ch, message)\n}\n\nfunction onoptions (ch, message, self) {\n  if (self.handlers.onoptions) self.handlers.onoptions(ch, message)\n}\n\nfunction onstatus (ch, message, self) {\n  if (self.handlers.onstatus) self.handlers.onstatus(ch, message)\n}\n\nfunction onhave (ch, message, self) {\n  if (self.handlers.onhave) self.handlers.onhave(ch, message)\n}\n\nfunction onunhave (ch, message, self) {\n  if (self.handlers.onunhave) self.handlers.onunhave(ch, message)\n}\n\nfunction onwant (ch, message, self) {\n  if (self.handlers.onwant) self.handlers.onwant(ch, message)\n}\n\nfunction onunwant (ch, message, self) {\n  if (self.handlers.onunwant) self.handlers.onunwant(ch, message)\n}\n\nfunction onrequest (ch, message, self) {\n  if (self.handlers.onrequest) self.handlers.onrequest(ch, message)\n}\n\nfunction oncancel (ch, message, self) {\n  if (self.handlers.oncancel) self.handlers.oncancel(ch, message)\n}\n\nfunction ondata (ch, message, self) {\n  if (self.handlers.ondata) self.handlers.ondata(ch, message)\n}\n\nfunction onclose (ch, message, self) {\n  if (self.handlers.onclose) self.handlers.onclose(ch, message)\n}\n\nfunction onmessage (ch, type, message, self) {\n  if (type !== 15) return\n  const id = varint.decode(message)\n  const m = message.slice(varint.decode.bytes)\n  if (self.handlers.onextension) self.handlers.onextension(ch, id, m)\n}\n\nfunction onmissing (bytes, self) {\n  if (self.handlers.onmissing) self.handlers.onmissing(bytes)\n}\n","start":1670465469268,"end":1670465469455},{"name":"vite:react-babel","result":"const Handshake = require('./lib/handshake')\nconst messages = require('./messages')\nconst XOR = require('./lib/xor')\nconst SMC = require('simple-message-channels')\nconst crypto = require('hypercore-crypto')\nconst varint = require('varint')\n\nmodule.exports = class SimpleProtocol {\n  constructor (initiator, handlers) {\n    const payload = { nonce: XOR.nonce() }\n\n    this.handlers = handlers || {}\n    this.remotePayload = null\n    this.remotePublicKey = null\n    this.publicKey = null\n    this.handshakeHash = null\n    this.destroyed = false\n\n    this._initiator = initiator\n    this._payload = payload\n    this._pending = []\n    this._handshake = null\n    this._split = null\n    this._encryption = null\n    this._noise = !(handlers.encrypted === false && handlers.noise === false)\n    this._buffering = null\n    this._handshaking = false\n\n    this._messages = new SMC({\n      onmessage,\n      onmissing,\n      context: this,\n      types: [\n        { context: this, onmessage: onopen, encoding: messages.Open },\n        { context: this, onmessage: onoptions, encoding: messages.Options },\n        { context: this, onmessage: onstatus, encoding: messages.Status },\n        { context: this, onmessage: onhave, encoding: messages.Have },\n        { context: this, onmessage: onunhave, encoding: messages.Unhave },\n        { context: this, onmessage: onwant, encoding: messages.Want },\n        { context: this, onmessage: onunwant, encoding: messages.Unwant },\n        { context: this, onmessage: onrequest, encoding: messages.Request },\n        { context: this, onmessage: oncancel, encoding: messages.Cancel },\n        { context: this, onmessage: ondata, encoding: messages.Data },\n        { context: this, onmessage: onclose, encoding: messages.Close }\n      ]\n    })\n\n    if (handlers.encrypted !== false || handlers.noise !== false) {\n      this._handshaking = true\n      if (typeof this.handlers.keyPair !== 'function') {\n        this._onkeypair(null, this.handlers.keyPair || null)\n      } else {\n        this._buffering = []\n        this.handlers.keyPair(this._onkeypair.bind(this))\n      }\n    }\n  }\n\n  _onkeypair (err, keyPair) {\n    if (err) return this.destroy(err)\n    if (this._handshake !== null) return\n\n    this.handlers.keyPair = keyPair\n    const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this))\n\n    this.publicKey = handshake.keyPair.publicKey\n    this._handshake = handshake\n\n    if (this._buffering) {\n      while (this._buffering.length) this._recv(this._buffering.shift())\n    }\n\n    this._buffering = null\n  }\n\n  open (ch, message) {\n    return this._send(ch, 0, message)\n  }\n\n  options (ch, message) {\n    return this._send(ch, 1, message)\n  }\n\n  status (ch, message) {\n    return this._send(ch, 2, message)\n  }\n\n  have (ch, message) {\n    return this._send(ch, 3, message)\n  }\n\n  unhave (ch, message) {\n    return this._send(ch, 4, message)\n  }\n\n  want (ch, message) {\n    return this._send(ch, 5, message)\n  }\n\n  unwant (ch, message) {\n    return this._send(ch, 6, message)\n  }\n\n  request (ch, message) {\n    return this._send(ch, 7, message)\n  }\n\n  cancel (ch, message) {\n    return this._send(ch, 8, message)\n  }\n\n  data (ch, message) {\n    return this._send(ch, 9, message)\n  }\n\n  close (ch, message) {\n    return this._send(ch, 10, message || {})\n  }\n\n  extension (ch, id, message) {\n    const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length)\n\n    varint.encode(id, buf, 0)\n    message.copy(buf, varint.encode.bytes)\n\n    return this._send(ch, 15, buf)\n  }\n\n  ping () {\n    if (this._handshaking || this._pending.length) return\n\n    let ping = Buffer.from([0])\n    if (this._encryption !== null) {\n      ping = this._encryption.encrypt(ping)\n    }\n\n    return this.handlers.send(ping)\n  }\n\n  _onhandshake (err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {\n    if (err) return this.destroy(new Error('Noise handshake error')) // workaround for https://github.com/emilbayes/noise-protocol/issues/5\n    if (!remotePayload) return this.destroy(new Error('Remote did not include a handshake payload'))\n\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    try {\n      remotePayload = messages.NoisePayload.decode(remotePayload)\n    } catch (_) {\n      return this.destroy(new Error('Could not parse remote payload'))\n    }\n\n    this._handshake = null\n    this._handshaking = false\n    this._split = split\n    this._encryption = this.handlers.encrypted === false\n      ? null\n      : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split)\n\n    this.remotePayload = remotePayload\n\n    if (this.handlers.onhandshake) this.handlers.onhandshake()\n    if (this.destroyed) return\n\n    if (overflow) this.recv(overflow)\n    while (this._pending.length && !this.destroyed) {\n      this._sendNow(...this._pending.shift())\n    }\n  }\n\n  _send (channel, type, message) {\n    if (this._handshaking || this._pending.length) {\n      this._pending.push([channel, type, message])\n      return false\n    }\n\n    return this._sendNow(channel, type, message)\n  }\n\n  _sendNow (channel, type, message) {\n    if (type === 0 && message.key && !message.capability) {\n      message.capability = this.capability(message.key)\n      message.key = null\n    }\n\n    let data = this._messages.send(channel, type, message)\n\n    if (this._encryption !== null) {\n      data = this._encryption.encrypt(data)\n    }\n\n    return this.handlers.send(data)\n  }\n\n  capability (key) {\n    return crypto.capability(key, this._split)\n  }\n\n  remoteCapability (key) {\n    return crypto.remoteCapability(key, this._split)\n  }\n\n  recv (data) {\n    if (this._buffering !== null) this._buffering.push(data)\n    else this._recv(data)\n  }\n\n  _recv (data) {\n    if (this.destroyed) return\n\n    if (this._handshaking) {\n      this._handshake.recv(data)\n      return\n    }\n\n    if (this._encryption !== null) {\n      data = this._encryption.decrypt(data)\n    }\n\n    if (!this._messages.recv(data)) {\n      this.destroy(this._messages.error)\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (this._handshake) this._handshake.destroy()\n    if (this._encryption) this._encryption.destroy()\n    if (this.handlers.destroy) this.handlers.destroy(err)\n  }\n\n  static keyPair (seed) {\n    return Handshake.keyPair(seed)\n  }\n}\n\nfunction onopen (ch, message, self) {\n  if (self.handlers.onopen) self.handlers.onopen(ch, message)\n}\n\nfunction onoptions (ch, message, self) {\n  if (self.handlers.onoptions) self.handlers.onoptions(ch, message)\n}\n\nfunction onstatus (ch, message, self) {\n  if (self.handlers.onstatus) self.handlers.onstatus(ch, message)\n}\n\nfunction onhave (ch, message, self) {\n  if (self.handlers.onhave) self.handlers.onhave(ch, message)\n}\n\nfunction onunhave (ch, message, self) {\n  if (self.handlers.onunhave) self.handlers.onunhave(ch, message)\n}\n\nfunction onwant (ch, message, self) {\n  if (self.handlers.onwant) self.handlers.onwant(ch, message)\n}\n\nfunction onunwant (ch, message, self) {\n  if (self.handlers.onunwant) self.handlers.onunwant(ch, message)\n}\n\nfunction onrequest (ch, message, self) {\n  if (self.handlers.onrequest) self.handlers.onrequest(ch, message)\n}\n\nfunction oncancel (ch, message, self) {\n  if (self.handlers.oncancel) self.handlers.oncancel(ch, message)\n}\n\nfunction ondata (ch, message, self) {\n  if (self.handlers.ondata) self.handlers.ondata(ch, message)\n}\n\nfunction onclose (ch, message, self) {\n  if (self.handlers.onclose) self.handlers.onclose(ch, message)\n}\n\nfunction onmessage (ch, type, message, self) {\n  if (type !== 15) return\n  const id = varint.decode(message)\n  const m = message.slice(varint.decode.bytes)\n  if (self.handlers.onextension) self.handlers.onextension(ch, id, m)\n}\n\nfunction onmissing (bytes, self) {\n  if (self.handlers.onmissing) self.handlers.onmissing(bytes)\n}\n","start":1670465469455,"end":1670465469455,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst Handshake = require$$0\nconst messages = require$$1\nconst XOR = require$$2\nconst SMC = require$$3\nconst crypto = require$$4\nconst varint = require$$5\n\nvar simpleHypercoreProtocol = class SimpleProtocol {\n  constructor (initiator, handlers) {\n    const payload = { nonce: XOR.nonce() }\n\n    this.handlers = handlers || {}\n    this.remotePayload = null\n    this.remotePublicKey = null\n    this.publicKey = null\n    this.handshakeHash = null\n    this.destroyed = false\n\n    this._initiator = initiator\n    this._payload = payload\n    this._pending = []\n    this._handshake = null\n    this._split = null\n    this._encryption = null\n    this._noise = !(handlers.encrypted === false && handlers.noise === false)\n    this._buffering = null\n    this._handshaking = false\n\n    this._messages = new SMC({\n      onmessage,\n      onmissing,\n      context: this,\n      types: [\n        { context: this, onmessage: onopen, encoding: messages.Open },\n        { context: this, onmessage: onoptions, encoding: messages.Options },\n        { context: this, onmessage: onstatus, encoding: messages.Status },\n        { context: this, onmessage: onhave, encoding: messages.Have },\n        { context: this, onmessage: onunhave, encoding: messages.Unhave },\n        { context: this, onmessage: onwant, encoding: messages.Want },\n        { context: this, onmessage: onunwant, encoding: messages.Unwant },\n        { context: this, onmessage: onrequest, encoding: messages.Request },\n        { context: this, onmessage: oncancel, encoding: messages.Cancel },\n        { context: this, onmessage: ondata, encoding: messages.Data },\n        { context: this, onmessage: onclose, encoding: messages.Close }\n      ]\n    })\n\n    if (handlers.encrypted !== false || handlers.noise !== false) {\n      this._handshaking = true\n      if (typeof this.handlers.keyPair !== 'function') {\n        this._onkeypair(null, this.handlers.keyPair || null)\n      } else {\n        this._buffering = []\n        this.handlers.keyPair(this._onkeypair.bind(this))\n      }\n    }\n  }\n\n  _onkeypair (err, keyPair) {\n    if (err) return this.destroy(err)\n    if (this._handshake !== null) return\n\n    this.handlers.keyPair = keyPair\n    const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this))\n\n    this.publicKey = handshake.keyPair.publicKey\n    this._handshake = handshake\n\n    if (this._buffering) {\n      while (this._buffering.length) this._recv(this._buffering.shift())\n    }\n\n    this._buffering = null\n  }\n\n  open (ch, message) {\n    return this._send(ch, 0, message)\n  }\n\n  options (ch, message) {\n    return this._send(ch, 1, message)\n  }\n\n  status (ch, message) {\n    return this._send(ch, 2, message)\n  }\n\n  have (ch, message) {\n    return this._send(ch, 3, message)\n  }\n\n  unhave (ch, message) {\n    return this._send(ch, 4, message)\n  }\n\n  want (ch, message) {\n    return this._send(ch, 5, message)\n  }\n\n  unwant (ch, message) {\n    return this._send(ch, 6, message)\n  }\n\n  request (ch, message) {\n    return this._send(ch, 7, message)\n  }\n\n  cancel (ch, message) {\n    return this._send(ch, 8, message)\n  }\n\n  data (ch, message) {\n    return this._send(ch, 9, message)\n  }\n\n  close (ch, message) {\n    return this._send(ch, 10, message || {})\n  }\n\n  extension (ch, id, message) {\n    const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length)\n\n    varint.encode(id, buf, 0)\n    message.copy(buf, varint.encode.bytes)\n\n    return this._send(ch, 15, buf)\n  }\n\n  ping () {\n    if (this._handshaking || this._pending.length) return\n\n    let ping = Buffer.from([0])\n    if (this._encryption !== null) {\n      ping = this._encryption.encrypt(ping)\n    }\n\n    return this.handlers.send(ping)\n  }\n\n  _onhandshake (err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {\n    if (err) return this.destroy(new Error('Noise handshake error')) // workaround for https://github.com/emilbayes/noise-protocol/issues/5\n    if (!remotePayload) return this.destroy(new Error('Remote did not include a handshake payload'))\n\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    try {\n      remotePayload = messages.NoisePayload.decode(remotePayload)\n    } catch (_) {\n      return this.destroy(new Error('Could not parse remote payload'))\n    }\n\n    this._handshake = null\n    this._handshaking = false\n    this._split = split\n    this._encryption = this.handlers.encrypted === false\n      ? null\n      : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split)\n\n    this.remotePayload = remotePayload\n\n    if (this.handlers.onhandshake) this.handlers.onhandshake()\n    if (this.destroyed) return\n\n    if (overflow) this.recv(overflow)\n    while (this._pending.length && !this.destroyed) {\n      this._sendNow(...this._pending.shift())\n    }\n  }\n\n  _send (channel, type, message) {\n    if (this._handshaking || this._pending.length) {\n      this._pending.push([channel, type, message])\n      return false\n    }\n\n    return this._sendNow(channel, type, message)\n  }\n\n  _sendNow (channel, type, message) {\n    if (type === 0 && message.key && !message.capability) {\n      message.capability = this.capability(message.key)\n      message.key = null\n    }\n\n    let data = this._messages.send(channel, type, message)\n\n    if (this._encryption !== null) {\n      data = this._encryption.encrypt(data)\n    }\n\n    return this.handlers.send(data)\n  }\n\n  capability (key) {\n    return crypto.capability(key, this._split)\n  }\n\n  remoteCapability (key) {\n    return crypto.remoteCapability(key, this._split)\n  }\n\n  recv (data) {\n    if (this._buffering !== null) this._buffering.push(data)\n    else this._recv(data)\n  }\n\n  _recv (data) {\n    if (this.destroyed) return\n\n    if (this._handshaking) {\n      this._handshake.recv(data)\n      return\n    }\n\n    if (this._encryption !== null) {\n      data = this._encryption.decrypt(data)\n    }\n\n    if (!this._messages.recv(data)) {\n      this.destroy(this._messages.error)\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (this._handshake) this._handshake.destroy()\n    if (this._encryption) this._encryption.destroy()\n    if (this.handlers.destroy) this.handlers.destroy(err)\n  }\n\n  static keyPair (seed) {\n    return Handshake.keyPair(seed)\n  }\n}\n\nfunction onopen (ch, message, self) {\n  if (self.handlers.onopen) self.handlers.onopen(ch, message)\n}\n\nfunction onoptions (ch, message, self) {\n  if (self.handlers.onoptions) self.handlers.onoptions(ch, message)\n}\n\nfunction onstatus (ch, message, self) {\n  if (self.handlers.onstatus) self.handlers.onstatus(ch, message)\n}\n\nfunction onhave (ch, message, self) {\n  if (self.handlers.onhave) self.handlers.onhave(ch, message)\n}\n\nfunction onunhave (ch, message, self) {\n  if (self.handlers.onunhave) self.handlers.onunhave(ch, message)\n}\n\nfunction onwant (ch, message, self) {\n  if (self.handlers.onwant) self.handlers.onwant(ch, message)\n}\n\nfunction onunwant (ch, message, self) {\n  if (self.handlers.onunwant) self.handlers.onunwant(ch, message)\n}\n\nfunction onrequest (ch, message, self) {\n  if (self.handlers.onrequest) self.handlers.onrequest(ch, message)\n}\n\nfunction oncancel (ch, message, self) {\n  if (self.handlers.oncancel) self.handlers.oncancel(ch, message)\n}\n\nfunction ondata (ch, message, self) {\n  if (self.handlers.ondata) self.handlers.ondata(ch, message)\n}\n\nfunction onclose (ch, message, self) {\n  if (self.handlers.onclose) self.handlers.onclose(ch, message)\n}\n\nfunction onmessage (ch, type, message, self) {\n  if (type !== 15) return\n  const id = varint.decode(message)\n  const m = message.slice(varint.decode.bytes)\n  if (self.handlers.onextension) self.handlers.onextension(ch, id, m)\n}\n\nfunction onmissing (bytes, self) {\n  if (self.handlers.onmissing) self.handlers.onmissing(bytes)\n}\n\nexport default simpleHypercoreProtocol;\nexport { simpleHypercoreProtocol as __moduleExports };","start":1670465469459,"end":1670465471826,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/handshake.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/lib/xor.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst Handshake = require$$0\nconst messages = require$$1\nconst XOR = require$$2\nconst SMC = require$$3\nconst crypto = require$$4\nconst varint = require$$5\n\nvar simpleHypercoreProtocol = class SimpleProtocol {\n  constructor (initiator, handlers) {\n    const payload = { nonce: XOR.nonce() }\n\n    this.handlers = handlers || {}\n    this.remotePayload = null\n    this.remotePublicKey = null\n    this.publicKey = null\n    this.handshakeHash = null\n    this.destroyed = false\n\n    this._initiator = initiator\n    this._payload = payload\n    this._pending = []\n    this._handshake = null\n    this._split = null\n    this._encryption = null\n    this._noise = !(handlers.encrypted === false && handlers.noise === false)\n    this._buffering = null\n    this._handshaking = false\n\n    this._messages = new SMC({\n      onmessage,\n      onmissing,\n      context: this,\n      types: [\n        { context: this, onmessage: onopen, encoding: messages.Open },\n        { context: this, onmessage: onoptions, encoding: messages.Options },\n        { context: this, onmessage: onstatus, encoding: messages.Status },\n        { context: this, onmessage: onhave, encoding: messages.Have },\n        { context: this, onmessage: onunhave, encoding: messages.Unhave },\n        { context: this, onmessage: onwant, encoding: messages.Want },\n        { context: this, onmessage: onunwant, encoding: messages.Unwant },\n        { context: this, onmessage: onrequest, encoding: messages.Request },\n        { context: this, onmessage: oncancel, encoding: messages.Cancel },\n        { context: this, onmessage: ondata, encoding: messages.Data },\n        { context: this, onmessage: onclose, encoding: messages.Close }\n      ]\n    })\n\n    if (handlers.encrypted !== false || handlers.noise !== false) {\n      this._handshaking = true\n      if (typeof this.handlers.keyPair !== 'function') {\n        this._onkeypair(null, this.handlers.keyPair || null)\n      } else {\n        this._buffering = []\n        this.handlers.keyPair(this._onkeypair.bind(this))\n      }\n    }\n  }\n\n  _onkeypair (err, keyPair) {\n    if (err) return this.destroy(err)\n    if (this._handshake !== null) return\n\n    this.handlers.keyPair = keyPair\n    const handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this))\n\n    this.publicKey = handshake.keyPair.publicKey\n    this._handshake = handshake\n\n    if (this._buffering) {\n      while (this._buffering.length) this._recv(this._buffering.shift())\n    }\n\n    this._buffering = null\n  }\n\n  open (ch, message) {\n    return this._send(ch, 0, message)\n  }\n\n  options (ch, message) {\n    return this._send(ch, 1, message)\n  }\n\n  status (ch, message) {\n    return this._send(ch, 2, message)\n  }\n\n  have (ch, message) {\n    return this._send(ch, 3, message)\n  }\n\n  unhave (ch, message) {\n    return this._send(ch, 4, message)\n  }\n\n  want (ch, message) {\n    return this._send(ch, 5, message)\n  }\n\n  unwant (ch, message) {\n    return this._send(ch, 6, message)\n  }\n\n  request (ch, message) {\n    return this._send(ch, 7, message)\n  }\n\n  cancel (ch, message) {\n    return this._send(ch, 8, message)\n  }\n\n  data (ch, message) {\n    return this._send(ch, 9, message)\n  }\n\n  close (ch, message) {\n    return this._send(ch, 10, message || {})\n  }\n\n  extension (ch, id, message) {\n    const buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length)\n\n    varint.encode(id, buf, 0)\n    message.copy(buf, varint.encode.bytes)\n\n    return this._send(ch, 15, buf)\n  }\n\n  ping () {\n    if (this._handshaking || this._pending.length) return\n\n    let ping = Buffer.from([0])\n    if (this._encryption !== null) {\n      ping = this._encryption.encrypt(ping)\n    }\n\n    return this.handlers.send(ping)\n  }\n\n  _onhandshake (err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {\n    if (err) return this.destroy(new Error('Noise handshake error')) // workaround for https://github.com/emilbayes/noise-protocol/issues/5\n    if (!remotePayload) return this.destroy(new Error('Remote did not include a handshake payload'))\n\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    try {\n      remotePayload = messages.NoisePayload.decode(remotePayload)\n    } catch (_) {\n      return this.destroy(new Error('Could not parse remote payload'))\n    }\n\n    this._handshake = null\n    this._handshaking = false\n    this._split = split\n    this._encryption = this.handlers.encrypted === false\n      ? null\n      : new XOR({ rnonce: remotePayload.nonce, tnonce: this._payload.nonce }, split)\n\n    this.remotePayload = remotePayload\n\n    if (this.handlers.onhandshake) this.handlers.onhandshake()\n    if (this.destroyed) return\n\n    if (overflow) this.recv(overflow)\n    while (this._pending.length && !this.destroyed) {\n      this._sendNow(...this._pending.shift())\n    }\n  }\n\n  _send (channel, type, message) {\n    if (this._handshaking || this._pending.length) {\n      this._pending.push([channel, type, message])\n      return false\n    }\n\n    return this._sendNow(channel, type, message)\n  }\n\n  _sendNow (channel, type, message) {\n    if (type === 0 && message.key && !message.capability) {\n      message.capability = this.capability(message.key)\n      message.key = null\n    }\n\n    let data = this._messages.send(channel, type, message)\n\n    if (this._encryption !== null) {\n      data = this._encryption.encrypt(data)\n    }\n\n    return this.handlers.send(data)\n  }\n\n  capability (key) {\n    return crypto.capability(key, this._split)\n  }\n\n  remoteCapability (key) {\n    return crypto.remoteCapability(key, this._split)\n  }\n\n  recv (data) {\n    if (this._buffering !== null) this._buffering.push(data)\n    else this._recv(data)\n  }\n\n  _recv (data) {\n    if (this.destroyed) return\n\n    if (this._handshaking) {\n      this._handshake.recv(data)\n      return\n    }\n\n    if (this._encryption !== null) {\n      data = this._encryption.decrypt(data)\n    }\n\n    if (!this._messages.recv(data)) {\n      this.destroy(this._messages.error)\n    }\n  }\n\n  destroy (err) {\n    if (this.destroyed) return\n    this.destroyed = true\n    if (this._handshake) this._handshake.destroy()\n    if (this._encryption) this._encryption.destroy()\n    if (this.handlers.destroy) this.handlers.destroy(err)\n  }\n\n  static keyPair (seed) {\n    return Handshake.keyPair(seed)\n  }\n}\n\nfunction onopen (ch, message, self) {\n  if (self.handlers.onopen) self.handlers.onopen(ch, message)\n}\n\nfunction onoptions (ch, message, self) {\n  if (self.handlers.onoptions) self.handlers.onoptions(ch, message)\n}\n\nfunction onstatus (ch, message, self) {\n  if (self.handlers.onstatus) self.handlers.onstatus(ch, message)\n}\n\nfunction onhave (ch, message, self) {\n  if (self.handlers.onhave) self.handlers.onhave(ch, message)\n}\n\nfunction onunhave (ch, message, self) {\n  if (self.handlers.onunhave) self.handlers.onunhave(ch, message)\n}\n\nfunction onwant (ch, message, self) {\n  if (self.handlers.onwant) self.handlers.onwant(ch, message)\n}\n\nfunction onunwant (ch, message, self) {\n  if (self.handlers.onunwant) self.handlers.onunwant(ch, message)\n}\n\nfunction onrequest (ch, message, self) {\n  if (self.handlers.onrequest) self.handlers.onrequest(ch, message)\n}\n\nfunction oncancel (ch, message, self) {\n  if (self.handlers.oncancel) self.handlers.oncancel(ch, message)\n}\n\nfunction ondata (ch, message, self) {\n  if (self.handlers.ondata) self.handlers.ondata(ch, message)\n}\n\nfunction onclose (ch, message, self) {\n  if (self.handlers.onclose) self.handlers.onclose(ch, message)\n}\n\nfunction onmessage (ch, type, message, self) {\n  if (type !== 15) return\n  const id = varint.decode(message)\n  const m = message.slice(varint.decode.bytes)\n  if (self.handlers.onextension) self.handlers.onextension(ch, id, m)\n}\n\nfunction onmissing (bytes, self) {\n  if (self.handlers.onmissing) self.handlers.onmissing(bytes)\n}\n\nexport default simpleHypercoreProtocol;\nexport { simpleHypercoreProtocol as __moduleExports };","start":1670465471826,"end":1670465471829,"order":"normal"}]}
