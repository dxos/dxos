{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/merkle-tree-stream@4.0.0/node_modules/merkle-tree-stream/generator.js","transforms":[{"name":"vite:load-fallback","result":"// a more low level interface to the merkle tree stream.\n// useful for certain applications the require non-streamy access to the algos.\n// versioned by the same semver as the stream interface.\n\nconst flat = require('flat-tree')\n\nmodule.exports = class MerkleGenerator {\n  constructor (opts, roots) {\n    if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')\n\n    this.roots = roots || opts.roots || []\n    this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0\n\n    for (var i = 0; i < this.roots.length; i++) {\n      var r = this.roots[i]\n      if (r && !r.parent) r.parent = flat.parent(r.index)\n    }\n\n    this._leaf = opts.leaf\n    this._parent = opts.parent\n  }\n\n  next (data, nodes) {\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data)\n    if (!nodes) nodes = []\n\n    var index = 2 * this.blocks++\n\n    var leaf = {\n      index: index,\n      parent: flat.parent(index),\n      hash: null,\n      size: data.length,\n      data: data\n    }\n\n    leaf.hash = this._leaf(leaf, this.roots)\n    this.roots.push(leaf)\n    nodes.push(leaf)\n\n    while (this.roots.length > 1) {\n      var left = this.roots[this.roots.length - 2]\n      var right = this.roots[this.roots.length - 1]\n\n      if (left.parent !== right.parent) break\n\n      this.roots.pop()\n      this.roots[this.roots.length - 1] = leaf = {\n        index: left.parent,\n        parent: flat.parent(left.parent),\n        hash: this._parent(left, right),\n        size: left.size + right.size,\n        data: null\n      }\n      nodes.push(leaf)\n    }\n\n    return nodes\n  }\n}\n","start":1670465469188,"end":1670465469266},{"name":"vite:react-babel","result":"// a more low level interface to the merkle tree stream.\n// useful for certain applications the require non-streamy access to the algos.\n// versioned by the same semver as the stream interface.\n\nconst flat = require('flat-tree')\n\nmodule.exports = class MerkleGenerator {\n  constructor (opts, roots) {\n    if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')\n\n    this.roots = roots || opts.roots || []\n    this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0\n\n    for (var i = 0; i < this.roots.length; i++) {\n      var r = this.roots[i]\n      if (r && !r.parent) r.parent = flat.parent(r.index)\n    }\n\n    this._leaf = opts.leaf\n    this._parent = opts.parent\n  }\n\n  next (data, nodes) {\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data)\n    if (!nodes) nodes = []\n\n    var index = 2 * this.blocks++\n\n    var leaf = {\n      index: index,\n      parent: flat.parent(index),\n      hash: null,\n      size: data.length,\n      data: data\n    }\n\n    leaf.hash = this._leaf(leaf, this.roots)\n    this.roots.push(leaf)\n    nodes.push(leaf)\n\n    while (this.roots.length > 1) {\n      var left = this.roots[this.roots.length - 2]\n      var right = this.roots[this.roots.length - 1]\n\n      if (left.parent !== right.parent) break\n\n      this.roots.pop()\n      this.roots[this.roots.length - 1] = leaf = {\n        index: left.parent,\n        parent: flat.parent(left.parent),\n        hash: this._parent(left, right),\n        size: left.size + right.size,\n        data: null\n      }\n      nodes.push(leaf)\n    }\n\n    return nodes\n  }\n}\n","start":1670465469266,"end":1670465469266,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js?commonjs-proxy\";\n\n// a more low level interface to the merkle tree stream.\n// useful for certain applications the require non-streamy access to the algos.\n// versioned by the same semver as the stream interface.\n\nconst flat = require$$0\n\nvar generator = class MerkleGenerator {\n  constructor (opts, roots) {\n    if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')\n\n    this.roots = roots || opts.roots || []\n    this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0\n\n    for (var i = 0; i < this.roots.length; i++) {\n      var r = this.roots[i]\n      if (r && !r.parent) r.parent = flat.parent(r.index)\n    }\n\n    this._leaf = opts.leaf\n    this._parent = opts.parent\n  }\n\n  next (data, nodes) {\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data)\n    if (!nodes) nodes = []\n\n    var index = 2 * this.blocks++\n\n    var leaf = {\n      index: index,\n      parent: flat.parent(index),\n      hash: null,\n      size: data.length,\n      data: data\n    }\n\n    leaf.hash = this._leaf(leaf, this.roots)\n    this.roots.push(leaf)\n    nodes.push(leaf)\n\n    while (this.roots.length > 1) {\n      var left = this.roots[this.roots.length - 2]\n      var right = this.roots[this.roots.length - 1]\n\n      if (left.parent !== right.parent) break\n\n      this.roots.pop()\n      this.roots[this.roots.length - 1] = leaf = {\n        index: left.parent,\n        parent: flat.parent(left.parent),\n        hash: this._parent(left, right),\n        size: left.size + right.size,\n        data: null\n      }\n      nodes.push(leaf)\n    }\n\n    return nodes\n  }\n}\n\nexport default generator;\nexport { generator as __moduleExports };","start":1670465469267,"end":1670465469277,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/flat-tree@1.9.0/node_modules/flat-tree/index.js?commonjs-proxy\";\n\n// a more low level interface to the merkle tree stream.\n// useful for certain applications the require non-streamy access to the algos.\n// versioned by the same semver as the stream interface.\n\nconst flat = require$$0\n\nvar generator = class MerkleGenerator {\n  constructor (opts, roots) {\n    if (!opts || !opts.leaf || !opts.parent) throw new Error('opts.leaf and opts.parent required')\n\n    this.roots = roots || opts.roots || []\n    this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0\n\n    for (var i = 0; i < this.roots.length; i++) {\n      var r = this.roots[i]\n      if (r && !r.parent) r.parent = flat.parent(r.index)\n    }\n\n    this._leaf = opts.leaf\n    this._parent = opts.parent\n  }\n\n  next (data, nodes) {\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data)\n    if (!nodes) nodes = []\n\n    var index = 2 * this.blocks++\n\n    var leaf = {\n      index: index,\n      parent: flat.parent(index),\n      hash: null,\n      size: data.length,\n      data: data\n    }\n\n    leaf.hash = this._leaf(leaf, this.roots)\n    this.roots.push(leaf)\n    nodes.push(leaf)\n\n    while (this.roots.length > 1) {\n      var left = this.roots[this.roots.length - 2]\n      var right = this.roots[this.roots.length - 1]\n\n      if (left.parent !== right.parent) break\n\n      this.roots.pop()\n      this.roots[this.roots.length - 1] = leaf = {\n        index: left.parent,\n        parent: flat.parent(left.parent),\n        hash: this._parent(left, right),\n        size: left.size + right.size,\n        data: null\n      }\n      nodes.push(leaf)\n    }\n\n    return nodes\n  }\n}\n\nexport default generator;\nexport { generator as __moduleExports };","start":1670465469277,"end":1670465469279,"order":"normal"}]}
