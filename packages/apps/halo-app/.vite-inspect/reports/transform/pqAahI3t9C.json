{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-message-channels@1.2.1/node_modules/simple-message-channels/index.js","transforms":[{"name":"vite:load-fallback","result":"const varint = require('varint')\n\nmodule.exports = class SimpleMessageChannels {\n  constructor ({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {\n    this._message = null\n    this._ptr = 0\n    this._varint = 0\n    this._factor = 1\n    this._length = 0\n    this._header = 0\n    this._state = 0\n    this._consumed = 0\n    this._maxSize = maxSize\n    this._types = types || []\n\n    this.receiving = false\n    this.destroyed = false\n    this.error = null\n    this.context = context\n    this.onmessage = onmessage\n    this.onmissing = onmissing\n  }\n\n  destroy (err) {\n    if (err) this.error = err\n    this.destroyed = true\n  }\n\n  recv (data) {\n    if (this.receiving === true) throw new Error('Cannot recursively receive data')\n    this.receiving = true\n\n    let offset = 0\n    while (offset < data.length) {\n      if (this._state === 2) offset = this._readMessage(data, offset)\n      else offset = this._readVarint(data, offset)\n    }\n    if (this._state === 2 && this._length === 0) {\n      this._readMessage(data, offset)\n    }\n\n    this.receiving = false\n    return !this.destroyed\n  }\n\n  _readMessage (data, offset) {\n    const free = data.length - offset\n    if (free >= this._length) {\n      if (this._message) {\n        data.copy(this._message, this._message.length - this._length, offset)\n      } else {\n        this._message = data.slice(offset, offset + this._length)\n      }\n      return this._nextState(data, offset += this._length) ? offset : data.length\n    }\n\n    if (!this._message) this._message = Buffer.allocUnsafe(this._length)\n    data.copy(this._message, this._message.length - this._length, offset)\n    this._length -= free\n\n    return data.length\n  }\n\n  _readVarint (data, offset) {\n    for (; offset < data.length; offset++) {\n      this._varint += (data[offset] & 127) * this._factor\n      this._consumed++\n      if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length\n      this._factor *= 128\n    }\n    if (this._consumed >= 8) this.destroy(new Error('Incoming varint is invalid')) // 8 * 7bits is 56 ie max for js\n    return data.length\n  }\n\n  _nextState (data, offset) {\n    switch (this._state) {\n      case 0:\n        this._state = 1\n        this._factor = 1\n        this._length = this._varint\n        this._consumed = this._varint = 0\n        if (this._length === 0) this._state = 0\n        return true\n\n      case 1:\n        this._state = 2\n        this._factor = 1\n        this._header = this._varint\n        this._length -= this._consumed\n        this._consumed = this._varint = 0\n        if (this._length < 0 || this._length > this._maxSize) {\n          this.destroy(new Error('Incoming message is larger than max size'))\n          return false\n        }\n        if (this.onmissing) {\n          const extra = data.length - offset\n          if (this._length > extra) this.onmissing(this._length - extra, this.context)\n        }\n        return true\n\n      case 2:\n        this._state = 0\n        this._onmessage(this._header >> 4, this._header & 0b1111, this._message, data, offset)\n        this._message = null\n        return !this.destroyed\n\n      default:\n        return false\n    }\n  }\n\n  _onmessage (channel, type, message, data, offset) {\n    if (type >= this._types.length) {\n      if (this.onmessage === null) return\n      return this.onmessage(channel, type, message, this.context, data, offset)\n    }\n\n    let m = null\n    const { onmessage, encoding, context } = this._types[type]\n\n    try {\n      m = encoding.decode(message)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    onmessage(channel, m, context, data, offset)\n  }\n\n  send (channel, type, message) {\n    const header = channel << 4 | type\n    const length = this._encodingLength(type, message) + varint.encodingLength(header)\n    const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length)\n\n    varint.encode(length, payload, 0)\n    const offset = varint.encode.bytes\n    varint.encode(header, payload, offset)\n    this._encode(type, message, payload, offset + varint.encode.bytes)\n\n    return payload\n  }\n\n  sendBatch (messages) {\n    let length = 0\n    let offset = 0\n\n    for (const { type, message } of messages) {\n      // 16 is >= the max size of the varints\n      length += 16 + this._encodingLength(type, message)\n    }\n\n    const payload = Buffer.allocUnsafe(length)\n\n    for (const { channel, type, message } of messages) {\n      const header = channel << 4 | type\n      const length = this._encodingLength(type, message) + varint.encodingLength(header)\n      varint.encode(length, payload, offset)\n      offset += varint.encode.bytes\n      varint.encode(header, payload, offset)\n      offset += varint.encode.bytes\n      offset += this._encode(type, message, payload, offset)\n    }\n\n    return payload.slice(0, offset)\n  }\n\n  _encodingLength (type, message) {\n    if (type >= this._types.length) return message.length\n    return this._types[type].encoding.encodingLength(message)\n  }\n\n  _encode (type, message, buf, offset) {\n    if (type >= this._types.length) {\n      message.copy(buf, offset)\n      return message.length\n    }\n\n    const enc = this._types[type].encoding\n    enc.encode(message, buf, offset)\n    return enc.encode.bytes\n  }\n}\n","start":1670465470115,"end":1670465470287},{"name":"vite:react-babel","result":"const varint = require('varint')\n\nmodule.exports = class SimpleMessageChannels {\n  constructor ({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {\n    this._message = null\n    this._ptr = 0\n    this._varint = 0\n    this._factor = 1\n    this._length = 0\n    this._header = 0\n    this._state = 0\n    this._consumed = 0\n    this._maxSize = maxSize\n    this._types = types || []\n\n    this.receiving = false\n    this.destroyed = false\n    this.error = null\n    this.context = context\n    this.onmessage = onmessage\n    this.onmissing = onmissing\n  }\n\n  destroy (err) {\n    if (err) this.error = err\n    this.destroyed = true\n  }\n\n  recv (data) {\n    if (this.receiving === true) throw new Error('Cannot recursively receive data')\n    this.receiving = true\n\n    let offset = 0\n    while (offset < data.length) {\n      if (this._state === 2) offset = this._readMessage(data, offset)\n      else offset = this._readVarint(data, offset)\n    }\n    if (this._state === 2 && this._length === 0) {\n      this._readMessage(data, offset)\n    }\n\n    this.receiving = false\n    return !this.destroyed\n  }\n\n  _readMessage (data, offset) {\n    const free = data.length - offset\n    if (free >= this._length) {\n      if (this._message) {\n        data.copy(this._message, this._message.length - this._length, offset)\n      } else {\n        this._message = data.slice(offset, offset + this._length)\n      }\n      return this._nextState(data, offset += this._length) ? offset : data.length\n    }\n\n    if (!this._message) this._message = Buffer.allocUnsafe(this._length)\n    data.copy(this._message, this._message.length - this._length, offset)\n    this._length -= free\n\n    return data.length\n  }\n\n  _readVarint (data, offset) {\n    for (; offset < data.length; offset++) {\n      this._varint += (data[offset] & 127) * this._factor\n      this._consumed++\n      if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length\n      this._factor *= 128\n    }\n    if (this._consumed >= 8) this.destroy(new Error('Incoming varint is invalid')) // 8 * 7bits is 56 ie max for js\n    return data.length\n  }\n\n  _nextState (data, offset) {\n    switch (this._state) {\n      case 0:\n        this._state = 1\n        this._factor = 1\n        this._length = this._varint\n        this._consumed = this._varint = 0\n        if (this._length === 0) this._state = 0\n        return true\n\n      case 1:\n        this._state = 2\n        this._factor = 1\n        this._header = this._varint\n        this._length -= this._consumed\n        this._consumed = this._varint = 0\n        if (this._length < 0 || this._length > this._maxSize) {\n          this.destroy(new Error('Incoming message is larger than max size'))\n          return false\n        }\n        if (this.onmissing) {\n          const extra = data.length - offset\n          if (this._length > extra) this.onmissing(this._length - extra, this.context)\n        }\n        return true\n\n      case 2:\n        this._state = 0\n        this._onmessage(this._header >> 4, this._header & 0b1111, this._message, data, offset)\n        this._message = null\n        return !this.destroyed\n\n      default:\n        return false\n    }\n  }\n\n  _onmessage (channel, type, message, data, offset) {\n    if (type >= this._types.length) {\n      if (this.onmessage === null) return\n      return this.onmessage(channel, type, message, this.context, data, offset)\n    }\n\n    let m = null\n    const { onmessage, encoding, context } = this._types[type]\n\n    try {\n      m = encoding.decode(message)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    onmessage(channel, m, context, data, offset)\n  }\n\n  send (channel, type, message) {\n    const header = channel << 4 | type\n    const length = this._encodingLength(type, message) + varint.encodingLength(header)\n    const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length)\n\n    varint.encode(length, payload, 0)\n    const offset = varint.encode.bytes\n    varint.encode(header, payload, offset)\n    this._encode(type, message, payload, offset + varint.encode.bytes)\n\n    return payload\n  }\n\n  sendBatch (messages) {\n    let length = 0\n    let offset = 0\n\n    for (const { type, message } of messages) {\n      // 16 is >= the max size of the varints\n      length += 16 + this._encodingLength(type, message)\n    }\n\n    const payload = Buffer.allocUnsafe(length)\n\n    for (const { channel, type, message } of messages) {\n      const header = channel << 4 | type\n      const length = this._encodingLength(type, message) + varint.encodingLength(header)\n      varint.encode(length, payload, offset)\n      offset += varint.encode.bytes\n      varint.encode(header, payload, offset)\n      offset += varint.encode.bytes\n      offset += this._encode(type, message, payload, offset)\n    }\n\n    return payload.slice(0, offset)\n  }\n\n  _encodingLength (type, message) {\n    if (type >= this._types.length) return message.length\n    return this._types[type].encoding.encodingLength(message)\n  }\n\n  _encode (type, message, buf, offset) {\n    if (type >= this._types.length) {\n      message.copy(buf, offset)\n      return message.length\n    }\n\n    const enc = this._types[type].encoding\n    enc.encode(message, buf, offset)\n    return enc.encode.bytes\n  }\n}\n","start":1670465470287,"end":1670465470287,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst varint = require$$0\n\nvar simpleMessageChannels = class SimpleMessageChannels {\n  constructor ({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {\n    this._message = null\n    this._ptr = 0\n    this._varint = 0\n    this._factor = 1\n    this._length = 0\n    this._header = 0\n    this._state = 0\n    this._consumed = 0\n    this._maxSize = maxSize\n    this._types = types || []\n\n    this.receiving = false\n    this.destroyed = false\n    this.error = null\n    this.context = context\n    this.onmessage = onmessage\n    this.onmissing = onmissing\n  }\n\n  destroy (err) {\n    if (err) this.error = err\n    this.destroyed = true\n  }\n\n  recv (data) {\n    if (this.receiving === true) throw new Error('Cannot recursively receive data')\n    this.receiving = true\n\n    let offset = 0\n    while (offset < data.length) {\n      if (this._state === 2) offset = this._readMessage(data, offset)\n      else offset = this._readVarint(data, offset)\n    }\n    if (this._state === 2 && this._length === 0) {\n      this._readMessage(data, offset)\n    }\n\n    this.receiving = false\n    return !this.destroyed\n  }\n\n  _readMessage (data, offset) {\n    const free = data.length - offset\n    if (free >= this._length) {\n      if (this._message) {\n        data.copy(this._message, this._message.length - this._length, offset)\n      } else {\n        this._message = data.slice(offset, offset + this._length)\n      }\n      return this._nextState(data, offset += this._length) ? offset : data.length\n    }\n\n    if (!this._message) this._message = Buffer.allocUnsafe(this._length)\n    data.copy(this._message, this._message.length - this._length, offset)\n    this._length -= free\n\n    return data.length\n  }\n\n  _readVarint (data, offset) {\n    for (; offset < data.length; offset++) {\n      this._varint += (data[offset] & 127) * this._factor\n      this._consumed++\n      if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length\n      this._factor *= 128\n    }\n    if (this._consumed >= 8) this.destroy(new Error('Incoming varint is invalid')) // 8 * 7bits is 56 ie max for js\n    return data.length\n  }\n\n  _nextState (data, offset) {\n    switch (this._state) {\n      case 0:\n        this._state = 1\n        this._factor = 1\n        this._length = this._varint\n        this._consumed = this._varint = 0\n        if (this._length === 0) this._state = 0\n        return true\n\n      case 1:\n        this._state = 2\n        this._factor = 1\n        this._header = this._varint\n        this._length -= this._consumed\n        this._consumed = this._varint = 0\n        if (this._length < 0 || this._length > this._maxSize) {\n          this.destroy(new Error('Incoming message is larger than max size'))\n          return false\n        }\n        if (this.onmissing) {\n          const extra = data.length - offset\n          if (this._length > extra) this.onmissing(this._length - extra, this.context)\n        }\n        return true\n\n      case 2:\n        this._state = 0\n        this._onmessage(this._header >> 4, this._header & 0b1111, this._message, data, offset)\n        this._message = null\n        return !this.destroyed\n\n      default:\n        return false\n    }\n  }\n\n  _onmessage (channel, type, message, data, offset) {\n    if (type >= this._types.length) {\n      if (this.onmessage === null) return\n      return this.onmessage(channel, type, message, this.context, data, offset)\n    }\n\n    let m = null\n    const { onmessage, encoding, context } = this._types[type]\n\n    try {\n      m = encoding.decode(message)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    onmessage(channel, m, context, data, offset)\n  }\n\n  send (channel, type, message) {\n    const header = channel << 4 | type\n    const length = this._encodingLength(type, message) + varint.encodingLength(header)\n    const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length)\n\n    varint.encode(length, payload, 0)\n    const offset = varint.encode.bytes\n    varint.encode(header, payload, offset)\n    this._encode(type, message, payload, offset + varint.encode.bytes)\n\n    return payload\n  }\n\n  sendBatch (messages) {\n    let length = 0\n    let offset = 0\n\n    for (const { type, message } of messages) {\n      // 16 is >= the max size of the varints\n      length += 16 + this._encodingLength(type, message)\n    }\n\n    const payload = Buffer.allocUnsafe(length)\n\n    for (const { channel, type, message } of messages) {\n      const header = channel << 4 | type\n      const length = this._encodingLength(type, message) + varint.encodingLength(header)\n      varint.encode(length, payload, offset)\n      offset += varint.encode.bytes\n      varint.encode(header, payload, offset)\n      offset += varint.encode.bytes\n      offset += this._encode(type, message, payload, offset)\n    }\n\n    return payload.slice(0, offset)\n  }\n\n  _encodingLength (type, message) {\n    if (type >= this._types.length) return message.length\n    return this._types[type].encoding.encodingLength(message)\n  }\n\n  _encode (type, message, buf, offset) {\n    if (type >= this._types.length) {\n      message.copy(buf, offset)\n      return message.length\n    }\n\n    const enc = this._types[type].encoding\n    enc.encode(message, buf, offset)\n    return enc.encode.bytes\n  }\n}\n\nexport default simpleMessageChannels;\nexport { simpleMessageChannels as __moduleExports };","start":1670465470287,"end":1670465470934,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/varint@5.0.2/node_modules/varint/index.js?commonjs-proxy\";\n\nconst varint = require$$0\n\nvar simpleMessageChannels = class SimpleMessageChannels {\n  constructor ({ maxSize = 8 * 1024 * 1024, context = null, onmessage = null, onmissing = null, types = null } = {}) {\n    this._message = null\n    this._ptr = 0\n    this._varint = 0\n    this._factor = 1\n    this._length = 0\n    this._header = 0\n    this._state = 0\n    this._consumed = 0\n    this._maxSize = maxSize\n    this._types = types || []\n\n    this.receiving = false\n    this.destroyed = false\n    this.error = null\n    this.context = context\n    this.onmessage = onmessage\n    this.onmissing = onmissing\n  }\n\n  destroy (err) {\n    if (err) this.error = err\n    this.destroyed = true\n  }\n\n  recv (data) {\n    if (this.receiving === true) throw new Error('Cannot recursively receive data')\n    this.receiving = true\n\n    let offset = 0\n    while (offset < data.length) {\n      if (this._state === 2) offset = this._readMessage(data, offset)\n      else offset = this._readVarint(data, offset)\n    }\n    if (this._state === 2 && this._length === 0) {\n      this._readMessage(data, offset)\n    }\n\n    this.receiving = false\n    return !this.destroyed\n  }\n\n  _readMessage (data, offset) {\n    const free = data.length - offset\n    if (free >= this._length) {\n      if (this._message) {\n        data.copy(this._message, this._message.length - this._length, offset)\n      } else {\n        this._message = data.slice(offset, offset + this._length)\n      }\n      return this._nextState(data, offset += this._length) ? offset : data.length\n    }\n\n    if (!this._message) this._message = Buffer.allocUnsafe(this._length)\n    data.copy(this._message, this._message.length - this._length, offset)\n    this._length -= free\n\n    return data.length\n  }\n\n  _readVarint (data, offset) {\n    for (; offset < data.length; offset++) {\n      this._varint += (data[offset] & 127) * this._factor\n      this._consumed++\n      if (data[offset] < 128) return this._nextState(data, ++offset) ? offset : data.length\n      this._factor *= 128\n    }\n    if (this._consumed >= 8) this.destroy(new Error('Incoming varint is invalid')) // 8 * 7bits is 56 ie max for js\n    return data.length\n  }\n\n  _nextState (data, offset) {\n    switch (this._state) {\n      case 0:\n        this._state = 1\n        this._factor = 1\n        this._length = this._varint\n        this._consumed = this._varint = 0\n        if (this._length === 0) this._state = 0\n        return true\n\n      case 1:\n        this._state = 2\n        this._factor = 1\n        this._header = this._varint\n        this._length -= this._consumed\n        this._consumed = this._varint = 0\n        if (this._length < 0 || this._length > this._maxSize) {\n          this.destroy(new Error('Incoming message is larger than max size'))\n          return false\n        }\n        if (this.onmissing) {\n          const extra = data.length - offset\n          if (this._length > extra) this.onmissing(this._length - extra, this.context)\n        }\n        return true\n\n      case 2:\n        this._state = 0\n        this._onmessage(this._header >> 4, this._header & 0b1111, this._message, data, offset)\n        this._message = null\n        return !this.destroyed\n\n      default:\n        return false\n    }\n  }\n\n  _onmessage (channel, type, message, data, offset) {\n    if (type >= this._types.length) {\n      if (this.onmessage === null) return\n      return this.onmessage(channel, type, message, this.context, data, offset)\n    }\n\n    let m = null\n    const { onmessage, encoding, context } = this._types[type]\n\n    try {\n      m = encoding.decode(message)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    onmessage(channel, m, context, data, offset)\n  }\n\n  send (channel, type, message) {\n    const header = channel << 4 | type\n    const length = this._encodingLength(type, message) + varint.encodingLength(header)\n    const payload = Buffer.allocUnsafe(varint.encodingLength(length) + length)\n\n    varint.encode(length, payload, 0)\n    const offset = varint.encode.bytes\n    varint.encode(header, payload, offset)\n    this._encode(type, message, payload, offset + varint.encode.bytes)\n\n    return payload\n  }\n\n  sendBatch (messages) {\n    let length = 0\n    let offset = 0\n\n    for (const { type, message } of messages) {\n      // 16 is >= the max size of the varints\n      length += 16 + this._encodingLength(type, message)\n    }\n\n    const payload = Buffer.allocUnsafe(length)\n\n    for (const { channel, type, message } of messages) {\n      const header = channel << 4 | type\n      const length = this._encodingLength(type, message) + varint.encodingLength(header)\n      varint.encode(length, payload, offset)\n      offset += varint.encode.bytes\n      varint.encode(header, payload, offset)\n      offset += varint.encode.bytes\n      offset += this._encode(type, message, payload, offset)\n    }\n\n    return payload.slice(0, offset)\n  }\n\n  _encodingLength (type, message) {\n    if (type >= this._types.length) return message.length\n    return this._types[type].encoding.encodingLength(message)\n  }\n\n  _encode (type, message, buf, offset) {\n    if (type >= this._types.length) {\n      message.copy(buf, offset)\n      return message.length\n    }\n\n    const enc = this._types[type].encoding\n    enc.encode(message, buf, offset)\n    return enc.encode.bytes\n  }\n}\n\nexport default simpleMessageChannels;\nexport { simpleMessageChannels as __moduleExports };","start":1670465470934,"end":1670465470937,"order":"normal"}]}
