{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/type.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(\"./namespace\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(\"./enum\"),\n    OneOf     = require(\"./oneof\"),\n    Field     = require(\"./field\"),\n    MapField  = require(\"./mapfield\"),\n    Service   = require(\"./service\"),\n    Message   = require(\"./message\"),\n    Reader    = require(\"./reader\"),\n    Writer    = require(\"./writer\"),\n    util      = require(\"./util\"),\n    encoder   = require(\"./encoder\"),\n    decoder   = require(\"./decoder\"),\n    verifier  = require(\"./verifier\"),\n    converter = require(\"./converter\"),\n    wrappers  = require(\"./wrappers\");\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {number[][]} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return this.fields[name]\n        || this.oneofs && this.oneofs[name]\n        || this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","start":1670465470599,"end":1670465470654},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(\"./namespace\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(\"./enum\"),\n    OneOf     = require(\"./oneof\"),\n    Field     = require(\"./field\"),\n    MapField  = require(\"./mapfield\"),\n    Service   = require(\"./service\"),\n    Message   = require(\"./message\"),\n    Reader    = require(\"./reader\"),\n    Writer    = require(\"./writer\"),\n    util      = require(\"./util\"),\n    encoder   = require(\"./encoder\"),\n    decoder   = require(\"./decoder\"),\n    verifier  = require(\"./verifier\"),\n    converter = require(\"./converter\"),\n    wrappers  = require(\"./wrappers\");\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {number[][]} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return this.fields[name]\n        || this.oneofs && this.oneofs[name]\n        || this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","start":1670465470654,"end":1670465470654,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/namespace.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/oneof.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/field.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/mapfield.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/service.js?commonjs-wrapped\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/message.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/reader.js?commonjs-proxy\";\nimport require$$8 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/writer.js?commonjs-proxy\";\nimport { __require as require$$9 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/encoder.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/decoder.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/verifier.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/converter.js?commonjs-wrapped\";\nimport require$$14 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/wrappers.js?commonjs-proxy\";\n\nvar type;\nvar hasRequiredType;\n\nfunction requireType () {\n\tif (hasRequiredType) return type;\n\thasRequiredType = 1;\n\t\"use strict\";\n\ttype = Type;\n\n\t// extends Namespace\n\tvar Namespace = require$$0();\n\t((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\n\tvar Enum      = require$$1(),\n\t    OneOf     = require$$2(),\n\t    Field     = require$$3(),\n\t    MapField  = require$$4(),\n\t    Service   = require$$5(),\n\t    Message   = require$$6,\n\t    Reader    = require$$7,\n\t    Writer    = require$$8,\n\t    util      = require$$9(),\n\t    encoder   = require$$10(),\n\t    decoder   = require$$11(),\n\t    verifier  = require$$12(),\n\t    converter = require$$13(),\n\t    wrappers  = require$$14;\n\n\t/**\n\t * Constructs a new reflected message type instance.\n\t * @classdesc Reflected message type.\n\t * @extends NamespaceBase\n\t * @constructor\n\t * @param {string} name Message name\n\t * @param {Object.<string,*>} [options] Declared options\n\t */\n\tfunction Type(name, options) {\n\t    Namespace.call(this, name, options);\n\n\t    /**\n\t     * Message fields.\n\t     * @type {Object.<string,Field>}\n\t     */\n\t    this.fields = {};  // toJSON, marker\n\n\t    /**\n\t     * Oneofs declared within this namespace, if any.\n\t     * @type {Object.<string,OneOf>}\n\t     */\n\t    this.oneofs = undefined; // toJSON\n\n\t    /**\n\t     * Extension ranges, if any.\n\t     * @type {number[][]}\n\t     */\n\t    this.extensions = undefined; // toJSON\n\n\t    /**\n\t     * Reserved ranges, if any.\n\t     * @type {Array.<number[]|string>}\n\t     */\n\t    this.reserved = undefined; // toJSON\n\n\t    /*?\n\t     * Whether this type is a legacy group.\n\t     * @type {boolean|undefined}\n\t     */\n\t    this.group = undefined; // toJSON\n\n\t    /**\n\t     * Cached fields by id.\n\t     * @type {Object.<number,Field>|null}\n\t     * @private\n\t     */\n\t    this._fieldsById = null;\n\n\t    /**\n\t     * Cached fields as an array.\n\t     * @type {Field[]|null}\n\t     * @private\n\t     */\n\t    this._fieldsArray = null;\n\n\t    /**\n\t     * Cached oneofs as an array.\n\t     * @type {OneOf[]|null}\n\t     * @private\n\t     */\n\t    this._oneofsArray = null;\n\n\t    /**\n\t     * Cached constructor.\n\t     * @type {Constructor<{}>}\n\t     * @private\n\t     */\n\t    this._ctor = null;\n\t}\n\n\tObject.defineProperties(Type.prototype, {\n\n\t    /**\n\t     * Message fields by id.\n\t     * @name Type#fieldsById\n\t     * @type {Object.<number,Field>}\n\t     * @readonly\n\t     */\n\t    fieldsById: {\n\t        get: function() {\n\n\t            /* istanbul ignore if */\n\t            if (this._fieldsById)\n\t                return this._fieldsById;\n\n\t            this._fieldsById = {};\n\t            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n\t                var field = this.fields[names[i]],\n\t                    id = field.id;\n\n\t                /* istanbul ignore if */\n\t                if (this._fieldsById[id])\n\t                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n\t                this._fieldsById[id] = field;\n\t            }\n\t            return this._fieldsById;\n\t        }\n\t    },\n\n\t    /**\n\t     * Fields of this message as an array for iteration.\n\t     * @name Type#fieldsArray\n\t     * @type {Field[]}\n\t     * @readonly\n\t     */\n\t    fieldsArray: {\n\t        get: function() {\n\t            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n\t        }\n\t    },\n\n\t    /**\n\t     * Oneofs of this message as an array for iteration.\n\t     * @name Type#oneofsArray\n\t     * @type {OneOf[]}\n\t     * @readonly\n\t     */\n\t    oneofsArray: {\n\t        get: function() {\n\t            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n\t        }\n\t    },\n\n\t    /**\n\t     * The registered constructor, if any registered, otherwise a generic constructor.\n\t     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n\t     * @name Type#ctor\n\t     * @type {Constructor<{}>}\n\t     */\n\t    ctor: {\n\t        get: function() {\n\t            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n\t        },\n\t        set: function(ctor) {\n\n\t            // Ensure proper prototype\n\t            var prototype = ctor.prototype;\n\t            if (!(prototype instanceof Message)) {\n\t                (ctor.prototype = new Message()).constructor = ctor;\n\t                util.merge(ctor.prototype, prototype);\n\t            }\n\n\t            // Classes and messages reference their reflected type\n\t            ctor.$type = ctor.prototype.$type = this;\n\n\t            // Mix in static methods\n\t            util.merge(ctor, Message, true);\n\n\t            this._ctor = ctor;\n\n\t            // Messages have non-enumerable default values on their prototype\n\t            var i = 0;\n\t            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n\t                this._fieldsArray[i].resolve(); // ensures a proper value\n\n\t            // Messages have non-enumerable getters and setters for each virtual oneof field\n\t            var ctorProperties = {};\n\t            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n\t                ctorProperties[this._oneofsArray[i].resolve().name] = {\n\t                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n\t                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n\t                };\n\t            if (i)\n\t                Object.defineProperties(ctor.prototype, ctorProperties);\n\t        }\n\t    }\n\t});\n\n\t/**\n\t * Generates a constructor function for the specified type.\n\t * @param {Type} mtype Message type\n\t * @returns {Codegen} Codegen instance\n\t */\n\tType.generateConstructor = function generateConstructor(mtype) {\n\t    /* eslint-disable no-unexpected-multiline */\n\t    var gen = util.codegen([\"p\"], mtype.name);\n\t    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n\t    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n\t        if ((field = mtype._fieldsArray[i]).map) gen\n\t            (\"this%s={}\", util.safeProp(field.name));\n\t        else if (field.repeated) gen\n\t            (\"this%s=[]\", util.safeProp(field.name));\n\t    return gen\n\t    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n\t        (\"this[ks[i]]=p[ks[i]]\");\n\t    /* eslint-enable no-unexpected-multiline */\n\t};\n\n\tfunction clearCache(type) {\n\t    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n\t    delete type.encode;\n\t    delete type.decode;\n\t    delete type.verify;\n\t    return type;\n\t}\n\n\t/**\n\t * Message type descriptor.\n\t * @interface IType\n\t * @extends INamespace\n\t * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n\t * @property {Object.<string,IField>} fields Field descriptors\n\t * @property {number[][]} [extensions] Extension ranges\n\t * @property {number[][]} [reserved] Reserved ranges\n\t * @property {boolean} [group=false] Whether a legacy group or not\n\t */\n\n\t/**\n\t * Creates a message type from a message type descriptor.\n\t * @param {string} name Message name\n\t * @param {IType} json Message type descriptor\n\t * @returns {Type} Created message type\n\t */\n\tType.fromJSON = function fromJSON(name, json) {\n\t    var type = new Type(name, json.options);\n\t    type.extensions = json.extensions;\n\t    type.reserved = json.reserved;\n\t    var names = Object.keys(json.fields),\n\t        i = 0;\n\t    for (; i < names.length; ++i)\n\t        type.add(\n\t            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n\t            ? MapField.fromJSON\n\t            : Field.fromJSON )(names[i], json.fields[names[i]])\n\t        );\n\t    if (json.oneofs)\n\t        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n\t            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n\t    if (json.nested)\n\t        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n\t            var nested = json.nested[names[i]];\n\t            type.add( // most to least likely\n\t                ( nested.id !== undefined\n\t                ? Field.fromJSON\n\t                : nested.fields !== undefined\n\t                ? Type.fromJSON\n\t                : nested.values !== undefined\n\t                ? Enum.fromJSON\n\t                : nested.methods !== undefined\n\t                ? Service.fromJSON\n\t                : Namespace.fromJSON )(names[i], nested)\n\t            );\n\t        }\n\t    if (json.extensions && json.extensions.length)\n\t        type.extensions = json.extensions;\n\t    if (json.reserved && json.reserved.length)\n\t        type.reserved = json.reserved;\n\t    if (json.group)\n\t        type.group = true;\n\t    if (json.comment)\n\t        type.comment = json.comment;\n\t    return type;\n\t};\n\n\t/**\n\t * Converts this message type to a message type descriptor.\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {IType} Message type descriptor\n\t */\n\tType.prototype.toJSON = function toJSON(toJSONOptions) {\n\t    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n\t    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n\t    return util.toObject([\n\t        \"options\"    , inherited && inherited.options || undefined,\n\t        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n\t        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n\t        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n\t        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n\t        \"group\"      , this.group || undefined,\n\t        \"nested\"     , inherited && inherited.nested || undefined,\n\t        \"comment\"    , keepComments ? this.comment : undefined\n\t    ]);\n\t};\n\n\t/**\n\t * @override\n\t */\n\tType.prototype.resolveAll = function resolveAll() {\n\t    var fields = this.fieldsArray, i = 0;\n\t    while (i < fields.length)\n\t        fields[i++].resolve();\n\t    var oneofs = this.oneofsArray; i = 0;\n\t    while (i < oneofs.length)\n\t        oneofs[i++].resolve();\n\t    return Namespace.prototype.resolveAll.call(this);\n\t};\n\n\t/**\n\t * @override\n\t */\n\tType.prototype.get = function get(name) {\n\t    return this.fields[name]\n\t        || this.oneofs && this.oneofs[name]\n\t        || this.nested && this.nested[name]\n\t        || null;\n\t};\n\n\t/**\n\t * Adds a nested object to this type.\n\t * @param {ReflectionObject} object Nested object to add\n\t * @returns {Type} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n\t */\n\tType.prototype.add = function add(object) {\n\n\t    if (this.get(object.name))\n\t        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n\t    if (object instanceof Field && object.extend === undefined) {\n\t        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n\t        // The root object takes care of adding distinct sister-fields to the respective extended\n\t        // type instead.\n\n\t        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n\t        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n\t            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n\t        if (this.isReservedId(object.id))\n\t            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n\t        if (this.isReservedName(object.name))\n\t            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n\t        if (object.parent)\n\t            object.parent.remove(object);\n\t        this.fields[object.name] = object;\n\t        object.message = this;\n\t        object.onAdd(this);\n\t        return clearCache(this);\n\t    }\n\t    if (object instanceof OneOf) {\n\t        if (!this.oneofs)\n\t            this.oneofs = {};\n\t        this.oneofs[object.name] = object;\n\t        object.onAdd(this);\n\t        return clearCache(this);\n\t    }\n\t    return Namespace.prototype.add.call(this, object);\n\t};\n\n\t/**\n\t * Removes a nested object from this type.\n\t * @param {ReflectionObject} object Nested object to remove\n\t * @returns {Type} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If `object` is not a member of this type\n\t */\n\tType.prototype.remove = function remove(object) {\n\t    if (object instanceof Field && object.extend === undefined) {\n\t        // See Type#add for the reason why extension fields are excluded here.\n\n\t        /* istanbul ignore if */\n\t        if (!this.fields || this.fields[object.name] !== object)\n\t            throw Error(object + \" is not a member of \" + this);\n\n\t        delete this.fields[object.name];\n\t        object.parent = null;\n\t        object.onRemove(this);\n\t        return clearCache(this);\n\t    }\n\t    if (object instanceof OneOf) {\n\n\t        /* istanbul ignore if */\n\t        if (!this.oneofs || this.oneofs[object.name] !== object)\n\t            throw Error(object + \" is not a member of \" + this);\n\n\t        delete this.oneofs[object.name];\n\t        object.parent = null;\n\t        object.onRemove(this);\n\t        return clearCache(this);\n\t    }\n\t    return Namespace.prototype.remove.call(this, object);\n\t};\n\n\t/**\n\t * Tests if the specified id is reserved.\n\t * @param {number} id Id to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tType.prototype.isReservedId = function isReservedId(id) {\n\t    return Namespace.isReservedId(this.reserved, id);\n\t};\n\n\t/**\n\t * Tests if the specified name is reserved.\n\t * @param {string} name Name to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tType.prototype.isReservedName = function isReservedName(name) {\n\t    return Namespace.isReservedName(this.reserved, name);\n\t};\n\n\t/**\n\t * Creates a new message of this type using the specified properties.\n\t * @param {Object.<string,*>} [properties] Properties to set\n\t * @returns {Message<{}>} Message instance\n\t */\n\tType.prototype.create = function create(properties) {\n\t    return new this.ctor(properties);\n\t};\n\n\t/**\n\t * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n\t * @returns {Type} `this`\n\t */\n\tType.prototype.setup = function setup() {\n\t    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n\t    // multiple times (V8, soft-deopt prototype-check).\n\n\t    var fullName = this.fullName,\n\t        types    = [];\n\t    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n\t        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n\t    // Replace setup methods with type-specific generated functions\n\t    this.encode = encoder(this)({\n\t        Writer : Writer,\n\t        types  : types,\n\t        util   : util\n\t    });\n\t    this.decode = decoder(this)({\n\t        Reader : Reader,\n\t        types  : types,\n\t        util   : util\n\t    });\n\t    this.verify = verifier(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\t    this.fromObject = converter.fromObject(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\t    this.toObject = converter.toObject(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\n\t    // Inject custom wrappers for common types\n\t    var wrapper = wrappers[fullName];\n\t    if (wrapper) {\n\t        var originalThis = Object.create(this);\n\t        // if (wrapper.fromObject) {\n\t            originalThis.fromObject = this.fromObject;\n\t            this.fromObject = wrapper.fromObject.bind(originalThis);\n\t        // }\n\t        // if (wrapper.toObject) {\n\t            originalThis.toObject = this.toObject;\n\t            this.toObject = wrapper.toObject.bind(originalThis);\n\t        // }\n\t    }\n\n\t    return this;\n\t};\n\n\t/**\n\t * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n\t * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n\t * @param {Writer} [writer] Writer to encode to\n\t * @returns {Writer} writer\n\t */\n\tType.prototype.encode = function encode_setup(message, writer) {\n\t    return this.setup().encode(message, writer); // overrides this method\n\t};\n\n\t/**\n\t * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n\t * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n\t * @param {Writer} [writer] Writer to encode to\n\t * @returns {Writer} writer\n\t */\n\tType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n\t    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n\t};\n\n\t/**\n\t * Decodes a message of this type.\n\t * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n\t * @param {number} [length] Length of the message, if known beforehand\n\t * @returns {Message<{}>} Decoded message\n\t * @throws {Error} If the payload is not a reader or valid buffer\n\t * @throws {util.ProtocolError<{}>} If required fields are missing\n\t */\n\tType.prototype.decode = function decode_setup(reader, length) {\n\t    return this.setup().decode(reader, length); // overrides this method\n\t};\n\n\t/**\n\t * Decodes a message of this type preceeded by its byte length as a varint.\n\t * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n\t * @returns {Message<{}>} Decoded message\n\t * @throws {Error} If the payload is not a reader or valid buffer\n\t * @throws {util.ProtocolError} If required fields are missing\n\t */\n\tType.prototype.decodeDelimited = function decodeDelimited(reader) {\n\t    if (!(reader instanceof Reader))\n\t        reader = Reader.create(reader);\n\t    return this.decode(reader, reader.uint32());\n\t};\n\n\t/**\n\t * Verifies that field values are valid and that required fields are present.\n\t * @param {Object.<string,*>} message Plain object to verify\n\t * @returns {null|string} `null` if valid, otherwise the reason why it is not\n\t */\n\tType.prototype.verify = function verify_setup(message) {\n\t    return this.setup().verify(message); // overrides this method\n\t};\n\n\t/**\n\t * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n\t * @param {Object.<string,*>} object Plain object to convert\n\t * @returns {Message<{}>} Message instance\n\t */\n\tType.prototype.fromObject = function fromObject(object) {\n\t    return this.setup().fromObject(object);\n\t};\n\n\t/**\n\t * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n\t * @interface IConversionOptions\n\t * @property {Function} [longs] Long conversion type.\n\t * Valid values are `String` and `Number` (the global types).\n\t * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n\t * @property {Function} [enums] Enum value conversion type.\n\t * Only valid value is `String` (the global type).\n\t * Defaults to copy the present value, which is the numeric id.\n\t * @property {Function} [bytes] Bytes value conversion type.\n\t * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n\t * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n\t * @property {boolean} [defaults=false] Also sets default values on the resulting object\n\t * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n\t * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n\t * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n\t * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n\t */\n\n\t/**\n\t * Creates a plain object from a message of this type. Also converts values to other types if specified.\n\t * @param {Message<{}>} message Message instance\n\t * @param {IConversionOptions} [options] Conversion options\n\t * @returns {Object.<string,*>} Plain object\n\t */\n\tType.prototype.toObject = function toObject(message, options) {\n\t    return this.setup().toObject(message, options);\n\t};\n\n\t/**\n\t * Decorator function as returned by {@link Type.d} (TypeScript).\n\t * @typedef TypeDecorator\n\t * @type {function}\n\t * @param {Constructor<T>} target Target constructor\n\t * @returns {undefined}\n\t * @template T extends Message<T>\n\t */\n\n\t/**\n\t * Type decorator (TypeScript).\n\t * @param {string} [typeName] Type name, defaults to the constructor's name\n\t * @returns {TypeDecorator<T>} Decorator function\n\t * @template T extends Message<T>\n\t */\n\tType.d = function decorateType(typeName) {\n\t    return function typeDecorator(target) {\n\t        util.decorateType(target, typeName);\n\t    };\n\t};\n\treturn type;\n}\n\nexport { requireType as __require };","start":1670465470654,"end":1670465471442,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/namespace.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/oneof.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/field.js?commonjs-wrapped\";\nimport { __require as require$$4 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/mapfield.js?commonjs-wrapped\";\nimport { __require as require$$5 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/service.js?commonjs-wrapped\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/message.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/reader.js?commonjs-proxy\";\nimport require$$8 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/writer.js?commonjs-proxy\";\nimport { __require as require$$9 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\nimport { __require as require$$10 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/encoder.js?commonjs-wrapped\";\nimport { __require as require$$11 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/decoder.js?commonjs-wrapped\";\nimport { __require as require$$12 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/verifier.js?commonjs-wrapped\";\nimport { __require as require$$13 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/converter.js?commonjs-wrapped\";\nimport require$$14 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/wrappers.js?commonjs-proxy\";\n\nvar type;\nvar hasRequiredType;\n\nfunction requireType () {\n\tif (hasRequiredType) return type;\n\thasRequiredType = 1;\n\t\"use strict\";\n\ttype = Type;\n\n\t// extends Namespace\n\tvar Namespace = require$$0();\n\t((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\n\tvar Enum      = require$$1(),\n\t    OneOf     = require$$2(),\n\t    Field     = require$$3(),\n\t    MapField  = require$$4(),\n\t    Service   = require$$5(),\n\t    Message   = require$$6,\n\t    Reader    = require$$7,\n\t    Writer    = require$$8,\n\t    util      = require$$9(),\n\t    encoder   = require$$10(),\n\t    decoder   = require$$11(),\n\t    verifier  = require$$12(),\n\t    converter = require$$13(),\n\t    wrappers  = require$$14;\n\n\t/**\n\t * Constructs a new reflected message type instance.\n\t * @classdesc Reflected message type.\n\t * @extends NamespaceBase\n\t * @constructor\n\t * @param {string} name Message name\n\t * @param {Object.<string,*>} [options] Declared options\n\t */\n\tfunction Type(name, options) {\n\t    Namespace.call(this, name, options);\n\n\t    /**\n\t     * Message fields.\n\t     * @type {Object.<string,Field>}\n\t     */\n\t    this.fields = {};  // toJSON, marker\n\n\t    /**\n\t     * Oneofs declared within this namespace, if any.\n\t     * @type {Object.<string,OneOf>}\n\t     */\n\t    this.oneofs = undefined; // toJSON\n\n\t    /**\n\t     * Extension ranges, if any.\n\t     * @type {number[][]}\n\t     */\n\t    this.extensions = undefined; // toJSON\n\n\t    /**\n\t     * Reserved ranges, if any.\n\t     * @type {Array.<number[]|string>}\n\t     */\n\t    this.reserved = undefined; // toJSON\n\n\t    /*?\n\t     * Whether this type is a legacy group.\n\t     * @type {boolean|undefined}\n\t     */\n\t    this.group = undefined; // toJSON\n\n\t    /**\n\t     * Cached fields by id.\n\t     * @type {Object.<number,Field>|null}\n\t     * @private\n\t     */\n\t    this._fieldsById = null;\n\n\t    /**\n\t     * Cached fields as an array.\n\t     * @type {Field[]|null}\n\t     * @private\n\t     */\n\t    this._fieldsArray = null;\n\n\t    /**\n\t     * Cached oneofs as an array.\n\t     * @type {OneOf[]|null}\n\t     * @private\n\t     */\n\t    this._oneofsArray = null;\n\n\t    /**\n\t     * Cached constructor.\n\t     * @type {Constructor<{}>}\n\t     * @private\n\t     */\n\t    this._ctor = null;\n\t}\n\n\tObject.defineProperties(Type.prototype, {\n\n\t    /**\n\t     * Message fields by id.\n\t     * @name Type#fieldsById\n\t     * @type {Object.<number,Field>}\n\t     * @readonly\n\t     */\n\t    fieldsById: {\n\t        get: function() {\n\n\t            /* istanbul ignore if */\n\t            if (this._fieldsById)\n\t                return this._fieldsById;\n\n\t            this._fieldsById = {};\n\t            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n\t                var field = this.fields[names[i]],\n\t                    id = field.id;\n\n\t                /* istanbul ignore if */\n\t                if (this._fieldsById[id])\n\t                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n\t                this._fieldsById[id] = field;\n\t            }\n\t            return this._fieldsById;\n\t        }\n\t    },\n\n\t    /**\n\t     * Fields of this message as an array for iteration.\n\t     * @name Type#fieldsArray\n\t     * @type {Field[]}\n\t     * @readonly\n\t     */\n\t    fieldsArray: {\n\t        get: function() {\n\t            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n\t        }\n\t    },\n\n\t    /**\n\t     * Oneofs of this message as an array for iteration.\n\t     * @name Type#oneofsArray\n\t     * @type {OneOf[]}\n\t     * @readonly\n\t     */\n\t    oneofsArray: {\n\t        get: function() {\n\t            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n\t        }\n\t    },\n\n\t    /**\n\t     * The registered constructor, if any registered, otherwise a generic constructor.\n\t     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n\t     * @name Type#ctor\n\t     * @type {Constructor<{}>}\n\t     */\n\t    ctor: {\n\t        get: function() {\n\t            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n\t        },\n\t        set: function(ctor) {\n\n\t            // Ensure proper prototype\n\t            var prototype = ctor.prototype;\n\t            if (!(prototype instanceof Message)) {\n\t                (ctor.prototype = new Message()).constructor = ctor;\n\t                util.merge(ctor.prototype, prototype);\n\t            }\n\n\t            // Classes and messages reference their reflected type\n\t            ctor.$type = ctor.prototype.$type = this;\n\n\t            // Mix in static methods\n\t            util.merge(ctor, Message, true);\n\n\t            this._ctor = ctor;\n\n\t            // Messages have non-enumerable default values on their prototype\n\t            var i = 0;\n\t            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n\t                this._fieldsArray[i].resolve(); // ensures a proper value\n\n\t            // Messages have non-enumerable getters and setters for each virtual oneof field\n\t            var ctorProperties = {};\n\t            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n\t                ctorProperties[this._oneofsArray[i].resolve().name] = {\n\t                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n\t                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n\t                };\n\t            if (i)\n\t                Object.defineProperties(ctor.prototype, ctorProperties);\n\t        }\n\t    }\n\t});\n\n\t/**\n\t * Generates a constructor function for the specified type.\n\t * @param {Type} mtype Message type\n\t * @returns {Codegen} Codegen instance\n\t */\n\tType.generateConstructor = function generateConstructor(mtype) {\n\t    /* eslint-disable no-unexpected-multiline */\n\t    var gen = util.codegen([\"p\"], mtype.name);\n\t    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n\t    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n\t        if ((field = mtype._fieldsArray[i]).map) gen\n\t            (\"this%s={}\", util.safeProp(field.name));\n\t        else if (field.repeated) gen\n\t            (\"this%s=[]\", util.safeProp(field.name));\n\t    return gen\n\t    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n\t        (\"this[ks[i]]=p[ks[i]]\");\n\t    /* eslint-enable no-unexpected-multiline */\n\t};\n\n\tfunction clearCache(type) {\n\t    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n\t    delete type.encode;\n\t    delete type.decode;\n\t    delete type.verify;\n\t    return type;\n\t}\n\n\t/**\n\t * Message type descriptor.\n\t * @interface IType\n\t * @extends INamespace\n\t * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n\t * @property {Object.<string,IField>} fields Field descriptors\n\t * @property {number[][]} [extensions] Extension ranges\n\t * @property {number[][]} [reserved] Reserved ranges\n\t * @property {boolean} [group=false] Whether a legacy group or not\n\t */\n\n\t/**\n\t * Creates a message type from a message type descriptor.\n\t * @param {string} name Message name\n\t * @param {IType} json Message type descriptor\n\t * @returns {Type} Created message type\n\t */\n\tType.fromJSON = function fromJSON(name, json) {\n\t    var type = new Type(name, json.options);\n\t    type.extensions = json.extensions;\n\t    type.reserved = json.reserved;\n\t    var names = Object.keys(json.fields),\n\t        i = 0;\n\t    for (; i < names.length; ++i)\n\t        type.add(\n\t            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n\t            ? MapField.fromJSON\n\t            : Field.fromJSON )(names[i], json.fields[names[i]])\n\t        );\n\t    if (json.oneofs)\n\t        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n\t            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n\t    if (json.nested)\n\t        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n\t            var nested = json.nested[names[i]];\n\t            type.add( // most to least likely\n\t                ( nested.id !== undefined\n\t                ? Field.fromJSON\n\t                : nested.fields !== undefined\n\t                ? Type.fromJSON\n\t                : nested.values !== undefined\n\t                ? Enum.fromJSON\n\t                : nested.methods !== undefined\n\t                ? Service.fromJSON\n\t                : Namespace.fromJSON )(names[i], nested)\n\t            );\n\t        }\n\t    if (json.extensions && json.extensions.length)\n\t        type.extensions = json.extensions;\n\t    if (json.reserved && json.reserved.length)\n\t        type.reserved = json.reserved;\n\t    if (json.group)\n\t        type.group = true;\n\t    if (json.comment)\n\t        type.comment = json.comment;\n\t    return type;\n\t};\n\n\t/**\n\t * Converts this message type to a message type descriptor.\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {IType} Message type descriptor\n\t */\n\tType.prototype.toJSON = function toJSON(toJSONOptions) {\n\t    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n\t    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n\t    return util.toObject([\n\t        \"options\"    , inherited && inherited.options || undefined,\n\t        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n\t        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n\t        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n\t        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n\t        \"group\"      , this.group || undefined,\n\t        \"nested\"     , inherited && inherited.nested || undefined,\n\t        \"comment\"    , keepComments ? this.comment : undefined\n\t    ]);\n\t};\n\n\t/**\n\t * @override\n\t */\n\tType.prototype.resolveAll = function resolveAll() {\n\t    var fields = this.fieldsArray, i = 0;\n\t    while (i < fields.length)\n\t        fields[i++].resolve();\n\t    var oneofs = this.oneofsArray; i = 0;\n\t    while (i < oneofs.length)\n\t        oneofs[i++].resolve();\n\t    return Namespace.prototype.resolveAll.call(this);\n\t};\n\n\t/**\n\t * @override\n\t */\n\tType.prototype.get = function get(name) {\n\t    return this.fields[name]\n\t        || this.oneofs && this.oneofs[name]\n\t        || this.nested && this.nested[name]\n\t        || null;\n\t};\n\n\t/**\n\t * Adds a nested object to this type.\n\t * @param {ReflectionObject} object Nested object to add\n\t * @returns {Type} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n\t */\n\tType.prototype.add = function add(object) {\n\n\t    if (this.get(object.name))\n\t        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n\t    if (object instanceof Field && object.extend === undefined) {\n\t        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n\t        // The root object takes care of adding distinct sister-fields to the respective extended\n\t        // type instead.\n\n\t        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n\t        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n\t            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n\t        if (this.isReservedId(object.id))\n\t            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n\t        if (this.isReservedName(object.name))\n\t            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n\t        if (object.parent)\n\t            object.parent.remove(object);\n\t        this.fields[object.name] = object;\n\t        object.message = this;\n\t        object.onAdd(this);\n\t        return clearCache(this);\n\t    }\n\t    if (object instanceof OneOf) {\n\t        if (!this.oneofs)\n\t            this.oneofs = {};\n\t        this.oneofs[object.name] = object;\n\t        object.onAdd(this);\n\t        return clearCache(this);\n\t    }\n\t    return Namespace.prototype.add.call(this, object);\n\t};\n\n\t/**\n\t * Removes a nested object from this type.\n\t * @param {ReflectionObject} object Nested object to remove\n\t * @returns {Type} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If `object` is not a member of this type\n\t */\n\tType.prototype.remove = function remove(object) {\n\t    if (object instanceof Field && object.extend === undefined) {\n\t        // See Type#add for the reason why extension fields are excluded here.\n\n\t        /* istanbul ignore if */\n\t        if (!this.fields || this.fields[object.name] !== object)\n\t            throw Error(object + \" is not a member of \" + this);\n\n\t        delete this.fields[object.name];\n\t        object.parent = null;\n\t        object.onRemove(this);\n\t        return clearCache(this);\n\t    }\n\t    if (object instanceof OneOf) {\n\n\t        /* istanbul ignore if */\n\t        if (!this.oneofs || this.oneofs[object.name] !== object)\n\t            throw Error(object + \" is not a member of \" + this);\n\n\t        delete this.oneofs[object.name];\n\t        object.parent = null;\n\t        object.onRemove(this);\n\t        return clearCache(this);\n\t    }\n\t    return Namespace.prototype.remove.call(this, object);\n\t};\n\n\t/**\n\t * Tests if the specified id is reserved.\n\t * @param {number} id Id to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tType.prototype.isReservedId = function isReservedId(id) {\n\t    return Namespace.isReservedId(this.reserved, id);\n\t};\n\n\t/**\n\t * Tests if the specified name is reserved.\n\t * @param {string} name Name to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tType.prototype.isReservedName = function isReservedName(name) {\n\t    return Namespace.isReservedName(this.reserved, name);\n\t};\n\n\t/**\n\t * Creates a new message of this type using the specified properties.\n\t * @param {Object.<string,*>} [properties] Properties to set\n\t * @returns {Message<{}>} Message instance\n\t */\n\tType.prototype.create = function create(properties) {\n\t    return new this.ctor(properties);\n\t};\n\n\t/**\n\t * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n\t * @returns {Type} `this`\n\t */\n\tType.prototype.setup = function setup() {\n\t    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n\t    // multiple times (V8, soft-deopt prototype-check).\n\n\t    var fullName = this.fullName,\n\t        types    = [];\n\t    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n\t        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n\t    // Replace setup methods with type-specific generated functions\n\t    this.encode = encoder(this)({\n\t        Writer : Writer,\n\t        types  : types,\n\t        util   : util\n\t    });\n\t    this.decode = decoder(this)({\n\t        Reader : Reader,\n\t        types  : types,\n\t        util   : util\n\t    });\n\t    this.verify = verifier(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\t    this.fromObject = converter.fromObject(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\t    this.toObject = converter.toObject(this)({\n\t        types : types,\n\t        util  : util\n\t    });\n\n\t    // Inject custom wrappers for common types\n\t    var wrapper = wrappers[fullName];\n\t    if (wrapper) {\n\t        var originalThis = Object.create(this);\n\t        // if (wrapper.fromObject) {\n\t            originalThis.fromObject = this.fromObject;\n\t            this.fromObject = wrapper.fromObject.bind(originalThis);\n\t        // }\n\t        // if (wrapper.toObject) {\n\t            originalThis.toObject = this.toObject;\n\t            this.toObject = wrapper.toObject.bind(originalThis);\n\t        // }\n\t    }\n\n\t    return this;\n\t};\n\n\t/**\n\t * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n\t * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n\t * @param {Writer} [writer] Writer to encode to\n\t * @returns {Writer} writer\n\t */\n\tType.prototype.encode = function encode_setup(message, writer) {\n\t    return this.setup().encode(message, writer); // overrides this method\n\t};\n\n\t/**\n\t * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n\t * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n\t * @param {Writer} [writer] Writer to encode to\n\t * @returns {Writer} writer\n\t */\n\tType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n\t    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n\t};\n\n\t/**\n\t * Decodes a message of this type.\n\t * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n\t * @param {number} [length] Length of the message, if known beforehand\n\t * @returns {Message<{}>} Decoded message\n\t * @throws {Error} If the payload is not a reader or valid buffer\n\t * @throws {util.ProtocolError<{}>} If required fields are missing\n\t */\n\tType.prototype.decode = function decode_setup(reader, length) {\n\t    return this.setup().decode(reader, length); // overrides this method\n\t};\n\n\t/**\n\t * Decodes a message of this type preceeded by its byte length as a varint.\n\t * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n\t * @returns {Message<{}>} Decoded message\n\t * @throws {Error} If the payload is not a reader or valid buffer\n\t * @throws {util.ProtocolError} If required fields are missing\n\t */\n\tType.prototype.decodeDelimited = function decodeDelimited(reader) {\n\t    if (!(reader instanceof Reader))\n\t        reader = Reader.create(reader);\n\t    return this.decode(reader, reader.uint32());\n\t};\n\n\t/**\n\t * Verifies that field values are valid and that required fields are present.\n\t * @param {Object.<string,*>} message Plain object to verify\n\t * @returns {null|string} `null` if valid, otherwise the reason why it is not\n\t */\n\tType.prototype.verify = function verify_setup(message) {\n\t    return this.setup().verify(message); // overrides this method\n\t};\n\n\t/**\n\t * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n\t * @param {Object.<string,*>} object Plain object to convert\n\t * @returns {Message<{}>} Message instance\n\t */\n\tType.prototype.fromObject = function fromObject(object) {\n\t    return this.setup().fromObject(object);\n\t};\n\n\t/**\n\t * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n\t * @interface IConversionOptions\n\t * @property {Function} [longs] Long conversion type.\n\t * Valid values are `String` and `Number` (the global types).\n\t * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n\t * @property {Function} [enums] Enum value conversion type.\n\t * Only valid value is `String` (the global type).\n\t * Defaults to copy the present value, which is the numeric id.\n\t * @property {Function} [bytes] Bytes value conversion type.\n\t * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n\t * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n\t * @property {boolean} [defaults=false] Also sets default values on the resulting object\n\t * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n\t * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n\t * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n\t * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n\t */\n\n\t/**\n\t * Creates a plain object from a message of this type. Also converts values to other types if specified.\n\t * @param {Message<{}>} message Message instance\n\t * @param {IConversionOptions} [options] Conversion options\n\t * @returns {Object.<string,*>} Plain object\n\t */\n\tType.prototype.toObject = function toObject(message, options) {\n\t    return this.setup().toObject(message, options);\n\t};\n\n\t/**\n\t * Decorator function as returned by {@link Type.d} (TypeScript).\n\t * @typedef TypeDecorator\n\t * @type {function}\n\t * @param {Constructor<T>} target Target constructor\n\t * @returns {undefined}\n\t * @template T extends Message<T>\n\t */\n\n\t/**\n\t * Type decorator (TypeScript).\n\t * @param {string} [typeName] Type name, defaults to the constructor's name\n\t * @returns {TypeDecorator<T>} Decorator function\n\t * @template T extends Message<T>\n\t */\n\tType.d = function decorateType(typeName) {\n\t    return function typeDecorator(target) {\n\t        util.decorateType(target, typeName);\n\t    };\n\t};\n\treturn type;\n}\n\nexport { requireType as __require };","start":1670465471442,"end":1670465471448,"order":"normal"}]}
