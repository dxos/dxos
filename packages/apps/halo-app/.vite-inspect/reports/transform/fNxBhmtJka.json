{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/method.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(\"./util\");\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","start":1670465470608,"end":1670465470681},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(\"./util\");\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","start":1670465470681,"end":1670465470681,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/object.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar method;\nvar hasRequiredMethod;\n\nfunction requireMethod () {\n\tif (hasRequiredMethod) return method;\n\thasRequiredMethod = 1;\n\t\"use strict\";\n\tmethod = Method;\n\n\t// extends ReflectionObject\n\tvar ReflectionObject = require$$0();\n\t((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\n\tvar util = require$$1();\n\n\t/**\n\t * Constructs a new service method instance.\n\t * @classdesc Reflected service method.\n\t * @extends ReflectionObject\n\t * @constructor\n\t * @param {string} name Method name\n\t * @param {string|undefined} type Method type, usually `\"rpc\"`\n\t * @param {string} requestType Request message type\n\t * @param {string} responseType Response message type\n\t * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n\t * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n\t * @param {Object.<string,*>} [options] Declared options\n\t * @param {string} [comment] The comment for this method\n\t * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n\t */\n\tfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n\t    /* istanbul ignore next */\n\t    if (util.isObject(requestStream)) {\n\t        options = requestStream;\n\t        requestStream = responseStream = undefined;\n\t    } else if (util.isObject(responseStream)) {\n\t        options = responseStream;\n\t        responseStream = undefined;\n\t    }\n\n\t    /* istanbul ignore if */\n\t    if (!(type === undefined || util.isString(type)))\n\t        throw TypeError(\"type must be a string\");\n\n\t    /* istanbul ignore if */\n\t    if (!util.isString(requestType))\n\t        throw TypeError(\"requestType must be a string\");\n\n\t    /* istanbul ignore if */\n\t    if (!util.isString(responseType))\n\t        throw TypeError(\"responseType must be a string\");\n\n\t    ReflectionObject.call(this, name, options);\n\n\t    /**\n\t     * Method type.\n\t     * @type {string}\n\t     */\n\t    this.type = type || \"rpc\"; // toJSON\n\n\t    /**\n\t     * Request type.\n\t     * @type {string}\n\t     */\n\t    this.requestType = requestType; // toJSON, marker\n\n\t    /**\n\t     * Whether requests are streamed or not.\n\t     * @type {boolean|undefined}\n\t     */\n\t    this.requestStream = requestStream ? true : undefined; // toJSON\n\n\t    /**\n\t     * Response type.\n\t     * @type {string}\n\t     */\n\t    this.responseType = responseType; // toJSON\n\n\t    /**\n\t     * Whether responses are streamed or not.\n\t     * @type {boolean|undefined}\n\t     */\n\t    this.responseStream = responseStream ? true : undefined; // toJSON\n\n\t    /**\n\t     * Resolved request type.\n\t     * @type {Type|null}\n\t     */\n\t    this.resolvedRequestType = null;\n\n\t    /**\n\t     * Resolved response type.\n\t     * @type {Type|null}\n\t     */\n\t    this.resolvedResponseType = null;\n\n\t    /**\n\t     * Comment for this method\n\t     * @type {string|null}\n\t     */\n\t    this.comment = comment;\n\n\t    /**\n\t     * Options properly parsed into an object\n\t     */\n\t    this.parsedOptions = parsedOptions;\n\t}\n\n\t/**\n\t * Method descriptor.\n\t * @interface IMethod\n\t * @property {string} [type=\"rpc\"] Method type\n\t * @property {string} requestType Request type\n\t * @property {string} responseType Response type\n\t * @property {boolean} [requestStream=false] Whether requests are streamed\n\t * @property {boolean} [responseStream=false] Whether responses are streamed\n\t * @property {Object.<string,*>} [options] Method options\n\t * @property {string} comment Method comments\n\t * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n\t */\n\n\t/**\n\t * Constructs a method from a method descriptor.\n\t * @param {string} name Method name\n\t * @param {IMethod} json Method descriptor\n\t * @returns {Method} Created method\n\t * @throws {TypeError} If arguments are invalid\n\t */\n\tMethod.fromJSON = function fromJSON(name, json) {\n\t    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n\t};\n\n\t/**\n\t * Converts this method to a method descriptor.\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {IMethod} Method descriptor\n\t */\n\tMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n\t    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n\t    return util.toObject([\n\t        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n\t        \"requestType\"    , this.requestType,\n\t        \"requestStream\"  , this.requestStream,\n\t        \"responseType\"   , this.responseType,\n\t        \"responseStream\" , this.responseStream,\n\t        \"options\"        , this.options,\n\t        \"comment\"        , keepComments ? this.comment : undefined,\n\t        \"parsedOptions\"  , this.parsedOptions,\n\t    ]);\n\t};\n\n\t/**\n\t * @override\n\t */\n\tMethod.prototype.resolve = function resolve() {\n\n\t    /* istanbul ignore if */\n\t    if (this.resolved)\n\t        return this;\n\n\t    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n\t    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n\t    return ReflectionObject.prototype.resolve.call(this);\n\t};\n\treturn method;\n}\n\nexport { requireMethod as __require };","start":1670465470682,"end":1670465471380,"order":"normal"}]}
