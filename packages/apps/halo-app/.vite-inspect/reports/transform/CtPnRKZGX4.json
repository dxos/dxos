{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/encoder.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(\"./enum\"),\n    types    = require(\"./types\"),\n    util     = require(\"./util\");\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","start":1670465470520,"end":1670465470620},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(\"./enum\"),\n    types    = require(\"./types\"),\n    util     = require(\"./util\");\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","start":1670465470620,"end":1670465470620,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/types.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar encoder_1;\nvar hasRequiredEncoder;\n\nfunction requireEncoder () {\n\tif (hasRequiredEncoder) return encoder_1;\n\thasRequiredEncoder = 1;\n\t\"use strict\";\n\tencoder_1 = encoder;\n\n\tvar Enum     = require$$0(),\n\t    types    = require$$1(),\n\t    util     = require$$2();\n\n\t/**\n\t * Generates a partial message type encoder.\n\t * @param {Codegen} gen Codegen instance\n\t * @param {Field} field Reflected field\n\t * @param {number} fieldIndex Field index\n\t * @param {string} ref Variable reference\n\t * @returns {Codegen} Codegen instance\n\t * @ignore\n\t */\n\tfunction genTypePartial(gen, field, fieldIndex, ref) {\n\t    return field.resolvedType.group\n\t        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n\t        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n\t}\n\n\t/**\n\t * Generates an encoder specific to the specified message type.\n\t * @param {Type} mtype Message type\n\t * @returns {Codegen} Codegen instance\n\t */\n\tfunction encoder(mtype) {\n\t    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n\t    (\"if(!w)\")\n\t        (\"w=Writer.create()\");\n\n\t    var i, ref;\n\n\t    // \"when a message is serialized its known fields should be written sequentially by field number\"\n\t    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n\t    for (var i = 0; i < fields.length; ++i) {\n\t        var field    = fields[i].resolve(),\n\t            index    = mtype._fieldsArray.indexOf(field),\n\t            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n\t            wireType = types.basic[type];\n\t            ref      = \"m\" + util.safeProp(field.name);\n\n\t        // Map fields\n\t        if (field.map) {\n\t            gen\n\t    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n\t        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n\t            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n\t            if (wireType === undefined) gen\n\t            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n\t            else gen\n\t            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n\t            gen\n\t        (\"}\")\n\t    (\"}\");\n\n\t            // Repeated fields\n\t        } else if (field.repeated) { gen\n\t    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n\t            // Packed repeated\n\t            if (field.packed && types.packed[type] !== undefined) { gen\n\n\t        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n\t        (\"for(var i=0;i<%s.length;++i)\", ref)\n\t            (\"w.%s(%s[i])\", type, ref)\n\t        (\"w.ldelim()\");\n\n\t            // Non-packed\n\t            } else { gen\n\n\t        (\"for(var i=0;i<%s.length;++i)\", ref);\n\t                if (wireType === undefined)\n\t            genTypePartial(gen, field, index, ref + \"[i]\");\n\t                else gen\n\t            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n\t            } gen\n\t    (\"}\");\n\n\t        // Non-repeated\n\t        } else {\n\t            if (field.optional) gen\n\t    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n\t            if (wireType === undefined)\n\t        genTypePartial(gen, field, index, ref);\n\t            else gen\n\t        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n\t        }\n\t    }\n\n\t    return gen\n\t    (\"return w\");\n\t    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n\t}\n\treturn encoder_1;\n}\n\nexport { requireEncoder as __require };","start":1670465470620,"end":1670465471407,"order":"normal"}]}
