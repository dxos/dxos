{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/verifier.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(\"./enum\"),\n    util      = require(\"./util\");\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","start":1670465470529,"end":1670465470625},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(\"./enum\"),\n    util      = require(\"./util\");\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","start":1670465470625,"end":1670465470625,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/enum.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar verifier_1;\nvar hasRequiredVerifier;\n\nfunction requireVerifier () {\n\tif (hasRequiredVerifier) return verifier_1;\n\thasRequiredVerifier = 1;\n\t\"use strict\";\n\tverifier_1 = verifier;\n\n\tvar Enum      = require$$0(),\n\t    util      = require$$1();\n\n\tfunction invalid(field, expected) {\n\t    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n\t}\n\n\t/**\n\t * Generates a partial value verifier.\n\t * @param {Codegen} gen Codegen instance\n\t * @param {Field} field Reflected field\n\t * @param {number} fieldIndex Field index\n\t * @param {string} ref Variable reference\n\t * @returns {Codegen} Codegen instance\n\t * @ignore\n\t */\n\tfunction genVerifyValue(gen, field, fieldIndex, ref) {\n\t    /* eslint-disable no-unexpected-multiline */\n\t    if (field.resolvedType) {\n\t        if (field.resolvedType instanceof Enum) { gen\n\t            (\"switch(%s){\", ref)\n\t                (\"default:\")\n\t                    (\"return%j\", invalid(field, \"enum value\"));\n\t            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n\t                (\"case %i:\", field.resolvedType.values[keys[j]]);\n\t            gen\n\t                    (\"break\")\n\t            (\"}\");\n\t        } else {\n\t            gen\n\t            (\"{\")\n\t                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n\t                (\"if(e)\")\n\t                    (\"return%j+e\", field.name + \".\")\n\t            (\"}\");\n\t        }\n\t    } else {\n\t        switch (field.type) {\n\t            case \"int32\":\n\t            case \"uint32\":\n\t            case \"sint32\":\n\t            case \"fixed32\":\n\t            case \"sfixed32\": gen\n\t                (\"if(!util.isInteger(%s))\", ref)\n\t                    (\"return%j\", invalid(field, \"integer\"));\n\t                break;\n\t            case \"int64\":\n\t            case \"uint64\":\n\t            case \"sint64\":\n\t            case \"fixed64\":\n\t            case \"sfixed64\": gen\n\t                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n\t                    (\"return%j\", invalid(field, \"integer|Long\"));\n\t                break;\n\t            case \"float\":\n\t            case \"double\": gen\n\t                (\"if(typeof %s!==\\\"number\\\")\", ref)\n\t                    (\"return%j\", invalid(field, \"number\"));\n\t                break;\n\t            case \"bool\": gen\n\t                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n\t                    (\"return%j\", invalid(field, \"boolean\"));\n\t                break;\n\t            case \"string\": gen\n\t                (\"if(!util.isString(%s))\", ref)\n\t                    (\"return%j\", invalid(field, \"string\"));\n\t                break;\n\t            case \"bytes\": gen\n\t                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n\t                    (\"return%j\", invalid(field, \"buffer\"));\n\t                break;\n\t        }\n\t    }\n\t    return gen;\n\t    /* eslint-enable no-unexpected-multiline */\n\t}\n\n\t/**\n\t * Generates a partial key verifier.\n\t * @param {Codegen} gen Codegen instance\n\t * @param {Field} field Reflected field\n\t * @param {string} ref Variable reference\n\t * @returns {Codegen} Codegen instance\n\t * @ignore\n\t */\n\tfunction genVerifyKey(gen, field, ref) {\n\t    /* eslint-disable no-unexpected-multiline */\n\t    switch (field.keyType) {\n\t        case \"int32\":\n\t        case \"uint32\":\n\t        case \"sint32\":\n\t        case \"fixed32\":\n\t        case \"sfixed32\": gen\n\t            (\"if(!util.key32Re.test(%s))\", ref)\n\t                (\"return%j\", invalid(field, \"integer key\"));\n\t            break;\n\t        case \"int64\":\n\t        case \"uint64\":\n\t        case \"sint64\":\n\t        case \"fixed64\":\n\t        case \"sfixed64\": gen\n\t            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n\t                (\"return%j\", invalid(field, \"integer|Long key\"));\n\t            break;\n\t        case \"bool\": gen\n\t            (\"if(!util.key2Re.test(%s))\", ref)\n\t                (\"return%j\", invalid(field, \"boolean key\"));\n\t            break;\n\t    }\n\t    return gen;\n\t    /* eslint-enable no-unexpected-multiline */\n\t}\n\n\t/**\n\t * Generates a verifier specific to the specified message type.\n\t * @param {Type} mtype Message type\n\t * @returns {Codegen} Codegen instance\n\t */\n\tfunction verifier(mtype) {\n\t    /* eslint-disable no-unexpected-multiline */\n\n\t    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n\t    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n\t        (\"return%j\", \"object expected\");\n\t    var oneofs = mtype.oneofsArray,\n\t        seenFirstField = {};\n\t    if (oneofs.length) gen\n\t    (\"var p={}\");\n\n\t    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n\t        var field = mtype._fieldsArray[i].resolve(),\n\t            ref   = \"m\" + util.safeProp(field.name);\n\n\t        if (field.optional) gen\n\t        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n\t        // map fields\n\t        if (field.map) { gen\n\t            (\"if(!util.isObject(%s))\", ref)\n\t                (\"return%j\", invalid(field, \"object\"))\n\t            (\"var k=Object.keys(%s)\", ref)\n\t            (\"for(var i=0;i<k.length;++i){\");\n\t                genVerifyKey(gen, field, \"k[i]\");\n\t                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n\t            (\"}\");\n\n\t        // repeated fields\n\t        } else if (field.repeated) { gen\n\t            (\"if(!Array.isArray(%s))\", ref)\n\t                (\"return%j\", invalid(field, \"array\"))\n\t            (\"for(var i=0;i<%s.length;++i){\", ref);\n\t                genVerifyValue(gen, field, i, ref + \"[i]\")\n\t            (\"}\");\n\n\t        // required or present fields\n\t        } else {\n\t            if (field.partOf) {\n\t                var oneofProp = util.safeProp(field.partOf.name);\n\t                if (seenFirstField[field.partOf.name] === 1) gen\n\t            (\"if(p%s===1)\", oneofProp)\n\t                (\"return%j\", field.partOf.name + \": multiple values\");\n\t                seenFirstField[field.partOf.name] = 1;\n\t                gen\n\t            (\"p%s=1\", oneofProp);\n\t            }\n\t            genVerifyValue(gen, field, i, ref);\n\t        }\n\t        if (field.optional) gen\n\t        (\"}\");\n\t    }\n\t    return gen\n\t    (\"return null\");\n\t    /* eslint-enable no-unexpected-multiline */\n\t}\n\treturn verifier_1;\n}\n\nexport { requireVerifier as __require };","start":1670465470626,"end":1670465471407,"order":"normal"}]}
