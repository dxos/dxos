{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/lib/parse.js","transforms":[{"name":"vite:load-fallback","result":"'use strict';\n\nvar at; // The index of the current character\nvar ch; // The current character\nvar escapee = {\n\t'\"': '\"',\n\t'\\\\': '\\\\',\n\t'/': '/',\n\tb: '\\b',\n\tf: '\\f',\n\tn: '\\n',\n\tr: '\\r',\n\tt: '\\t'\n};\nvar text;\n\n// Call error when something is wrong.\nfunction error(m) {\n\tthrow {\n\t\tname: 'SyntaxError',\n\t\tmessage: m,\n\t\tat: at,\n\t\ttext: text\n\t};\n}\n\nfunction next(c) {\n\t// If a c parameter is provided, verify that it matches the current character.\n\tif (c && c !== ch) {\n\t\terror(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n\t}\n\n\t// Get the next character. When there are no more characters, return the empty string.\n\n\tch = text.charAt(at);\n\tat += 1;\n\treturn ch;\n}\n\nfunction number() {\n\t// Parse a number value.\n\tvar num;\n\tvar str = '';\n\n\tif (ch === '-') {\n\t\tstr = '-';\n\t\tnext('-');\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tstr += ch;\n\t\tnext();\n\t}\n\tif (ch === '.') {\n\t\tstr += '.';\n\t\twhile (next() && ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t}\n\t}\n\tif (ch === 'e' || ch === 'E') {\n\t\tstr += ch;\n\t\tnext();\n\t\tif (ch === '-' || ch === '+') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t}\n\tnum = Number(str);\n\tif (!isFinite(num)) {\n\t\terror('Bad number');\n\t}\n\treturn num;\n}\n\nfunction string() {\n\t// Parse a string value.\n\tvar hex;\n\tvar i;\n\tvar str = '';\n\tvar uffff;\n\n\t// When parsing for string values, we must look for \" and \\ characters.\n\tif (ch === '\"') {\n\t\twhile (next()) {\n\t\t\tif (ch === '\"') {\n\t\t\t\tnext();\n\t\t\t\treturn str;\n\t\t\t} else if (ch === '\\\\') {\n\t\t\t\tnext();\n\t\t\t\tif (ch === 'u') {\n\t\t\t\t\tuffff = 0;\n\t\t\t\t\tfor (i = 0; i < 4; i += 1) {\n\t\t\t\t\t\thex = parseInt(next(), 16);\n\t\t\t\t\t\tif (!isFinite(hex)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuffff = (uffff * 16) + hex;\n\t\t\t\t\t}\n\t\t\t\t\tstr += String.fromCharCode(uffff);\n\t\t\t\t} else if (typeof escapee[ch] === 'string') {\n\t\t\t\t\tstr += escapee[ch];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\t}\n\terror('Bad string');\n}\n\n// Skip whitespace.\nfunction white() {\n\twhile (ch && ch <= ' ') {\n\t\tnext();\n\t}\n}\n\n// true, false, or null.\nfunction word() {\n\tswitch (ch) {\n\t\tcase 't':\n\t\t\tnext('t');\n\t\t\tnext('r');\n\t\t\tnext('u');\n\t\t\tnext('e');\n\t\t\treturn true;\n\t\tcase 'f':\n\t\t\tnext('f');\n\t\t\tnext('a');\n\t\t\tnext('l');\n\t\t\tnext('s');\n\t\t\tnext('e');\n\t\t\treturn false;\n\t\tcase 'n':\n\t\t\tnext('n');\n\t\t\tnext('u');\n\t\t\tnext('l');\n\t\t\tnext('l');\n\t\t\treturn null;\n\t\tdefault:\n\t\t\terror(\"Unexpected '\" + ch + \"'\");\n\t}\n}\n\n// Parse an array value.\nfunction array() {\n\tvar arr = [];\n\n\tif (ch === '[') {\n\t\tnext('[');\n\t\twhite();\n\t\tif (ch === ']') {\n\t\t\tnext(']');\n\t\t\treturn arr; // empty array\n\t\t}\n\t\twhile (ch) {\n\t\t\tarr.push(value()); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === ']') {\n\t\t\t\tnext(']');\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad array');\n}\n\n// Parse an object value.\nfunction object() {\n\tvar key;\n\tvar obj = {};\n\n\tif (ch === '{') {\n\t\tnext('{');\n\t\twhite();\n\t\tif (ch === '}') {\n\t\t\tnext('}');\n\t\t\treturn obj; // empty object\n\t\t}\n\t\twhile (ch) {\n\t\t\tkey = string();\n\t\t\twhite();\n\t\t\tnext(':');\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\terror('Duplicate key \"' + key + '\"');\n\t\t\t}\n\t\t\tobj[key] = value(); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === '}') {\n\t\t\t\tnext('}');\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad object');\n}\n\n// Parse a JSON value. It could be an object, an array, a string, a number, or a word.\nfunction value() {\n\twhite();\n\tswitch (ch) {\n\t\tcase '{':\n\t\t\treturn object();\n\t\tcase '[':\n\t\t\treturn array();\n\t\tcase '\"':\n\t\t\treturn string();\n\t\tcase '-':\n\t\t\treturn number();\n\t\tdefault:\n\t\t\treturn ch >= '0' && ch <= '9' ? number() : word();\n\t}\n}\n\n// Return the json_parse function. It will have access to all of the above functions and variables.\nmodule.exports = function (source, reviver) {\n\tvar result;\n\n\ttext = source;\n\tat = 0;\n\tch = ' ';\n\tresult = value();\n\twhite();\n\tif (ch) {\n\t\terror('Syntax error');\n\t}\n\n\t// If there is a reviver function, we recursively walk the new structure,\n\t// passing each name/value pair to the reviver function for possible\n\t// transformation, starting with a temporary root object that holds the result\n\t// in an empty key. If there is not a reviver function, we simply return the\n\t// result.\n\n\treturn typeof reviver === 'function' ? (function walk(holder, key) {\n\t\tvar k;\n\t\tvar v;\n\t\tvar val = holder[key];\n\t\tif (val && typeof val === 'object') {\n\t\t\tfor (k in value) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(val, k)) {\n\t\t\t\t\tv = walk(val, k);\n\t\t\t\t\tif (typeof v === 'undefined') {\n\t\t\t\t\t\tdelete val[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval[k] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reviver.call(holder, key, val);\n\t}({ '': result }, '')) : result;\n};\n","start":1670465468819,"end":1670465469027},{"name":"vite:react-babel","result":"'use strict';\n\nvar at; // The index of the current character\nvar ch; // The current character\nvar escapee = {\n\t'\"': '\"',\n\t'\\\\': '\\\\',\n\t'/': '/',\n\tb: '\\b',\n\tf: '\\f',\n\tn: '\\n',\n\tr: '\\r',\n\tt: '\\t'\n};\nvar text;\n\n// Call error when something is wrong.\nfunction error(m) {\n\tthrow {\n\t\tname: 'SyntaxError',\n\t\tmessage: m,\n\t\tat: at,\n\t\ttext: text\n\t};\n}\n\nfunction next(c) {\n\t// If a c parameter is provided, verify that it matches the current character.\n\tif (c && c !== ch) {\n\t\terror(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n\t}\n\n\t// Get the next character. When there are no more characters, return the empty string.\n\n\tch = text.charAt(at);\n\tat += 1;\n\treturn ch;\n}\n\nfunction number() {\n\t// Parse a number value.\n\tvar num;\n\tvar str = '';\n\n\tif (ch === '-') {\n\t\tstr = '-';\n\t\tnext('-');\n\t}\n\twhile (ch >= '0' && ch <= '9') {\n\t\tstr += ch;\n\t\tnext();\n\t}\n\tif (ch === '.') {\n\t\tstr += '.';\n\t\twhile (next() && ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t}\n\t}\n\tif (ch === 'e' || ch === 'E') {\n\t\tstr += ch;\n\t\tnext();\n\t\tif (ch === '-' || ch === '+') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t}\n\tnum = Number(str);\n\tif (!isFinite(num)) {\n\t\terror('Bad number');\n\t}\n\treturn num;\n}\n\nfunction string() {\n\t// Parse a string value.\n\tvar hex;\n\tvar i;\n\tvar str = '';\n\tvar uffff;\n\n\t// When parsing for string values, we must look for \" and \\ characters.\n\tif (ch === '\"') {\n\t\twhile (next()) {\n\t\t\tif (ch === '\"') {\n\t\t\t\tnext();\n\t\t\t\treturn str;\n\t\t\t} else if (ch === '\\\\') {\n\t\t\t\tnext();\n\t\t\t\tif (ch === 'u') {\n\t\t\t\t\tuffff = 0;\n\t\t\t\t\tfor (i = 0; i < 4; i += 1) {\n\t\t\t\t\t\thex = parseInt(next(), 16);\n\t\t\t\t\t\tif (!isFinite(hex)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuffff = (uffff * 16) + hex;\n\t\t\t\t\t}\n\t\t\t\t\tstr += String.fromCharCode(uffff);\n\t\t\t\t} else if (typeof escapee[ch] === 'string') {\n\t\t\t\t\tstr += escapee[ch];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\t}\n\terror('Bad string');\n}\n\n// Skip whitespace.\nfunction white() {\n\twhile (ch && ch <= ' ') {\n\t\tnext();\n\t}\n}\n\n// true, false, or null.\nfunction word() {\n\tswitch (ch) {\n\t\tcase 't':\n\t\t\tnext('t');\n\t\t\tnext('r');\n\t\t\tnext('u');\n\t\t\tnext('e');\n\t\t\treturn true;\n\t\tcase 'f':\n\t\t\tnext('f');\n\t\t\tnext('a');\n\t\t\tnext('l');\n\t\t\tnext('s');\n\t\t\tnext('e');\n\t\t\treturn false;\n\t\tcase 'n':\n\t\t\tnext('n');\n\t\t\tnext('u');\n\t\t\tnext('l');\n\t\t\tnext('l');\n\t\t\treturn null;\n\t\tdefault:\n\t\t\terror(\"Unexpected '\" + ch + \"'\");\n\t}\n}\n\n// Parse an array value.\nfunction array() {\n\tvar arr = [];\n\n\tif (ch === '[') {\n\t\tnext('[');\n\t\twhite();\n\t\tif (ch === ']') {\n\t\t\tnext(']');\n\t\t\treturn arr; // empty array\n\t\t}\n\t\twhile (ch) {\n\t\t\tarr.push(value()); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === ']') {\n\t\t\t\tnext(']');\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad array');\n}\n\n// Parse an object value.\nfunction object() {\n\tvar key;\n\tvar obj = {};\n\n\tif (ch === '{') {\n\t\tnext('{');\n\t\twhite();\n\t\tif (ch === '}') {\n\t\t\tnext('}');\n\t\t\treturn obj; // empty object\n\t\t}\n\t\twhile (ch) {\n\t\t\tkey = string();\n\t\t\twhite();\n\t\t\tnext(':');\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\terror('Duplicate key \"' + key + '\"');\n\t\t\t}\n\t\t\tobj[key] = value(); // eslint-disable-line no-use-before-define\n\t\t\twhite();\n\t\t\tif (ch === '}') {\n\t\t\t\tnext('}');\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tnext(',');\n\t\t\twhite();\n\t\t}\n\t}\n\terror('Bad object');\n}\n\n// Parse a JSON value. It could be an object, an array, a string, a number, or a word.\nfunction value() {\n\twhite();\n\tswitch (ch) {\n\t\tcase '{':\n\t\t\treturn object();\n\t\tcase '[':\n\t\t\treturn array();\n\t\tcase '\"':\n\t\t\treturn string();\n\t\tcase '-':\n\t\t\treturn number();\n\t\tdefault:\n\t\t\treturn ch >= '0' && ch <= '9' ? number() : word();\n\t}\n}\n\n// Return the json_parse function. It will have access to all of the above functions and variables.\nmodule.exports = function (source, reviver) {\n\tvar result;\n\n\ttext = source;\n\tat = 0;\n\tch = ' ';\n\tresult = value();\n\twhite();\n\tif (ch) {\n\t\terror('Syntax error');\n\t}\n\n\t// If there is a reviver function, we recursively walk the new structure,\n\t// passing each name/value pair to the reviver function for possible\n\t// transformation, starting with a temporary root object that holds the result\n\t// in an empty key. If there is not a reviver function, we simply return the\n\t// result.\n\n\treturn typeof reviver === 'function' ? (function walk(holder, key) {\n\t\tvar k;\n\t\tvar v;\n\t\tvar val = holder[key];\n\t\tif (val && typeof val === 'object') {\n\t\t\tfor (k in value) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(val, k)) {\n\t\t\t\t\tv = walk(val, k);\n\t\t\t\t\tif (typeof v === 'undefined') {\n\t\t\t\t\t\tdelete val[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval[k] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reviver.call(holder, key, val);\n\t}({ '': result }, '')) : result;\n};\n","start":1670465469027,"end":1670465469027,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nvar parse;\nvar hasRequiredParse;\n\nfunction requireParse () {\n\tif (hasRequiredParse) return parse;\n\thasRequiredParse = 1;\n\t'use strict';\n\n\tvar at; // The index of the current character\n\tvar ch; // The current character\n\tvar escapee = {\n\t\t'\"': '\"',\n\t\t'\\\\': '\\\\',\n\t\t'/': '/',\n\t\tb: '\\b',\n\t\tf: '\\f',\n\t\tn: '\\n',\n\t\tr: '\\r',\n\t\tt: '\\t'\n\t};\n\tvar text;\n\n\t// Call error when something is wrong.\n\tfunction error(m) {\n\t\tthrow {\n\t\t\tname: 'SyntaxError',\n\t\t\tmessage: m,\n\t\t\tat: at,\n\t\t\ttext: text\n\t\t};\n\t}\n\n\tfunction next(c) {\n\t\t// If a c parameter is provided, verify that it matches the current character.\n\t\tif (c && c !== ch) {\n\t\t\terror(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n\t\t}\n\n\t\t// Get the next character. When there are no more characters, return the empty string.\n\n\t\tch = text.charAt(at);\n\t\tat += 1;\n\t\treturn ch;\n\t}\n\n\tfunction number() {\n\t\t// Parse a number value.\n\t\tvar num;\n\t\tvar str = '';\n\n\t\tif (ch === '-') {\n\t\t\tstr = '-';\n\t\t\tnext('-');\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t}\n\t\tif (ch === '.') {\n\t\t\tstr += '.';\n\t\t\twhile (next() && ch >= '0' && ch <= '9') {\n\t\t\t\tstr += ch;\n\t\t\t}\n\t\t}\n\t\tif (ch === 'e' || ch === 'E') {\n\t\t\tstr += ch;\n\t\t\tnext();\n\t\t\tif (ch === '-' || ch === '+') {\n\t\t\t\tstr += ch;\n\t\t\t\tnext();\n\t\t\t}\n\t\t\twhile (ch >= '0' && ch <= '9') {\n\t\t\t\tstr += ch;\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\t\tnum = Number(str);\n\t\tif (!isFinite(num)) {\n\t\t\terror('Bad number');\n\t\t}\n\t\treturn num;\n\t}\n\n\tfunction string() {\n\t\t// Parse a string value.\n\t\tvar hex;\n\t\tvar i;\n\t\tvar str = '';\n\t\tvar uffff;\n\n\t\t// When parsing for string values, we must look for \" and \\ characters.\n\t\tif (ch === '\"') {\n\t\t\twhile (next()) {\n\t\t\t\tif (ch === '\"') {\n\t\t\t\t\tnext();\n\t\t\t\t\treturn str;\n\t\t\t\t} else if (ch === '\\\\') {\n\t\t\t\t\tnext();\n\t\t\t\t\tif (ch === 'u') {\n\t\t\t\t\t\tuffff = 0;\n\t\t\t\t\t\tfor (i = 0; i < 4; i += 1) {\n\t\t\t\t\t\t\thex = parseInt(next(), 16);\n\t\t\t\t\t\t\tif (!isFinite(hex)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuffff = (uffff * 16) + hex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += String.fromCharCode(uffff);\n\t\t\t\t\t} else if (typeof escapee[ch] === 'string') {\n\t\t\t\t\t\tstr += escapee[ch];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstr += ch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terror('Bad string');\n\t}\n\n\t// Skip whitespace.\n\tfunction white() {\n\t\twhile (ch && ch <= ' ') {\n\t\t\tnext();\n\t\t}\n\t}\n\n\t// true, false, or null.\n\tfunction word() {\n\t\tswitch (ch) {\n\t\t\tcase 't':\n\t\t\t\tnext('t');\n\t\t\t\tnext('r');\n\t\t\t\tnext('u');\n\t\t\t\tnext('e');\n\t\t\t\treturn true;\n\t\t\tcase 'f':\n\t\t\t\tnext('f');\n\t\t\t\tnext('a');\n\t\t\t\tnext('l');\n\t\t\t\tnext('s');\n\t\t\t\tnext('e');\n\t\t\t\treturn false;\n\t\t\tcase 'n':\n\t\t\t\tnext('n');\n\t\t\t\tnext('u');\n\t\t\t\tnext('l');\n\t\t\t\tnext('l');\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\terror(\"Unexpected '\" + ch + \"'\");\n\t\t}\n\t}\n\n\t// Parse an array value.\n\tfunction array() {\n\t\tvar arr = [];\n\n\t\tif (ch === '[') {\n\t\t\tnext('[');\n\t\t\twhite();\n\t\t\tif (ch === ']') {\n\t\t\t\tnext(']');\n\t\t\t\treturn arr; // empty array\n\t\t\t}\n\t\t\twhile (ch) {\n\t\t\t\tarr.push(value()); // eslint-disable-line no-use-before-define\n\t\t\t\twhite();\n\t\t\t\tif (ch === ']') {\n\t\t\t\t\tnext(']');\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t\tnext(',');\n\t\t\t\twhite();\n\t\t\t}\n\t\t}\n\t\terror('Bad array');\n\t}\n\n\t// Parse an object value.\n\tfunction object() {\n\t\tvar key;\n\t\tvar obj = {};\n\n\t\tif (ch === '{') {\n\t\t\tnext('{');\n\t\t\twhite();\n\t\t\tif (ch === '}') {\n\t\t\t\tnext('}');\n\t\t\t\treturn obj; // empty object\n\t\t\t}\n\t\t\twhile (ch) {\n\t\t\t\tkey = string();\n\t\t\t\twhite();\n\t\t\t\tnext(':');\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\terror('Duplicate key \"' + key + '\"');\n\t\t\t\t}\n\t\t\t\tobj[key] = value(); // eslint-disable-line no-use-before-define\n\t\t\t\twhite();\n\t\t\t\tif (ch === '}') {\n\t\t\t\t\tnext('}');\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t\tnext(',');\n\t\t\t\twhite();\n\t\t\t}\n\t\t}\n\t\terror('Bad object');\n\t}\n\n\t// Parse a JSON value. It could be an object, an array, a string, a number, or a word.\n\tfunction value() {\n\t\twhite();\n\t\tswitch (ch) {\n\t\t\tcase '{':\n\t\t\t\treturn object();\n\t\t\tcase '[':\n\t\t\t\treturn array();\n\t\t\tcase '\"':\n\t\t\t\treturn string();\n\t\t\tcase '-':\n\t\t\t\treturn number();\n\t\t\tdefault:\n\t\t\t\treturn ch >= '0' && ch <= '9' ? number() : word();\n\t\t}\n\t}\n\n\t// Return the json_parse function. It will have access to all of the above functions and variables.\n\tparse = function (source, reviver) {\n\t\tvar result;\n\n\t\ttext = source;\n\t\tat = 0;\n\t\tch = ' ';\n\t\tresult = value();\n\t\twhite();\n\t\tif (ch) {\n\t\t\terror('Syntax error');\n\t\t}\n\n\t\t// If there is a reviver function, we recursively walk the new structure,\n\t\t// passing each name/value pair to the reviver function for possible\n\t\t// transformation, starting with a temporary root object that holds the result\n\t\t// in an empty key. If there is not a reviver function, we simply return the\n\t\t// result.\n\n\t\treturn typeof reviver === 'function' ? (function walk(holder, key) {\n\t\t\tvar k;\n\t\t\tvar v;\n\t\t\tvar val = holder[key];\n\t\t\tif (val && typeof val === 'object') {\n\t\t\t\tfor (k in value) {\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(val, k)) {\n\t\t\t\t\t\tv = walk(val, k);\n\t\t\t\t\t\tif (typeof v === 'undefined') {\n\t\t\t\t\t\t\tdelete val[k];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tval[k] = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reviver.call(holder, key, val);\n\t\t}({ '': result }, '')) : result;\n\t};\n\treturn parse;\n}\n\nexport { requireParse as __require };","start":1670465469027,"end":1670465469029,"order":"normal"}]}
