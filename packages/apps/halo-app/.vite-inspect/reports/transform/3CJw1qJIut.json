{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher-state.js","transforms":[{"name":"vite:load-fallback","result":"/* eslint-disable camelcase */\nconst { sodium_memzero } = require('sodium-universal/memory')\nconst { sodium_increment, sodium_memcmp, sodium_is_zero } = require('sodium-universal/helpers')\n\nvar assert = require('nanoassert')\nvar cipher = require('./cipher')\n\nvar STATELEN = cipher.KEYLEN + cipher.NONCELEN\nvar NONCELEN = cipher.NONCELEN\nvar MACLEN = cipher.MACLEN\n\nmodule.exports = {\n  STATELEN,\n  NONCELEN,\n  MACLEN,\n  initializeKey,\n  hasKey,\n  setNonce,\n  encryptWithAd,\n  decryptWithAd,\n  rekey\n}\n\nvar KEY_BEGIN = 0\nvar KEY_END = cipher.KEYLEN\nvar NONCE_BEGIN = KEY_END\nvar NONCE_END = NONCE_BEGIN + cipher.NONCELEN\n\nfunction initializeKey (state, key) {\n  assert(state.byteLength === STATELEN)\n  assert(key == null ? true : key.byteLength === cipher.KEYLEN)\n\n  if (key == null) {\n    sodium_memzero(state.subarray(KEY_BEGIN, KEY_END))\n    return\n  }\n\n  state.set(key)\n  sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END))\n}\n\nfunction hasKey (state) {\n  assert(state.byteLength === STATELEN)\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  return sodium_is_zero(k) === false\n}\n\nfunction setNonce (state, nonce) {\n  assert(state.byteLength === STATELEN)\n  assert(nonce.byteLength === NONCELEN)\n\n  state.set(nonce, NONCE_BEGIN)\n}\n\nvar maxnonce = new Uint8Array(8).fill(0xff)\nfunction encryptWithAd (state, out, ad, plaintext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(plaintext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(plaintext)\n    encryptWithAd.bytesRead = plaintext.byteLength\n    encryptWithAd.bytesWritten = encryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.encrypt(\n    out,\n    k,\n    n,\n    ad,\n    plaintext\n  )\n  encryptWithAd.bytesRead = cipher.encrypt.bytesRead\n  encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten\n\n  sodium_increment(n)\n}\nencryptWithAd.bytesRead = 0\nencryptWithAd.bytesWritten = 0\n\nfunction decryptWithAd (state, out, ad, ciphertext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(ciphertext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(ciphertext)\n    decryptWithAd.bytesRead = ciphertext.byteLength\n    decryptWithAd.bytesWritten = decryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.decrypt(\n    out,\n    k,\n    n,\n    ad,\n    ciphertext\n  )\n  decryptWithAd.bytesRead = cipher.decrypt.bytesRead\n  decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten\n\n  sodium_increment(n)\n}\ndecryptWithAd.bytesRead = 0\ndecryptWithAd.bytesWritten = 0\n\nfunction rekey (state) {\n  assert(state.byteLength === STATELEN)\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  cipher.rekey(k, k)\n  rekey.bytesRead = cipher.rekey.bytesRead\n  rekey.bytesWritten = cipher.rekey.bytesWritten\n}\nrekey.bytesRead = 0\nrekey.bytesWritten = 0\n","start":1670465471433,"end":1670465471669},{"name":"vite:react-babel","result":"/* eslint-disable camelcase */\nconst { sodium_memzero } = require('sodium-universal/memory')\nconst { sodium_increment, sodium_memcmp, sodium_is_zero } = require('sodium-universal/helpers')\n\nvar assert = require('nanoassert')\nvar cipher = require('./cipher')\n\nvar STATELEN = cipher.KEYLEN + cipher.NONCELEN\nvar NONCELEN = cipher.NONCELEN\nvar MACLEN = cipher.MACLEN\n\nmodule.exports = {\n  STATELEN,\n  NONCELEN,\n  MACLEN,\n  initializeKey,\n  hasKey,\n  setNonce,\n  encryptWithAd,\n  decryptWithAd,\n  rekey\n}\n\nvar KEY_BEGIN = 0\nvar KEY_END = cipher.KEYLEN\nvar NONCE_BEGIN = KEY_END\nvar NONCE_END = NONCE_BEGIN + cipher.NONCELEN\n\nfunction initializeKey (state, key) {\n  assert(state.byteLength === STATELEN)\n  assert(key == null ? true : key.byteLength === cipher.KEYLEN)\n\n  if (key == null) {\n    sodium_memzero(state.subarray(KEY_BEGIN, KEY_END))\n    return\n  }\n\n  state.set(key)\n  sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END))\n}\n\nfunction hasKey (state) {\n  assert(state.byteLength === STATELEN)\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  return sodium_is_zero(k) === false\n}\n\nfunction setNonce (state, nonce) {\n  assert(state.byteLength === STATELEN)\n  assert(nonce.byteLength === NONCELEN)\n\n  state.set(nonce, NONCE_BEGIN)\n}\n\nvar maxnonce = new Uint8Array(8).fill(0xff)\nfunction encryptWithAd (state, out, ad, plaintext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(plaintext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(plaintext)\n    encryptWithAd.bytesRead = plaintext.byteLength\n    encryptWithAd.bytesWritten = encryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.encrypt(\n    out,\n    k,\n    n,\n    ad,\n    plaintext\n  )\n  encryptWithAd.bytesRead = cipher.encrypt.bytesRead\n  encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten\n\n  sodium_increment(n)\n}\nencryptWithAd.bytesRead = 0\nencryptWithAd.bytesWritten = 0\n\nfunction decryptWithAd (state, out, ad, ciphertext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(ciphertext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(ciphertext)\n    decryptWithAd.bytesRead = ciphertext.byteLength\n    decryptWithAd.bytesWritten = decryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.decrypt(\n    out,\n    k,\n    n,\n    ad,\n    ciphertext\n  )\n  decryptWithAd.bytesRead = cipher.decrypt.bytesRead\n  decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten\n\n  sodium_increment(n)\n}\ndecryptWithAd.bytesRead = 0\ndecryptWithAd.bytesWritten = 0\n\nfunction rekey (state) {\n  assert(state.byteLength === STATELEN)\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  cipher.rekey(k, k)\n  rekey.bytesRead = cipher.rekey.bytesRead\n  rekey.bytesWritten = cipher.rekey.bytesWritten\n}\nrekey.bytesRead = 0\nrekey.bytesWritten = 0\n","start":1670465471669,"end":1670465471669,"order":"pre"},{"name":"commonjs","result":"/* eslint-disable camelcase */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/memory.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/helpers.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/cipher.js?commonjs-proxy\";\n\nconst { sodium_memzero } = require$$0\nconst { sodium_increment, sodium_memcmp, sodium_is_zero } = require$$1\n\nvar assert = require$$2\nvar cipher = require$$3\n\nvar STATELEN = cipher.KEYLEN + cipher.NONCELEN\nvar NONCELEN = cipher.NONCELEN\nvar MACLEN = cipher.MACLEN\n\nvar cipherState = {\n  STATELEN,\n  NONCELEN,\n  MACLEN,\n  initializeKey,\n  hasKey,\n  setNonce,\n  encryptWithAd,\n  decryptWithAd,\n  rekey\n}\n\nvar KEY_BEGIN = 0\nvar KEY_END = cipher.KEYLEN\nvar NONCE_BEGIN = KEY_END\nvar NONCE_END = NONCE_BEGIN + cipher.NONCELEN\n\nfunction initializeKey (state, key) {\n  assert(state.byteLength === STATELEN)\n  assert(key == null ? true : key.byteLength === cipher.KEYLEN)\n\n  if (key == null) {\n    sodium_memzero(state.subarray(KEY_BEGIN, KEY_END))\n    return\n  }\n\n  state.set(key)\n  sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END))\n}\n\nfunction hasKey (state) {\n  assert(state.byteLength === STATELEN)\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  return sodium_is_zero(k) === false\n}\n\nfunction setNonce (state, nonce) {\n  assert(state.byteLength === STATELEN)\n  assert(nonce.byteLength === NONCELEN)\n\n  state.set(nonce, NONCE_BEGIN)\n}\n\nvar maxnonce = new Uint8Array(8).fill(0xff)\nfunction encryptWithAd (state, out, ad, plaintext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(plaintext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(plaintext)\n    encryptWithAd.bytesRead = plaintext.byteLength\n    encryptWithAd.bytesWritten = encryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.encrypt(\n    out,\n    k,\n    n,\n    ad,\n    plaintext\n  )\n  encryptWithAd.bytesRead = cipher.encrypt.bytesRead\n  encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten\n\n  sodium_increment(n)\n}\nencryptWithAd.bytesRead = 0\nencryptWithAd.bytesWritten = 0\n\nfunction decryptWithAd (state, out, ad, ciphertext) {\n  assert(state.byteLength === STATELEN)\n  assert(out.byteLength != null)\n  assert(ciphertext.byteLength != null)\n\n  var n = state.subarray(NONCE_BEGIN, NONCE_END)\n  if (sodium_memcmp(n, maxnonce)) throw new Error('Nonce overflow')\n\n  if (hasKey(state) === false) {\n    out.set(ciphertext)\n    decryptWithAd.bytesRead = ciphertext.byteLength\n    decryptWithAd.bytesWritten = decryptWithAd.bytesRead\n    return\n  }\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n\n  cipher.decrypt(\n    out,\n    k,\n    n,\n    ad,\n    ciphertext\n  )\n  decryptWithAd.bytesRead = cipher.decrypt.bytesRead\n  decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten\n\n  sodium_increment(n)\n}\ndecryptWithAd.bytesRead = 0\ndecryptWithAd.bytesWritten = 0\n\nfunction rekey (state) {\n  assert(state.byteLength === STATELEN)\n\n  var k = state.subarray(KEY_BEGIN, KEY_END)\n  cipher.rekey(k, k)\n  rekey.bytesRead = cipher.rekey.bytesRead\n  rekey.bytesWritten = cipher.rekey.bytesWritten\n}\nrekey.bytesRead = 0\nrekey.bytesWritten = 0\n\nexport default cipherState;\nexport { cipherState as __moduleExports };","start":1670465471669,"end":1670465471799,"order":"normal"}]}
