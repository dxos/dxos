{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/protocol-plugin-rpc/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/protocol-plugin-rpc/src/rpc-plugin.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { log } from \"@dxos/log\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nvar _RpcPlugin = class {\n  constructor(_onConnect) {\n    this._onConnect = _onConnect;\n    this._peers = /* @__PURE__ */ new Map();\n  }\n  createExtension() {\n    return new Extension(_RpcPlugin.EXTENSION).setHandshakeHandler(this._onPeerConnect.bind(this)).setMessageHandler(this._onMessage.bind(this)).setCloseHandler(this._onPeerDisconnect.bind(this));\n  }\n  async close() {\n    var _a;\n    for (const connection of this._peers.values()) {\n      await ((_a = connection.cleanup) == null ? void 0 : _a.call(connection));\n      await connection.peer.close();\n    }\n  }\n  async _onPeerConnect(peer) {\n    const peerId = getPeerId(peer);\n    const receive = new Event();\n    this._peers.set(peerId, {\n      peer,\n      receive\n    });\n    const port = createPort(peer, receive);\n    const cleanup = await this._onConnect(port, peerId);\n    if (typeof cleanup === \"function\") {\n      const connection = this._peers.get(peerId);\n      connection && (connection.cleanup = cleanup);\n    }\n  }\n  async _onPeerDisconnect(peer) {\n    var _a;\n    const peerId = getPeerId(peer);\n    const connection = this._peers.get(peerId);\n    if (connection) {\n      await ((_a = connection.cleanup) == null ? void 0 : _a.call(connection));\n      this._peers.delete(peerId);\n    }\n  }\n  _onMessage(peer, data) {\n    const peerId = getPeerId(peer);\n    const connection = this._peers.get(peerId);\n    if (connection) {\n      connection.receive.emit(data);\n    }\n  }\n};\nvar RpcPlugin = _RpcPlugin;\nRpcPlugin.EXTENSION = \"dxos.mesh.protocol.rpc\";\nvar createPort = (peer, receive) => {\n  return {\n    send: async (msg) => {\n      const extension = peer.getExtension(RpcPlugin.EXTENSION);\n      assert(extension, \"Extension is not set.\");\n      await extension.send(msg);\n    },\n    subscribe: (cb) => {\n      const adapterCallback = (obj) => {\n        cb(obj.data);\n      };\n      receive.on(adapterCallback);\n      return () => receive.off(adapterCallback);\n    }\n  };\n};\nvar getPeerId = (peer) => {\n  var _a;\n  const { peerId } = (_a = peer.getSession()) != null ? _a : {};\n  return peerId;\n};\nvar createRpcPlugin = (onOpen, options = {\n  maxConnections: 1\n}) => {\n  let count = 0;\n  return new RpcPlugin(async (port, peerId) => {\n    if (count >= options.maxConnections) {\n      log(`max connections reached: ${count}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/protocol-plugin-rpc/src/rpc-plugin.ts\",\n        line: 121,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    count++;\n    await onOpen(port, peerId);\n  });\n};\nexport {\n  RpcPlugin,\n  createPort,\n  createRpcPlugin,\n  getPeerId\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466988,"end":1670465467173},{"name":"vite:react-babel","result":"// packages/core/mesh/protocol-plugin-rpc/src/rpc-plugin.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nimport { log } from \"@dxos/log\";\nimport { Extension } from \"@dxos/mesh-protocol\";\nvar _RpcPlugin = class {\n  constructor(_onConnect) {\n    this._onConnect = _onConnect;\n    this._peers = /* @__PURE__ */ new Map();\n  }\n  createExtension() {\n    return new Extension(_RpcPlugin.EXTENSION).setHandshakeHandler(this._onPeerConnect.bind(this)).setMessageHandler(this._onMessage.bind(this)).setCloseHandler(this._onPeerDisconnect.bind(this));\n  }\n  async close() {\n    var _a;\n    for (const connection of this._peers.values()) {\n      await ((_a = connection.cleanup) == null ? void 0 : _a.call(connection));\n      await connection.peer.close();\n    }\n  }\n  async _onPeerConnect(peer) {\n    const peerId = getPeerId(peer);\n    const receive = new Event();\n    this._peers.set(peerId, {\n      peer,\n      receive\n    });\n    const port = createPort(peer, receive);\n    const cleanup = await this._onConnect(port, peerId);\n    if (typeof cleanup === \"function\") {\n      const connection = this._peers.get(peerId);\n      connection && (connection.cleanup = cleanup);\n    }\n  }\n  async _onPeerDisconnect(peer) {\n    var _a;\n    const peerId = getPeerId(peer);\n    const connection = this._peers.get(peerId);\n    if (connection) {\n      await ((_a = connection.cleanup) == null ? void 0 : _a.call(connection));\n      this._peers.delete(peerId);\n    }\n  }\n  _onMessage(peer, data) {\n    const peerId = getPeerId(peer);\n    const connection = this._peers.get(peerId);\n    if (connection) {\n      connection.receive.emit(data);\n    }\n  }\n};\nvar RpcPlugin = _RpcPlugin;\nRpcPlugin.EXTENSION = \"dxos.mesh.protocol.rpc\";\nvar createPort = (peer, receive) => {\n  return {\n    send: async (msg) => {\n      const extension = peer.getExtension(RpcPlugin.EXTENSION);\n      assert(extension, \"Extension is not set.\");\n      await extension.send(msg);\n    },\n    subscribe: (cb) => {\n      const adapterCallback = (obj) => {\n        cb(obj.data);\n      };\n      receive.on(adapterCallback);\n      return () => receive.off(adapterCallback);\n    }\n  };\n};\nvar getPeerId = (peer) => {\n  var _a;\n  const { peerId } = (_a = peer.getSession()) != null ? _a : {};\n  return peerId;\n};\nvar createRpcPlugin = (onOpen, options = {\n  maxConnections: 1\n}) => {\n  let count = 0;\n  return new RpcPlugin(async (port, peerId) => {\n    if (count >= options.maxConnections) {\n      log(`max connections reached: ${count}`, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/protocol-plugin-rpc/src/rpc-plugin.ts\",\n        line: 121,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    count++;\n    await onOpen(port, peerId);\n  });\n};\nexport {\n  RpcPlugin,\n  createPort,\n  createRpcPlugin,\n  getPeerId\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467173,"end":1670465467173,"order":"pre"}]}
