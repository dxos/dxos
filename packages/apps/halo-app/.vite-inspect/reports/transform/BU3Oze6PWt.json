{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-handshake@3.0.0/node_modules/simple-handshake/index.js","transforms":[{"name":"vite:load-fallback","result":"var noise = require('noise-protocol')\nvar NoiseSymmetricState = require('noise-protocol/symmetric-state')\nvar NoiseHash = require('noise-protocol/hash')\nvar assert = require('nanoassert')\nvar EMPTY = Buffer.alloc(0)\n\nfunction SimpleHandshake (isInitiator, opts) {\n  if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts)\n  opts = opts || {}\n\n  var pattern = opts.pattern || 'NN'\n  var prolouge = opts.prolouge || EMPTY\n\n  this.handshakeHash = null\n  this.onstatickey = opts.onstatickey || function (_, cb) { cb() }\n  this.onephemeralkey = opts.onephemeralkey || function (_, cb) { cb() }\n  this.onhandshake = opts.onhandshake || function (_, cb) { cb() }\n\n  this.state = noise.initialize(\n    pattern,\n    isInitiator,\n    prolouge,\n    opts.staticKeyPair,\n    opts.ephemeralKeyPair,\n    opts.remoteStaticKey,\n    opts.remoteEphemeralKey\n  )\n\n  // initiators should send first message, so if initiator, waiting = false\n  // while servers should await any message, so if not initiator, waiting = true\n  this.waiting = isInitiator === false\n  this.finished = false\n  // Will hold the \"split\" for transport encryption after handshake\n  this.split = null\n\n  // ~64KiB is the max noise message length\n  this._tx = Buffer.alloc(65535)\n  this._rx = Buffer.alloc(65535)\n}\n\nSimpleHandshake.prototype.recv = function recv (data, cb) {\n  var self = this\n  assert(self.finished === false, 'Should not call recv if finished')\n  assert(data != null, 'must have data')\n  assert(data.byteLength <= self._rx.byteLength, 'too much data received')\n  assert(self.waiting === true, 'Wrong state, not ready to receive data')\n  assert(self.split == null, 'split should be null')\n\n  var hasREBefore = self.state.re != null\n  var hasRSBefore = self.state.rs != null\n  try {\n    self.split = noise.readMessage(self.state, data, self._rx)\n  } catch (ex) {\n    return self._finish(ex, null, cb)\n  }\n\n  self.waiting = false\n\n  var hasREAfter = self.state.re != null\n  var hasRSAfter = self.state.rs != null\n\n  // e and s may come in the same message, so we always have to check static\n  // after ephemeral. Assumption here (which holds for all official Noise handshakes)\n  // is that e always comes before s\n  if (hasREBefore === false && hasREAfter === true) {\n    return self.onephemeralkey(self.state.re, checkStatic)\n  }\n\n  return checkStatic()\n\n  function checkStatic (err) {\n    if (err) return ondone(err)\n\n    if (hasRSBefore === false && hasRSAfter === true) {\n      return self.onstatickey(self.state.rs, ondone)\n    }\n\n    return ondone()\n  }\n\n  function ondone (err) {\n    if (err) return self._finish(err, null, cb)\n\n    var msg = self._rx.subarray(0, noise.readMessage.bytes)\n    if (self.split) return self._finish(null, msg, cb)\n\n    cb(null, msg)\n  }\n}\n\nSimpleHandshake.prototype.send = function send (data, cb) {\n  assert(this.finished === false, 'Should not call send if finished')\n  assert(this.waiting === false, 'Wrong state, not ready to send data')\n  assert(this.split == null, 'split should be null')\n\n  data = data || EMPTY\n\n  try {\n    this.split = noise.writeMessage(this.state, data, this._tx)\n  } catch (ex) {\n    return this._finish(ex, null, cb)\n  }\n\n  this.waiting = true\n\n  var buf = this._tx.subarray(0, noise.writeMessage.bytes)\n\n  if (this.split != null) return this._finish(null, buf, cb)\n\n  return cb(null, buf)\n}\n\nSimpleHandshake.prototype.destroy = function () {\n  this._finish(null, null, function () {})\n}\n\nSimpleHandshake.prototype._finish = function _finish (err, msg, cb) {\n  assert(this.finished === false, 'Already finished')\n  const self = this\n\n  self.finished = true\n  self.waiting = false\n\n  if (self.split) {\n    self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN)\n    NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash)\n  }\n  if (err) return ondone(err)\n  self.onhandshake(self.state, ondone)\n\n  function ondone (err) {\n    noise.destroy(self.state)\n\n    cb(err, msg, self.split)\n\n    // Should be sodium_memzero?\n    self._rx.fill(0)\n    self._tx.fill(0)\n  }\n}\n\nSimpleHandshake.keygen = noise.keygen\nSimpleHandshake.seedKeygen = noise.seedKeygen\n\nmodule.exports = SimpleHandshake\n","start":1670465470843,"end":1670465470917},{"name":"vite:react-babel","result":"var noise = require('noise-protocol')\nvar NoiseSymmetricState = require('noise-protocol/symmetric-state')\nvar NoiseHash = require('noise-protocol/hash')\nvar assert = require('nanoassert')\nvar EMPTY = Buffer.alloc(0)\n\nfunction SimpleHandshake (isInitiator, opts) {\n  if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts)\n  opts = opts || {}\n\n  var pattern = opts.pattern || 'NN'\n  var prolouge = opts.prolouge || EMPTY\n\n  this.handshakeHash = null\n  this.onstatickey = opts.onstatickey || function (_, cb) { cb() }\n  this.onephemeralkey = opts.onephemeralkey || function (_, cb) { cb() }\n  this.onhandshake = opts.onhandshake || function (_, cb) { cb() }\n\n  this.state = noise.initialize(\n    pattern,\n    isInitiator,\n    prolouge,\n    opts.staticKeyPair,\n    opts.ephemeralKeyPair,\n    opts.remoteStaticKey,\n    opts.remoteEphemeralKey\n  )\n\n  // initiators should send first message, so if initiator, waiting = false\n  // while servers should await any message, so if not initiator, waiting = true\n  this.waiting = isInitiator === false\n  this.finished = false\n  // Will hold the \"split\" for transport encryption after handshake\n  this.split = null\n\n  // ~64KiB is the max noise message length\n  this._tx = Buffer.alloc(65535)\n  this._rx = Buffer.alloc(65535)\n}\n\nSimpleHandshake.prototype.recv = function recv (data, cb) {\n  var self = this\n  assert(self.finished === false, 'Should not call recv if finished')\n  assert(data != null, 'must have data')\n  assert(data.byteLength <= self._rx.byteLength, 'too much data received')\n  assert(self.waiting === true, 'Wrong state, not ready to receive data')\n  assert(self.split == null, 'split should be null')\n\n  var hasREBefore = self.state.re != null\n  var hasRSBefore = self.state.rs != null\n  try {\n    self.split = noise.readMessage(self.state, data, self._rx)\n  } catch (ex) {\n    return self._finish(ex, null, cb)\n  }\n\n  self.waiting = false\n\n  var hasREAfter = self.state.re != null\n  var hasRSAfter = self.state.rs != null\n\n  // e and s may come in the same message, so we always have to check static\n  // after ephemeral. Assumption here (which holds for all official Noise handshakes)\n  // is that e always comes before s\n  if (hasREBefore === false && hasREAfter === true) {\n    return self.onephemeralkey(self.state.re, checkStatic)\n  }\n\n  return checkStatic()\n\n  function checkStatic (err) {\n    if (err) return ondone(err)\n\n    if (hasRSBefore === false && hasRSAfter === true) {\n      return self.onstatickey(self.state.rs, ondone)\n    }\n\n    return ondone()\n  }\n\n  function ondone (err) {\n    if (err) return self._finish(err, null, cb)\n\n    var msg = self._rx.subarray(0, noise.readMessage.bytes)\n    if (self.split) return self._finish(null, msg, cb)\n\n    cb(null, msg)\n  }\n}\n\nSimpleHandshake.prototype.send = function send (data, cb) {\n  assert(this.finished === false, 'Should not call send if finished')\n  assert(this.waiting === false, 'Wrong state, not ready to send data')\n  assert(this.split == null, 'split should be null')\n\n  data = data || EMPTY\n\n  try {\n    this.split = noise.writeMessage(this.state, data, this._tx)\n  } catch (ex) {\n    return this._finish(ex, null, cb)\n  }\n\n  this.waiting = true\n\n  var buf = this._tx.subarray(0, noise.writeMessage.bytes)\n\n  if (this.split != null) return this._finish(null, buf, cb)\n\n  return cb(null, buf)\n}\n\nSimpleHandshake.prototype.destroy = function () {\n  this._finish(null, null, function () {})\n}\n\nSimpleHandshake.prototype._finish = function _finish (err, msg, cb) {\n  assert(this.finished === false, 'Already finished')\n  const self = this\n\n  self.finished = true\n  self.waiting = false\n\n  if (self.split) {\n    self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN)\n    NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash)\n  }\n  if (err) return ondone(err)\n  self.onhandshake(self.state, ondone)\n\n  function ondone (err) {\n    noise.destroy(self.state)\n\n    cb(err, msg, self.split)\n\n    // Should be sodium_memzero?\n    self._rx.fill(0)\n    self._tx.fill(0)\n  }\n}\n\nSimpleHandshake.keygen = noise.keygen\nSimpleHandshake.seedKeygen = noise.seedKeygen\n\nmodule.exports = SimpleHandshake\n","start":1670465470917,"end":1670465470917,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\n\nvar noise = require$$0\nvar NoiseSymmetricState = require$$1\nvar NoiseHash = require$$2\nvar assert = require$$3\nvar EMPTY = Buffer.alloc(0)\n\nfunction SimpleHandshake (isInitiator, opts) {\n  if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts)\n  opts = opts || {}\n\n  var pattern = opts.pattern || 'NN'\n  var prolouge = opts.prolouge || EMPTY\n\n  this.handshakeHash = null\n  this.onstatickey = opts.onstatickey || function (_, cb) { cb() }\n  this.onephemeralkey = opts.onephemeralkey || function (_, cb) { cb() }\n  this.onhandshake = opts.onhandshake || function (_, cb) { cb() }\n\n  this.state = noise.initialize(\n    pattern,\n    isInitiator,\n    prolouge,\n    opts.staticKeyPair,\n    opts.ephemeralKeyPair,\n    opts.remoteStaticKey,\n    opts.remoteEphemeralKey\n  )\n\n  // initiators should send first message, so if initiator, waiting = false\n  // while servers should await any message, so if not initiator, waiting = true\n  this.waiting = isInitiator === false\n  this.finished = false\n  // Will hold the \"split\" for transport encryption after handshake\n  this.split = null\n\n  // ~64KiB is the max noise message length\n  this._tx = Buffer.alloc(65535)\n  this._rx = Buffer.alloc(65535)\n}\n\nSimpleHandshake.prototype.recv = function recv (data, cb) {\n  var self = this\n  assert(self.finished === false, 'Should not call recv if finished')\n  assert(data != null, 'must have data')\n  assert(data.byteLength <= self._rx.byteLength, 'too much data received')\n  assert(self.waiting === true, 'Wrong state, not ready to receive data')\n  assert(self.split == null, 'split should be null')\n\n  var hasREBefore = self.state.re != null\n  var hasRSBefore = self.state.rs != null\n  try {\n    self.split = noise.readMessage(self.state, data, self._rx)\n  } catch (ex) {\n    return self._finish(ex, null, cb)\n  }\n\n  self.waiting = false\n\n  var hasREAfter = self.state.re != null\n  var hasRSAfter = self.state.rs != null\n\n  // e and s may come in the same message, so we always have to check static\n  // after ephemeral. Assumption here (which holds for all official Noise handshakes)\n  // is that e always comes before s\n  if (hasREBefore === false && hasREAfter === true) {\n    return self.onephemeralkey(self.state.re, checkStatic)\n  }\n\n  return checkStatic()\n\n  function checkStatic (err) {\n    if (err) return ondone(err)\n\n    if (hasRSBefore === false && hasRSAfter === true) {\n      return self.onstatickey(self.state.rs, ondone)\n    }\n\n    return ondone()\n  }\n\n  function ondone (err) {\n    if (err) return self._finish(err, null, cb)\n\n    var msg = self._rx.subarray(0, noise.readMessage.bytes)\n    if (self.split) return self._finish(null, msg, cb)\n\n    cb(null, msg)\n  }\n}\n\nSimpleHandshake.prototype.send = function send (data, cb) {\n  assert(this.finished === false, 'Should not call send if finished')\n  assert(this.waiting === false, 'Wrong state, not ready to send data')\n  assert(this.split == null, 'split should be null')\n\n  data = data || EMPTY\n\n  try {\n    this.split = noise.writeMessage(this.state, data, this._tx)\n  } catch (ex) {\n    return this._finish(ex, null, cb)\n  }\n\n  this.waiting = true\n\n  var buf = this._tx.subarray(0, noise.writeMessage.bytes)\n\n  if (this.split != null) return this._finish(null, buf, cb)\n\n  return cb(null, buf)\n}\n\nSimpleHandshake.prototype.destroy = function () {\n  this._finish(null, null, function () {})\n}\n\nSimpleHandshake.prototype._finish = function _finish (err, msg, cb) {\n  assert(this.finished === false, 'Already finished')\n  const self = this\n\n  self.finished = true\n  self.waiting = false\n\n  if (self.split) {\n    self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN)\n    NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash)\n  }\n  if (err) return ondone(err)\n  self.onhandshake(self.state, ondone)\n\n  function ondone (err) {\n    noise.destroy(self.state)\n\n    cb(err, msg, self.split)\n\n    // Should be sodium_memzero?\n    self._rx.fill(0)\n    self._tx.fill(0)\n  }\n}\n\nSimpleHandshake.keygen = noise.keygen\nSimpleHandshake.seedKeygen = noise.seedKeygen\n\nvar simpleHandshake = SimpleHandshake\n\nexport default simpleHandshake;\nexport { simpleHandshake as __moduleExports };","start":1670465470917,"end":1670465471813,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/symmetric-state.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\n\nvar noise = require$$0\nvar NoiseSymmetricState = require$$1\nvar NoiseHash = require$$2\nvar assert = require$$3\nvar EMPTY = Buffer.alloc(0)\n\nfunction SimpleHandshake (isInitiator, opts) {\n  if (!(this instanceof SimpleHandshake)) return new SimpleHandshake(isInitiator, opts)\n  opts = opts || {}\n\n  var pattern = opts.pattern || 'NN'\n  var prolouge = opts.prolouge || EMPTY\n\n  this.handshakeHash = null\n  this.onstatickey = opts.onstatickey || function (_, cb) { cb() }\n  this.onephemeralkey = opts.onephemeralkey || function (_, cb) { cb() }\n  this.onhandshake = opts.onhandshake || function (_, cb) { cb() }\n\n  this.state = noise.initialize(\n    pattern,\n    isInitiator,\n    prolouge,\n    opts.staticKeyPair,\n    opts.ephemeralKeyPair,\n    opts.remoteStaticKey,\n    opts.remoteEphemeralKey\n  )\n\n  // initiators should send first message, so if initiator, waiting = false\n  // while servers should await any message, so if not initiator, waiting = true\n  this.waiting = isInitiator === false\n  this.finished = false\n  // Will hold the \"split\" for transport encryption after handshake\n  this.split = null\n\n  // ~64KiB is the max noise message length\n  this._tx = Buffer.alloc(65535)\n  this._rx = Buffer.alloc(65535)\n}\n\nSimpleHandshake.prototype.recv = function recv (data, cb) {\n  var self = this\n  assert(self.finished === false, 'Should not call recv if finished')\n  assert(data != null, 'must have data')\n  assert(data.byteLength <= self._rx.byteLength, 'too much data received')\n  assert(self.waiting === true, 'Wrong state, not ready to receive data')\n  assert(self.split == null, 'split should be null')\n\n  var hasREBefore = self.state.re != null\n  var hasRSBefore = self.state.rs != null\n  try {\n    self.split = noise.readMessage(self.state, data, self._rx)\n  } catch (ex) {\n    return self._finish(ex, null, cb)\n  }\n\n  self.waiting = false\n\n  var hasREAfter = self.state.re != null\n  var hasRSAfter = self.state.rs != null\n\n  // e and s may come in the same message, so we always have to check static\n  // after ephemeral. Assumption here (which holds for all official Noise handshakes)\n  // is that e always comes before s\n  if (hasREBefore === false && hasREAfter === true) {\n    return self.onephemeralkey(self.state.re, checkStatic)\n  }\n\n  return checkStatic()\n\n  function checkStatic (err) {\n    if (err) return ondone(err)\n\n    if (hasRSBefore === false && hasRSAfter === true) {\n      return self.onstatickey(self.state.rs, ondone)\n    }\n\n    return ondone()\n  }\n\n  function ondone (err) {\n    if (err) return self._finish(err, null, cb)\n\n    var msg = self._rx.subarray(0, noise.readMessage.bytes)\n    if (self.split) return self._finish(null, msg, cb)\n\n    cb(null, msg)\n  }\n}\n\nSimpleHandshake.prototype.send = function send (data, cb) {\n  assert(this.finished === false, 'Should not call send if finished')\n  assert(this.waiting === false, 'Wrong state, not ready to send data')\n  assert(this.split == null, 'split should be null')\n\n  data = data || EMPTY\n\n  try {\n    this.split = noise.writeMessage(this.state, data, this._tx)\n  } catch (ex) {\n    return this._finish(ex, null, cb)\n  }\n\n  this.waiting = true\n\n  var buf = this._tx.subarray(0, noise.writeMessage.bytes)\n\n  if (this.split != null) return this._finish(null, buf, cb)\n\n  return cb(null, buf)\n}\n\nSimpleHandshake.prototype.destroy = function () {\n  this._finish(null, null, function () {})\n}\n\nSimpleHandshake.prototype._finish = function _finish (err, msg, cb) {\n  assert(this.finished === false, 'Already finished')\n  const self = this\n\n  self.finished = true\n  self.waiting = false\n\n  if (self.split) {\n    self.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN)\n    NoiseSymmetricState.getHandshakeHash(self.state.symmetricState, self.handshakeHash)\n  }\n  if (err) return ondone(err)\n  self.onhandshake(self.state, ondone)\n\n  function ondone (err) {\n    noise.destroy(self.state)\n\n    cb(err, msg, self.split)\n\n    // Should be sodium_memzero?\n    self._rx.fill(0)\n    self._tx.fill(0)\n  }\n}\n\nSimpleHandshake.keygen = noise.keygen\nSimpleHandshake.seedKeygen = noise.seedKeygen\n\nvar simpleHandshake = SimpleHandshake\n\nexport default simpleHandshake;\nexport { simpleHandshake as __moduleExports };","start":1670465471813,"end":1670465471815,"order":"normal"}]}
