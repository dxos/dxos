{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/hash.js","transforms":[{"name":"vite:load-fallback","result":"/* eslint-disable camelcase */\nconst { sodium_malloc, sodium_memzero } = require('sodium-universal/memory')\nconst { crypto_generichash_batch } = require('sodium-universal/crypto_generichash')\n\nconst assert = require('nanoassert')\nconst hmacBlake2b = require('hmac-blake2b')\nconst dh = require('./dh')\n\nconst HASHLEN = 64\nconst BLOCKLEN = 128\n\nassert(hmacBlake2b.KEYBYTES === BLOCKLEN, 'mismatching hmac BLOCKLEN')\nassert(hmacBlake2b.BYTES === HASHLEN, 'mismatching hmac HASHLEN')\n\nmodule.exports = {\n  HASHLEN,\n  BLOCKLEN,\n  hash,\n  hkdf\n}\n\nfunction hash (out, data) {\n  assert(out.byteLength === HASHLEN)\n  assert(Array.isArray(data))\n\n  crypto_generichash_batch(out, data)\n}\n\nfunction hmac (out, key, data) {\n  return hmacBlake2b(out, data, key)\n}\n\nconst TempKey = sodium_malloc(HASHLEN)\nconst Byte0x01 = new Uint8Array([0x01])\nconst Byte0x02 = new Uint8Array([0x02])\nconst Byte0x03 = new Uint8Array([0x03])\n\nfunction hkdf (out1, out2, out3, chainingKey, inputKeyMaterial) {\n  assert(out1.byteLength === HASHLEN)\n  assert(out2.byteLength === HASHLEN)\n  assert(out3 == null ? true : out3.byteLength === HASHLEN)\n  assert(chainingKey.byteLength === HASHLEN)\n  assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength))\n\n  sodium_memzero(TempKey)\n  hmac(TempKey, chainingKey, [inputKeyMaterial])\n  hmac(out1, TempKey, [Byte0x01])\n  hmac(out2, TempKey, [out1, Byte0x02])\n\n  if (out3 != null) {\n    hmac(out3, TempKey, [out2, Byte0x03])\n  }\n\n  sodium_memzero(TempKey)\n}\n","start":1670465471032,"end":1670465471204},{"name":"vite:react-babel","result":"/* eslint-disable camelcase */\nconst { sodium_malloc, sodium_memzero } = require('sodium-universal/memory')\nconst { crypto_generichash_batch } = require('sodium-universal/crypto_generichash')\n\nconst assert = require('nanoassert')\nconst hmacBlake2b = require('hmac-blake2b')\nconst dh = require('./dh')\n\nconst HASHLEN = 64\nconst BLOCKLEN = 128\n\nassert(hmacBlake2b.KEYBYTES === BLOCKLEN, 'mismatching hmac BLOCKLEN')\nassert(hmacBlake2b.BYTES === HASHLEN, 'mismatching hmac HASHLEN')\n\nmodule.exports = {\n  HASHLEN,\n  BLOCKLEN,\n  hash,\n  hkdf\n}\n\nfunction hash (out, data) {\n  assert(out.byteLength === HASHLEN)\n  assert(Array.isArray(data))\n\n  crypto_generichash_batch(out, data)\n}\n\nfunction hmac (out, key, data) {\n  return hmacBlake2b(out, data, key)\n}\n\nconst TempKey = sodium_malloc(HASHLEN)\nconst Byte0x01 = new Uint8Array([0x01])\nconst Byte0x02 = new Uint8Array([0x02])\nconst Byte0x03 = new Uint8Array([0x03])\n\nfunction hkdf (out1, out2, out3, chainingKey, inputKeyMaterial) {\n  assert(out1.byteLength === HASHLEN)\n  assert(out2.byteLength === HASHLEN)\n  assert(out3 == null ? true : out3.byteLength === HASHLEN)\n  assert(chainingKey.byteLength === HASHLEN)\n  assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength))\n\n  sodium_memzero(TempKey)\n  hmac(TempKey, chainingKey, [inputKeyMaterial])\n  hmac(out1, TempKey, [Byte0x01])\n  hmac(out2, TempKey, [out1, Byte0x02])\n\n  if (out3 != null) {\n    hmac(out3, TempKey, [out2, Byte0x03])\n  }\n\n  sodium_memzero(TempKey)\n}\n","start":1670465471204,"end":1670465471204,"order":"pre"},{"name":"commonjs","result":"/* eslint-disable camelcase */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/memory.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/crypto_generichash.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hmac-blake2b@2.0.0/node_modules/hmac-blake2b/index.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/noise-protocol@3.0.1/node_modules/noise-protocol/dh.js?commonjs-proxy\";\n\nconst { sodium_malloc, sodium_memzero } = require$$0\nconst { crypto_generichash_batch } = require$$1\n\nconst assert = require$$2\nconst hmacBlake2b = require$$3\nconst dh = require$$4\n\nconst HASHLEN = 64\nconst BLOCKLEN = 128\n\nassert(hmacBlake2b.KEYBYTES === BLOCKLEN, 'mismatching hmac BLOCKLEN')\nassert(hmacBlake2b.BYTES === HASHLEN, 'mismatching hmac HASHLEN')\n\nvar hash_1 = {\n  HASHLEN,\n  BLOCKLEN,\n  hash,\n  hkdf\n}\n\nfunction hash (out, data) {\n  assert(out.byteLength === HASHLEN)\n  assert(Array.isArray(data))\n\n  crypto_generichash_batch(out, data)\n}\n\nfunction hmac (out, key, data) {\n  return hmacBlake2b(out, data, key)\n}\n\nconst TempKey = sodium_malloc(HASHLEN)\nconst Byte0x01 = new Uint8Array([0x01])\nconst Byte0x02 = new Uint8Array([0x02])\nconst Byte0x03 = new Uint8Array([0x03])\n\nfunction hkdf (out1, out2, out3, chainingKey, inputKeyMaterial) {\n  assert(out1.byteLength === HASHLEN)\n  assert(out2.byteLength === HASHLEN)\n  assert(out3 == null ? true : out3.byteLength === HASHLEN)\n  assert(chainingKey.byteLength === HASHLEN)\n  assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength))\n\n  sodium_memzero(TempKey)\n  hmac(TempKey, chainingKey, [inputKeyMaterial])\n  hmac(out1, TempKey, [Byte0x01])\n  hmac(out2, TempKey, [out1, Byte0x02])\n\n  if (out3 != null) {\n    hmac(out3, TempKey, [out2, Byte0x03])\n  }\n\n  sodium_memzero(TempKey)\n}\n\nexport default hash_1;\nexport { hash_1 as __moduleExports };","start":1670465471204,"end":1670465471789,"order":"normal"}]}
