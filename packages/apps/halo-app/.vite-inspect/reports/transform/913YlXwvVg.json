{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js","transforms":[{"name":"vite:load-fallback","result":"// This file is auto generated by the protocol-buffers compiler\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n/* eslint-disable camelcase */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar NoisePayload = exports.NoisePayload = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Open = exports.Open = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Options = exports.Options = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Status = exports.Status = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Have = exports.Have = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unhave = exports.Unhave = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Want = exports.Want = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unwant = exports.Unwant = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Request = exports.Request = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Cancel = exports.Cancel = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Data = exports.Data = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Close = exports.Close = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineNoisePayload()\ndefineOpen()\ndefineOptions()\ndefineStatus()\ndefineHave()\ndefineUnhave()\ndefineWant()\ndefineUnwant()\ndefineRequest()\ndefineCancel()\ndefineData()\ndefineClose()\n\nfunction defineNoisePayload () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  NoisePayload.encodingLength = encodingLength\n  NoisePayload.encode = encode\n  NoisePayload.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    var len = enc[0].encodingLength(obj.nonce)\n    length += 1 + len\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.nonce, buf, offset)\n    offset += enc[0].encode.bytes\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      nonce: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.nonce = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOpen () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Open.encodingLength = encodingLength\n  Open.encode = encode\n  Open.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    var len = enc[0].encodingLength(obj.discoveryKey)\n    length += 1 + len\n    if (defined(obj.capability)) {\n      var len = enc[0].encodingLength(obj.capability)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.discoveryKey, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.capability)) {\n      buf[offset++] = 18\n      enc[0].encode(obj.capability, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null,\n      capability: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.capability = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOptions () {\n  var enc = [\n    encodings.string,\n    encodings.bool\n  ]\n\n  Options.encodingLength = encodingLength\n  Options.encode = encode\n  Options.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        var len = enc[0].encodingLength(obj.extensions[i])\n        length += 1 + len\n      }\n    }\n    if (defined(obj.ack)) {\n      var len = enc[1].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        buf[offset++] = 10\n        enc[0].encode(obj.extensions[i], buf, offset)\n        offset += enc[0].encode.bytes\n      }\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 16\n      enc[1].encode(obj.ack, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      extensions: [],\n      ack: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.extensions.push(enc[0].decode(buf, offset))\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.ack = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineStatus () {\n  var enc = [\n    encodings.bool\n  ]\n\n  Status.encodingLength = encodingLength\n  Status.encode = encode\n  Status.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.uploading)) {\n      var len = enc[0].encodingLength(obj.uploading)\n      length += 1 + len\n    }\n    if (defined(obj.downloading)) {\n      var len = enc[0].encodingLength(obj.downloading)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.uploading)) {\n      buf[offset++] = 8\n      enc[0].encode(obj.uploading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.downloading)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.downloading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      uploading: false,\n      downloading: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.uploading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.downloading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHave () {\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    encodings.bool\n  ]\n\n  Have.encodingLength = encodingLength\n  Have.encode = encode\n  Have.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    if (defined(obj.bitfield)) {\n      var len = enc[1].encodingLength(obj.bitfield)\n      length += 1 + len\n    }\n    if (defined(obj.ack)) {\n      var len = enc[2].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.bitfield)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.bitfield, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 32\n      enc[2].encode(obj.ack, buf, offset)\n      offset += enc[2].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1,\n      bitfield: null,\n      ack: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.bitfield = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.ack = enc[2].decode(buf, offset)\n        offset += enc[2].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnhave () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unhave.encodingLength = encodingLength\n  Unhave.encode = encode\n  Unhave.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineWant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Want.encodingLength = encodingLength\n  Want.encode = encode\n  Want.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnwant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unwant.encodingLength = encodingLength\n  Unwant.encode = encode\n  Unwant.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineRequest () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Request.encodingLength = encodingLength\n  Request.encode = encode\n  Request.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      var len = enc[0].encodingLength(obj.nodes)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.nodes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false,\n      nodes: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.nodes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineCancel () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Cancel.encodingLength = encodingLength\n  Cancel.encode = encode\n  Cancel.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineData () {\n  var Node = Data.Node = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineNode()\n\n  function defineNode () {\n    var enc = [\n      encodings.varint,\n      encodings.bytes\n    ]\n\n    Node.encodingLength = encodingLength\n    Node.encode = encode\n    Node.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      var len = enc[0].encodingLength(obj.index)\n      length += 1 + len\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      buf[offset++] = 8\n      enc[0].encode(obj.index, buf, offset)\n      offset += enc[0].encode.bytes\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      buf[offset++] = 18\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      buf[offset++] = 24\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        index: 0,\n        hash: null,\n        size: 0\n      }\n      var found0 = false\n      var found1 = false\n      var found2 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1 || !found2) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.index = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.hash = enc[1].decode(buf, offset)\n          offset += enc[1].decode.bytes\n          found1 = true\n          break\n          case 3:\n          obj.size = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found2 = true\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    Node\n  ]\n\n  Data.encodingLength = encodingLength\n  Data.encode = encode\n  Data.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        var len = enc[2].encodingLength(obj.nodes[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    if (defined(obj.signature)) {\n      var len = enc[1].encodingLength(obj.signature)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        buf[offset++] = 26\n        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset)\n        offset += varint.encode.bytes\n        enc[2].encode(obj.nodes[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.signature)) {\n      buf[offset++] = 34\n      enc[1].encode(obj.signature, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      value: null,\n      nodes: [],\n      signature: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.nodes.push(enc[2].decode(buf, offset, offset + len))\n        offset += enc[2].decode.bytes\n        break\n        case 4:\n        obj.signature = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineClose () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Close.encodingLength = encodingLength\n  Close.encode = encode\n  Close.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.discoveryKey)) {\n      var len = enc[0].encodingLength(obj.discoveryKey)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.discoveryKey)) {\n      buf[offset++] = 10\n      enc[0].encode(obj.discoveryKey, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n","start":1670465470113,"end":1670465470278},{"name":"vite:react-babel","result":"// This file is auto generated by the protocol-buffers compiler\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n/* eslint-disable camelcase */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require('protocol-buffers-encodings')\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar NoisePayload = exports.NoisePayload = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Open = exports.Open = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Options = exports.Options = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Status = exports.Status = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Have = exports.Have = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unhave = exports.Unhave = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Want = exports.Want = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unwant = exports.Unwant = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Request = exports.Request = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Cancel = exports.Cancel = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Data = exports.Data = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Close = exports.Close = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineNoisePayload()\ndefineOpen()\ndefineOptions()\ndefineStatus()\ndefineHave()\ndefineUnhave()\ndefineWant()\ndefineUnwant()\ndefineRequest()\ndefineCancel()\ndefineData()\ndefineClose()\n\nfunction defineNoisePayload () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  NoisePayload.encodingLength = encodingLength\n  NoisePayload.encode = encode\n  NoisePayload.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    var len = enc[0].encodingLength(obj.nonce)\n    length += 1 + len\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.nonce, buf, offset)\n    offset += enc[0].encode.bytes\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      nonce: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.nonce = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOpen () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Open.encodingLength = encodingLength\n  Open.encode = encode\n  Open.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    var len = enc[0].encodingLength(obj.discoveryKey)\n    length += 1 + len\n    if (defined(obj.capability)) {\n      var len = enc[0].encodingLength(obj.capability)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.discoveryKey, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.capability)) {\n      buf[offset++] = 18\n      enc[0].encode(obj.capability, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null,\n      capability: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.capability = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOptions () {\n  var enc = [\n    encodings.string,\n    encodings.bool\n  ]\n\n  Options.encodingLength = encodingLength\n  Options.encode = encode\n  Options.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        var len = enc[0].encodingLength(obj.extensions[i])\n        length += 1 + len\n      }\n    }\n    if (defined(obj.ack)) {\n      var len = enc[1].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        buf[offset++] = 10\n        enc[0].encode(obj.extensions[i], buf, offset)\n        offset += enc[0].encode.bytes\n      }\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 16\n      enc[1].encode(obj.ack, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      extensions: [],\n      ack: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.extensions.push(enc[0].decode(buf, offset))\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.ack = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineStatus () {\n  var enc = [\n    encodings.bool\n  ]\n\n  Status.encodingLength = encodingLength\n  Status.encode = encode\n  Status.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.uploading)) {\n      var len = enc[0].encodingLength(obj.uploading)\n      length += 1 + len\n    }\n    if (defined(obj.downloading)) {\n      var len = enc[0].encodingLength(obj.downloading)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.uploading)) {\n      buf[offset++] = 8\n      enc[0].encode(obj.uploading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.downloading)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.downloading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      uploading: false,\n      downloading: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.uploading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.downloading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHave () {\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    encodings.bool\n  ]\n\n  Have.encodingLength = encodingLength\n  Have.encode = encode\n  Have.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    if (defined(obj.bitfield)) {\n      var len = enc[1].encodingLength(obj.bitfield)\n      length += 1 + len\n    }\n    if (defined(obj.ack)) {\n      var len = enc[2].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.bitfield)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.bitfield, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 32\n      enc[2].encode(obj.ack, buf, offset)\n      offset += enc[2].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1,\n      bitfield: null,\n      ack: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.bitfield = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.ack = enc[2].decode(buf, offset)\n        offset += enc[2].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnhave () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unhave.encodingLength = encodingLength\n  Unhave.encode = encode\n  Unhave.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineWant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Want.encodingLength = encodingLength\n  Want.encode = encode\n  Want.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnwant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unwant.encodingLength = encodingLength\n  Unwant.encode = encode\n  Unwant.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineRequest () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Request.encodingLength = encodingLength\n  Request.encode = encode\n  Request.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      var len = enc[0].encodingLength(obj.nodes)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.nodes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false,\n      nodes: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.nodes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineCancel () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Cancel.encodingLength = encodingLength\n  Cancel.encode = encode\n  Cancel.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineData () {\n  var Node = Data.Node = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineNode()\n\n  function defineNode () {\n    var enc = [\n      encodings.varint,\n      encodings.bytes\n    ]\n\n    Node.encodingLength = encodingLength\n    Node.encode = encode\n    Node.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      var len = enc[0].encodingLength(obj.index)\n      length += 1 + len\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      buf[offset++] = 8\n      enc[0].encode(obj.index, buf, offset)\n      offset += enc[0].encode.bytes\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      buf[offset++] = 18\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      buf[offset++] = 24\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        index: 0,\n        hash: null,\n        size: 0\n      }\n      var found0 = false\n      var found1 = false\n      var found2 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1 || !found2) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.index = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.hash = enc[1].decode(buf, offset)\n          offset += enc[1].decode.bytes\n          found1 = true\n          break\n          case 3:\n          obj.size = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found2 = true\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    Node\n  ]\n\n  Data.encodingLength = encodingLength\n  Data.encode = encode\n  Data.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        var len = enc[2].encodingLength(obj.nodes[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    if (defined(obj.signature)) {\n      var len = enc[1].encodingLength(obj.signature)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        buf[offset++] = 26\n        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset)\n        offset += varint.encode.bytes\n        enc[2].encode(obj.nodes[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.signature)) {\n      buf[offset++] = 34\n      enc[1].encode(obj.signature, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      value: null,\n      nodes: [],\n      signature: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.nodes.push(enc[2].decode(buf, offset, offset + len))\n        offset += enc[2].decode.bytes\n        break\n        case 4:\n        obj.signature = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineClose () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Close.encodingLength = encodingLength\n  Close.encode = encode\n  Close.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.discoveryKey)) {\n      var len = enc[0].encodingLength(obj.discoveryKey)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.discoveryKey)) {\n      buf[offset++] = 10\n      enc[0].encode(obj.discoveryKey, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n","start":1670465470278,"end":1670465470278,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as messages } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js?commonjs-proxy\";\n\nvar Close_1;\nvar Data_1;\nvar Cancel_1;\nvar Request_1;\nvar Unwant_1;\nvar Want_1;\nvar Unhave_1;\nvar Have_1;\nvar Status_1;\nvar Options_1;\nvar Open_1;\nvar NoisePayload_1;\n// This file is auto generated by the protocol-buffers compiler\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n/* eslint-disable camelcase */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require$$0\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar NoisePayload = NoisePayload_1 = messages.NoisePayload = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Open = Open_1 = messages.Open = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Options = Options_1 = messages.Options = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Status = Status_1 = messages.Status = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Have = Have_1 = messages.Have = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unhave = Unhave_1 = messages.Unhave = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Want = Want_1 = messages.Want = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unwant = Unwant_1 = messages.Unwant = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Request = Request_1 = messages.Request = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Cancel = Cancel_1 = messages.Cancel = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Data = Data_1 = messages.Data = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Close = Close_1 = messages.Close = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineNoisePayload()\ndefineOpen()\ndefineOptions()\ndefineStatus()\ndefineHave()\ndefineUnhave()\ndefineWant()\ndefineUnwant()\ndefineRequest()\ndefineCancel()\ndefineData()\ndefineClose()\n\nfunction defineNoisePayload () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  NoisePayload.encodingLength = encodingLength\n  NoisePayload.encode = encode\n  NoisePayload.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    var len = enc[0].encodingLength(obj.nonce)\n    length += 1 + len\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.nonce, buf, offset)\n    offset += enc[0].encode.bytes\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      nonce: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.nonce = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOpen () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Open.encodingLength = encodingLength\n  Open.encode = encode\n  Open.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    var len = enc[0].encodingLength(obj.discoveryKey)\n    length += 1 + len\n    if (defined(obj.capability)) {\n      var len = enc[0].encodingLength(obj.capability)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.discoveryKey, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.capability)) {\n      buf[offset++] = 18\n      enc[0].encode(obj.capability, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null,\n      capability: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.capability = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOptions () {\n  var enc = [\n    encodings.string,\n    encodings.bool\n  ]\n\n  Options.encodingLength = encodingLength\n  Options.encode = encode\n  Options.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        var len = enc[0].encodingLength(obj.extensions[i])\n        length += 1 + len\n      }\n    }\n    if (defined(obj.ack)) {\n      var len = enc[1].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        buf[offset++] = 10\n        enc[0].encode(obj.extensions[i], buf, offset)\n        offset += enc[0].encode.bytes\n      }\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 16\n      enc[1].encode(obj.ack, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      extensions: [],\n      ack: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.extensions.push(enc[0].decode(buf, offset))\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.ack = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineStatus () {\n  var enc = [\n    encodings.bool\n  ]\n\n  Status.encodingLength = encodingLength\n  Status.encode = encode\n  Status.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.uploading)) {\n      var len = enc[0].encodingLength(obj.uploading)\n      length += 1 + len\n    }\n    if (defined(obj.downloading)) {\n      var len = enc[0].encodingLength(obj.downloading)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.uploading)) {\n      buf[offset++] = 8\n      enc[0].encode(obj.uploading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.downloading)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.downloading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      uploading: false,\n      downloading: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.uploading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.downloading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHave () {\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    encodings.bool\n  ]\n\n  Have.encodingLength = encodingLength\n  Have.encode = encode\n  Have.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    if (defined(obj.bitfield)) {\n      var len = enc[1].encodingLength(obj.bitfield)\n      length += 1 + len\n    }\n    if (defined(obj.ack)) {\n      var len = enc[2].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.bitfield)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.bitfield, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 32\n      enc[2].encode(obj.ack, buf, offset)\n      offset += enc[2].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1,\n      bitfield: null,\n      ack: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.bitfield = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.ack = enc[2].decode(buf, offset)\n        offset += enc[2].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnhave () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unhave.encodingLength = encodingLength\n  Unhave.encode = encode\n  Unhave.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineWant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Want.encodingLength = encodingLength\n  Want.encode = encode\n  Want.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnwant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unwant.encodingLength = encodingLength\n  Unwant.encode = encode\n  Unwant.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineRequest () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Request.encodingLength = encodingLength\n  Request.encode = encode\n  Request.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      var len = enc[0].encodingLength(obj.nodes)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.nodes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false,\n      nodes: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.nodes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineCancel () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Cancel.encodingLength = encodingLength\n  Cancel.encode = encode\n  Cancel.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineData () {\n  var Node = Data.Node = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineNode()\n\n  function defineNode () {\n    var enc = [\n      encodings.varint,\n      encodings.bytes\n    ]\n\n    Node.encodingLength = encodingLength\n    Node.encode = encode\n    Node.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      var len = enc[0].encodingLength(obj.index)\n      length += 1 + len\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      buf[offset++] = 8\n      enc[0].encode(obj.index, buf, offset)\n      offset += enc[0].encode.bytes\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      buf[offset++] = 18\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      buf[offset++] = 24\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        index: 0,\n        hash: null,\n        size: 0\n      }\n      var found0 = false\n      var found1 = false\n      var found2 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1 || !found2) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.index = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.hash = enc[1].decode(buf, offset)\n          offset += enc[1].decode.bytes\n          found1 = true\n          break\n          case 3:\n          obj.size = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found2 = true\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    Node\n  ]\n\n  Data.encodingLength = encodingLength\n  Data.encode = encode\n  Data.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        var len = enc[2].encodingLength(obj.nodes[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    if (defined(obj.signature)) {\n      var len = enc[1].encodingLength(obj.signature)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        buf[offset++] = 26\n        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset)\n        offset += varint.encode.bytes\n        enc[2].encode(obj.nodes[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.signature)) {\n      buf[offset++] = 34\n      enc[1].encode(obj.signature, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      value: null,\n      nodes: [],\n      signature: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.nodes.push(enc[2].decode(buf, offset, offset + len))\n        offset += enc[2].decode.bytes\n        break\n        case 4:\n        obj.signature = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineClose () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Close.encodingLength = encodingLength\n  Close.encode = encode\n  Close.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.discoveryKey)) {\n      var len = enc[0].encodingLength(obj.discoveryKey)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.discoveryKey)) {\n      buf[offset++] = 10\n      enc[0].encode(obj.discoveryKey, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n\nexport { messages as __moduleExports, NoisePayload_1 as NoisePayload, Open_1 as Open, Options_1 as Options, Status_1 as Status, Have_1 as Have, Unhave_1 as Unhave, Want_1 as Want, Unwant_1 as Unwant, Request_1 as Request, Cancel_1 as Cancel, Data_1 as Data, Close_1 as Close, messages as default };","start":1670465470278,"end":1670465471636,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as messages } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/simple-hypercore-protocol@2.1.2/node_modules/simple-hypercore-protocol/messages.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protocol-buffers-encodings@1.2.0/node_modules/protocol-buffers-encodings/index.js?commonjs-proxy\";\n\nvar Close_1;\nvar Data_1;\nvar Cancel_1;\nvar Request_1;\nvar Unwant_1;\nvar Want_1;\nvar Unhave_1;\nvar Have_1;\nvar Status_1;\nvar Options_1;\nvar Open_1;\nvar NoisePayload_1;\n// This file is auto generated by the protocol-buffers compiler\n\n/* eslint-disable quotes */\n/* eslint-disable indent */\n/* eslint-disable no-redeclare */\n/* eslint-disable camelcase */\n\n// Remember to `npm install --save protocol-buffers-encodings`\nvar encodings = require$$0\nvar varint = encodings.varint\nvar skip = encodings.skip\n\nvar NoisePayload = NoisePayload_1 = messages.NoisePayload = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Open = Open_1 = messages.Open = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Options = Options_1 = messages.Options = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Status = Status_1 = messages.Status = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Have = Have_1 = messages.Have = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unhave = Unhave_1 = messages.Unhave = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Want = Want_1 = messages.Want = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Unwant = Unwant_1 = messages.Unwant = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Request = Request_1 = messages.Request = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Cancel = Cancel_1 = messages.Cancel = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Data = Data_1 = messages.Data = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\nvar Close = Close_1 = messages.Close = {\n  buffer: true,\n  encodingLength: null,\n  encode: null,\n  decode: null\n}\n\ndefineNoisePayload()\ndefineOpen()\ndefineOptions()\ndefineStatus()\ndefineHave()\ndefineUnhave()\ndefineWant()\ndefineUnwant()\ndefineRequest()\ndefineCancel()\ndefineData()\ndefineClose()\n\nfunction defineNoisePayload () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  NoisePayload.encodingLength = encodingLength\n  NoisePayload.encode = encode\n  NoisePayload.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    var len = enc[0].encodingLength(obj.nonce)\n    length += 1 + len\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.nonce)) throw new Error(\"nonce is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.nonce, buf, offset)\n    offset += enc[0].encode.bytes\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      nonce: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.nonce = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOpen () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Open.encodingLength = encodingLength\n  Open.encode = encode\n  Open.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    var len = enc[0].encodingLength(obj.discoveryKey)\n    length += 1 + len\n    if (defined(obj.capability)) {\n      var len = enc[0].encodingLength(obj.capability)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.discoveryKey)) throw new Error(\"discoveryKey is required\")\n    buf[offset++] = 10\n    enc[0].encode(obj.discoveryKey, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.capability)) {\n      buf[offset++] = 18\n      enc[0].encode(obj.capability, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null,\n      capability: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.capability = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineOptions () {\n  var enc = [\n    encodings.string,\n    encodings.bool\n  ]\n\n  Options.encodingLength = encodingLength\n  Options.encode = encode\n  Options.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        var len = enc[0].encodingLength(obj.extensions[i])\n        length += 1 + len\n      }\n    }\n    if (defined(obj.ack)) {\n      var len = enc[1].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.extensions)) {\n      for (var i = 0; i < obj.extensions.length; i++) {\n        if (!defined(obj.extensions[i])) continue\n        buf[offset++] = 10\n        enc[0].encode(obj.extensions[i], buf, offset)\n        offset += enc[0].encode.bytes\n      }\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 16\n      enc[1].encode(obj.ack, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      extensions: [],\n      ack: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.extensions.push(enc[0].decode(buf, offset))\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.ack = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineStatus () {\n  var enc = [\n    encodings.bool\n  ]\n\n  Status.encodingLength = encodingLength\n  Status.encode = encode\n  Status.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.uploading)) {\n      var len = enc[0].encodingLength(obj.uploading)\n      length += 1 + len\n    }\n    if (defined(obj.downloading)) {\n      var len = enc[0].encodingLength(obj.downloading)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.uploading)) {\n      buf[offset++] = 8\n      enc[0].encode(obj.uploading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.downloading)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.downloading, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      uploading: false,\n      downloading: false\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.uploading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 2:\n        obj.downloading = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineHave () {\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    encodings.bool\n  ]\n\n  Have.encodingLength = encodingLength\n  Have.encode = encode\n  Have.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    if (defined(obj.bitfield)) {\n      var len = enc[1].encodingLength(obj.bitfield)\n      length += 1 + len\n    }\n    if (defined(obj.ack)) {\n      var len = enc[2].encodingLength(obj.ack)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.bitfield)) {\n      buf[offset++] = 26\n      enc[1].encode(obj.bitfield, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.ack)) {\n      buf[offset++] = 32\n      enc[2].encode(obj.ack, buf, offset)\n      offset += enc[2].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1,\n      bitfield: null,\n      ack: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.bitfield = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.ack = enc[2].decode(buf, offset)\n        offset += enc[2].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnhave () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unhave.encodingLength = encodingLength\n  Unhave.encode = encode\n  Unhave.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 1\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineWant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Want.encodingLength = encodingLength\n  Want.encode = encode\n  Want.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineUnwant () {\n  var enc = [\n    encodings.varint\n  ]\n\n  Unwant.encodingLength = encodingLength\n  Unwant.encode = encode\n  Unwant.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    var len = enc[0].encodingLength(obj.start)\n    length += 1 + len\n    if (defined(obj.length)) {\n      var len = enc[0].encodingLength(obj.length)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.start)) throw new Error(\"start is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.start, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.length)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.length, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      start: 0,\n      length: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.start = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.length = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineRequest () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Request.encodingLength = encodingLength\n  Request.encode = encode\n  Request.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      var len = enc[0].encodingLength(obj.nodes)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      buf[offset++] = 32\n      enc[0].encode(obj.nodes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false,\n      nodes: 0\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 4:\n        obj.nodes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineCancel () {\n  var enc = [\n    encodings.varint,\n    encodings.bool\n  ]\n\n  Cancel.encodingLength = encodingLength\n  Cancel.encode = encode\n  Cancel.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.bytes)) {\n      var len = enc[0].encodingLength(obj.bytes)\n      length += 1 + len\n    }\n    if (defined(obj.hash)) {\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.bytes)) {\n      buf[offset++] = 16\n      enc[0].encode(obj.bytes, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    if (defined(obj.hash)) {\n      buf[offset++] = 24\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      bytes: 0,\n      hash: false\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.bytes = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        case 3:\n        obj.hash = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineData () {\n  var Node = Data.Node = {\n    buffer: true,\n    encodingLength: null,\n    encode: null,\n    decode: null\n  }\n\n  defineNode()\n\n  function defineNode () {\n    var enc = [\n      encodings.varint,\n      encodings.bytes\n    ]\n\n    Node.encodingLength = encodingLength\n    Node.encode = encode\n    Node.decode = decode\n\n    function encodingLength (obj) {\n      var length = 0\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      var len = enc[0].encodingLength(obj.index)\n      length += 1 + len\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      var len = enc[1].encodingLength(obj.hash)\n      length += 1 + len\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      var len = enc[0].encodingLength(obj.size)\n      length += 1 + len\n      return length\n    }\n\n    function encode (obj, buf, offset) {\n      if (!offset) offset = 0\n      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n      var oldOffset = offset\n      if (!defined(obj.index)) throw new Error(\"index is required\")\n      buf[offset++] = 8\n      enc[0].encode(obj.index, buf, offset)\n      offset += enc[0].encode.bytes\n      if (!defined(obj.hash)) throw new Error(\"hash is required\")\n      buf[offset++] = 18\n      enc[1].encode(obj.hash, buf, offset)\n      offset += enc[1].encode.bytes\n      if (!defined(obj.size)) throw new Error(\"size is required\")\n      buf[offset++] = 24\n      enc[0].encode(obj.size, buf, offset)\n      offset += enc[0].encode.bytes\n      encode.bytes = offset - oldOffset\n      return buf\n    }\n\n    function decode (buf, offset, end) {\n      if (!offset) offset = 0\n      if (!end) end = buf.length\n      if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n      var oldOffset = offset\n      var obj = {\n        index: 0,\n        hash: null,\n        size: 0\n      }\n      var found0 = false\n      var found1 = false\n      var found2 = false\n      while (true) {\n        if (end <= offset) {\n          if (!found0 || !found1 || !found2) throw new Error(\"Decoded message is not valid\")\n          decode.bytes = offset - oldOffset\n          return obj\n        }\n        var prefix = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        var tag = prefix >> 3\n        switch (tag) {\n          case 1:\n          obj.index = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found0 = true\n          break\n          case 2:\n          obj.hash = enc[1].decode(buf, offset)\n          offset += enc[1].decode.bytes\n          found1 = true\n          break\n          case 3:\n          obj.size = enc[0].decode(buf, offset)\n          offset += enc[0].decode.bytes\n          found2 = true\n          break\n          default:\n          offset = skip(prefix & 7, buf, offset)\n        }\n      }\n    }\n  }\n\n  var enc = [\n    encodings.varint,\n    encodings.bytes,\n    Node\n  ]\n\n  Data.encodingLength = encodingLength\n  Data.encode = encode\n  Data.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    var len = enc[0].encodingLength(obj.index)\n    length += 1 + len\n    if (defined(obj.value)) {\n      var len = enc[1].encodingLength(obj.value)\n      length += 1 + len\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        var len = enc[2].encodingLength(obj.nodes[i])\n        length += varint.encodingLength(len)\n        length += 1 + len\n      }\n    }\n    if (defined(obj.signature)) {\n      var len = enc[1].encodingLength(obj.signature)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (!defined(obj.index)) throw new Error(\"index is required\")\n    buf[offset++] = 8\n    enc[0].encode(obj.index, buf, offset)\n    offset += enc[0].encode.bytes\n    if (defined(obj.value)) {\n      buf[offset++] = 18\n      enc[1].encode(obj.value, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    if (defined(obj.nodes)) {\n      for (var i = 0; i < obj.nodes.length; i++) {\n        if (!defined(obj.nodes[i])) continue\n        buf[offset++] = 26\n        varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset)\n        offset += varint.encode.bytes\n        enc[2].encode(obj.nodes[i], buf, offset)\n        offset += enc[2].encode.bytes\n      }\n    }\n    if (defined(obj.signature)) {\n      buf[offset++] = 34\n      enc[1].encode(obj.signature, buf, offset)\n      offset += enc[1].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      index: 0,\n      value: null,\n      nodes: [],\n      signature: null\n    }\n    var found0 = false\n    while (true) {\n      if (end <= offset) {\n        if (!found0) throw new Error(\"Decoded message is not valid\")\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.index = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        found0 = true\n        break\n        case 2:\n        obj.value = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        case 3:\n        var len = varint.decode(buf, offset)\n        offset += varint.decode.bytes\n        obj.nodes.push(enc[2].decode(buf, offset, offset + len))\n        offset += enc[2].decode.bytes\n        break\n        case 4:\n        obj.signature = enc[1].decode(buf, offset)\n        offset += enc[1].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defineClose () {\n  var enc = [\n    encodings.bytes\n  ]\n\n  Close.encodingLength = encodingLength\n  Close.encode = encode\n  Close.decode = decode\n\n  function encodingLength (obj) {\n    var length = 0\n    if (defined(obj.discoveryKey)) {\n      var len = enc[0].encodingLength(obj.discoveryKey)\n      length += 1 + len\n    }\n    return length\n  }\n\n  function encode (obj, buf, offset) {\n    if (!offset) offset = 0\n    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))\n    var oldOffset = offset\n    if (defined(obj.discoveryKey)) {\n      buf[offset++] = 10\n      enc[0].encode(obj.discoveryKey, buf, offset)\n      offset += enc[0].encode.bytes\n    }\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n\n  function decode (buf, offset, end) {\n    if (!offset) offset = 0\n    if (!end) end = buf.length\n    if (!(end <= buf.length && offset <= buf.length)) throw new Error(\"Decoded message is not valid\")\n    var oldOffset = offset\n    var obj = {\n      discoveryKey: null\n    }\n    while (true) {\n      if (end <= offset) {\n        decode.bytes = offset - oldOffset\n        return obj\n      }\n      var prefix = varint.decode(buf, offset)\n      offset += varint.decode.bytes\n      var tag = prefix >> 3\n      switch (tag) {\n        case 1:\n        obj.discoveryKey = enc[0].decode(buf, offset)\n        offset += enc[0].decode.bytes\n        break\n        default:\n        offset = skip(prefix & 7, buf, offset)\n      }\n    }\n  }\n}\n\nfunction defined (val) {\n  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))\n}\n\nexport { messages as __moduleExports, NoisePayload_1 as NoisePayload, Open_1 as Open, Options_1 as Options, Status_1 as Status, Have_1 as Have, Unhave_1 as Unhave, Want_1 as Want, Unwant_1 as Unwant, Request_1 as Request, Cancel_1 as Cancel, Data_1 as Data, Close_1 as Close, messages as default };","start":1670465471637,"end":1670465471648,"order":"normal"}]}
