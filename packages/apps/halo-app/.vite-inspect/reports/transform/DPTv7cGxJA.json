{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/sha3.js","transforms":[{"name":"vite:load-fallback","result":";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));","start":1670465468960,"end":1670465469118},{"name":"vite:react-babel","result":";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./x64-core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./x64-core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));","start":1670465469118,"end":1670465469118,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as sha3Module, exports as sha3 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/sha3.js?commonjs-module\"\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/core.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/x64-core.js?commonjs-wrapped\";\n\nvar hasRequiredSha3;\n\nfunction requireSha3 () {\n\tif (hasRequiredSha3) return sha3;\n\thasRequiredSha3 = 1;\n\t(function (module, exports) {\n\t\t;(function (root, factory, undef) {\n\t\t\tif ('object' === \"object\") {\n\t\t\t\t// CommonJS\n\t\t\t\tmodule.exports = exports = factory(require$$0(), require$$1());\n\t\t\t}\n\t\t\telse if (typeof undefined === \"function\" && undefined.amd) {\n\t\t\t\t// AMD\n\t\t\t\tundefined([\"./core\", \"./x64-core\"], factory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Global (browser)\n\t\t\t\tfactory(root.CryptoJS);\n\t\t\t}\n\t\t}(commonjsHelpers.commonjsGlobal, function (CryptoJS) {\n\n\t\t\t(function (Math) {\n\t\t\t    // Shortcuts\n\t\t\t    var C = CryptoJS;\n\t\t\t    var C_lib = C.lib;\n\t\t\t    var WordArray = C_lib.WordArray;\n\t\t\t    var Hasher = C_lib.Hasher;\n\t\t\t    var C_x64 = C.x64;\n\t\t\t    var X64Word = C_x64.Word;\n\t\t\t    var C_algo = C.algo;\n\n\t\t\t    // Constants tables\n\t\t\t    var RHO_OFFSETS = [];\n\t\t\t    var PI_INDEXES  = [];\n\t\t\t    var ROUND_CONSTANTS = [];\n\n\t\t\t    // Compute Constants\n\t\t\t    (function () {\n\t\t\t        // Compute rho offset constants\n\t\t\t        var x = 1, y = 0;\n\t\t\t        for (var t = 0; t < 24; t++) {\n\t\t\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t\t\t            var newX = y % 5;\n\t\t\t            var newY = (2 * x + 3 * y) % 5;\n\t\t\t            x = newX;\n\t\t\t            y = newY;\n\t\t\t        }\n\n\t\t\t        // Compute pi index constants\n\t\t\t        for (var x = 0; x < 5; x++) {\n\t\t\t            for (var y = 0; y < 5; y++) {\n\t\t\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t\t\t            }\n\t\t\t        }\n\n\t\t\t        // Compute round constants\n\t\t\t        var LFSR = 0x01;\n\t\t\t        for (var i = 0; i < 24; i++) {\n\t\t\t            var roundConstantMsw = 0;\n\t\t\t            var roundConstantLsw = 0;\n\n\t\t\t            for (var j = 0; j < 7; j++) {\n\t\t\t                if (LFSR & 0x01) {\n\t\t\t                    var bitPosition = (1 << j) - 1;\n\t\t\t                    if (bitPosition < 32) {\n\t\t\t                        roundConstantLsw ^= 1 << bitPosition;\n\t\t\t                    } else /* if (bitPosition >= 32) */ {\n\t\t\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Compute next LFSR\n\t\t\t                if (LFSR & 0x80) {\n\t\t\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t\t\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t\t\t                } else {\n\t\t\t                    LFSR <<= 1;\n\t\t\t                }\n\t\t\t            }\n\n\t\t\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t\t\t        }\n\t\t\t    }());\n\n\t\t\t    // Reusable objects for temporary values\n\t\t\t    var T = [];\n\t\t\t    (function () {\n\t\t\t        for (var i = 0; i < 25; i++) {\n\t\t\t            T[i] = X64Word.create();\n\t\t\t        }\n\t\t\t    }());\n\n\t\t\t    /**\n\t\t\t     * SHA-3 hash algorithm.\n\t\t\t     */\n\t\t\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t\t\t        /**\n\t\t\t         * Configuration options.\n\t\t\t         *\n\t\t\t         * @property {number} outputLength\n\t\t\t         *   The desired number of bits in the output hash.\n\t\t\t         *   Only values permitted are: 224, 256, 384, 512.\n\t\t\t         *   Default: 512\n\t\t\t         */\n\t\t\t        cfg: Hasher.cfg.extend({\n\t\t\t            outputLength: 512\n\t\t\t        }),\n\n\t\t\t        _doReset: function () {\n\t\t\t            var state = this._state = []\n\t\t\t            for (var i = 0; i < 25; i++) {\n\t\t\t                state[i] = new X64Word.init();\n\t\t\t            }\n\n\t\t\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t\t\t        },\n\n\t\t\t        _doProcessBlock: function (M, offset) {\n\t\t\t            // Shortcuts\n\t\t\t            var state = this._state;\n\t\t\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t\t\t            // Absorb\n\t\t\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t\t\t                // Shortcuts\n\t\t\t                var M2i  = M[offset + 2 * i];\n\t\t\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t\t\t                // Swap endian\n\t\t\t                M2i = (\n\t\t\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\t\t\t                M2i1 = (\n\t\t\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\n\t\t\t                // Absorb message into state\n\t\t\t                var lane = state[i];\n\t\t\t                lane.high ^= M2i1;\n\t\t\t                lane.low  ^= M2i;\n\t\t\t            }\n\n\t\t\t            // Rounds\n\t\t\t            for (var round = 0; round < 24; round++) {\n\t\t\t                // Theta\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    // Mix column lanes\n\t\t\t                    var tMsw = 0, tLsw = 0;\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        var lane = state[x + 5 * y];\n\t\t\t                        tMsw ^= lane.high;\n\t\t\t                        tLsw ^= lane.low;\n\t\t\t                    }\n\n\t\t\t                    // Temporary values\n\t\t\t                    var Tx = T[x];\n\t\t\t                    Tx.high = tMsw;\n\t\t\t                    Tx.low  = tLsw;\n\t\t\t                }\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    // Shortcuts\n\t\t\t                    var Tx4 = T[(x + 4) % 5];\n\t\t\t                    var Tx1 = T[(x + 1) % 5];\n\t\t\t                    var Tx1Msw = Tx1.high;\n\t\t\t                    var Tx1Lsw = Tx1.low;\n\n\t\t\t                    // Mix surrounding columns\n\t\t\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t\t\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        var lane = state[x + 5 * y];\n\t\t\t                        lane.high ^= tMsw;\n\t\t\t                        lane.low  ^= tLsw;\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Rho Pi\n\t\t\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t\t\t                    // Shortcuts\n\t\t\t                    var lane = state[laneIndex];\n\t\t\t                    var laneMsw = lane.high;\n\t\t\t                    var laneLsw = lane.low;\n\t\t\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t\t\t                    // Rotate lanes\n\t\t\t                    if (rhoOffset < 32) {\n\t\t\t                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t\t\t                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t\t\t                    } else /* if (rhoOffset >= 32) */ {\n\t\t\t                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t\t\t                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t\t\t                    }\n\n\t\t\t                    // Transpose lanes\n\t\t\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t\t\t                    TPiLane.high = tMsw;\n\t\t\t                    TPiLane.low  = tLsw;\n\t\t\t                }\n\n\t\t\t                // Rho pi at x = y = 0\n\t\t\t                var T0 = T[0];\n\t\t\t                var state0 = state[0];\n\t\t\t                T0.high = state0.high;\n\t\t\t                T0.low  = state0.low;\n\n\t\t\t                // Chi\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        // Shortcuts\n\t\t\t                        var laneIndex = x + 5 * y;\n\t\t\t                        var lane = state[laneIndex];\n\t\t\t                        var TLane = T[laneIndex];\n\t\t\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t\t\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t\t\t                        // Mix rows\n\t\t\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t\t\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Iota\n\t\t\t                var lane = state[0];\n\t\t\t                var roundConstant = ROUND_CONSTANTS[round];\n\t\t\t                lane.high ^= roundConstant.high;\n\t\t\t                lane.low  ^= roundConstant.low;;\n\t\t\t            }\n\t\t\t        },\n\n\t\t\t        _doFinalize: function () {\n\t\t\t            // Shortcuts\n\t\t\t            var data = this._data;\n\t\t\t            var dataWords = data.words;\n\t\t\t            var nBitsTotal = this._nDataBytes * 8;\n\t\t\t            var nBitsLeft = data.sigBytes * 8;\n\t\t\t            var blockSizeBits = this.blockSize * 32;\n\n\t\t\t            // Add padding\n\t\t\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t\t\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t\t\t            data.sigBytes = dataWords.length * 4;\n\n\t\t\t            // Hash final blocks\n\t\t\t            this._process();\n\n\t\t\t            // Shortcuts\n\t\t\t            var state = this._state;\n\t\t\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t\t\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t\t\t            // Squeeze\n\t\t\t            var hashWords = [];\n\t\t\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t\t\t                // Shortcuts\n\t\t\t                var lane = state[i];\n\t\t\t                var laneMsw = lane.high;\n\t\t\t                var laneLsw = lane.low;\n\n\t\t\t                // Swap endian\n\t\t\t                laneMsw = (\n\t\t\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\t\t\t                laneLsw = (\n\t\t\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\n\t\t\t                // Squeeze state to retrieve hash\n\t\t\t                hashWords.push(laneLsw);\n\t\t\t                hashWords.push(laneMsw);\n\t\t\t            }\n\n\t\t\t            // Return final computed hash\n\t\t\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t\t\t        },\n\n\t\t\t        clone: function () {\n\t\t\t            var clone = Hasher.clone.call(this);\n\n\t\t\t            var state = clone._state = this._state.slice(0);\n\t\t\t            for (var i = 0; i < 25; i++) {\n\t\t\t                state[i] = state[i].clone();\n\t\t\t            }\n\n\t\t\t            return clone;\n\t\t\t        }\n\t\t\t    });\n\n\t\t\t    /**\n\t\t\t     * Shortcut function to the hasher's object interface.\n\t\t\t     *\n\t\t\t     * @param {WordArray|string} message The message to hash.\n\t\t\t     *\n\t\t\t     * @return {WordArray} The hash.\n\t\t\t     *\n\t\t\t     * @static\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     *\n\t\t\t     *     var hash = CryptoJS.SHA3('message');\n\t\t\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t\t\t     */\n\t\t\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t\t\t    /**\n\t\t\t     * Shortcut function to the HMAC's object interface.\n\t\t\t     *\n\t\t\t     * @param {WordArray|string} message The message to hash.\n\t\t\t     * @param {WordArray|string} key The secret key.\n\t\t\t     *\n\t\t\t     * @return {WordArray} The HMAC.\n\t\t\t     *\n\t\t\t     * @static\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     *\n\t\t\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t\t\t     */\n\t\t\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t\t\t}(Math));\n\n\n\t\t\treturn CryptoJS.SHA3;\n\n\t\t}));\n} (sha3Module, sha3));\n\treturn sha3;\n}\n\nexport { requireSha3 as __require };","start":1670465469119,"end":1670465469124,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as sha3Module, exports as sha3 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/sha3.js?commonjs-module\"\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/core.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/crypto-js@3.3.0/node_modules/crypto-js/x64-core.js?commonjs-wrapped\";\n\nvar hasRequiredSha3;\n\nfunction requireSha3 () {\n\tif (hasRequiredSha3) return sha3;\n\thasRequiredSha3 = 1;\n\t(function (module, exports) {\n\t\t;(function (root, factory, undef) {\n\t\t\tif ('object' === \"object\") {\n\t\t\t\t// CommonJS\n\t\t\t\tmodule.exports = exports = factory(require$$0(), require$$1());\n\t\t\t}\n\t\t\telse if (typeof undefined === \"function\" && undefined.amd) {\n\t\t\t\t// AMD\n\t\t\t\tundefined([\"./core\", \"./x64-core\"], factory);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Global (browser)\n\t\t\t\tfactory(root.CryptoJS);\n\t\t\t}\n\t\t}(commonjsHelpers.commonjsGlobal, function (CryptoJS) {\n\n\t\t\t(function (Math) {\n\t\t\t    // Shortcuts\n\t\t\t    var C = CryptoJS;\n\t\t\t    var C_lib = C.lib;\n\t\t\t    var WordArray = C_lib.WordArray;\n\t\t\t    var Hasher = C_lib.Hasher;\n\t\t\t    var C_x64 = C.x64;\n\t\t\t    var X64Word = C_x64.Word;\n\t\t\t    var C_algo = C.algo;\n\n\t\t\t    // Constants tables\n\t\t\t    var RHO_OFFSETS = [];\n\t\t\t    var PI_INDEXES  = [];\n\t\t\t    var ROUND_CONSTANTS = [];\n\n\t\t\t    // Compute Constants\n\t\t\t    (function () {\n\t\t\t        // Compute rho offset constants\n\t\t\t        var x = 1, y = 0;\n\t\t\t        for (var t = 0; t < 24; t++) {\n\t\t\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t\t\t            var newX = y % 5;\n\t\t\t            var newY = (2 * x + 3 * y) % 5;\n\t\t\t            x = newX;\n\t\t\t            y = newY;\n\t\t\t        }\n\n\t\t\t        // Compute pi index constants\n\t\t\t        for (var x = 0; x < 5; x++) {\n\t\t\t            for (var y = 0; y < 5; y++) {\n\t\t\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t\t\t            }\n\t\t\t        }\n\n\t\t\t        // Compute round constants\n\t\t\t        var LFSR = 0x01;\n\t\t\t        for (var i = 0; i < 24; i++) {\n\t\t\t            var roundConstantMsw = 0;\n\t\t\t            var roundConstantLsw = 0;\n\n\t\t\t            for (var j = 0; j < 7; j++) {\n\t\t\t                if (LFSR & 0x01) {\n\t\t\t                    var bitPosition = (1 << j) - 1;\n\t\t\t                    if (bitPosition < 32) {\n\t\t\t                        roundConstantLsw ^= 1 << bitPosition;\n\t\t\t                    } else /* if (bitPosition >= 32) */ {\n\t\t\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Compute next LFSR\n\t\t\t                if (LFSR & 0x80) {\n\t\t\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t\t\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t\t\t                } else {\n\t\t\t                    LFSR <<= 1;\n\t\t\t                }\n\t\t\t            }\n\n\t\t\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t\t\t        }\n\t\t\t    }());\n\n\t\t\t    // Reusable objects for temporary values\n\t\t\t    var T = [];\n\t\t\t    (function () {\n\t\t\t        for (var i = 0; i < 25; i++) {\n\t\t\t            T[i] = X64Word.create();\n\t\t\t        }\n\t\t\t    }());\n\n\t\t\t    /**\n\t\t\t     * SHA-3 hash algorithm.\n\t\t\t     */\n\t\t\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t\t\t        /**\n\t\t\t         * Configuration options.\n\t\t\t         *\n\t\t\t         * @property {number} outputLength\n\t\t\t         *   The desired number of bits in the output hash.\n\t\t\t         *   Only values permitted are: 224, 256, 384, 512.\n\t\t\t         *   Default: 512\n\t\t\t         */\n\t\t\t        cfg: Hasher.cfg.extend({\n\t\t\t            outputLength: 512\n\t\t\t        }),\n\n\t\t\t        _doReset: function () {\n\t\t\t            var state = this._state = []\n\t\t\t            for (var i = 0; i < 25; i++) {\n\t\t\t                state[i] = new X64Word.init();\n\t\t\t            }\n\n\t\t\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t\t\t        },\n\n\t\t\t        _doProcessBlock: function (M, offset) {\n\t\t\t            // Shortcuts\n\t\t\t            var state = this._state;\n\t\t\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t\t\t            // Absorb\n\t\t\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t\t\t                // Shortcuts\n\t\t\t                var M2i  = M[offset + 2 * i];\n\t\t\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t\t\t                // Swap endian\n\t\t\t                M2i = (\n\t\t\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\t\t\t                M2i1 = (\n\t\t\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\n\t\t\t                // Absorb message into state\n\t\t\t                var lane = state[i];\n\t\t\t                lane.high ^= M2i1;\n\t\t\t                lane.low  ^= M2i;\n\t\t\t            }\n\n\t\t\t            // Rounds\n\t\t\t            for (var round = 0; round < 24; round++) {\n\t\t\t                // Theta\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    // Mix column lanes\n\t\t\t                    var tMsw = 0, tLsw = 0;\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        var lane = state[x + 5 * y];\n\t\t\t                        tMsw ^= lane.high;\n\t\t\t                        tLsw ^= lane.low;\n\t\t\t                    }\n\n\t\t\t                    // Temporary values\n\t\t\t                    var Tx = T[x];\n\t\t\t                    Tx.high = tMsw;\n\t\t\t                    Tx.low  = tLsw;\n\t\t\t                }\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    // Shortcuts\n\t\t\t                    var Tx4 = T[(x + 4) % 5];\n\t\t\t                    var Tx1 = T[(x + 1) % 5];\n\t\t\t                    var Tx1Msw = Tx1.high;\n\t\t\t                    var Tx1Lsw = Tx1.low;\n\n\t\t\t                    // Mix surrounding columns\n\t\t\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t\t\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        var lane = state[x + 5 * y];\n\t\t\t                        lane.high ^= tMsw;\n\t\t\t                        lane.low  ^= tLsw;\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Rho Pi\n\t\t\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t\t\t                    // Shortcuts\n\t\t\t                    var lane = state[laneIndex];\n\t\t\t                    var laneMsw = lane.high;\n\t\t\t                    var laneLsw = lane.low;\n\t\t\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t\t\t                    // Rotate lanes\n\t\t\t                    if (rhoOffset < 32) {\n\t\t\t                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t\t\t                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t\t\t                    } else /* if (rhoOffset >= 32) */ {\n\t\t\t                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t\t\t                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t\t\t                    }\n\n\t\t\t                    // Transpose lanes\n\t\t\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t\t\t                    TPiLane.high = tMsw;\n\t\t\t                    TPiLane.low  = tLsw;\n\t\t\t                }\n\n\t\t\t                // Rho pi at x = y = 0\n\t\t\t                var T0 = T[0];\n\t\t\t                var state0 = state[0];\n\t\t\t                T0.high = state0.high;\n\t\t\t                T0.low  = state0.low;\n\n\t\t\t                // Chi\n\t\t\t                for (var x = 0; x < 5; x++) {\n\t\t\t                    for (var y = 0; y < 5; y++) {\n\t\t\t                        // Shortcuts\n\t\t\t                        var laneIndex = x + 5 * y;\n\t\t\t                        var lane = state[laneIndex];\n\t\t\t                        var TLane = T[laneIndex];\n\t\t\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t\t\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t\t\t                        // Mix rows\n\t\t\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t\t\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t\t\t                    }\n\t\t\t                }\n\n\t\t\t                // Iota\n\t\t\t                var lane = state[0];\n\t\t\t                var roundConstant = ROUND_CONSTANTS[round];\n\t\t\t                lane.high ^= roundConstant.high;\n\t\t\t                lane.low  ^= roundConstant.low;;\n\t\t\t            }\n\t\t\t        },\n\n\t\t\t        _doFinalize: function () {\n\t\t\t            // Shortcuts\n\t\t\t            var data = this._data;\n\t\t\t            var dataWords = data.words;\n\t\t\t            var nBitsTotal = this._nDataBytes * 8;\n\t\t\t            var nBitsLeft = data.sigBytes * 8;\n\t\t\t            var blockSizeBits = this.blockSize * 32;\n\n\t\t\t            // Add padding\n\t\t\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t\t\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t\t\t            data.sigBytes = dataWords.length * 4;\n\n\t\t\t            // Hash final blocks\n\t\t\t            this._process();\n\n\t\t\t            // Shortcuts\n\t\t\t            var state = this._state;\n\t\t\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t\t\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t\t\t            // Squeeze\n\t\t\t            var hashWords = [];\n\t\t\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t\t\t                // Shortcuts\n\t\t\t                var lane = state[i];\n\t\t\t                var laneMsw = lane.high;\n\t\t\t                var laneLsw = lane.low;\n\n\t\t\t                // Swap endian\n\t\t\t                laneMsw = (\n\t\t\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\t\t\t                laneLsw = (\n\t\t\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t\t\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t\t\t                );\n\n\t\t\t                // Squeeze state to retrieve hash\n\t\t\t                hashWords.push(laneLsw);\n\t\t\t                hashWords.push(laneMsw);\n\t\t\t            }\n\n\t\t\t            // Return final computed hash\n\t\t\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t\t\t        },\n\n\t\t\t        clone: function () {\n\t\t\t            var clone = Hasher.clone.call(this);\n\n\t\t\t            var state = clone._state = this._state.slice(0);\n\t\t\t            for (var i = 0; i < 25; i++) {\n\t\t\t                state[i] = state[i].clone();\n\t\t\t            }\n\n\t\t\t            return clone;\n\t\t\t        }\n\t\t\t    });\n\n\t\t\t    /**\n\t\t\t     * Shortcut function to the hasher's object interface.\n\t\t\t     *\n\t\t\t     * @param {WordArray|string} message The message to hash.\n\t\t\t     *\n\t\t\t     * @return {WordArray} The hash.\n\t\t\t     *\n\t\t\t     * @static\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     *\n\t\t\t     *     var hash = CryptoJS.SHA3('message');\n\t\t\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t\t\t     */\n\t\t\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t\t\t    /**\n\t\t\t     * Shortcut function to the HMAC's object interface.\n\t\t\t     *\n\t\t\t     * @param {WordArray|string} message The message to hash.\n\t\t\t     * @param {WordArray|string} key The secret key.\n\t\t\t     *\n\t\t\t     * @return {WordArray} The HMAC.\n\t\t\t     *\n\t\t\t     * @static\n\t\t\t     *\n\t\t\t     * @example\n\t\t\t     *\n\t\t\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t\t\t     */\n\t\t\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t\t\t}(Math));\n\n\n\t\t\treturn CryptoJS.SHA3;\n\n\t\t}));\n} (sha3Module, sha3));\n\treturn sha3;\n}\n\nexport { requireSha3 as __require };","start":1670465469124,"end":1670465469127,"order":"normal"}]}
