{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/crypto_secretstream.js","transforms":[{"name":"vite:load-fallback","result":"/* eslint-disable camelcase */\nconst assert = require('nanoassert')\nconst { randombytes_buf } = require('./randombytes')\nconst {\n  crypto_stream_chacha20_ietf,\n  crypto_stream_chacha20_ietf_xor,\n  crypto_stream_chacha20_ietf_xor_ic,\n  crypto_stream_chacha20_ietf_KEYBYTES\n} = require('./crypto_stream_chacha20')\nconst { crypto_core_hchacha20, crypto_core_hchacha20_INPUTBYTES } = require('./internal/hchacha20')\nconst Poly1305 = require('./internal/poly1305')\nconst { sodium_increment, sodium_is_zero, sodium_memcmp } = require('./helpers')\n\nconst crypto_onetimeauth_poly1305_BYTES = 16\nconst crypto_secretstream_xchacha20poly1305_COUNTERBYTES = 4\nconst crypto_secretstream_xchacha20poly1305_INONCEBYTES = 8\nconst crypto_aead_xchacha20poly1305_ietf_KEYBYTES = 32\nconst crypto_secretstream_xchacha20poly1305_KEYBYTES = crypto_aead_xchacha20poly1305_ietf_KEYBYTES\nconst crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = 24\nconst crypto_secretstream_xchacha20poly1305_HEADERBYTES = crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\nconst crypto_aead_xchacha20poly1305_ietf_ABYTES = 16\nconst crypto_secretstream_xchacha20poly1305_ABYTES = 1 + crypto_aead_xchacha20poly1305_ietf_ABYTES\nconst crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_secretstream_xchacha20poly1305_TAGBYTES = 1\nconst crypto_secretstream_xchacha20poly1305_TAG_MESSAGE = new Uint8Array([0])\nconst crypto_secretstream_xchacha20poly1305_TAG_PUSH = new Uint8Array([1])\nconst crypto_secretstream_xchacha20poly1305_TAG_REKEY = new Uint8Array([2])\nconst crypto_secretstream_xchacha20poly1305_TAG_FINAL = new Uint8Array([crypto_secretstream_xchacha20poly1305_TAG_PUSH | crypto_secretstream_xchacha20poly1305_TAG_REKEY])\nconst crypto_secretstream_xchacha20poly1305_STATEBYTES = crypto_secretstream_xchacha20poly1305_KEYBYTES +\n  crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES + 8\n\nconst KEY_OFFSET = 0\nconst NONCE_OFFSET = crypto_secretstream_xchacha20poly1305_KEYBYTES\nconst PAD_OFFSET = NONCE_OFFSET + crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES\n\nconst _pad0 = new Uint8Array(16)\n\nfunction STORE64_LE (dest, int) {\n  let mul = 1\n  let i = 0\n  dest[0] = int & 0xFF\n  while (++i < 8 && (mul *= 0x100)) {\n    dest[i] = (int / mul) & 0xFF\n  }\n}\n\nfunction crypto_secretstream_xchacha20poly1305_counter_reset (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_COUNTERBYTES; i++) {\n    nonce[i] = 0\n  }\n  nonce[0] = 1\n}\n\nfunction crypto_secretstream_xchacha20poly1305_keygen (k) {\n  assert(k.length === crypto_secretstream_xchacha20poly1305_KEYBYTES)\n  randombytes_buf(k)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_push (state, out, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(out instanceof Uint8Array && out.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES, 'out not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES, 'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  randombytes_buf(out, crypto_secretstream_xchacha20poly1305_HEADERBYTES)\n  crypto_core_hchacha20(k, out, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = out[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_pull (state, _in, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(_in instanceof Uint8Array && _in.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    '_in not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  crypto_core_hchacha20(k, _in, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = _in[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_rekey (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const new_key_and_inonce = new Uint8Array(\n    crypto_stream_chacha20_ietf_KEYBYTES + crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  let i\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    new_key_and_inonce[i] = k[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i] =\n      nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i]\n  }\n  crypto_stream_chacha20_ietf_xor(new_key_and_inonce, new_key_and_inonce, nonce, k)\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    k[i] = new_key_and_inonce[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i] =\n      new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i]\n  }\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_push (state, out, m, ad, tag) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n\n  assert(crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX <=\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX)\n\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0)\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block[0] = tag[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  poly.update(block, 0, block.byteLength)\n  out[0] = block[0]\n\n  const c = out.subarray(1, out.byteLength)\n  crypto_stream_chacha20_ietf_xor_ic(c, m, nonce, 2, k)\n  poly.update(c, 0, m.byteLength)\n  poly.update(_pad0, 0, (0x10 - block.byteLength + m.byteLength) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  const mac = out.subarray(1 + m.byteLength, out.byteLength)\n  poly.finish(mac, 0)\n\n  assert(crypto_onetimeauth_poly1305_BYTES >=\n    crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag[0] & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return crypto_secretstream_xchacha20poly1305_ABYTES + m.byteLength\n}\n\nfunction crypto_secretstream_xchacha20poly1305_pull (state, m, tag, _in, ad) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n  const mac = new Uint8Array(crypto_onetimeauth_poly1305_BYTES)\n\n  assert(_in.byteLength >= crypto_secretstream_xchacha20poly1305_ABYTES,\n    'ciphertext is too short.')\n\n  const mlen = _in.byteLength - crypto_secretstream_xchacha20poly1305_ABYTES\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0) // sodium_memzero(block, sizeof block);\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block.fill(0) // memset(block, 0, sizeof block);\n  block[0] = _in[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  tag[0] = block[0]\n  block[0] = _in[0]\n  poly.update(block, 0, block.byteLength)\n\n  const c = _in.subarray(1, _in.length)\n  poly.update(c, 0, mlen)\n\n  poly.update(_pad0, 0, (0x10 - block.byteLength + mlen) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  poly.finish(mac, 0)\n  const stored_mac = _in.subarray(1 + mlen, _in.length)\n\n  if (!sodium_memcmp(mac, stored_mac)) {\n    mac.fill(0)\n    throw new Error('MAC could not be verified.')\n  }\n\n  crypto_stream_chacha20_ietf_xor_ic(m, c.subarray(0, m.length), nonce, 2, k)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return mlen\n}\n\nfunction xor_buf (out, _in, n) {\n  for (let i = 0; i < n; i++) {\n    out[i] ^= _in[i]\n  }\n}\n\nmodule.exports = {\n  crypto_secretstream_xchacha20poly1305_keygen,\n  crypto_secretstream_xchacha20poly1305_init_push,\n  crypto_secretstream_xchacha20poly1305_init_pull,\n  crypto_secretstream_xchacha20poly1305_rekey,\n  crypto_secretstream_xchacha20poly1305_push,\n  crypto_secretstream_xchacha20poly1305_pull,\n  crypto_secretstream_xchacha20poly1305_STATEBYTES,\n  crypto_secretstream_xchacha20poly1305_ABYTES,\n  crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n  crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX,\n  crypto_secretstream_xchacha20poly1305_TAGBYTES,\n  crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n  crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n  crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n  crypto_secretstream_xchacha20poly1305_TAG_FINAL\n}\n","start":1670465470695,"end":1670465470863},{"name":"vite:react-babel","result":"/* eslint-disable camelcase */\nconst assert = require('nanoassert')\nconst { randombytes_buf } = require('./randombytes')\nconst {\n  crypto_stream_chacha20_ietf,\n  crypto_stream_chacha20_ietf_xor,\n  crypto_stream_chacha20_ietf_xor_ic,\n  crypto_stream_chacha20_ietf_KEYBYTES\n} = require('./crypto_stream_chacha20')\nconst { crypto_core_hchacha20, crypto_core_hchacha20_INPUTBYTES } = require('./internal/hchacha20')\nconst Poly1305 = require('./internal/poly1305')\nconst { sodium_increment, sodium_is_zero, sodium_memcmp } = require('./helpers')\n\nconst crypto_onetimeauth_poly1305_BYTES = 16\nconst crypto_secretstream_xchacha20poly1305_COUNTERBYTES = 4\nconst crypto_secretstream_xchacha20poly1305_INONCEBYTES = 8\nconst crypto_aead_xchacha20poly1305_ietf_KEYBYTES = 32\nconst crypto_secretstream_xchacha20poly1305_KEYBYTES = crypto_aead_xchacha20poly1305_ietf_KEYBYTES\nconst crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = 24\nconst crypto_secretstream_xchacha20poly1305_HEADERBYTES = crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\nconst crypto_aead_xchacha20poly1305_ietf_ABYTES = 16\nconst crypto_secretstream_xchacha20poly1305_ABYTES = 1 + crypto_aead_xchacha20poly1305_ietf_ABYTES\nconst crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_secretstream_xchacha20poly1305_TAGBYTES = 1\nconst crypto_secretstream_xchacha20poly1305_TAG_MESSAGE = new Uint8Array([0])\nconst crypto_secretstream_xchacha20poly1305_TAG_PUSH = new Uint8Array([1])\nconst crypto_secretstream_xchacha20poly1305_TAG_REKEY = new Uint8Array([2])\nconst crypto_secretstream_xchacha20poly1305_TAG_FINAL = new Uint8Array([crypto_secretstream_xchacha20poly1305_TAG_PUSH | crypto_secretstream_xchacha20poly1305_TAG_REKEY])\nconst crypto_secretstream_xchacha20poly1305_STATEBYTES = crypto_secretstream_xchacha20poly1305_KEYBYTES +\n  crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES + 8\n\nconst KEY_OFFSET = 0\nconst NONCE_OFFSET = crypto_secretstream_xchacha20poly1305_KEYBYTES\nconst PAD_OFFSET = NONCE_OFFSET + crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES\n\nconst _pad0 = new Uint8Array(16)\n\nfunction STORE64_LE (dest, int) {\n  let mul = 1\n  let i = 0\n  dest[0] = int & 0xFF\n  while (++i < 8 && (mul *= 0x100)) {\n    dest[i] = (int / mul) & 0xFF\n  }\n}\n\nfunction crypto_secretstream_xchacha20poly1305_counter_reset (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_COUNTERBYTES; i++) {\n    nonce[i] = 0\n  }\n  nonce[0] = 1\n}\n\nfunction crypto_secretstream_xchacha20poly1305_keygen (k) {\n  assert(k.length === crypto_secretstream_xchacha20poly1305_KEYBYTES)\n  randombytes_buf(k)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_push (state, out, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(out instanceof Uint8Array && out.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES, 'out not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES, 'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  randombytes_buf(out, crypto_secretstream_xchacha20poly1305_HEADERBYTES)\n  crypto_core_hchacha20(k, out, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = out[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_pull (state, _in, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(_in instanceof Uint8Array && _in.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    '_in not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  crypto_core_hchacha20(k, _in, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = _in[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_rekey (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const new_key_and_inonce = new Uint8Array(\n    crypto_stream_chacha20_ietf_KEYBYTES + crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  let i\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    new_key_and_inonce[i] = k[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i] =\n      nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i]\n  }\n  crypto_stream_chacha20_ietf_xor(new_key_and_inonce, new_key_and_inonce, nonce, k)\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    k[i] = new_key_and_inonce[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i] =\n      new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i]\n  }\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_push (state, out, m, ad, tag) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n\n  assert(crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX <=\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX)\n\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0)\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block[0] = tag[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  poly.update(block, 0, block.byteLength)\n  out[0] = block[0]\n\n  const c = out.subarray(1, out.byteLength)\n  crypto_stream_chacha20_ietf_xor_ic(c, m, nonce, 2, k)\n  poly.update(c, 0, m.byteLength)\n  poly.update(_pad0, 0, (0x10 - block.byteLength + m.byteLength) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  const mac = out.subarray(1 + m.byteLength, out.byteLength)\n  poly.finish(mac, 0)\n\n  assert(crypto_onetimeauth_poly1305_BYTES >=\n    crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag[0] & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return crypto_secretstream_xchacha20poly1305_ABYTES + m.byteLength\n}\n\nfunction crypto_secretstream_xchacha20poly1305_pull (state, m, tag, _in, ad) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n  const mac = new Uint8Array(crypto_onetimeauth_poly1305_BYTES)\n\n  assert(_in.byteLength >= crypto_secretstream_xchacha20poly1305_ABYTES,\n    'ciphertext is too short.')\n\n  const mlen = _in.byteLength - crypto_secretstream_xchacha20poly1305_ABYTES\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0) // sodium_memzero(block, sizeof block);\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block.fill(0) // memset(block, 0, sizeof block);\n  block[0] = _in[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  tag[0] = block[0]\n  block[0] = _in[0]\n  poly.update(block, 0, block.byteLength)\n\n  const c = _in.subarray(1, _in.length)\n  poly.update(c, 0, mlen)\n\n  poly.update(_pad0, 0, (0x10 - block.byteLength + mlen) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  poly.finish(mac, 0)\n  const stored_mac = _in.subarray(1 + mlen, _in.length)\n\n  if (!sodium_memcmp(mac, stored_mac)) {\n    mac.fill(0)\n    throw new Error('MAC could not be verified.')\n  }\n\n  crypto_stream_chacha20_ietf_xor_ic(m, c.subarray(0, m.length), nonce, 2, k)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return mlen\n}\n\nfunction xor_buf (out, _in, n) {\n  for (let i = 0; i < n; i++) {\n    out[i] ^= _in[i]\n  }\n}\n\nmodule.exports = {\n  crypto_secretstream_xchacha20poly1305_keygen,\n  crypto_secretstream_xchacha20poly1305_init_push,\n  crypto_secretstream_xchacha20poly1305_init_pull,\n  crypto_secretstream_xchacha20poly1305_rekey,\n  crypto_secretstream_xchacha20poly1305_push,\n  crypto_secretstream_xchacha20poly1305_pull,\n  crypto_secretstream_xchacha20poly1305_STATEBYTES,\n  crypto_secretstream_xchacha20poly1305_ABYTES,\n  crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n  crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX,\n  crypto_secretstream_xchacha20poly1305_TAGBYTES,\n  crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n  crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n  crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n  crypto_secretstream_xchacha20poly1305_TAG_FINAL\n}\n","start":1670465470863,"end":1670465470863,"order":"pre"},{"name":"commonjs","result":"/* eslint-disable camelcase */\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoassert@2.0.0/node_modules/nanoassert/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/randombytes.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/crypto_stream_chacha20.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/internal/hchacha20.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/internal/poly1305.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-javascript@0.8.0/node_modules/sodium-javascript/helpers.js?commonjs-proxy\";\n\nconst assert = require$$0\nconst { randombytes_buf } = require$$1\nconst {\n  crypto_stream_chacha20_ietf,\n  crypto_stream_chacha20_ietf_xor,\n  crypto_stream_chacha20_ietf_xor_ic,\n  crypto_stream_chacha20_ietf_KEYBYTES\n} = require$$2\nconst { crypto_core_hchacha20, crypto_core_hchacha20_INPUTBYTES } = require$$3\nconst Poly1305 = require$$4\nconst { sodium_increment, sodium_is_zero, sodium_memcmp } = require$$5\n\nconst crypto_onetimeauth_poly1305_BYTES = 16\nconst crypto_secretstream_xchacha20poly1305_COUNTERBYTES = 4\nconst crypto_secretstream_xchacha20poly1305_INONCEBYTES = 8\nconst crypto_aead_xchacha20poly1305_ietf_KEYBYTES = 32\nconst crypto_secretstream_xchacha20poly1305_KEYBYTES = crypto_aead_xchacha20poly1305_ietf_KEYBYTES\nconst crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = 24\nconst crypto_secretstream_xchacha20poly1305_HEADERBYTES = crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\nconst crypto_aead_xchacha20poly1305_ietf_ABYTES = 16\nconst crypto_secretstream_xchacha20poly1305_ABYTES = 1 + crypto_aead_xchacha20poly1305_ietf_ABYTES\nconst crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER\nconst crypto_secretstream_xchacha20poly1305_TAGBYTES = 1\nconst crypto_secretstream_xchacha20poly1305_TAG_MESSAGE = new Uint8Array([0])\nconst crypto_secretstream_xchacha20poly1305_TAG_PUSH = new Uint8Array([1])\nconst crypto_secretstream_xchacha20poly1305_TAG_REKEY = new Uint8Array([2])\nconst crypto_secretstream_xchacha20poly1305_TAG_FINAL = new Uint8Array([crypto_secretstream_xchacha20poly1305_TAG_PUSH | crypto_secretstream_xchacha20poly1305_TAG_REKEY])\nconst crypto_secretstream_xchacha20poly1305_STATEBYTES = crypto_secretstream_xchacha20poly1305_KEYBYTES +\n  crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES + 8\n\nconst KEY_OFFSET = 0\nconst NONCE_OFFSET = crypto_secretstream_xchacha20poly1305_KEYBYTES\nconst PAD_OFFSET = NONCE_OFFSET + crypto_secretstream_xchacha20poly1305_INONCEBYTES + crypto_secretstream_xchacha20poly1305_COUNTERBYTES\n\nconst _pad0 = new Uint8Array(16)\n\nfunction STORE64_LE (dest, int) {\n  let mul = 1\n  let i = 0\n  dest[0] = int & 0xFF\n  while (++i < 8 && (mul *= 0x100)) {\n    dest[i] = (int / mul) & 0xFF\n  }\n}\n\nfunction crypto_secretstream_xchacha20poly1305_counter_reset (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_COUNTERBYTES; i++) {\n    nonce[i] = 0\n  }\n  nonce[0] = 1\n}\n\nfunction crypto_secretstream_xchacha20poly1305_keygen (k) {\n  assert(k.length === crypto_secretstream_xchacha20poly1305_KEYBYTES)\n  randombytes_buf(k)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_push (state, out, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(out instanceof Uint8Array && out.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES, 'out not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES, 'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  randombytes_buf(out, crypto_secretstream_xchacha20poly1305_HEADERBYTES)\n  crypto_core_hchacha20(k, out, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = out[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_init_pull (state, _in, key) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  assert(_in instanceof Uint8Array && _in.length === crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    '_in not byte array of length crypto_secretstream_xchacha20poly1305_HEADERBYTES')\n  assert(key instanceof Uint8Array && key.length === crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    'key not byte array of length crypto_secretstream_xchacha20poly1305_KEYBYTES')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n  const pad = state.subarray(PAD_OFFSET)\n\n  crypto_core_hchacha20(k, _in, key, null)\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n\n  for (let i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[i + crypto_secretstream_xchacha20poly1305_COUNTERBYTES] = _in[i + crypto_core_hchacha20_INPUTBYTES]\n  }\n  pad.fill(0)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_rekey (state) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const new_key_and_inonce = new Uint8Array(\n    crypto_stream_chacha20_ietf_KEYBYTES + crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  let i\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    new_key_and_inonce[i] = k[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i] =\n      nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i]\n  }\n  crypto_stream_chacha20_ietf_xor(new_key_and_inonce, new_key_and_inonce, nonce, k)\n  for (i = 0; i < crypto_stream_chacha20_ietf_KEYBYTES; i++) {\n    k[i] = new_key_and_inonce[i]\n  }\n  for (i = 0; i < crypto_secretstream_xchacha20poly1305_INONCEBYTES; i++) {\n    nonce[crypto_secretstream_xchacha20poly1305_COUNTERBYTES + i] =\n      new_key_and_inonce[crypto_stream_chacha20_ietf_KEYBYTES + i]\n  }\n  crypto_secretstream_xchacha20poly1305_counter_reset(state)\n}\n\nfunction crypto_secretstream_xchacha20poly1305_push (state, out, m, ad, tag) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n\n  assert(crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX <=\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX)\n\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0)\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block[0] = tag[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  poly.update(block, 0, block.byteLength)\n  out[0] = block[0]\n\n  const c = out.subarray(1, out.byteLength)\n  crypto_stream_chacha20_ietf_xor_ic(c, m, nonce, 2, k)\n  poly.update(c, 0, m.byteLength)\n  poly.update(_pad0, 0, (0x10 - block.byteLength + m.byteLength) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  const mac = out.subarray(1 + m.byteLength, out.byteLength)\n  poly.finish(mac, 0)\n\n  assert(crypto_onetimeauth_poly1305_BYTES >=\n    crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag[0] & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return crypto_secretstream_xchacha20poly1305_ABYTES + m.byteLength\n}\n\nfunction crypto_secretstream_xchacha20poly1305_pull (state, m, tag, _in, ad) {\n  assert(state.byteLength === crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    'state is should be crypto_secretstream_xchacha20poly1305_STATEBYTES long')\n  if (!ad) ad = new Uint8Array(0)\n\n  const k = state.subarray(KEY_OFFSET, NONCE_OFFSET)\n  const nonce = state.subarray(NONCE_OFFSET, PAD_OFFSET)\n\n  const block = new Uint8Array(64)\n  const slen = new Uint8Array(8)\n  const mac = new Uint8Array(crypto_onetimeauth_poly1305_BYTES)\n\n  assert(_in.byteLength >= crypto_secretstream_xchacha20poly1305_ABYTES,\n    'ciphertext is too short.')\n\n  const mlen = _in.byteLength - crypto_secretstream_xchacha20poly1305_ABYTES\n  crypto_stream_chacha20_ietf(block, nonce, k)\n  const poly = new Poly1305(block)\n  block.fill(0) // sodium_memzero(block, sizeof block);\n\n  poly.update(ad, 0, ad.byteLength)\n  poly.update(_pad0, 0, (0x10 - ad.byteLength) & 0xf)\n\n  block.fill(0) // memset(block, 0, sizeof block);\n  block[0] = _in[0]\n  crypto_stream_chacha20_ietf_xor_ic(block, block, nonce, 1, k)\n\n  tag[0] = block[0]\n  block[0] = _in[0]\n  poly.update(block, 0, block.byteLength)\n\n  const c = _in.subarray(1, _in.length)\n  poly.update(c, 0, mlen)\n\n  poly.update(_pad0, 0, (0x10 - block.byteLength + mlen) & 0xf)\n\n  STORE64_LE(slen, ad.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n  STORE64_LE(slen, block.byteLength + m.byteLength)\n  poly.update(slen, 0, slen.byteLength)\n\n  poly.finish(mac, 0)\n  const stored_mac = _in.subarray(1 + mlen, _in.length)\n\n  if (!sodium_memcmp(mac, stored_mac)) {\n    mac.fill(0)\n    throw new Error('MAC could not be verified.')\n  }\n\n  crypto_stream_chacha20_ietf_xor_ic(m, c.subarray(0, m.length), nonce, 2, k)\n  xor_buf(nonce.subarray(crypto_secretstream_xchacha20poly1305_COUNTERBYTES, nonce.length),\n    mac, crypto_secretstream_xchacha20poly1305_INONCEBYTES)\n  sodium_increment(nonce)\n\n  if ((tag & crypto_secretstream_xchacha20poly1305_TAG_REKEY) !== 0 ||\n    sodium_is_zero(nonce.subarray(0, crypto_secretstream_xchacha20poly1305_COUNTERBYTES))) {\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n  }\n\n  return mlen\n}\n\nfunction xor_buf (out, _in, n) {\n  for (let i = 0; i < n; i++) {\n    out[i] ^= _in[i]\n  }\n}\n\nvar crypto_secretstream = {\n  crypto_secretstream_xchacha20poly1305_keygen,\n  crypto_secretstream_xchacha20poly1305_init_push,\n  crypto_secretstream_xchacha20poly1305_init_pull,\n  crypto_secretstream_xchacha20poly1305_rekey,\n  crypto_secretstream_xchacha20poly1305_push,\n  crypto_secretstream_xchacha20poly1305_pull,\n  crypto_secretstream_xchacha20poly1305_STATEBYTES,\n  crypto_secretstream_xchacha20poly1305_ABYTES,\n  crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n  crypto_secretstream_xchacha20poly1305_KEYBYTES,\n  crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX,\n  crypto_secretstream_xchacha20poly1305_TAGBYTES,\n  crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n  crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n  crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n  crypto_secretstream_xchacha20poly1305_TAG_FINAL\n}\n\nexport default crypto_secretstream;\nexport { crypto_secretstream as __moduleExports };","start":1670465470863,"end":1670465471146,"order":"normal"}]}
