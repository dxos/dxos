{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/feed-store/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/feed-store/src/feed-factory.ts\nimport hypercore from \"hypercore\";\nimport { sha256 } from \"@dxos/crypto\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { createCrypto } from \"@dxos/hypercore\";\nimport { log } from \"@dxos/log\";\nvar FeedFactory = class {\n  constructor({ root, signer, hypercore: hypercore2 }) {\n    this._root = root != null ? root : failUndefined();\n    this._signer = signer;\n    this._hypercoreOptions = hypercore2;\n    this._storage = (publicKey) => (filename) => {\n      const dir = this._root.createDirectory(publicKey.toHex());\n      const { type, native } = dir.getOrCreateFile(filename);\n      log(\"created\", {\n        path: `${type}:${this._root.path}/${publicKey.truncate()}/${filename}`\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-factory.ts\",\n        line: 46,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return native;\n    };\n  }\n  createFeed(publicKey, options) {\n    if ((options == null ? void 0 : options.writable) && !this._signer) {\n      throw new Error(\"Signer required to create writable feeds.\");\n    }\n    if (options == null ? void 0 : options.secretKey) {\n      console.warn(\"Secret key ignored due to signer.\");\n    }\n    const key = sha256(publicKey.toHex());\n    const opts = Object.assign({}, this._hypercoreOptions, {\n      secretKey: this._signer && (options == null ? void 0 : options.writable) ? Buffer.from(\"secret\") : void 0,\n      crypto: this._signer ? createCrypto(this._signer, publicKey) : void 0\n    }, options);\n    return hypercore(this._storage(publicKey), key, opts);\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\n\n// packages/common/feed-store/src/feed-queue.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { Writable } from \"streamx\";\nimport { Event, latch, Trigger } from \"@dxos/async\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log as log2 } from \"@dxos/log\";\nvar defaultReadStreamOptions = {\n  live: true\n};\nvar FeedQueue = class {\n  constructor(_feed, _options = {}) {\n    this._feed = _feed;\n    this._options = _options;\n    this.updated = new Event();\n    this._messageTrigger = new Trigger({\n      autoReset: true\n    });\n    this._currentBlock = void 0;\n    this._index = -1;\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._feed.key,\n      index: this.index,\n      length: this.length,\n      open: this.isOpen\n    };\n  }\n  get feed() {\n    return this._feed;\n  }\n  get isOpen() {\n    return Boolean(this._feedConsumer);\n  }\n  get length() {\n    return this._feed.properties.length;\n  }\n  get index() {\n    return this._index;\n  }\n  async open(options = {}) {\n    var _a;\n    if (this.isOpen) {\n      return;\n    }\n    this._index = (_a = options.start) != null ? _a : 0;\n    if (this._index !== 0) {\n      console.warn(\"Start index not yet supported.\");\n    }\n    log2(\"opening\", {\n      feedKey: this._feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 90,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const opts = Object.assign({}, defaultReadStreamOptions, options);\n    const feedStream = this._feed.core.createReadStream(opts);\n    this._feedConsumer = new Writable({\n      write: (data, next) => {\n        this._next = () => {\n          this._next = void 0;\n          this._currentBlock = void 0;\n          this._index++;\n          next();\n        };\n        this._currentBlock = {\n          feedKey: this._feed.key,\n          seq: this._index,\n          data\n        };\n        this._messageTrigger.wake(this._currentBlock);\n        this.updated.emit(this);\n      }\n    });\n    const onClose = () => {\n      if (this._feedConsumer) {\n        log2(\"queue closed\", {\n          feedKey: this._feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n          line: 118,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._feedConsumer = void 0;\n        this._next = void 0;\n        this._currentBlock = void 0;\n        this._index = -1;\n      }\n    };\n    this._feed.core.once(\"close\", () => {\n      log2(\"feed closed\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 128,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      onClose();\n    });\n    this._feedConsumer.once(\"close\", () => {\n      onClose();\n    });\n    feedStream.pipe(this._feedConsumer, () => {\n      onClose();\n    });\n    log2(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isOpen) {\n      assert(this._feedConsumer);\n      assert(!this._feed.properties.closed);\n      log2(\"closing\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 153,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const [closed, setClosed] = latch();\n      this._feedConsumer.once(\"close\", setClosed);\n      this._feedConsumer.destroy();\n      (_a = this._next) == null ? void 0 : _a.call(this);\n      await closed();\n      log2(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 159,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  peek() {\n    return this._currentBlock;\n  }\n  async pop() {\n    var _a;\n    if (!this.isOpen) {\n      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);\n    }\n    let block = this.peek();\n    if (!block) {\n      block = await this._messageTrigger.wait();\n    }\n    if (block) {\n      (_a = this._next) == null ? void 0 : _a.call(this);\n    }\n    return block;\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nvar AbstractFeedIterator = class {\n  constructor() {\n    this._stopTrigger = new Trigger2();\n    this._open = false;\n    this._running = false;\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning\n    };\n  }\n  get isOpen() {\n    return this._open;\n  }\n  get isRunning() {\n    return this._running;\n  }\n  async open() {\n    if (!this._open) {\n      log3(\"opening...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._onOpen();\n      this._open = true;\n      await this.start();\n      log3(\"opened\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async close() {\n    if (this._open) {\n      log3(\"closing...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 51,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.stop();\n      await this._onClose();\n      this._open = false;\n      log3(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 56,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async start() {\n    assert2(this._open);\n    if (!this._running) {\n      this._running = true;\n    }\n  }\n  async stop() {\n    assert2(this._open);\n    if (this._running) {\n      this._running = false;\n      this._stopTrigger.wake();\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this._generator();\n  }\n  async *_generator() {\n    log3(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 84,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    while (this._running) {\n      const block = await Promise.race([\n        this._stopTrigger.wait(),\n        this._nextBlock()\n      ]);\n      if (block === void 0) {\n        break;\n      }\n      yield block;\n    }\n    log3(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\nvar FeedIterator = class extends AbstractFeedIterator {\n  constructor(_feed) {\n    super();\n    this._feed = _feed;\n    this._queue = new FeedQueue(this._feed);\n  }\n  async _onOpen() {\n    await this._queue.open();\n  }\n  async _onClose() {\n    await this._queue.close();\n  }\n  async _nextBlock() {\n    return this._queue.pop();\n  }\n};\n\n// packages/common/feed-store/src/feed-set-iterator.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { inspect as inspect2 } from \"@dxos/node-std/util\";\nimport { Event as Event2, EventSubscriptions, Trigger as Trigger3 } from \"@dxos/async\";\nimport { inspectObject as inspectObject2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap, isNotNullOrUndefined } from \"@dxos/util\";\nvar defaultFeedSetIteratorOptions = {\n  stallTimeout: 1e3\n};\nvar FeedSetIterator = class extends AbstractFeedIterator {\n  constructor(_selector, options = defaultFeedSetIteratorOptions) {\n    super();\n    this._selector = _selector;\n    this.options = options;\n    this._feedQueues = new ComplexMap(PublicKey.hash);\n    this._trigger = new Trigger3({\n      autoReset: true\n    });\n    this._subscriptions = new EventSubscriptions();\n    this.stalled = new Event2();\n    assert3(_selector);\n    assert3(options);\n  }\n  [inspect2.custom]() {\n    return inspectObject2(this);\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n      indexes: this.indexes\n    };\n  }\n  get size() {\n    return this._feedQueues.size;\n  }\n  get feeds() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);\n  }\n  get indexes() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => ({\n      feedKey: feedQueue.feed.key,\n      index: feedQueue.index\n    }));\n  }\n  async addFeed(feed) {\n    assert3(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`);\n    assert3(feed.properties.opened);\n    log4(\"feed added\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n      line: 89,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const queue = new FeedQueue(feed);\n    this._feedQueues.set(feed.key, queue);\n    this._subscriptions.add(queue.updated.on(() => {\n      this._trigger.wake();\n    }));\n    await queue.open();\n    this._trigger.wake();\n  }\n  async _onOpen() {\n    for (const queue of this._feedQueues.values()) {\n      await queue.open();\n    }\n  }\n  async _onClose() {\n    this._subscriptions.clear();\n    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));\n    this._trigger.wake();\n  }\n  async _nextBlock() {\n    let t;\n    while (this._running) {\n      const queues = Array.from(this._feedQueues.values());\n      const blocks = queues.map((queue) => queue.peek()).filter(isNotNullOrUndefined);\n      if (blocks.length) {\n        const idx = this._selector(blocks);\n        if (idx === void 0) {\n          log4.warn(\"Stalled\", {\n            blocks\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 135,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (t === void 0) {\n            t = setTimeout(() => {\n              this.stalled.emit(this);\n            }, this.options.stallTimeout);\n          }\n        } else {\n          if (t !== void 0) {\n            clearTimeout(t);\n            t = void 0;\n          }\n          if (idx >= blocks.length) {\n            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);\n          }\n          const queue = this._feedQueues.get(blocks[idx].feedKey);\n          log4(\"popping\", queue.toJSON(), {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 153,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          try {\n            const message = await queue.pop();\n            assert3(message === blocks[idx]);\n            return message;\n          } catch (err) {\n            log4.warn(\"queue closed\", {\n              feedKey: queue.feed.key\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n              line: 160,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            console.log(Array.from(this._feedQueues.values()));\n          }\n        }\n      }\n      await this._trigger.wait();\n    }\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event3, sleep } from \"@dxos/async\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\n\n// packages/common/feed-store/src/feed-wrapper.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { inspect as inspect3 } from \"@dxos/node-std/util\";\nimport { inspectObject as inspectObject3, StackTrace } from \"@dxos/debug\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createBinder } from \"@dxos/util\";\nvar FeedWrapper = class {\n  constructor(_hypercore, _key) {\n    this._hypercore = _hypercore;\n    this._key = _key;\n    this._pendingWrites = /* @__PURE__ */ new Set();\n    this._binder = createBinder(this._hypercore);\n    this.on = this._binder.fn(this._hypercore.on);\n    this.off = this._binder.fn(this._hypercore.off);\n    this.open = this._binder.async(this._hypercore.open);\n    this._close = this._binder.async(this._hypercore.close);\n    this.close = async () => {\n      if (this._pendingWrites.size) {\n        log5.warn(\"Closing feed with pending writes\", {\n          feed: this._key,\n          count: this._pendingWrites.size,\n          pendingWrites: Array.from(this._pendingWrites.values()).map((stack) => stack.getStack())\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 103,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      await this._close();\n    };\n    this.get = this._binder.async(this._hypercore.get);\n    this.append = this._binder.async(this._hypercore.append);\n    this.download = this._binder.async(this._hypercore.download);\n    this.replicate = this._binder.fn(this._hypercore.replicate);\n    assert4(this._hypercore);\n    assert4(this._key);\n  }\n  [inspect3.custom]() {\n    return inspectObject3(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._key,\n      length: this.properties.length,\n      opened: this.properties.opened,\n      closed: this.properties.closed\n    };\n  }\n  get key() {\n    return this._key;\n  }\n  get core() {\n    return this._hypercore;\n  }\n  get properties() {\n    return this._hypercore;\n  }\n  createReadableStream() {\n    return this._hypercore.createReadStream({\n      live: true\n    });\n  }\n  createFeedWriter() {\n    return {\n      write: async (data) => {\n        log5(\"write\", {\n          feed: this._key,\n          seq: this._hypercore.length,\n          data\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 66,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const stackTrace = new StackTrace();\n        try {\n          this._pendingWrites.add(stackTrace);\n          const seq = await this.append(data);\n          log5(\"write complete\", {\n            feed: this._key,\n            seq\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n            line: 72,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return {\n            feedKey: this.key,\n            seq\n          };\n        } finally {\n          this._pendingWrites.delete(stackTrace);\n        }\n      }\n    };\n  }\n  get opened() {\n    return this._hypercore.opened;\n  }\n  get closed() {\n    return this._hypercore.closed;\n  }\n  get length() {\n    return this._hypercore.length;\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nvar FeedStore = class {\n  constructor({ factory }) {\n    this._feeds = new ComplexMap2(PublicKey2.hash);\n    this.feedOpened = new Event3();\n    this._factory = factory != null ? factory : failUndefined2();\n  }\n  get size() {\n    return this._feeds.size;\n  }\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n  getFeed(publicKey) {\n    return this._feeds.get(publicKey);\n  }\n  async openFeed(feedKey, { writable } = {}) {\n    log6(\"opening feed\", {\n      feedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 53,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    let feed = this.getFeed(feedKey);\n    if (feed) {\n      if (writable && !feed.properties.writable) {\n        throw new Error(`Read-only feed is already open: ${feedKey.truncate()}`);\n      } else {\n        await feed.open();\n        return feed;\n      }\n    }\n    const core = this._factory.createFeed(feedKey, {\n      writable\n    });\n    feed = new FeedWrapper(core, feedKey);\n    this._feeds.set(feed.key, feed);\n    await feed.open();\n    this.feedOpened.emit(feed);\n    log6(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 74,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return feed;\n  }\n  async close() {\n    log6(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 82,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all(Array.from(this._feeds.values()).map(async (feed) => {\n      await feed.close();\n      assert5(feed.closed);\n      await sleep(100);\n    }));\n    this._feeds.clear();\n    log6(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/common/feed-store/src/feed-writer.ts\nvar createFeedWriter = (cb) => ({\n  write: async (data) => {\n    return cb(data);\n  }\n});\nvar writeMessages = async (writer, messages) => {\n  const receipts = [];\n  for (const message of messages) {\n    receipts.push(await writer.write(message));\n  }\n  return receipts;\n};\nexport {\n  AbstractFeedIterator,\n  FeedFactory,\n  FeedIterator,\n  FeedQueue,\n  FeedSetIterator,\n  FeedStore,\n  FeedWrapper,\n  createFeedWriter,\n  defaultFeedSetIteratorOptions,\n  defaultReadStreamOptions,\n  writeMessages\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466970,"end":1670465467040},{"name":"vite:react-babel","result":"// packages/common/feed-store/src/feed-factory.ts\nimport hypercore from \"hypercore\";\nimport { sha256 } from \"@dxos/crypto\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { createCrypto } from \"@dxos/hypercore\";\nimport { log } from \"@dxos/log\";\nvar FeedFactory = class {\n  constructor({ root, signer, hypercore: hypercore2 }) {\n    this._root = root != null ? root : failUndefined();\n    this._signer = signer;\n    this._hypercoreOptions = hypercore2;\n    this._storage = (publicKey) => (filename) => {\n      const dir = this._root.createDirectory(publicKey.toHex());\n      const { type, native } = dir.getOrCreateFile(filename);\n      log(\"created\", {\n        path: `${type}:${this._root.path}/${publicKey.truncate()}/${filename}`\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-factory.ts\",\n        line: 46,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return native;\n    };\n  }\n  createFeed(publicKey, options) {\n    if ((options == null ? void 0 : options.writable) && !this._signer) {\n      throw new Error(\"Signer required to create writable feeds.\");\n    }\n    if (options == null ? void 0 : options.secretKey) {\n      console.warn(\"Secret key ignored due to signer.\");\n    }\n    const key = sha256(publicKey.toHex());\n    const opts = Object.assign({}, this._hypercoreOptions, {\n      secretKey: this._signer && (options == null ? void 0 : options.writable) ? Buffer.from(\"secret\") : void 0,\n      crypto: this._signer ? createCrypto(this._signer, publicKey) : void 0\n    }, options);\n    return hypercore(this._storage(publicKey), key, opts);\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\n\n// packages/common/feed-store/src/feed-queue.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { Writable } from \"streamx\";\nimport { Event, latch, Trigger } from \"@dxos/async\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log as log2 } from \"@dxos/log\";\nvar defaultReadStreamOptions = {\n  live: true\n};\nvar FeedQueue = class {\n  constructor(_feed, _options = {}) {\n    this._feed = _feed;\n    this._options = _options;\n    this.updated = new Event();\n    this._messageTrigger = new Trigger({\n      autoReset: true\n    });\n    this._currentBlock = void 0;\n    this._index = -1;\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._feed.key,\n      index: this.index,\n      length: this.length,\n      open: this.isOpen\n    };\n  }\n  get feed() {\n    return this._feed;\n  }\n  get isOpen() {\n    return Boolean(this._feedConsumer);\n  }\n  get length() {\n    return this._feed.properties.length;\n  }\n  get index() {\n    return this._index;\n  }\n  async open(options = {}) {\n    var _a;\n    if (this.isOpen) {\n      return;\n    }\n    this._index = (_a = options.start) != null ? _a : 0;\n    if (this._index !== 0) {\n      console.warn(\"Start index not yet supported.\");\n    }\n    log2(\"opening\", {\n      feedKey: this._feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 90,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const opts = Object.assign({}, defaultReadStreamOptions, options);\n    const feedStream = this._feed.core.createReadStream(opts);\n    this._feedConsumer = new Writable({\n      write: (data, next) => {\n        this._next = () => {\n          this._next = void 0;\n          this._currentBlock = void 0;\n          this._index++;\n          next();\n        };\n        this._currentBlock = {\n          feedKey: this._feed.key,\n          seq: this._index,\n          data\n        };\n        this._messageTrigger.wake(this._currentBlock);\n        this.updated.emit(this);\n      }\n    });\n    const onClose = () => {\n      if (this._feedConsumer) {\n        log2(\"queue closed\", {\n          feedKey: this._feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n          line: 118,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._feedConsumer = void 0;\n        this._next = void 0;\n        this._currentBlock = void 0;\n        this._index = -1;\n      }\n    };\n    this._feed.core.once(\"close\", () => {\n      log2(\"feed closed\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 128,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      onClose();\n    });\n    this._feedConsumer.once(\"close\", () => {\n      onClose();\n    });\n    feedStream.pipe(this._feedConsumer, () => {\n      onClose();\n    });\n    log2(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isOpen) {\n      assert(this._feedConsumer);\n      assert(!this._feed.properties.closed);\n      log2(\"closing\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 153,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const [closed, setClosed] = latch();\n      this._feedConsumer.once(\"close\", setClosed);\n      this._feedConsumer.destroy();\n      (_a = this._next) == null ? void 0 : _a.call(this);\n      await closed();\n      log2(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 159,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  peek() {\n    return this._currentBlock;\n  }\n  async pop() {\n    var _a;\n    if (!this.isOpen) {\n      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);\n    }\n    let block = this.peek();\n    if (!block) {\n      block = await this._messageTrigger.wait();\n    }\n    if (block) {\n      (_a = this._next) == null ? void 0 : _a.call(this);\n    }\n    return block;\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nvar AbstractFeedIterator = class {\n  constructor() {\n    this._stopTrigger = new Trigger2();\n    this._open = false;\n    this._running = false;\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning\n    };\n  }\n  get isOpen() {\n    return this._open;\n  }\n  get isRunning() {\n    return this._running;\n  }\n  async open() {\n    if (!this._open) {\n      log3(\"opening...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._onOpen();\n      this._open = true;\n      await this.start();\n      log3(\"opened\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async close() {\n    if (this._open) {\n      log3(\"closing...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 51,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.stop();\n      await this._onClose();\n      this._open = false;\n      log3(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 56,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async start() {\n    assert2(this._open);\n    if (!this._running) {\n      this._running = true;\n    }\n  }\n  async stop() {\n    assert2(this._open);\n    if (this._running) {\n      this._running = false;\n      this._stopTrigger.wake();\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this._generator();\n  }\n  async *_generator() {\n    log3(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 84,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    while (this._running) {\n      const block = await Promise.race([\n        this._stopTrigger.wait(),\n        this._nextBlock()\n      ]);\n      if (block === void 0) {\n        break;\n      }\n      yield block;\n    }\n    log3(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\nvar FeedIterator = class extends AbstractFeedIterator {\n  constructor(_feed) {\n    super();\n    this._feed = _feed;\n    this._queue = new FeedQueue(this._feed);\n  }\n  async _onOpen() {\n    await this._queue.open();\n  }\n  async _onClose() {\n    await this._queue.close();\n  }\n  async _nextBlock() {\n    return this._queue.pop();\n  }\n};\n\n// packages/common/feed-store/src/feed-set-iterator.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { inspect as inspect2 } from \"@dxos/node-std/util\";\nimport { Event as Event2, EventSubscriptions, Trigger as Trigger3 } from \"@dxos/async\";\nimport { inspectObject as inspectObject2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap, isNotNullOrUndefined } from \"@dxos/util\";\nvar defaultFeedSetIteratorOptions = {\n  stallTimeout: 1e3\n};\nvar FeedSetIterator = class extends AbstractFeedIterator {\n  constructor(_selector, options = defaultFeedSetIteratorOptions) {\n    super();\n    this._selector = _selector;\n    this.options = options;\n    this._feedQueues = new ComplexMap(PublicKey.hash);\n    this._trigger = new Trigger3({\n      autoReset: true\n    });\n    this._subscriptions = new EventSubscriptions();\n    this.stalled = new Event2();\n    assert3(_selector);\n    assert3(options);\n  }\n  [inspect2.custom]() {\n    return inspectObject2(this);\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n      indexes: this.indexes\n    };\n  }\n  get size() {\n    return this._feedQueues.size;\n  }\n  get feeds() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);\n  }\n  get indexes() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => ({\n      feedKey: feedQueue.feed.key,\n      index: feedQueue.index\n    }));\n  }\n  async addFeed(feed) {\n    assert3(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`);\n    assert3(feed.properties.opened);\n    log4(\"feed added\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n      line: 89,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const queue = new FeedQueue(feed);\n    this._feedQueues.set(feed.key, queue);\n    this._subscriptions.add(queue.updated.on(() => {\n      this._trigger.wake();\n    }));\n    await queue.open();\n    this._trigger.wake();\n  }\n  async _onOpen() {\n    for (const queue of this._feedQueues.values()) {\n      await queue.open();\n    }\n  }\n  async _onClose() {\n    this._subscriptions.clear();\n    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));\n    this._trigger.wake();\n  }\n  async _nextBlock() {\n    let t;\n    while (this._running) {\n      const queues = Array.from(this._feedQueues.values());\n      const blocks = queues.map((queue) => queue.peek()).filter(isNotNullOrUndefined);\n      if (blocks.length) {\n        const idx = this._selector(blocks);\n        if (idx === void 0) {\n          log4.warn(\"Stalled\", {\n            blocks\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 135,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (t === void 0) {\n            t = setTimeout(() => {\n              this.stalled.emit(this);\n            }, this.options.stallTimeout);\n          }\n        } else {\n          if (t !== void 0) {\n            clearTimeout(t);\n            t = void 0;\n          }\n          if (idx >= blocks.length) {\n            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);\n          }\n          const queue = this._feedQueues.get(blocks[idx].feedKey);\n          log4(\"popping\", queue.toJSON(), {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 153,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          try {\n            const message = await queue.pop();\n            assert3(message === blocks[idx]);\n            return message;\n          } catch (err) {\n            log4.warn(\"queue closed\", {\n              feedKey: queue.feed.key\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n              line: 160,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            console.log(Array.from(this._feedQueues.values()));\n          }\n        }\n      }\n      await this._trigger.wait();\n    }\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event3, sleep } from \"@dxos/async\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\n\n// packages/common/feed-store/src/feed-wrapper.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { inspect as inspect3 } from \"@dxos/node-std/util\";\nimport { inspectObject as inspectObject3, StackTrace } from \"@dxos/debug\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createBinder } from \"@dxos/util\";\nvar FeedWrapper = class {\n  constructor(_hypercore, _key) {\n    this._hypercore = _hypercore;\n    this._key = _key;\n    this._pendingWrites = /* @__PURE__ */ new Set();\n    this._binder = createBinder(this._hypercore);\n    this.on = this._binder.fn(this._hypercore.on);\n    this.off = this._binder.fn(this._hypercore.off);\n    this.open = this._binder.async(this._hypercore.open);\n    this._close = this._binder.async(this._hypercore.close);\n    this.close = async () => {\n      if (this._pendingWrites.size) {\n        log5.warn(\"Closing feed with pending writes\", {\n          feed: this._key,\n          count: this._pendingWrites.size,\n          pendingWrites: Array.from(this._pendingWrites.values()).map((stack) => stack.getStack())\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 103,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      await this._close();\n    };\n    this.get = this._binder.async(this._hypercore.get);\n    this.append = this._binder.async(this._hypercore.append);\n    this.download = this._binder.async(this._hypercore.download);\n    this.replicate = this._binder.fn(this._hypercore.replicate);\n    assert4(this._hypercore);\n    assert4(this._key);\n  }\n  [inspect3.custom]() {\n    return inspectObject3(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._key,\n      length: this.properties.length,\n      opened: this.properties.opened,\n      closed: this.properties.closed\n    };\n  }\n  get key() {\n    return this._key;\n  }\n  get core() {\n    return this._hypercore;\n  }\n  get properties() {\n    return this._hypercore;\n  }\n  createReadableStream() {\n    return this._hypercore.createReadStream({\n      live: true\n    });\n  }\n  createFeedWriter() {\n    return {\n      write: async (data) => {\n        log5(\"write\", {\n          feed: this._key,\n          seq: this._hypercore.length,\n          data\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 66,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const stackTrace = new StackTrace();\n        try {\n          this._pendingWrites.add(stackTrace);\n          const seq = await this.append(data);\n          log5(\"write complete\", {\n            feed: this._key,\n            seq\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n            line: 72,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return {\n            feedKey: this.key,\n            seq\n          };\n        } finally {\n          this._pendingWrites.delete(stackTrace);\n        }\n      }\n    };\n  }\n  get opened() {\n    return this._hypercore.opened;\n  }\n  get closed() {\n    return this._hypercore.closed;\n  }\n  get length() {\n    return this._hypercore.length;\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nvar FeedStore = class {\n  constructor({ factory }) {\n    this._feeds = new ComplexMap2(PublicKey2.hash);\n    this.feedOpened = new Event3();\n    this._factory = factory != null ? factory : failUndefined2();\n  }\n  get size() {\n    return this._feeds.size;\n  }\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n  getFeed(publicKey) {\n    return this._feeds.get(publicKey);\n  }\n  async openFeed(feedKey, { writable } = {}) {\n    log6(\"opening feed\", {\n      feedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 53,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    let feed = this.getFeed(feedKey);\n    if (feed) {\n      if (writable && !feed.properties.writable) {\n        throw new Error(`Read-only feed is already open: ${feedKey.truncate()}`);\n      } else {\n        await feed.open();\n        return feed;\n      }\n    }\n    const core = this._factory.createFeed(feedKey, {\n      writable\n    });\n    feed = new FeedWrapper(core, feedKey);\n    this._feeds.set(feed.key, feed);\n    await feed.open();\n    this.feedOpened.emit(feed);\n    log6(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 74,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return feed;\n  }\n  async close() {\n    log6(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 82,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all(Array.from(this._feeds.values()).map(async (feed) => {\n      await feed.close();\n      assert5(feed.closed);\n      await sleep(100);\n    }));\n    this._feeds.clear();\n    log6(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/common/feed-store/src/feed-writer.ts\nvar createFeedWriter = (cb) => ({\n  write: async (data) => {\n    return cb(data);\n  }\n});\nvar writeMessages = async (writer, messages) => {\n  const receipts = [];\n  for (const message of messages) {\n    receipts.push(await writer.write(message));\n  }\n  return receipts;\n};\nexport {\n  AbstractFeedIterator,\n  FeedFactory,\n  FeedIterator,\n  FeedQueue,\n  FeedSetIterator,\n  FeedStore,\n  FeedWrapper,\n  createFeedWriter,\n  defaultFeedSetIteratorOptions,\n  defaultReadStreamOptions,\n  writeMessages\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467040,"end":1670465467040,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/feed-store/src/feed-factory.ts\nimport hypercore from \"hypercore\";\nimport { sha256 } from \"@dxos/crypto\";\nimport { failUndefined } from \"@dxos/debug\";\nimport { createCrypto } from \"@dxos/hypercore\";\nimport { log } from \"@dxos/log\";\nvar FeedFactory = class {\n  constructor({ root, signer, hypercore: hypercore2 }) {\n    this._root = root != null ? root : failUndefined();\n    this._signer = signer;\n    this._hypercoreOptions = hypercore2;\n    this._storage = (publicKey) => (filename) => {\n      const dir = this._root.createDirectory(publicKey.toHex());\n      const { type, native } = dir.getOrCreateFile(filename);\n      log(\"created\", {\n        path: `${type}:${this._root.path}/${publicKey.truncate()}/${filename}`\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-factory.ts\",\n        line: 46,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return native;\n    };\n  }\n  createFeed(publicKey, options) {\n    if ((options == null ? void 0 : options.writable) && !this._signer) {\n      throw new Error(\"Signer required to create writable feeds.\");\n    }\n    if (options == null ? void 0 : options.secretKey) {\n      console.warn(\"Secret key ignored due to signer.\");\n    }\n    const key = sha256(publicKey.toHex());\n    const opts = Object.assign({}, this._hypercoreOptions, {\n      secretKey: this._signer && (options == null ? void 0 : options.writable) ? Buffer.from(\"secret\") : void 0,\n      crypto: this._signer ? createCrypto(this._signer, publicKey) : void 0\n    }, options);\n    return hypercore(this._storage(publicKey), key, opts);\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Trigger as Trigger2 } from \"@dxos/async\";\nimport { log as log3 } from \"@dxos/log\";\n\n// packages/common/feed-store/src/feed-queue.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { Writable } from \"streamx\";\nimport { Event, latch, Trigger } from \"@dxos/async\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log as log2 } from \"@dxos/log\";\nvar defaultReadStreamOptions = {\n  live: true\n};\nvar FeedQueue = class {\n  constructor(_feed, _options = {}) {\n    this._feed = _feed;\n    this._options = _options;\n    this.updated = new Event();\n    this._messageTrigger = new Trigger({\n      autoReset: true\n    });\n    this._currentBlock = void 0;\n    this._index = -1;\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._feed.key,\n      index: this.index,\n      length: this.length,\n      open: this.isOpen\n    };\n  }\n  get feed() {\n    return this._feed;\n  }\n  get isOpen() {\n    return Boolean(this._feedConsumer);\n  }\n  get length() {\n    return this._feed.properties.length;\n  }\n  get index() {\n    return this._index;\n  }\n  async open(options = {}) {\n    var _a;\n    if (this.isOpen) {\n      return;\n    }\n    this._index = (_a = options.start) != null ? _a : 0;\n    if (this._index !== 0) {\n      console.warn(\"Start index not yet supported.\");\n    }\n    log2(\"opening\", {\n      feedKey: this._feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 90,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const opts = Object.assign({}, defaultReadStreamOptions, options);\n    const feedStream = this._feed.core.createReadStream(opts);\n    this._feedConsumer = new Writable({\n      write: (data, next) => {\n        this._next = () => {\n          this._next = void 0;\n          this._currentBlock = void 0;\n          this._index++;\n          next();\n        };\n        this._currentBlock = {\n          feedKey: this._feed.key,\n          seq: this._index,\n          data\n        };\n        this._messageTrigger.wake(this._currentBlock);\n        this.updated.emit(this);\n      }\n    });\n    const onClose = () => {\n      if (this._feedConsumer) {\n        log2(\"queue closed\", {\n          feedKey: this._feed.key\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n          line: 118,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._feedConsumer = void 0;\n        this._next = void 0;\n        this._currentBlock = void 0;\n        this._index = -1;\n      }\n    };\n    this._feed.core.once(\"close\", () => {\n      log2(\"feed closed\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 128,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      onClose();\n    });\n    this._feedConsumer.once(\"close\", () => {\n      onClose();\n    });\n    feedStream.pipe(this._feedConsumer, () => {\n      onClose();\n    });\n    log2(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n      line: 142,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isOpen) {\n      assert(this._feedConsumer);\n      assert(!this._feed.properties.closed);\n      log2(\"closing\", {\n        feedKey: this._feed.key\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 153,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      const [closed, setClosed] = latch();\n      this._feedConsumer.once(\"close\", setClosed);\n      this._feedConsumer.destroy();\n      (_a = this._next) == null ? void 0 : _a.call(this);\n      await closed();\n      log2(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-queue.ts\",\n        line: 159,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  peek() {\n    return this._currentBlock;\n  }\n  async pop() {\n    var _a;\n    if (!this.isOpen) {\n      throw new Error(`Queue closed: ${this.feed.key.truncate()}`);\n    }\n    let block = this.peek();\n    if (!block) {\n      block = await this._messageTrigger.wait();\n    }\n    if (block) {\n      (_a = this._next) == null ? void 0 : _a.call(this);\n    }\n    return block;\n  }\n};\n\n// packages/common/feed-store/src/feed-iterator.ts\nvar AbstractFeedIterator = class {\n  constructor() {\n    this._stopTrigger = new Trigger2();\n    this._open = false;\n    this._running = false;\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning\n    };\n  }\n  get isOpen() {\n    return this._open;\n  }\n  get isRunning() {\n    return this._running;\n  }\n  async open() {\n    if (!this._open) {\n      log3(\"opening...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 40,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._onOpen();\n      this._open = true;\n      await this.start();\n      log3(\"opened\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 45,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async close() {\n    if (this._open) {\n      log3(\"closing...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 51,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this.stop();\n      await this._onClose();\n      this._open = false;\n      log3(\"closed\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n        line: 56,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  async start() {\n    assert2(this._open);\n    if (!this._running) {\n      this._running = true;\n    }\n  }\n  async stop() {\n    assert2(this._open);\n    if (this._running) {\n      this._running = false;\n      this._stopTrigger.wake();\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this._generator();\n  }\n  async *_generator() {\n    log3(\"started\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 84,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    while (this._running) {\n      const block = await Promise.race([\n        this._stopTrigger.wait(),\n        this._nextBlock()\n      ]);\n      if (block === void 0) {\n        break;\n      }\n      yield block;\n    }\n    log3(\"stopped\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-iterator.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\nvar FeedIterator = class extends AbstractFeedIterator {\n  constructor(_feed) {\n    super();\n    this._feed = _feed;\n    this._queue = new FeedQueue(this._feed);\n  }\n  async _onOpen() {\n    await this._queue.open();\n  }\n  async _onClose() {\n    await this._queue.close();\n  }\n  async _nextBlock() {\n    return this._queue.pop();\n  }\n};\n\n// packages/common/feed-store/src/feed-set-iterator.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { inspect as inspect2 } from \"@dxos/node-std/util\";\nimport { Event as Event2, EventSubscriptions, Trigger as Trigger3 } from \"@dxos/async\";\nimport { inspectObject as inspectObject2 } from \"@dxos/debug\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { log as log4 } from \"@dxos/log\";\nimport { ComplexMap, isNotNullOrUndefined } from \"@dxos/util\";\nvar defaultFeedSetIteratorOptions = {\n  stallTimeout: 1e3\n};\nvar FeedSetIterator = class extends AbstractFeedIterator {\n  constructor(_selector, options = defaultFeedSetIteratorOptions) {\n    super();\n    this._selector = _selector;\n    this.options = options;\n    this._feedQueues = new ComplexMap(PublicKey.hash);\n    this._trigger = new Trigger3({\n      autoReset: true\n    });\n    this._subscriptions = new EventSubscriptions();\n    this.stalled = new Event2();\n    assert3(_selector);\n    assert3(options);\n  }\n  [inspect2.custom]() {\n    return inspectObject2(this);\n  }\n  toJSON() {\n    return {\n      open: this.isOpen,\n      running: this.isRunning,\n      indexes: this.indexes\n    };\n  }\n  get size() {\n    return this._feedQueues.size;\n  }\n  get feeds() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => feedQueue.feed);\n  }\n  get indexes() {\n    return Array.from(this._feedQueues.values()).map((feedQueue) => ({\n      feedKey: feedQueue.feed.key,\n      index: feedQueue.index\n    }));\n  }\n  async addFeed(feed) {\n    assert3(!this._feedQueues.has(feed.key), `Feed already added: ${feed.key}`);\n    assert3(feed.properties.opened);\n    log4(\"feed added\", {\n      feedKey: feed.key\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n      line: 89,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const queue = new FeedQueue(feed);\n    this._feedQueues.set(feed.key, queue);\n    this._subscriptions.add(queue.updated.on(() => {\n      this._trigger.wake();\n    }));\n    await queue.open();\n    this._trigger.wake();\n  }\n  async _onOpen() {\n    for (const queue of this._feedQueues.values()) {\n      await queue.open();\n    }\n  }\n  async _onClose() {\n    this._subscriptions.clear();\n    await Promise.all(Array.from(this._feedQueues.values()).map((queue) => queue.close()));\n    this._trigger.wake();\n  }\n  async _nextBlock() {\n    let t;\n    while (this._running) {\n      const queues = Array.from(this._feedQueues.values());\n      const blocks = queues.map((queue) => queue.peek()).filter(isNotNullOrUndefined);\n      if (blocks.length) {\n        const idx = this._selector(blocks);\n        if (idx === void 0) {\n          log4.warn(\"Stalled\", {\n            blocks\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 135,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          if (t === void 0) {\n            t = setTimeout(() => {\n              this.stalled.emit(this);\n            }, this.options.stallTimeout);\n          }\n        } else {\n          if (t !== void 0) {\n            clearTimeout(t);\n            t = void 0;\n          }\n          if (idx >= blocks.length) {\n            throw new Error(`Index out of bounds: ${idx} of ${blocks.length}`);\n          }\n          const queue = this._feedQueues.get(blocks[idx].feedKey);\n          log4(\"popping\", queue.toJSON(), {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n            line: 153,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          try {\n            const message = await queue.pop();\n            assert3(message === blocks[idx]);\n            return message;\n          } catch (err) {\n            log4.warn(\"queue closed\", {\n              feedKey: queue.feed.key\n            }, {\n              file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-set-iterator.ts\",\n              line: 160,\n              scope: this,\n              callSite: (f, a) => f(...a)\n            });\n            console.log(Array.from(this._feedQueues.values()));\n          }\n        }\n      }\n      await this._trigger.wait();\n    }\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nimport assert5 from \"@dxos/node-std/assert\";\nimport { Event as Event3, sleep } from \"@dxos/async\";\nimport { failUndefined as failUndefined2 } from \"@dxos/debug\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log as log6 } from \"@dxos/log\";\nimport { ComplexMap as ComplexMap2 } from \"@dxos/util\";\n\n// packages/common/feed-store/src/feed-wrapper.ts\nimport assert4 from \"@dxos/node-std/assert\";\nimport { inspect as inspect3 } from \"@dxos/node-std/util\";\nimport { inspectObject as inspectObject3, StackTrace } from \"@dxos/debug\";\nimport { log as log5 } from \"@dxos/log\";\nimport { createBinder } from \"@dxos/util\";\nvar FeedWrapper = class {\n  constructor(_hypercore, _key) {\n    this._hypercore = _hypercore;\n    this._key = _key;\n    this._pendingWrites = /* @__PURE__ */ new Set();\n    this._binder = createBinder(this._hypercore);\n    this.on = this._binder.fn(this._hypercore.on);\n    this.off = this._binder.fn(this._hypercore.off);\n    this.open = this._binder.async(this._hypercore.open);\n    this._close = this._binder.async(this._hypercore.close);\n    this.close = async () => {\n      if (this._pendingWrites.size) {\n        log5.warn(\"Closing feed with pending writes\", {\n          feed: this._key,\n          count: this._pendingWrites.size,\n          pendingWrites: Array.from(this._pendingWrites.values()).map((stack) => stack.getStack())\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 103,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      await this._close();\n    };\n    this.get = this._binder.async(this._hypercore.get);\n    this.append = this._binder.async(this._hypercore.append);\n    this.download = this._binder.async(this._hypercore.download);\n    this.replicate = this._binder.fn(this._hypercore.replicate);\n    assert4(this._hypercore);\n    assert4(this._key);\n  }\n  [inspect3.custom]() {\n    return inspectObject3(this);\n  }\n  toJSON() {\n    return {\n      feedKey: this._key,\n      length: this.properties.length,\n      opened: this.properties.opened,\n      closed: this.properties.closed\n    };\n  }\n  get key() {\n    return this._key;\n  }\n  get core() {\n    return this._hypercore;\n  }\n  get properties() {\n    return this._hypercore;\n  }\n  createReadableStream() {\n    return this._hypercore.createReadStream({\n      live: true\n    });\n  }\n  createFeedWriter() {\n    return {\n      write: async (data) => {\n        log5(\"write\", {\n          feed: this._key,\n          seq: this._hypercore.length,\n          data\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n          line: 66,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const stackTrace = new StackTrace();\n        try {\n          this._pendingWrites.add(stackTrace);\n          const seq = await this.append(data);\n          log5(\"write complete\", {\n            feed: this._key,\n            seq\n          }, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-wrapper.ts\",\n            line: 72,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n          return {\n            feedKey: this.key,\n            seq\n          };\n        } finally {\n          this._pendingWrites.delete(stackTrace);\n        }\n      }\n    };\n  }\n  get opened() {\n    return this._hypercore.opened;\n  }\n  get closed() {\n    return this._hypercore.closed;\n  }\n  get length() {\n    return this._hypercore.length;\n  }\n};\n\n// packages/common/feed-store/src/feed-store.ts\nvar FeedStore = class {\n  constructor({ factory }) {\n    this._feeds = new ComplexMap2(PublicKey2.hash);\n    this.feedOpened = new Event3();\n    this._factory = factory != null ? factory : failUndefined2();\n  }\n  get size() {\n    return this._feeds.size;\n  }\n  get feeds() {\n    return Array.from(this._feeds.values());\n  }\n  getFeed(publicKey) {\n    return this._feeds.get(publicKey);\n  }\n  async openFeed(feedKey, { writable } = {}) {\n    log6(\"opening feed\", {\n      feedKey\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 53,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    let feed = this.getFeed(feedKey);\n    if (feed) {\n      if (writable && !feed.properties.writable) {\n        throw new Error(`Read-only feed is already open: ${feedKey.truncate()}`);\n      } else {\n        await feed.open();\n        return feed;\n      }\n    }\n    const core = this._factory.createFeed(feedKey, {\n      writable\n    });\n    feed = new FeedWrapper(core, feedKey);\n    this._feeds.set(feed.key, feed);\n    await feed.open();\n    this.feedOpened.emit(feed);\n    log6(\"opened\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 74,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    return feed;\n  }\n  async close() {\n    log6(\"closing...\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 82,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    await Promise.all(Array.from(this._feeds.values()).map(async (feed) => {\n      await feed.close();\n      assert5(feed.closed);\n      await sleep(100);\n    }));\n    this._feeds.clear();\n    log6(\"closed\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/feed-store/src/feed-store.ts\",\n      line: 95,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\n\n// packages/common/feed-store/src/feed-writer.ts\nvar createFeedWriter = (cb) => ({\n  write: async (data) => {\n    return cb(data);\n  }\n});\nvar writeMessages = async (writer, messages) => {\n  const receipts = [];\n  for (const message of messages) {\n    receipts.push(await writer.write(message));\n  }\n  return receipts;\n};\nexport {\n  AbstractFeedIterator,\n  FeedFactory,\n  FeedIterator,\n  FeedQueue,\n  FeedSetIterator,\n  FeedStore,\n  FeedWrapper,\n  createFeedWriter,\n  defaultFeedSetIteratorOptions,\n  defaultReadStreamOptions,\n  writeMessages\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467041,"end":1670465467051,"order":"normal"}]}
