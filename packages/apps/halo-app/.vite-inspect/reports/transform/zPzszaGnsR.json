{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/context/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/context/src/context.ts\nimport { log } from \"@dxos/log\";\nimport { safeInstanceof } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Context = class Context1 {\n  constructor({ onError = (error) => {\n    void this.dispose();\n    throw error;\n  } } = {}) {\n    this._disposeCallbacks = [];\n    this._isDisposed = false;\n    this._onError = onError;\n  }\n  get disposed() {\n    return this._isDisposed;\n  }\n  onDispose(callback) {\n    if (this._isDisposed) {\n      throw new Error(\"Context is already disposed\");\n    }\n    this._disposeCallbacks.push(callback);\n  }\n  dispose() {\n    if (this._disposePromise) {\n      return this._disposePromise;\n    }\n    this._isDisposed = true;\n    const promises = [];\n    for (const callback of this._disposeCallbacks.reverse()) {\n      promises.push((async () => {\n        try {\n          await callback();\n        } catch (error) {\n          log.catch(error, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/context/src/context.ts\",\n            line: 72,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      })());\n    }\n    this._disposeCallbacks.length = 0;\n    return this._disposePromise = Promise.all(promises).then(() => {\n    });\n  }\n  raise(error) {\n    if (this._isDisposed) {\n      log.warn(\"Error in disposed context\", error, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/context/src/context.ts\",\n        line: 89,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    try {\n      this._onError(error);\n    } catch (err) {\n      void Promise.reject(err);\n    }\n  }\n  derive({ onError }) {\n    const newCtx = new Context({\n      onError: async (error) => {\n        if (!onError) {\n          this.raise(error);\n        } else {\n          try {\n            await onError(error);\n          } catch (e) {\n            this.raise(error);\n          }\n        }\n      }\n    });\n    this.onDispose(() => newCtx.dispose());\n    return newCtx;\n  }\n};\nContext = __decorate([\n  safeInstanceof(\"Context\")\n], Context);\nexport {\n  Context\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466319,"end":1670465466508},{"name":"vite:react-babel","result":"// packages/common/context/src/context.ts\nimport { log } from \"@dxos/log\";\nimport { safeInstanceof } from \"@dxos/util\";\nvar __decorate = function(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Context = class Context1 {\n  constructor({ onError = (error) => {\n    void this.dispose();\n    throw error;\n  } } = {}) {\n    this._disposeCallbacks = [];\n    this._isDisposed = false;\n    this._onError = onError;\n  }\n  get disposed() {\n    return this._isDisposed;\n  }\n  onDispose(callback) {\n    if (this._isDisposed) {\n      throw new Error(\"Context is already disposed\");\n    }\n    this._disposeCallbacks.push(callback);\n  }\n  dispose() {\n    if (this._disposePromise) {\n      return this._disposePromise;\n    }\n    this._isDisposed = true;\n    const promises = [];\n    for (const callback of this._disposeCallbacks.reverse()) {\n      promises.push((async () => {\n        try {\n          await callback();\n        } catch (error) {\n          log.catch(error, {}, {\n            file: \"/home/jdw/Code/dxos/dxos/packages/common/context/src/context.ts\",\n            line: 72,\n            scope: this,\n            callSite: (f, a) => f(...a)\n          });\n        }\n      })());\n    }\n    this._disposeCallbacks.length = 0;\n    return this._disposePromise = Promise.all(promises).then(() => {\n    });\n  }\n  raise(error) {\n    if (this._isDisposed) {\n      log.warn(\"Error in disposed context\", error, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/context/src/context.ts\",\n        line: 89,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      return;\n    }\n    try {\n      this._onError(error);\n    } catch (err) {\n      void Promise.reject(err);\n    }\n  }\n  derive({ onError }) {\n    const newCtx = new Context({\n      onError: async (error) => {\n        if (!onError) {\n          this.raise(error);\n        } else {\n          try {\n            await onError(error);\n          } catch (e) {\n            this.raise(error);\n          }\n        }\n      }\n    });\n    this.onDispose(() => newCtx.dispose());\n    return newCtx;\n  }\n};\nContext = __decorate([\n  safeInstanceof(\"Context\")\n], Context);\nexport {\n  Context\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466508,"end":1670465466508,"order":"pre"}]}
