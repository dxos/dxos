{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/echo/object-model/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/echo/object-model/src/index.ts\nimport { ItemID } from \"@dxos/protocols\";\n\n// packages/core/echo/object-model/src/matcher.ts\nimport { Predicate } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/mutation.ts\nimport get from \"lodash.get\";\nimport set from \"lodash.set\";\nimport assert from \"@dxos/node-std/assert\";\nimport { ObjectMutation } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/util.ts\nvar validateKey = (key) => {\n  const parts = key.split(\".\");\n  const valid = parts.every((part) => part.match(/^\\w+$/));\n  if (!valid) {\n    throw new Error(`Invalid key: ${key}`);\n  }\n  return key;\n};\nvar removeKey = (object, key) => {\n  const parts = key.split(\".\");\n  let sub = object;\n  if (parts.length > 1) {\n    for (let i = 0; i < parts.length; i++) {\n      const key1 = parts[i];\n      if (i === parts.length - 1) {\n        delete sub[key1];\n      } else {\n        sub = sub[key1];\n      }\n    }\n  } else {\n    delete object[key];\n  }\n  return object;\n};\n\n// packages/core/echo/object-model/src/mutation.ts\nvar Type;\n(function(Type2) {\n  Type2[\"NULL\"] = \"null\";\n  Type2[\"BOOLEAN\"] = \"bool\";\n  Type2[\"INTEGER\"] = \"int\";\n  Type2[\"FLOAT\"] = \"float\";\n  Type2[\"STRING\"] = \"string\";\n  Type2[\"BYTES\"] = \"bytes\";\n  Type2[\"TIMESTAMP\"] = \"timestamp\";\n  Type2[\"DATETIME\"] = \"datetime\";\n  Type2[\"OBJECT\"] = \"object\";\n})(Type || (Type = {}));\nvar SCALAR_TYPES = [\n  Type.BOOLEAN,\n  Type.INTEGER,\n  Type.FLOAT,\n  Type.STRING,\n  Type.BYTES,\n  Type.TIMESTAMP,\n  Type.DATETIME\n];\nvar KeyValueUtil = class {\n  static createMessage(key, value) {\n    assert(key);\n    return {\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n};\nvar ValueUtil = class {\n  static createMessage(value) {\n    if (value === null) {\n      return {\n        [Type.NULL]: true\n      };\n    } else if (typeof value === \"boolean\") {\n      return ValueUtil.bool(value);\n    } else if (typeof value === \"number\") {\n      return value % 1 === 0 ? ValueUtil.integer(value) : ValueUtil.float(value);\n    } else if (typeof value === \"string\") {\n      return ValueUtil.string(value);\n    } else if (value instanceof Uint8Array || Buffer.isBuffer(value)) {\n      return ValueUtil.bytes(value);\n    } else if (typeof value === \"object\") {\n      return ValueUtil.object(value);\n    } else {\n      throw new Error(`Invalid value: ${value}`);\n    }\n  }\n  static valueOf(value) {\n    if (value.object !== void 0) {\n      return ValueUtil.getObjectValue(value.object);\n    }\n    if (value.array !== void 0) {\n      return value.array.values.map((value2) => ValueUtil.valueOf(value2));\n    }\n    if (value.int) {\n      return parseInt(value.int);\n    }\n    const type = SCALAR_TYPES.find((type2) => value[type2] !== void 0);\n    if (type) {\n      return value[type];\n    }\n    return void 0;\n  }\n  static bytes(value) {\n    return {\n      [Type.BYTES]: value\n    };\n  }\n  static bool(value) {\n    return {\n      [Type.BOOLEAN]: value\n    };\n  }\n  static integer(value) {\n    return {\n      [Type.INTEGER]: value.toString()\n    };\n  }\n  static float(value) {\n    return {\n      [Type.FLOAT]: value\n    };\n  }\n  static string(value) {\n    return {\n      [Type.STRING]: value\n    };\n  }\n  static datetime(value) {\n    return {\n      [Type.DATETIME]: value\n    };\n  }\n  static object(value) {\n    return {\n      [Type.OBJECT]: {\n        properties: Object.keys(value).map((key) => KeyValueUtil.createMessage(key, value[key]))\n      }\n    };\n  }\n  static getObjectValue(value) {\n    const nestedObject = {};\n    const { properties } = value;\n    (properties != null ? properties : []).forEach(({ key, value: value2 }) => ValueUtil.applyValue(nestedObject, key, value2));\n    return nestedObject;\n  }\n  static getScalarValue(value) {\n    const type = SCALAR_TYPES.find((field) => value[field] !== void 0);\n    if (type) {\n      return value[type];\n    }\n  }\n  static applyKeyValue(object, keyValue) {\n    const { key, value } = keyValue;\n    return ValueUtil.applyValue(object, key, value);\n  }\n  static applyValue(object, key, value) {\n    assert(object);\n    assert(key);\n    if (value === void 0) {\n      return removeKey(object, key);\n    }\n    if (value[Type.OBJECT]) {\n      set(object, key, ValueUtil.getObjectValue(value[Type.OBJECT]));\n      return object;\n    }\n    if (value[Type.NULL]) {\n      set(object, key, null);\n      return object;\n    }\n    const intValue = value[Type.INTEGER];\n    if (intValue !== void 0) {\n      set(object, key, parseInt(intValue));\n      return object;\n    }\n    const scalar = ValueUtil.getScalarValue(value);\n    if (scalar !== void 0) {\n      set(object, key, scalar);\n      return object;\n    }\n    throw new Error(`Unhandled value: ${JSON.stringify(value)}`);\n  }\n};\nvar MutationUtil = class {\n  static applyMutationSet(object, message) {\n    assert(message);\n    const { mutations } = message;\n    mutations == null ? void 0 : mutations.forEach((mutation) => MutationUtil.applyMutation(object, mutation));\n    return object;\n  }\n  static applyMutation(object, mutation) {\n    assert(object);\n    const { operation = ObjectMutation.Operation.SET, key, value } = mutation;\n    switch (operation) {\n      case ObjectMutation.Operation.SET: {\n        ValueUtil.applyValue(object, key, value);\n        break;\n      }\n      case ObjectMutation.Operation.DELETE: {\n        removeKey(object, key);\n        break;\n      }\n      case ObjectMutation.Operation.ARRAY_PUSH: {\n        const values = get(object, key, []);\n        values.push(ValueUtil.valueOf(value));\n        set(object, key, values);\n        break;\n      }\n      case ObjectMutation.Operation.SET_ADD: {\n        const values1 = new Set(get(object, key, []));\n        values1.add(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values1.values()));\n        break;\n      }\n      case ObjectMutation.Operation.SET_DELETE: {\n        const values2 = new Set(get(object, key, []));\n        values2.delete(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values2.values()));\n        break;\n      }\n      default: {\n        throw new Error(`Operation not implemented: ${operation}`);\n      }\n    }\n    return object;\n  }\n  static createFieldMutation(key, value) {\n    return value === void 0 ? {\n      operation: ObjectMutation.Operation.DELETE,\n      key\n    } : {\n      operation: ObjectMutation.Operation.SET,\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n  static createMultiFieldMutation(object) {\n    return Object.entries(object).map(([key, value]) => MutationUtil.createFieldMutation(key, value));\n  }\n};\n\n// packages/core/echo/object-model/src/matcher.ts\nvar Matcher = class {\n  constructor(_options) {\n    this._options = _options;\n  }\n  getFilter(query) {\n    return (item) => this._matchItem(item, query.root);\n  }\n  matchItems(query, items) {\n    return items.filter((item) => this._matchItem(item, query.root));\n  }\n  _matchItem(item, predicate) {\n    var _a, _b;\n    const { getter } = this._options;\n    switch (predicate.op) {\n      case Predicate.Operation.OR: {\n        return predicate.predicates.findIndex((predicate2) => this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.AND: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) === -1;\n      }\n      case Predicate.Operation.NOT: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.IN: {\n        const values = ValueUtil.valueOf(predicate.value) || [];\n        const value = getter(item, predicate.key);\n        return value && values.indexOf(value) !== -1;\n      }\n      case Predicate.Operation.EQUALS: {\n        const value1 = getter(item, predicate.key);\n        return value1 === ValueUtil.valueOf(predicate.value);\n      }\n      case Predicate.Operation.PREFIX_MATCH: {\n        const value2 = getter(item, predicate.key);\n        if (typeof value2 === \"string\") {\n          const match = (_a = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _a.toLowerCase();\n          return match && value2.toLowerCase().indexOf(match) === 0;\n        }\n        break;\n      }\n      case Predicate.Operation.TEXT_MATCH: {\n        const text = (_b = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _b.trim().toLowerCase();\n        if (!text) {\n          break;\n        }\n        if (this._options.textIndex) {\n          const matches = this._options.textIndex.search(text);\n          return matches.findIndex((match) => match.id === item.id) !== -1;\n        }\n        const value3 = getter(item, predicate.key);\n        if (typeof value3 === \"string\") {\n          const words = value3.toLowerCase().split(/\\s+/);\n          return words.findIndex((word) => word.indexOf(text) === 0) !== -1;\n        }\n        break;\n      }\n    }\n    return false;\n  }\n};\n\n// packages/core/echo/object-model/src/object-model.ts\nimport cloneDeep from \"lodash.clonedeep\";\nimport get2 from \"lodash.get\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nimport { ObjectMutation as ObjectMutation2 } from \"@dxos/protocols/proto/dxos/echo/model/object\";\nvar ObjectModelStateMachine = class {\n  constructor() {\n    this._object = {};\n  }\n  getState() {\n    return this._object;\n  }\n  reset(snapshot) {\n    assert2(snapshot.root);\n    const object = {};\n    ValueUtil.applyValue(object, \"root\", snapshot.root);\n    this._object = object.root;\n  }\n  process(mutation, meta) {\n    MutationUtil.applyMutationSet(this._object, mutation);\n  }\n  snapshot() {\n    return {\n      root: ValueUtil.createMessage(this._object)\n    };\n  }\n};\nvar MutationBuilder = class {\n  constructor(_model) {\n    this._model = _model;\n    this._mutations = [];\n  }\n  set(key, value) {\n    this._mutations.push(MutationUtil.createFieldMutation(key, value));\n    return this;\n  }\n  async commit() {\n    return this._model._makeMutation({\n      mutations: this._mutations\n    });\n  }\n};\nvar ObjectModel = class extends Model {\n  toObject() {\n    return cloneDeep(this._getState());\n  }\n  builder() {\n    return new MutationBuilder(this);\n  }\n  get(key, defaultValue) {\n    validateKey(key);\n    return cloneDeep(get2(this._getState(), key, defaultValue));\n  }\n  async set(key, value) {\n    validateKey(key);\n    await this._makeMutation({\n      mutations: [\n        MutationUtil.createFieldMutation(key, value)\n      ]\n    });\n  }\n  getProperty(key, defaultValue = void 0) {\n    return this.get(key, defaultValue);\n  }\n  async setProperty(key, value) {\n    await this.set(key, value);\n  }\n  async setProperties(properties) {\n    await this._makeMutation({\n      mutations: MutationUtil.createMultiFieldMutation(properties)\n    });\n  }\n  async addToSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_ADD,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async removeFromSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_DELETE,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async pushToArray(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.ARRAY_PUSH,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async _makeMutation(mutation) {\n    const receipt = await this.write(mutation);\n    await receipt.waitToBeProcessed();\n  }\n};\nObjectModel.meta = {\n  type: \"dxos:model/object\",\n  stateMachine: () => new ObjectModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectMutationSet\"),\n  async getInitMutation(obj) {\n    return {\n      mutations: MutationUtil.createMultiFieldMutation(obj)\n    };\n  },\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectSnapshot\")\n};\n\n// packages/core/echo/object-model/src/ordered-list.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar OrderedList = class {\n  constructor(_model, _property = \"order\") {\n    this._model = _model;\n    this._property = _property;\n    this._values = [];\n    this.update = new Event();\n    this.refresh();\n    this._unsubscribe = this._model.update.on(() => this.refresh());\n  }\n  get id() {\n    return this._model.itemId;\n  }\n  get values() {\n    return this._values;\n  }\n  destroy() {\n    this._unsubscribe();\n  }\n  refresh() {\n    var _a;\n    this._values = [];\n    const properties = (_a = this._model.get(this._property)) != null ? _a : {};\n    for (const [left, right] of Object.entries(properties)) {\n      const i = this._values.findIndex((value) => value === left);\n      const j = this._values.findIndex((value) => value === right);\n      if (i === -1 && j === -1) {\n        this._values.splice(this._values.length, 0, left, right);\n      } else if (i === -1) {\n        this._values.splice(j, 1, left, right);\n      } else if (j === -1) {\n        this._values.splice(i, 1, left, right);\n      } else {\n      }\n    }\n    this.update.emit(this.values);\n    return this;\n  }\n  async init(values) {\n    const builder = this._model.builder();\n    builder.set(this._property, void 0);\n    if (values && values.length >= 2) {\n      const [first, ...rest] = values;\n      let left = first;\n      for (const value of rest) {\n        builder.set(`${this._property}.${left}`, value);\n        left = value;\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n  async insert(left, right) {\n    assert3(left && right);\n    const next = this._model.get(`${this._property}.${left}`);\n    const last = this._model.get(`${this._property}.${right}`);\n    if (next !== right) {\n      const builder = this._model.builder();\n      builder.set(`${this._property}.${left}`, right);\n      if (next) {\n        builder.set(`${this._property}.${right}`, next);\n        builder.set(`${this._property}.${next}`, last);\n      }\n      const commited = builder.commit();\n      this.refresh();\n      await commited;\n    }\n    return this._values;\n  }\n  async remove(values) {\n    const builder = this._model.builder();\n    for (const value of values) {\n      const map = this._model.get(this._property);\n      const left = Object.keys(map).find((key) => map[key] === value);\n      const right = map[value];\n      if (right) {\n        builder.set(`${this._property}.${value}`, void 0);\n      }\n      if (left) {\n        builder.set(`${this._property}.${left}`, right);\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n};\n\n// packages/core/echo/object-model/src/text-index.ts\nimport MiniSearch from \"minisearch\";\nvar TextIndex = class {\n  constructor({ fields, getter }) {\n    this._cache = /* @__PURE__ */ new Map();\n    this._items = [];\n    this._minisearch = new MiniSearch({\n      idField: \"id\",\n      fields,\n      extractField: getter\n    });\n  }\n  update(items) {\n    this._items = items;\n    this._minisearch.removeAll();\n    this._minisearch.addAll(items);\n    this._cache.clear();\n    return this;\n  }\n  search(text) {\n    let results = this._cache.get(text);\n    if (!results) {\n      results = this._minisearch.search(text).map((result) => ({\n        ...result,\n        item: this._items.find((item) => item.id === result.id)\n      }));\n      this._cache.set(text, results);\n    }\n    return results;\n  }\n};\nexport {\n  ItemID,\n  KeyValueUtil,\n  Matcher,\n  MutationBuilder,\n  MutationUtil,\n  ObjectModel,\n  OrderedList,\n  TextIndex,\n  ValueUtil,\n  removeKey,\n  validateKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465339,"end":1670465466097},{"name":"vite:react-babel","result":"// packages/core/echo/object-model/src/index.ts\nimport { ItemID } from \"@dxos/protocols\";\n\n// packages/core/echo/object-model/src/matcher.ts\nimport { Predicate } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/mutation.ts\nimport get from \"lodash.get\";\nimport set from \"lodash.set\";\nimport assert from \"@dxos/node-std/assert\";\nimport { ObjectMutation } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/util.ts\nvar validateKey = (key) => {\n  const parts = key.split(\".\");\n  const valid = parts.every((part) => part.match(/^\\w+$/));\n  if (!valid) {\n    throw new Error(`Invalid key: ${key}`);\n  }\n  return key;\n};\nvar removeKey = (object, key) => {\n  const parts = key.split(\".\");\n  let sub = object;\n  if (parts.length > 1) {\n    for (let i = 0; i < parts.length; i++) {\n      const key1 = parts[i];\n      if (i === parts.length - 1) {\n        delete sub[key1];\n      } else {\n        sub = sub[key1];\n      }\n    }\n  } else {\n    delete object[key];\n  }\n  return object;\n};\n\n// packages/core/echo/object-model/src/mutation.ts\nvar Type;\n(function(Type2) {\n  Type2[\"NULL\"] = \"null\";\n  Type2[\"BOOLEAN\"] = \"bool\";\n  Type2[\"INTEGER\"] = \"int\";\n  Type2[\"FLOAT\"] = \"float\";\n  Type2[\"STRING\"] = \"string\";\n  Type2[\"BYTES\"] = \"bytes\";\n  Type2[\"TIMESTAMP\"] = \"timestamp\";\n  Type2[\"DATETIME\"] = \"datetime\";\n  Type2[\"OBJECT\"] = \"object\";\n})(Type || (Type = {}));\nvar SCALAR_TYPES = [\n  Type.BOOLEAN,\n  Type.INTEGER,\n  Type.FLOAT,\n  Type.STRING,\n  Type.BYTES,\n  Type.TIMESTAMP,\n  Type.DATETIME\n];\nvar KeyValueUtil = class {\n  static createMessage(key, value) {\n    assert(key);\n    return {\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n};\nvar ValueUtil = class {\n  static createMessage(value) {\n    if (value === null) {\n      return {\n        [Type.NULL]: true\n      };\n    } else if (typeof value === \"boolean\") {\n      return ValueUtil.bool(value);\n    } else if (typeof value === \"number\") {\n      return value % 1 === 0 ? ValueUtil.integer(value) : ValueUtil.float(value);\n    } else if (typeof value === \"string\") {\n      return ValueUtil.string(value);\n    } else if (value instanceof Uint8Array || Buffer.isBuffer(value)) {\n      return ValueUtil.bytes(value);\n    } else if (typeof value === \"object\") {\n      return ValueUtil.object(value);\n    } else {\n      throw new Error(`Invalid value: ${value}`);\n    }\n  }\n  static valueOf(value) {\n    if (value.object !== void 0) {\n      return ValueUtil.getObjectValue(value.object);\n    }\n    if (value.array !== void 0) {\n      return value.array.values.map((value2) => ValueUtil.valueOf(value2));\n    }\n    if (value.int) {\n      return parseInt(value.int);\n    }\n    const type = SCALAR_TYPES.find((type2) => value[type2] !== void 0);\n    if (type) {\n      return value[type];\n    }\n    return void 0;\n  }\n  static bytes(value) {\n    return {\n      [Type.BYTES]: value\n    };\n  }\n  static bool(value) {\n    return {\n      [Type.BOOLEAN]: value\n    };\n  }\n  static integer(value) {\n    return {\n      [Type.INTEGER]: value.toString()\n    };\n  }\n  static float(value) {\n    return {\n      [Type.FLOAT]: value\n    };\n  }\n  static string(value) {\n    return {\n      [Type.STRING]: value\n    };\n  }\n  static datetime(value) {\n    return {\n      [Type.DATETIME]: value\n    };\n  }\n  static object(value) {\n    return {\n      [Type.OBJECT]: {\n        properties: Object.keys(value).map((key) => KeyValueUtil.createMessage(key, value[key]))\n      }\n    };\n  }\n  static getObjectValue(value) {\n    const nestedObject = {};\n    const { properties } = value;\n    (properties != null ? properties : []).forEach(({ key, value: value2 }) => ValueUtil.applyValue(nestedObject, key, value2));\n    return nestedObject;\n  }\n  static getScalarValue(value) {\n    const type = SCALAR_TYPES.find((field) => value[field] !== void 0);\n    if (type) {\n      return value[type];\n    }\n  }\n  static applyKeyValue(object, keyValue) {\n    const { key, value } = keyValue;\n    return ValueUtil.applyValue(object, key, value);\n  }\n  static applyValue(object, key, value) {\n    assert(object);\n    assert(key);\n    if (value === void 0) {\n      return removeKey(object, key);\n    }\n    if (value[Type.OBJECT]) {\n      set(object, key, ValueUtil.getObjectValue(value[Type.OBJECT]));\n      return object;\n    }\n    if (value[Type.NULL]) {\n      set(object, key, null);\n      return object;\n    }\n    const intValue = value[Type.INTEGER];\n    if (intValue !== void 0) {\n      set(object, key, parseInt(intValue));\n      return object;\n    }\n    const scalar = ValueUtil.getScalarValue(value);\n    if (scalar !== void 0) {\n      set(object, key, scalar);\n      return object;\n    }\n    throw new Error(`Unhandled value: ${JSON.stringify(value)}`);\n  }\n};\nvar MutationUtil = class {\n  static applyMutationSet(object, message) {\n    assert(message);\n    const { mutations } = message;\n    mutations == null ? void 0 : mutations.forEach((mutation) => MutationUtil.applyMutation(object, mutation));\n    return object;\n  }\n  static applyMutation(object, mutation) {\n    assert(object);\n    const { operation = ObjectMutation.Operation.SET, key, value } = mutation;\n    switch (operation) {\n      case ObjectMutation.Operation.SET: {\n        ValueUtil.applyValue(object, key, value);\n        break;\n      }\n      case ObjectMutation.Operation.DELETE: {\n        removeKey(object, key);\n        break;\n      }\n      case ObjectMutation.Operation.ARRAY_PUSH: {\n        const values = get(object, key, []);\n        values.push(ValueUtil.valueOf(value));\n        set(object, key, values);\n        break;\n      }\n      case ObjectMutation.Operation.SET_ADD: {\n        const values1 = new Set(get(object, key, []));\n        values1.add(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values1.values()));\n        break;\n      }\n      case ObjectMutation.Operation.SET_DELETE: {\n        const values2 = new Set(get(object, key, []));\n        values2.delete(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values2.values()));\n        break;\n      }\n      default: {\n        throw new Error(`Operation not implemented: ${operation}`);\n      }\n    }\n    return object;\n  }\n  static createFieldMutation(key, value) {\n    return value === void 0 ? {\n      operation: ObjectMutation.Operation.DELETE,\n      key\n    } : {\n      operation: ObjectMutation.Operation.SET,\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n  static createMultiFieldMutation(object) {\n    return Object.entries(object).map(([key, value]) => MutationUtil.createFieldMutation(key, value));\n  }\n};\n\n// packages/core/echo/object-model/src/matcher.ts\nvar Matcher = class {\n  constructor(_options) {\n    this._options = _options;\n  }\n  getFilter(query) {\n    return (item) => this._matchItem(item, query.root);\n  }\n  matchItems(query, items) {\n    return items.filter((item) => this._matchItem(item, query.root));\n  }\n  _matchItem(item, predicate) {\n    var _a, _b;\n    const { getter } = this._options;\n    switch (predicate.op) {\n      case Predicate.Operation.OR: {\n        return predicate.predicates.findIndex((predicate2) => this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.AND: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) === -1;\n      }\n      case Predicate.Operation.NOT: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.IN: {\n        const values = ValueUtil.valueOf(predicate.value) || [];\n        const value = getter(item, predicate.key);\n        return value && values.indexOf(value) !== -1;\n      }\n      case Predicate.Operation.EQUALS: {\n        const value1 = getter(item, predicate.key);\n        return value1 === ValueUtil.valueOf(predicate.value);\n      }\n      case Predicate.Operation.PREFIX_MATCH: {\n        const value2 = getter(item, predicate.key);\n        if (typeof value2 === \"string\") {\n          const match = (_a = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _a.toLowerCase();\n          return match && value2.toLowerCase().indexOf(match) === 0;\n        }\n        break;\n      }\n      case Predicate.Operation.TEXT_MATCH: {\n        const text = (_b = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _b.trim().toLowerCase();\n        if (!text) {\n          break;\n        }\n        if (this._options.textIndex) {\n          const matches = this._options.textIndex.search(text);\n          return matches.findIndex((match) => match.id === item.id) !== -1;\n        }\n        const value3 = getter(item, predicate.key);\n        if (typeof value3 === \"string\") {\n          const words = value3.toLowerCase().split(/\\s+/);\n          return words.findIndex((word) => word.indexOf(text) === 0) !== -1;\n        }\n        break;\n      }\n    }\n    return false;\n  }\n};\n\n// packages/core/echo/object-model/src/object-model.ts\nimport cloneDeep from \"lodash.clonedeep\";\nimport get2 from \"lodash.get\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nimport { ObjectMutation as ObjectMutation2 } from \"@dxos/protocols/proto/dxos/echo/model/object\";\nvar ObjectModelStateMachine = class {\n  constructor() {\n    this._object = {};\n  }\n  getState() {\n    return this._object;\n  }\n  reset(snapshot) {\n    assert2(snapshot.root);\n    const object = {};\n    ValueUtil.applyValue(object, \"root\", snapshot.root);\n    this._object = object.root;\n  }\n  process(mutation, meta) {\n    MutationUtil.applyMutationSet(this._object, mutation);\n  }\n  snapshot() {\n    return {\n      root: ValueUtil.createMessage(this._object)\n    };\n  }\n};\nvar MutationBuilder = class {\n  constructor(_model) {\n    this._model = _model;\n    this._mutations = [];\n  }\n  set(key, value) {\n    this._mutations.push(MutationUtil.createFieldMutation(key, value));\n    return this;\n  }\n  async commit() {\n    return this._model._makeMutation({\n      mutations: this._mutations\n    });\n  }\n};\nvar ObjectModel = class extends Model {\n  toObject() {\n    return cloneDeep(this._getState());\n  }\n  builder() {\n    return new MutationBuilder(this);\n  }\n  get(key, defaultValue) {\n    validateKey(key);\n    return cloneDeep(get2(this._getState(), key, defaultValue));\n  }\n  async set(key, value) {\n    validateKey(key);\n    await this._makeMutation({\n      mutations: [\n        MutationUtil.createFieldMutation(key, value)\n      ]\n    });\n  }\n  getProperty(key, defaultValue = void 0) {\n    return this.get(key, defaultValue);\n  }\n  async setProperty(key, value) {\n    await this.set(key, value);\n  }\n  async setProperties(properties) {\n    await this._makeMutation({\n      mutations: MutationUtil.createMultiFieldMutation(properties)\n    });\n  }\n  async addToSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_ADD,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async removeFromSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_DELETE,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async pushToArray(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.ARRAY_PUSH,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async _makeMutation(mutation) {\n    const receipt = await this.write(mutation);\n    await receipt.waitToBeProcessed();\n  }\n};\nObjectModel.meta = {\n  type: \"dxos:model/object\",\n  stateMachine: () => new ObjectModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectMutationSet\"),\n  async getInitMutation(obj) {\n    return {\n      mutations: MutationUtil.createMultiFieldMutation(obj)\n    };\n  },\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectSnapshot\")\n};\n\n// packages/core/echo/object-model/src/ordered-list.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar OrderedList = class {\n  constructor(_model, _property = \"order\") {\n    this._model = _model;\n    this._property = _property;\n    this._values = [];\n    this.update = new Event();\n    this.refresh();\n    this._unsubscribe = this._model.update.on(() => this.refresh());\n  }\n  get id() {\n    return this._model.itemId;\n  }\n  get values() {\n    return this._values;\n  }\n  destroy() {\n    this._unsubscribe();\n  }\n  refresh() {\n    var _a;\n    this._values = [];\n    const properties = (_a = this._model.get(this._property)) != null ? _a : {};\n    for (const [left, right] of Object.entries(properties)) {\n      const i = this._values.findIndex((value) => value === left);\n      const j = this._values.findIndex((value) => value === right);\n      if (i === -1 && j === -1) {\n        this._values.splice(this._values.length, 0, left, right);\n      } else if (i === -1) {\n        this._values.splice(j, 1, left, right);\n      } else if (j === -1) {\n        this._values.splice(i, 1, left, right);\n      } else {\n      }\n    }\n    this.update.emit(this.values);\n    return this;\n  }\n  async init(values) {\n    const builder = this._model.builder();\n    builder.set(this._property, void 0);\n    if (values && values.length >= 2) {\n      const [first, ...rest] = values;\n      let left = first;\n      for (const value of rest) {\n        builder.set(`${this._property}.${left}`, value);\n        left = value;\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n  async insert(left, right) {\n    assert3(left && right);\n    const next = this._model.get(`${this._property}.${left}`);\n    const last = this._model.get(`${this._property}.${right}`);\n    if (next !== right) {\n      const builder = this._model.builder();\n      builder.set(`${this._property}.${left}`, right);\n      if (next) {\n        builder.set(`${this._property}.${right}`, next);\n        builder.set(`${this._property}.${next}`, last);\n      }\n      const commited = builder.commit();\n      this.refresh();\n      await commited;\n    }\n    return this._values;\n  }\n  async remove(values) {\n    const builder = this._model.builder();\n    for (const value of values) {\n      const map = this._model.get(this._property);\n      const left = Object.keys(map).find((key) => map[key] === value);\n      const right = map[value];\n      if (right) {\n        builder.set(`${this._property}.${value}`, void 0);\n      }\n      if (left) {\n        builder.set(`${this._property}.${left}`, right);\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n};\n\n// packages/core/echo/object-model/src/text-index.ts\nimport MiniSearch from \"minisearch\";\nvar TextIndex = class {\n  constructor({ fields, getter }) {\n    this._cache = /* @__PURE__ */ new Map();\n    this._items = [];\n    this._minisearch = new MiniSearch({\n      idField: \"id\",\n      fields,\n      extractField: getter\n    });\n  }\n  update(items) {\n    this._items = items;\n    this._minisearch.removeAll();\n    this._minisearch.addAll(items);\n    this._cache.clear();\n    return this;\n  }\n  search(text) {\n    let results = this._cache.get(text);\n    if (!results) {\n      results = this._minisearch.search(text).map((result) => ({\n        ...result,\n        item: this._items.find((item) => item.id === result.id)\n      }));\n      this._cache.set(text, results);\n    }\n    return results;\n  }\n};\nexport {\n  ItemID,\n  KeyValueUtil,\n  Matcher,\n  MutationBuilder,\n  MutationUtil,\n  ObjectModel,\n  OrderedList,\n  TextIndex,\n  ValueUtil,\n  removeKey,\n  validateKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466097,"end":1670465466097,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/echo/object-model/src/index.ts\nimport { ItemID } from \"@dxos/protocols\";\n\n// packages/core/echo/object-model/src/matcher.ts\nimport { Predicate } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/mutation.ts\nimport get from \"lodash.get\";\nimport set from \"lodash.set\";\nimport assert from \"@dxos/node-std/assert\";\nimport { ObjectMutation } from \"@dxos/protocols/proto/dxos/echo/model/object\";\n\n// packages/core/echo/object-model/src/util.ts\nvar validateKey = (key) => {\n  const parts = key.split(\".\");\n  const valid = parts.every((part) => part.match(/^\\w+$/));\n  if (!valid) {\n    throw new Error(`Invalid key: ${key}`);\n  }\n  return key;\n};\nvar removeKey = (object, key) => {\n  const parts = key.split(\".\");\n  let sub = object;\n  if (parts.length > 1) {\n    for (let i = 0; i < parts.length; i++) {\n      const key1 = parts[i];\n      if (i === parts.length - 1) {\n        delete sub[key1];\n      } else {\n        sub = sub[key1];\n      }\n    }\n  } else {\n    delete object[key];\n  }\n  return object;\n};\n\n// packages/core/echo/object-model/src/mutation.ts\nvar Type;\n(function(Type2) {\n  Type2[\"NULL\"] = \"null\";\n  Type2[\"BOOLEAN\"] = \"bool\";\n  Type2[\"INTEGER\"] = \"int\";\n  Type2[\"FLOAT\"] = \"float\";\n  Type2[\"STRING\"] = \"string\";\n  Type2[\"BYTES\"] = \"bytes\";\n  Type2[\"TIMESTAMP\"] = \"timestamp\";\n  Type2[\"DATETIME\"] = \"datetime\";\n  Type2[\"OBJECT\"] = \"object\";\n})(Type || (Type = {}));\nvar SCALAR_TYPES = [\n  Type.BOOLEAN,\n  Type.INTEGER,\n  Type.FLOAT,\n  Type.STRING,\n  Type.BYTES,\n  Type.TIMESTAMP,\n  Type.DATETIME\n];\nvar KeyValueUtil = class {\n  static createMessage(key, value) {\n    assert(key);\n    return {\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n};\nvar ValueUtil = class {\n  static createMessage(value) {\n    if (value === null) {\n      return {\n        [Type.NULL]: true\n      };\n    } else if (typeof value === \"boolean\") {\n      return ValueUtil.bool(value);\n    } else if (typeof value === \"number\") {\n      return value % 1 === 0 ? ValueUtil.integer(value) : ValueUtil.float(value);\n    } else if (typeof value === \"string\") {\n      return ValueUtil.string(value);\n    } else if (value instanceof Uint8Array || Buffer.isBuffer(value)) {\n      return ValueUtil.bytes(value);\n    } else if (typeof value === \"object\") {\n      return ValueUtil.object(value);\n    } else {\n      throw new Error(`Invalid value: ${value}`);\n    }\n  }\n  static valueOf(value) {\n    if (value.object !== void 0) {\n      return ValueUtil.getObjectValue(value.object);\n    }\n    if (value.array !== void 0) {\n      return value.array.values.map((value2) => ValueUtil.valueOf(value2));\n    }\n    if (value.int) {\n      return parseInt(value.int);\n    }\n    const type = SCALAR_TYPES.find((type2) => value[type2] !== void 0);\n    if (type) {\n      return value[type];\n    }\n    return void 0;\n  }\n  static bytes(value) {\n    return {\n      [Type.BYTES]: value\n    };\n  }\n  static bool(value) {\n    return {\n      [Type.BOOLEAN]: value\n    };\n  }\n  static integer(value) {\n    return {\n      [Type.INTEGER]: value.toString()\n    };\n  }\n  static float(value) {\n    return {\n      [Type.FLOAT]: value\n    };\n  }\n  static string(value) {\n    return {\n      [Type.STRING]: value\n    };\n  }\n  static datetime(value) {\n    return {\n      [Type.DATETIME]: value\n    };\n  }\n  static object(value) {\n    return {\n      [Type.OBJECT]: {\n        properties: Object.keys(value).map((key) => KeyValueUtil.createMessage(key, value[key]))\n      }\n    };\n  }\n  static getObjectValue(value) {\n    const nestedObject = {};\n    const { properties } = value;\n    (properties != null ? properties : []).forEach(({ key, value: value2 }) => ValueUtil.applyValue(nestedObject, key, value2));\n    return nestedObject;\n  }\n  static getScalarValue(value) {\n    const type = SCALAR_TYPES.find((field) => value[field] !== void 0);\n    if (type) {\n      return value[type];\n    }\n  }\n  static applyKeyValue(object, keyValue) {\n    const { key, value } = keyValue;\n    return ValueUtil.applyValue(object, key, value);\n  }\n  static applyValue(object, key, value) {\n    assert(object);\n    assert(key);\n    if (value === void 0) {\n      return removeKey(object, key);\n    }\n    if (value[Type.OBJECT]) {\n      set(object, key, ValueUtil.getObjectValue(value[Type.OBJECT]));\n      return object;\n    }\n    if (value[Type.NULL]) {\n      set(object, key, null);\n      return object;\n    }\n    const intValue = value[Type.INTEGER];\n    if (intValue !== void 0) {\n      set(object, key, parseInt(intValue));\n      return object;\n    }\n    const scalar = ValueUtil.getScalarValue(value);\n    if (scalar !== void 0) {\n      set(object, key, scalar);\n      return object;\n    }\n    throw new Error(`Unhandled value: ${JSON.stringify(value)}`);\n  }\n};\nvar MutationUtil = class {\n  static applyMutationSet(object, message) {\n    assert(message);\n    const { mutations } = message;\n    mutations == null ? void 0 : mutations.forEach((mutation) => MutationUtil.applyMutation(object, mutation));\n    return object;\n  }\n  static applyMutation(object, mutation) {\n    assert(object);\n    const { operation = ObjectMutation.Operation.SET, key, value } = mutation;\n    switch (operation) {\n      case ObjectMutation.Operation.SET: {\n        ValueUtil.applyValue(object, key, value);\n        break;\n      }\n      case ObjectMutation.Operation.DELETE: {\n        removeKey(object, key);\n        break;\n      }\n      case ObjectMutation.Operation.ARRAY_PUSH: {\n        const values = get(object, key, []);\n        values.push(ValueUtil.valueOf(value));\n        set(object, key, values);\n        break;\n      }\n      case ObjectMutation.Operation.SET_ADD: {\n        const values1 = new Set(get(object, key, []));\n        values1.add(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values1.values()));\n        break;\n      }\n      case ObjectMutation.Operation.SET_DELETE: {\n        const values2 = new Set(get(object, key, []));\n        values2.delete(ValueUtil.valueOf(value));\n        set(object, key, Array.from(values2.values()));\n        break;\n      }\n      default: {\n        throw new Error(`Operation not implemented: ${operation}`);\n      }\n    }\n    return object;\n  }\n  static createFieldMutation(key, value) {\n    return value === void 0 ? {\n      operation: ObjectMutation.Operation.DELETE,\n      key\n    } : {\n      operation: ObjectMutation.Operation.SET,\n      key,\n      value: ValueUtil.createMessage(value)\n    };\n  }\n  static createMultiFieldMutation(object) {\n    return Object.entries(object).map(([key, value]) => MutationUtil.createFieldMutation(key, value));\n  }\n};\n\n// packages/core/echo/object-model/src/matcher.ts\nvar Matcher = class {\n  constructor(_options) {\n    this._options = _options;\n  }\n  getFilter(query) {\n    return (item) => this._matchItem(item, query.root);\n  }\n  matchItems(query, items) {\n    return items.filter((item) => this._matchItem(item, query.root));\n  }\n  _matchItem(item, predicate) {\n    var _a, _b;\n    const { getter } = this._options;\n    switch (predicate.op) {\n      case Predicate.Operation.OR: {\n        return predicate.predicates.findIndex((predicate2) => this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.AND: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) === -1;\n      }\n      case Predicate.Operation.NOT: {\n        return predicate.predicates.findIndex((predicate2) => !this._matchItem(item, predicate2)) !== -1;\n      }\n      case Predicate.Operation.IN: {\n        const values = ValueUtil.valueOf(predicate.value) || [];\n        const value = getter(item, predicate.key);\n        return value && values.indexOf(value) !== -1;\n      }\n      case Predicate.Operation.EQUALS: {\n        const value1 = getter(item, predicate.key);\n        return value1 === ValueUtil.valueOf(predicate.value);\n      }\n      case Predicate.Operation.PREFIX_MATCH: {\n        const value2 = getter(item, predicate.key);\n        if (typeof value2 === \"string\") {\n          const match = (_a = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _a.toLowerCase();\n          return match && value2.toLowerCase().indexOf(match) === 0;\n        }\n        break;\n      }\n      case Predicate.Operation.TEXT_MATCH: {\n        const text = (_b = ValueUtil.valueOf(predicate.value)) == null ? void 0 : _b.trim().toLowerCase();\n        if (!text) {\n          break;\n        }\n        if (this._options.textIndex) {\n          const matches = this._options.textIndex.search(text);\n          return matches.findIndex((match) => match.id === item.id) !== -1;\n        }\n        const value3 = getter(item, predicate.key);\n        if (typeof value3 === \"string\") {\n          const words = value3.toLowerCase().split(/\\s+/);\n          return words.findIndex((word) => word.indexOf(text) === 0) !== -1;\n        }\n        break;\n      }\n    }\n    return false;\n  }\n};\n\n// packages/core/echo/object-model/src/object-model.ts\nimport cloneDeep from \"lodash.clonedeep\";\nimport get2 from \"lodash.get\";\nimport assert2 from \"@dxos/node-std/assert\";\nimport { Model } from \"@dxos/model-factory\";\nimport { schema } from \"@dxos/protocols\";\nimport { ObjectMutation as ObjectMutation2 } from \"@dxos/protocols/proto/dxos/echo/model/object\";\nvar ObjectModelStateMachine = class {\n  constructor() {\n    this._object = {};\n  }\n  getState() {\n    return this._object;\n  }\n  reset(snapshot) {\n    assert2(snapshot.root);\n    const object = {};\n    ValueUtil.applyValue(object, \"root\", snapshot.root);\n    this._object = object.root;\n  }\n  process(mutation, meta) {\n    MutationUtil.applyMutationSet(this._object, mutation);\n  }\n  snapshot() {\n    return {\n      root: ValueUtil.createMessage(this._object)\n    };\n  }\n};\nvar MutationBuilder = class {\n  constructor(_model) {\n    this._model = _model;\n    this._mutations = [];\n  }\n  set(key, value) {\n    this._mutations.push(MutationUtil.createFieldMutation(key, value));\n    return this;\n  }\n  async commit() {\n    return this._model._makeMutation({\n      mutations: this._mutations\n    });\n  }\n};\nvar ObjectModel = class extends Model {\n  toObject() {\n    return cloneDeep(this._getState());\n  }\n  builder() {\n    return new MutationBuilder(this);\n  }\n  get(key, defaultValue) {\n    validateKey(key);\n    return cloneDeep(get2(this._getState(), key, defaultValue));\n  }\n  async set(key, value) {\n    validateKey(key);\n    await this._makeMutation({\n      mutations: [\n        MutationUtil.createFieldMutation(key, value)\n      ]\n    });\n  }\n  getProperty(key, defaultValue = void 0) {\n    return this.get(key, defaultValue);\n  }\n  async setProperty(key, value) {\n    await this.set(key, value);\n  }\n  async setProperties(properties) {\n    await this._makeMutation({\n      mutations: MutationUtil.createMultiFieldMutation(properties)\n    });\n  }\n  async addToSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_ADD,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async removeFromSet(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.SET_DELETE,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async pushToArray(key, value) {\n    await this._makeMutation({\n      mutations: [\n        {\n          operation: ObjectMutation2.Operation.ARRAY_PUSH,\n          key,\n          value: ValueUtil.createMessage(value)\n        }\n      ]\n    });\n  }\n  async _makeMutation(mutation) {\n    const receipt = await this.write(mutation);\n    await receipt.waitToBeProcessed();\n  }\n};\nObjectModel.meta = {\n  type: \"dxos:model/object\",\n  stateMachine: () => new ObjectModelStateMachine(),\n  mutationCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectMutationSet\"),\n  async getInitMutation(obj) {\n    return {\n      mutations: MutationUtil.createMultiFieldMutation(obj)\n    };\n  },\n  snapshotCodec: schema.getCodecForType(\"dxos.echo.model.object.ObjectSnapshot\")\n};\n\n// packages/core/echo/object-model/src/ordered-list.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event } from \"@dxos/async\";\nvar OrderedList = class {\n  constructor(_model, _property = \"order\") {\n    this._model = _model;\n    this._property = _property;\n    this._values = [];\n    this.update = new Event();\n    this.refresh();\n    this._unsubscribe = this._model.update.on(() => this.refresh());\n  }\n  get id() {\n    return this._model.itemId;\n  }\n  get values() {\n    return this._values;\n  }\n  destroy() {\n    this._unsubscribe();\n  }\n  refresh() {\n    var _a;\n    this._values = [];\n    const properties = (_a = this._model.get(this._property)) != null ? _a : {};\n    for (const [left, right] of Object.entries(properties)) {\n      const i = this._values.findIndex((value) => value === left);\n      const j = this._values.findIndex((value) => value === right);\n      if (i === -1 && j === -1) {\n        this._values.splice(this._values.length, 0, left, right);\n      } else if (i === -1) {\n        this._values.splice(j, 1, left, right);\n      } else if (j === -1) {\n        this._values.splice(i, 1, left, right);\n      } else {\n      }\n    }\n    this.update.emit(this.values);\n    return this;\n  }\n  async init(values) {\n    const builder = this._model.builder();\n    builder.set(this._property, void 0);\n    if (values && values.length >= 2) {\n      const [first, ...rest] = values;\n      let left = first;\n      for (const value of rest) {\n        builder.set(`${this._property}.${left}`, value);\n        left = value;\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n  async insert(left, right) {\n    assert3(left && right);\n    const next = this._model.get(`${this._property}.${left}`);\n    const last = this._model.get(`${this._property}.${right}`);\n    if (next !== right) {\n      const builder = this._model.builder();\n      builder.set(`${this._property}.${left}`, right);\n      if (next) {\n        builder.set(`${this._property}.${right}`, next);\n        builder.set(`${this._property}.${next}`, last);\n      }\n      const commited = builder.commit();\n      this.refresh();\n      await commited;\n    }\n    return this._values;\n  }\n  async remove(values) {\n    const builder = this._model.builder();\n    for (const value of values) {\n      const map = this._model.get(this._property);\n      const left = Object.keys(map).find((key) => map[key] === value);\n      const right = map[value];\n      if (right) {\n        builder.set(`${this._property}.${value}`, void 0);\n      }\n      if (left) {\n        builder.set(`${this._property}.${left}`, right);\n      }\n    }\n    const commited = builder.commit();\n    this.refresh();\n    await commited;\n    return this._values;\n  }\n};\n\n// packages/core/echo/object-model/src/text-index.ts\nimport MiniSearch from \"minisearch\";\nvar TextIndex = class {\n  constructor({ fields, getter }) {\n    this._cache = /* @__PURE__ */ new Map();\n    this._items = [];\n    this._minisearch = new MiniSearch({\n      idField: \"id\",\n      fields,\n      extractField: getter\n    });\n  }\n  update(items) {\n    this._items = items;\n    this._minisearch.removeAll();\n    this._minisearch.addAll(items);\n    this._cache.clear();\n    return this;\n  }\n  search(text) {\n    let results = this._cache.get(text);\n    if (!results) {\n      results = this._minisearch.search(text).map((result) => ({\n        ...result,\n        item: this._items.find((item) => item.id === result.id)\n      }));\n      this._cache.set(text, results);\n    }\n    return results;\n  }\n};\nexport {\n  ItemID,\n  KeyValueUtil,\n  Matcher,\n  MutationBuilder,\n  MutationUtil,\n  ObjectModel,\n  OrderedList,\n  TextIndex,\n  ValueUtil,\n  removeKey,\n  validateKey\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466098,"end":1670465466108,"order":"normal"}]}
