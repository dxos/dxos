{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/echo/model-factory/src/model.ts\nimport { Event } from \"@dxos/async\";\nvar Model = class {\n  constructor(_meta, _itemId, _getState, _mutationWriter) {\n    this._meta = _meta;\n    this._itemId = _itemId;\n    this._getState = _getState;\n    this._mutationWriter = _mutationWriter;\n    this.update = new Event();\n  }\n  toString() {\n    return `Model(${JSON.stringify(this.toJSON())})`;\n  }\n  toJSON() {\n    return {\n      id: this.itemId,\n      type: this._meta.type\n    };\n  }\n  get modelMeta() {\n    return this._meta;\n  }\n  get itemId() {\n    return this._itemId;\n  }\n  get readOnly() {\n    return this._mutationWriter === void 0;\n  }\n  subscribe(listener) {\n    return this.update.on(listener);\n  }\n  async write(mutation) {\n    if (!this._mutationWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    return this._mutationWriter(mutation);\n  }\n};\n\n// packages/core/echo/model-factory/src/model-factory.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, scheduleTask as scheduleTask2 } from \"@dxos/async\";\nimport { Context as Context2 } from \"@dxos/context\";\n\n// packages/core/echo/model-factory/src/state-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\n\n// packages/core/echo/model-factory/src/ordering.ts\nimport { PublicKey } from \"@dxos/keys\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar getInsertionIndex = (existing, newMutation) => {\n  let start = existing.length - 1;\n  for (const ourKey = PublicKey.from(newMutation.meta.feedKey); start >= 0; start--) {\n    if (ourKey.equals(existing[start].meta.feedKey)) {\n      break;\n    }\n  }\n  for (let i = start + 1; i < existing.length; i++) {\n    const existingTimeframe = Timeframe.merge(existing[i].meta.timeframe, new Timeframe([\n      [\n        PublicKey.from(existing[i].meta.feedKey),\n        existing[i].meta.seq - 1\n      ]\n    ]));\n    const deps = Timeframe.dependencies(newMutation.meta.timeframe, existingTimeframe);\n    if (deps.isEmpty()) {\n      if (PublicKey.from(newMutation.meta.feedKey).toHex() < PublicKey.from(existing[i].meta.feedKey).toHex()) {\n        return i;\n      }\n    }\n  }\n  return existing.length;\n};\n\n// packages/core/echo/model-factory/src/state-manager.ts\nvar StateManager = class {\n  constructor(_modelType, modelConstructor, _itemId, _initialState, _memberKey, _feedWriter) {\n    this._modelType = _modelType;\n    this._itemId = _itemId;\n    this._initialState = _initialState;\n    this._memberKey = _memberKey;\n    this._feedWriter = _feedWriter;\n    this._mutationProcessed = new Event2();\n    this._modelMeta = null;\n    this._stateMachine = null;\n    this._model = null;\n    this._mutations = [];\n    this._optimisticMutations = [];\n    if (modelConstructor) {\n      this.initialize(modelConstructor);\n    }\n  }\n  get initialized() {\n    return !!this._modelMeta;\n  }\n  get modelType() {\n    return this._modelType;\n  }\n  get modelMeta() {\n    assert(this._modelMeta, \"Model not initialized.\");\n    return this._modelMeta;\n  }\n  get model() {\n    assert(this._model, \"Model not initialized.\");\n    return this._model;\n  }\n  _emitModelUpdate() {\n    scheduleTask(new Context(), () => {\n      assert(this._model);\n      this._model.update.emit(this._model);\n    });\n  }\n  async _write(mutation) {\n    log(\"Write\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 120,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._feedWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    const mutationEncoded = this._modelMeta.mutationCodec.encode(mutation);\n    const optimisticMutation = {\n      mutation: mutationEncoded,\n      meta: {\n        author: this._memberKey\n      }\n    };\n    this._optimisticMutations.push(optimisticMutation);\n    if (this.initialized) {\n      log(\"Optimistic apply\", mutation, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._stateMachine.process(mutation, optimisticMutation.meta);\n      this._emitModelUpdate();\n    }\n    const receipt = await this._feedWriter.write(mutationEncoded);\n    log(\"Confirm\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 146,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    optimisticMutation.receipt = receipt;\n    const processed = this._mutationProcessed.waitFor((meta) => receipt.feedKey.equals(meta.feedKey) && meta.seq === receipt.seq);\n    void processed.then(() => {\n      if (!optimisticMutation.receipt) {\n        log.error(\"Optimistic mutation was processed without being confirmed\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 157,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      if (this._optimisticMutations.includes(optimisticMutation)) {\n        log.error(\"Optimistic mutation was processed without being removed from the optimistic queue\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 163,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    return {\n      ...receipt,\n      waitToBeProcessed: async () => {\n        await processed;\n      }\n    };\n  }\n  _resetStateMachine() {\n    var _a;\n    assert(this._modelMeta, \"Model not initialized.\");\n    log(\"Construct state machine\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._stateMachine = this._modelMeta.stateMachine();\n    if (this._initialState.snapshot) {\n      assert(this._modelMeta.snapshotCodec);\n      const decoded = this._modelMeta.snapshotCodec.decode(this._initialState.snapshot);\n      this._stateMachine.reset(decoded);\n    }\n    for (const mutation of (_a = this._initialState.mutations) != null ? _a : []) {\n      const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation.mutation);\n      this._stateMachine.process(mutationDecoded, {\n        author: PublicKey2.from(mutation.meta.memberKey)\n      });\n    }\n    for (const mutation1 of this._mutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation1.mutation), {\n        author: PublicKey2.from(mutation1.meta.memberKey)\n      });\n    }\n    for (const mutation2 of this._optimisticMutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation2.mutation), mutation2.meta);\n    }\n  }\n  initialize(modelConstructor) {\n    assert(!this._modelMeta, \"Already iniitalized.\");\n    this._modelMeta = modelConstructor.meta;\n    this._resetStateMachine();\n    this._model = new modelConstructor(this._modelMeta, this._itemId, () => this._stateMachine.getState(), this._feedWriter ? (mutation) => this._write(mutation) : void 0);\n  }\n  processMessage(meta, mutation) {\n    const optimisticIndex = this._optimisticMutations.findIndex((message) => message.receipt && PublicKey2.equals(message.receipt.feedKey, meta.feedKey) && message.receipt.seq === meta.seq);\n    if (optimisticIndex !== -1) {\n      this._optimisticMutations.splice(optimisticIndex, 1);\n    }\n    const insertionIndex = getInsertionIndex(this._mutations, {\n      meta,\n      mutation\n    });\n    const lengthBefore = this._mutations.length;\n    this._mutations.splice(insertionIndex, 0, {\n      meta,\n      mutation\n    });\n    log(`Process ${PublicKey2.from(meta.feedKey)}/${meta.seq} insertionIndex=${insertionIndex} optimisticIndex=${optimisticIndex} queue length=${lengthBefore}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 256,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this.initialized) {\n      if (insertionIndex !== lengthBefore || optimisticIndex > 0 || optimisticIndex === -1 && this._optimisticMutations.length > 0) {\n        log(\"Reset due to order change\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 271,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._resetStateMachine();\n      } else if (optimisticIndex === -1) {\n        log(`Apply ${JSON.stringify(meta)}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation);\n        this._stateMachine.process(mutationDecoded, {\n          author: PublicKey2.from(meta.memberKey)\n        });\n        this._emitModelUpdate();\n      }\n    }\n    scheduleTask(new Context(), () => this._mutationProcessed.emit(meta));\n  }\n  createSnapshot() {\n    var _a;\n    if (this.initialized && this.modelMeta.snapshotCodec) {\n      return {\n        snapshot: this.modelMeta.snapshotCodec.encode(this._stateMachine.snapshot())\n      };\n    }\n    return {\n      snapshot: this._initialState.snapshot,\n      mutations: [\n        ...(_a = this._initialState.mutations) != null ? _a : [],\n        ...this._mutations\n      ]\n    };\n  }\n  resetToSnapshot(snapshot) {\n    this._initialState = snapshot;\n    this._mutations = [];\n    if (this.initialized) {\n      this._resetStateMachine();\n      this._emitModelUpdate();\n    }\n  }\n};\n\n// packages/core/echo/model-factory/src/types.ts\nimport assert2 from \"@dxos/node-std/assert\";\nfunction validateModelClass(model) {\n  assert2(typeof model === \"function\");\n  if (!model.meta) {\n    throw new TypeError(\"Invalid model: missing static `meta` field.\");\n  }\n  if (!model.meta.type) {\n    throw new TypeError(\"Invalid model: missing type URL.\");\n  }\n  if (!model.meta.mutationCodec) {\n    throw new TypeError(\"Invalid model: missing mutation codec.\");\n  }\n}\n\n// packages/core/echo/model-factory/src/model-factory.ts\nvar ModelFactory = class {\n  constructor() {\n    this.registered = new Event3();\n    this._models = /* @__PURE__ */ new Map();\n  }\n  hasModel(modelType) {\n    return this.getModel(modelType) !== void 0;\n  }\n  getModels() {\n    return Array.from(this._models.values());\n  }\n  getModel(modelType) {\n    assert3(modelType);\n    return this._models.get(modelType);\n  }\n  getModelMeta(modelType) {\n    if (!this._models.has(modelType)) {\n      throw new Error(`Invalid model type: ${modelType}`);\n    }\n    const { meta } = this._models.get(modelType);\n    return meta;\n  }\n  registerModel(constructor) {\n    validateModelClass(constructor);\n    const { meta } = constructor;\n    this._models.set(meta.type, {\n      meta,\n      constructor\n    });\n    scheduleTask2(new Context2(), () => {\n      this.registered.emit(constructor);\n    });\n    return this;\n  }\n  createModel(modelType, itemId, snapshot, memberKey, writeStream) {\n    var _a;\n    assert3(itemId);\n    const constructor = (_a = this._models.get(modelType)) == null ? void 0 : _a.constructor;\n    return new StateManager(modelType, constructor, itemId, snapshot, memberKey, writeStream != null ? writeStream : null);\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/messages.ts\nimport { schema } from \"@dxos/protocols\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\nvar createSetPropertyMutation = (itemId, key, value, timeframe = new Timeframe2()) => ({\n  timeframe,\n  payload: {\n    \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n    itemId,\n    mutation: schema.getCodecForType(\"example.testing.data.TestItemMutation\").encode({\n      key,\n      value\n    })\n  }\n});\n\n// packages/core/echo/model-factory/src/testing/test-builder.ts\nimport debug from \"debug\";\nimport { Trigger } from \"@dxos/async\";\nimport { createFeedWriter } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { ComplexMap } from \"@dxos/util\";\nvar log2 = debug(\"dxos:echo:model-test-rig\");\nvar TestBuilder = class {\n  constructor(_modelFactory, _modelConstructor) {\n    this._modelFactory = _modelFactory;\n    this._modelConstructor = _modelConstructor;\n    this._peers = new ComplexMap(PublicKey3.hash);\n    this._replicationFinished = new Trigger();\n    this._replicating = true;\n    this._replicationFinished.wake();\n  }\n  createPeer() {\n    const key = PublicKey3.random();\n    const writer = createFeedWriter((data) => {\n      return Promise.resolve(this._writeMessage(key, data));\n    });\n    const id = PublicKey3.random().toHex();\n    const stateManager = this._modelFactory.createModel(this._modelConstructor.meta.type, id, {}, key, writer);\n    const peer = new TestPeer(stateManager, key);\n    this._peers.set(key, peer);\n    return peer;\n  }\n  configureReplication(value) {\n    this._replicating = value;\n    this._replicate();\n  }\n  async waitForReplication() {\n    log2(\"Waiting for replication...\");\n    await this._replicationFinished.wait();\n    log2(\"Replications started.\");\n  }\n  _writeMessage(peerKey, mutation) {\n    const peer = this._peers.get(peerKey);\n    const seq = peer.mutations.length;\n    const timeframe = peer.timeframe;\n    log2(`Write ${peerKey}:${seq}`);\n    const message = {\n      meta: {\n        feedKey: peerKey,\n        memberKey: peerKey,\n        seq,\n        timeframe\n      },\n      mutation\n    };\n    peer.mutations.push(message);\n    setTimeout(() => peer.processMutation(message));\n    if (this._replicating) {\n      setTimeout(() => this._replicate());\n    }\n    this._replicationFinished.reset();\n    log2(\"Reset replication lock.\");\n    return {\n      feedKey: peerKey,\n      seq\n    };\n  }\n  _replicate() {\n    for (const peer of this._peers.values()) {\n      for (const [feed, { mutations }] of this._peers) {\n        if (peer.key.equals(feed)) {\n          continue;\n        }\n        const timeframeSeq = peer.timeframe.get(feed);\n        const startingIndex = timeframeSeq === void 0 ? 0 : timeframeSeq + 1;\n        log2(`Replicating feed ${feed} -> ${peer.key} range [${startingIndex}; ${mutations.length})`);\n        for (let i = startingIndex; i < mutations.length; i++) {\n          log2(`Process ${feed}:${i} -> ${peer.key}`);\n          peer.processMutation(mutations[i]);\n        }\n      }\n    }\n    this._replicationFinished.wake();\n    log2(\"Wake replication lock.\");\n  }\n};\nvar TestPeer = class {\n  constructor(stateManager, key) {\n    this.stateManager = stateManager;\n    this.key = key;\n    this.timeframe = new Timeframe3();\n    this.mutations = [];\n  }\n  get model() {\n    return this.stateManager.model;\n  }\n  processMutation(message) {\n    this.stateManager.processMessage(message.meta, message.mutation);\n    this.timeframe = Timeframe3.merge(this.timeframe, new Timeframe3([\n      [\n        PublicKey3.from(message.meta.feedKey),\n        message.meta.seq\n      ]\n    ]));\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/test-model.ts\nimport { checkType } from \"@dxos/debug\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar TestModelStateMachine = class {\n  constructor() {\n    this._state = /* @__PURE__ */ new Map();\n  }\n  getState() {\n    return this._state;\n  }\n  process(mutation, meta) {\n    const { key, value } = mutation;\n    this._state.set(key, value);\n  }\n  snapshot() {\n    return {\n      keys: Array.from(this._state.entries()).map(([key, value]) => ({\n        key,\n        value\n      }))\n    };\n  }\n  reset(snapshot) {\n    var _a;\n    this._state.clear();\n    ((_a = snapshot.keys) != null ? _a : []).forEach(({ key, value }) => this._state.set(key, value));\n  }\n};\nvar TestModel = class extends Model {\n  get keys() {\n    return Array.from(this._getState().keys());\n  }\n  get properties() {\n    return Object.fromEntries(this._getState());\n  }\n  get(key) {\n    return this._getState().get(key);\n  }\n  async set(key, value) {\n    const receipt = await this.write(checkType({\n      key,\n      value\n    }));\n    await receipt.waitToBeProcessed();\n  }\n};\nTestModel.meta = {\n  type: \"dxos:model/test\",\n  stateMachine: () => new TestModelStateMachine(),\n  mutationCodec: schema2.getCodecForType(\"example.testing.data.TestItemMutation\"),\n  snapshotCodec: schema2.getCodecForType(\"example.testing.data.TestItemSnapshot\")\n};\n\n// packages/core/echo/model-factory/src/testing/test-list-model.ts\nimport { schema as schema3 } from \"@dxos/protocols\";\nvar TestListModelStateMachine = class {\n  constructor() {\n    this._messages = [];\n  }\n  getState() {\n    return this._messages;\n  }\n  process(mutation, meta) {\n    this._messages.push(mutation);\n  }\n  snapshot() {\n    throw new Error(\"Method not implemented.\");\n  }\n  reset(snapshot) {\n    throw new Error(\"Method not implemented.\");\n  }\n};\nvar TestListModel = class extends Model {\n  get messages() {\n    return this._getState();\n  }\n  async sendMessage(data) {\n    const receipt = await this.write({\n      data\n    });\n    await receipt.waitToBeProcessed();\n  }\n};\nTestListModel.meta = {\n  type: \"dxos:model/test-list\",\n  stateMachine: () => new TestListModelStateMachine(),\n  mutationCodec: schema3.getCodecForType(\"example.testing.data.TestListMutation\")\n};\nexport {\n  Model,\n  ModelFactory,\n  StateManager,\n  TestBuilder,\n  TestListModel,\n  TestModel,\n  TestPeer,\n  createSetPropertyMutation,\n  validateModelClass\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466963,"end":1670465467000},{"name":"vite:react-babel","result":"// packages/core/echo/model-factory/src/model.ts\nimport { Event } from \"@dxos/async\";\nvar Model = class {\n  constructor(_meta, _itemId, _getState, _mutationWriter) {\n    this._meta = _meta;\n    this._itemId = _itemId;\n    this._getState = _getState;\n    this._mutationWriter = _mutationWriter;\n    this.update = new Event();\n  }\n  toString() {\n    return `Model(${JSON.stringify(this.toJSON())})`;\n  }\n  toJSON() {\n    return {\n      id: this.itemId,\n      type: this._meta.type\n    };\n  }\n  get modelMeta() {\n    return this._meta;\n  }\n  get itemId() {\n    return this._itemId;\n  }\n  get readOnly() {\n    return this._mutationWriter === void 0;\n  }\n  subscribe(listener) {\n    return this.update.on(listener);\n  }\n  async write(mutation) {\n    if (!this._mutationWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    return this._mutationWriter(mutation);\n  }\n};\n\n// packages/core/echo/model-factory/src/model-factory.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, scheduleTask as scheduleTask2 } from \"@dxos/async\";\nimport { Context as Context2 } from \"@dxos/context\";\n\n// packages/core/echo/model-factory/src/state-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\n\n// packages/core/echo/model-factory/src/ordering.ts\nimport { PublicKey } from \"@dxos/keys\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar getInsertionIndex = (existing, newMutation) => {\n  let start = existing.length - 1;\n  for (const ourKey = PublicKey.from(newMutation.meta.feedKey); start >= 0; start--) {\n    if (ourKey.equals(existing[start].meta.feedKey)) {\n      break;\n    }\n  }\n  for (let i = start + 1; i < existing.length; i++) {\n    const existingTimeframe = Timeframe.merge(existing[i].meta.timeframe, new Timeframe([\n      [\n        PublicKey.from(existing[i].meta.feedKey),\n        existing[i].meta.seq - 1\n      ]\n    ]));\n    const deps = Timeframe.dependencies(newMutation.meta.timeframe, existingTimeframe);\n    if (deps.isEmpty()) {\n      if (PublicKey.from(newMutation.meta.feedKey).toHex() < PublicKey.from(existing[i].meta.feedKey).toHex()) {\n        return i;\n      }\n    }\n  }\n  return existing.length;\n};\n\n// packages/core/echo/model-factory/src/state-manager.ts\nvar StateManager = class {\n  constructor(_modelType, modelConstructor, _itemId, _initialState, _memberKey, _feedWriter) {\n    this._modelType = _modelType;\n    this._itemId = _itemId;\n    this._initialState = _initialState;\n    this._memberKey = _memberKey;\n    this._feedWriter = _feedWriter;\n    this._mutationProcessed = new Event2();\n    this._modelMeta = null;\n    this._stateMachine = null;\n    this._model = null;\n    this._mutations = [];\n    this._optimisticMutations = [];\n    if (modelConstructor) {\n      this.initialize(modelConstructor);\n    }\n  }\n  get initialized() {\n    return !!this._modelMeta;\n  }\n  get modelType() {\n    return this._modelType;\n  }\n  get modelMeta() {\n    assert(this._modelMeta, \"Model not initialized.\");\n    return this._modelMeta;\n  }\n  get model() {\n    assert(this._model, \"Model not initialized.\");\n    return this._model;\n  }\n  _emitModelUpdate() {\n    scheduleTask(new Context(), () => {\n      assert(this._model);\n      this._model.update.emit(this._model);\n    });\n  }\n  async _write(mutation) {\n    log(\"Write\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 120,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._feedWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    const mutationEncoded = this._modelMeta.mutationCodec.encode(mutation);\n    const optimisticMutation = {\n      mutation: mutationEncoded,\n      meta: {\n        author: this._memberKey\n      }\n    };\n    this._optimisticMutations.push(optimisticMutation);\n    if (this.initialized) {\n      log(\"Optimistic apply\", mutation, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._stateMachine.process(mutation, optimisticMutation.meta);\n      this._emitModelUpdate();\n    }\n    const receipt = await this._feedWriter.write(mutationEncoded);\n    log(\"Confirm\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 146,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    optimisticMutation.receipt = receipt;\n    const processed = this._mutationProcessed.waitFor((meta) => receipt.feedKey.equals(meta.feedKey) && meta.seq === receipt.seq);\n    void processed.then(() => {\n      if (!optimisticMutation.receipt) {\n        log.error(\"Optimistic mutation was processed without being confirmed\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 157,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      if (this._optimisticMutations.includes(optimisticMutation)) {\n        log.error(\"Optimistic mutation was processed without being removed from the optimistic queue\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 163,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    return {\n      ...receipt,\n      waitToBeProcessed: async () => {\n        await processed;\n      }\n    };\n  }\n  _resetStateMachine() {\n    var _a;\n    assert(this._modelMeta, \"Model not initialized.\");\n    log(\"Construct state machine\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._stateMachine = this._modelMeta.stateMachine();\n    if (this._initialState.snapshot) {\n      assert(this._modelMeta.snapshotCodec);\n      const decoded = this._modelMeta.snapshotCodec.decode(this._initialState.snapshot);\n      this._stateMachine.reset(decoded);\n    }\n    for (const mutation of (_a = this._initialState.mutations) != null ? _a : []) {\n      const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation.mutation);\n      this._stateMachine.process(mutationDecoded, {\n        author: PublicKey2.from(mutation.meta.memberKey)\n      });\n    }\n    for (const mutation1 of this._mutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation1.mutation), {\n        author: PublicKey2.from(mutation1.meta.memberKey)\n      });\n    }\n    for (const mutation2 of this._optimisticMutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation2.mutation), mutation2.meta);\n    }\n  }\n  initialize(modelConstructor) {\n    assert(!this._modelMeta, \"Already iniitalized.\");\n    this._modelMeta = modelConstructor.meta;\n    this._resetStateMachine();\n    this._model = new modelConstructor(this._modelMeta, this._itemId, () => this._stateMachine.getState(), this._feedWriter ? (mutation) => this._write(mutation) : void 0);\n  }\n  processMessage(meta, mutation) {\n    const optimisticIndex = this._optimisticMutations.findIndex((message) => message.receipt && PublicKey2.equals(message.receipt.feedKey, meta.feedKey) && message.receipt.seq === meta.seq);\n    if (optimisticIndex !== -1) {\n      this._optimisticMutations.splice(optimisticIndex, 1);\n    }\n    const insertionIndex = getInsertionIndex(this._mutations, {\n      meta,\n      mutation\n    });\n    const lengthBefore = this._mutations.length;\n    this._mutations.splice(insertionIndex, 0, {\n      meta,\n      mutation\n    });\n    log(`Process ${PublicKey2.from(meta.feedKey)}/${meta.seq} insertionIndex=${insertionIndex} optimisticIndex=${optimisticIndex} queue length=${lengthBefore}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 256,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this.initialized) {\n      if (insertionIndex !== lengthBefore || optimisticIndex > 0 || optimisticIndex === -1 && this._optimisticMutations.length > 0) {\n        log(\"Reset due to order change\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 271,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._resetStateMachine();\n      } else if (optimisticIndex === -1) {\n        log(`Apply ${JSON.stringify(meta)}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation);\n        this._stateMachine.process(mutationDecoded, {\n          author: PublicKey2.from(meta.memberKey)\n        });\n        this._emitModelUpdate();\n      }\n    }\n    scheduleTask(new Context(), () => this._mutationProcessed.emit(meta));\n  }\n  createSnapshot() {\n    var _a;\n    if (this.initialized && this.modelMeta.snapshotCodec) {\n      return {\n        snapshot: this.modelMeta.snapshotCodec.encode(this._stateMachine.snapshot())\n      };\n    }\n    return {\n      snapshot: this._initialState.snapshot,\n      mutations: [\n        ...(_a = this._initialState.mutations) != null ? _a : [],\n        ...this._mutations\n      ]\n    };\n  }\n  resetToSnapshot(snapshot) {\n    this._initialState = snapshot;\n    this._mutations = [];\n    if (this.initialized) {\n      this._resetStateMachine();\n      this._emitModelUpdate();\n    }\n  }\n};\n\n// packages/core/echo/model-factory/src/types.ts\nimport assert2 from \"@dxos/node-std/assert\";\nfunction validateModelClass(model) {\n  assert2(typeof model === \"function\");\n  if (!model.meta) {\n    throw new TypeError(\"Invalid model: missing static `meta` field.\");\n  }\n  if (!model.meta.type) {\n    throw new TypeError(\"Invalid model: missing type URL.\");\n  }\n  if (!model.meta.mutationCodec) {\n    throw new TypeError(\"Invalid model: missing mutation codec.\");\n  }\n}\n\n// packages/core/echo/model-factory/src/model-factory.ts\nvar ModelFactory = class {\n  constructor() {\n    this.registered = new Event3();\n    this._models = /* @__PURE__ */ new Map();\n  }\n  hasModel(modelType) {\n    return this.getModel(modelType) !== void 0;\n  }\n  getModels() {\n    return Array.from(this._models.values());\n  }\n  getModel(modelType) {\n    assert3(modelType);\n    return this._models.get(modelType);\n  }\n  getModelMeta(modelType) {\n    if (!this._models.has(modelType)) {\n      throw new Error(`Invalid model type: ${modelType}`);\n    }\n    const { meta } = this._models.get(modelType);\n    return meta;\n  }\n  registerModel(constructor) {\n    validateModelClass(constructor);\n    const { meta } = constructor;\n    this._models.set(meta.type, {\n      meta,\n      constructor\n    });\n    scheduleTask2(new Context2(), () => {\n      this.registered.emit(constructor);\n    });\n    return this;\n  }\n  createModel(modelType, itemId, snapshot, memberKey, writeStream) {\n    var _a;\n    assert3(itemId);\n    const constructor = (_a = this._models.get(modelType)) == null ? void 0 : _a.constructor;\n    return new StateManager(modelType, constructor, itemId, snapshot, memberKey, writeStream != null ? writeStream : null);\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/messages.ts\nimport { schema } from \"@dxos/protocols\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\nvar createSetPropertyMutation = (itemId, key, value, timeframe = new Timeframe2()) => ({\n  timeframe,\n  payload: {\n    \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n    itemId,\n    mutation: schema.getCodecForType(\"example.testing.data.TestItemMutation\").encode({\n      key,\n      value\n    })\n  }\n});\n\n// packages/core/echo/model-factory/src/testing/test-builder.ts\nimport debug from \"debug\";\nimport { Trigger } from \"@dxos/async\";\nimport { createFeedWriter } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { ComplexMap } from \"@dxos/util\";\nvar log2 = debug(\"dxos:echo:model-test-rig\");\nvar TestBuilder = class {\n  constructor(_modelFactory, _modelConstructor) {\n    this._modelFactory = _modelFactory;\n    this._modelConstructor = _modelConstructor;\n    this._peers = new ComplexMap(PublicKey3.hash);\n    this._replicationFinished = new Trigger();\n    this._replicating = true;\n    this._replicationFinished.wake();\n  }\n  createPeer() {\n    const key = PublicKey3.random();\n    const writer = createFeedWriter((data) => {\n      return Promise.resolve(this._writeMessage(key, data));\n    });\n    const id = PublicKey3.random().toHex();\n    const stateManager = this._modelFactory.createModel(this._modelConstructor.meta.type, id, {}, key, writer);\n    const peer = new TestPeer(stateManager, key);\n    this._peers.set(key, peer);\n    return peer;\n  }\n  configureReplication(value) {\n    this._replicating = value;\n    this._replicate();\n  }\n  async waitForReplication() {\n    log2(\"Waiting for replication...\");\n    await this._replicationFinished.wait();\n    log2(\"Replications started.\");\n  }\n  _writeMessage(peerKey, mutation) {\n    const peer = this._peers.get(peerKey);\n    const seq = peer.mutations.length;\n    const timeframe = peer.timeframe;\n    log2(`Write ${peerKey}:${seq}`);\n    const message = {\n      meta: {\n        feedKey: peerKey,\n        memberKey: peerKey,\n        seq,\n        timeframe\n      },\n      mutation\n    };\n    peer.mutations.push(message);\n    setTimeout(() => peer.processMutation(message));\n    if (this._replicating) {\n      setTimeout(() => this._replicate());\n    }\n    this._replicationFinished.reset();\n    log2(\"Reset replication lock.\");\n    return {\n      feedKey: peerKey,\n      seq\n    };\n  }\n  _replicate() {\n    for (const peer of this._peers.values()) {\n      for (const [feed, { mutations }] of this._peers) {\n        if (peer.key.equals(feed)) {\n          continue;\n        }\n        const timeframeSeq = peer.timeframe.get(feed);\n        const startingIndex = timeframeSeq === void 0 ? 0 : timeframeSeq + 1;\n        log2(`Replicating feed ${feed} -> ${peer.key} range [${startingIndex}; ${mutations.length})`);\n        for (let i = startingIndex; i < mutations.length; i++) {\n          log2(`Process ${feed}:${i} -> ${peer.key}`);\n          peer.processMutation(mutations[i]);\n        }\n      }\n    }\n    this._replicationFinished.wake();\n    log2(\"Wake replication lock.\");\n  }\n};\nvar TestPeer = class {\n  constructor(stateManager, key) {\n    this.stateManager = stateManager;\n    this.key = key;\n    this.timeframe = new Timeframe3();\n    this.mutations = [];\n  }\n  get model() {\n    return this.stateManager.model;\n  }\n  processMutation(message) {\n    this.stateManager.processMessage(message.meta, message.mutation);\n    this.timeframe = Timeframe3.merge(this.timeframe, new Timeframe3([\n      [\n        PublicKey3.from(message.meta.feedKey),\n        message.meta.seq\n      ]\n    ]));\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/test-model.ts\nimport { checkType } from \"@dxos/debug\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar TestModelStateMachine = class {\n  constructor() {\n    this._state = /* @__PURE__ */ new Map();\n  }\n  getState() {\n    return this._state;\n  }\n  process(mutation, meta) {\n    const { key, value } = mutation;\n    this._state.set(key, value);\n  }\n  snapshot() {\n    return {\n      keys: Array.from(this._state.entries()).map(([key, value]) => ({\n        key,\n        value\n      }))\n    };\n  }\n  reset(snapshot) {\n    var _a;\n    this._state.clear();\n    ((_a = snapshot.keys) != null ? _a : []).forEach(({ key, value }) => this._state.set(key, value));\n  }\n};\nvar TestModel = class extends Model {\n  get keys() {\n    return Array.from(this._getState().keys());\n  }\n  get properties() {\n    return Object.fromEntries(this._getState());\n  }\n  get(key) {\n    return this._getState().get(key);\n  }\n  async set(key, value) {\n    const receipt = await this.write(checkType({\n      key,\n      value\n    }));\n    await receipt.waitToBeProcessed();\n  }\n};\nTestModel.meta = {\n  type: \"dxos:model/test\",\n  stateMachine: () => new TestModelStateMachine(),\n  mutationCodec: schema2.getCodecForType(\"example.testing.data.TestItemMutation\"),\n  snapshotCodec: schema2.getCodecForType(\"example.testing.data.TestItemSnapshot\")\n};\n\n// packages/core/echo/model-factory/src/testing/test-list-model.ts\nimport { schema as schema3 } from \"@dxos/protocols\";\nvar TestListModelStateMachine = class {\n  constructor() {\n    this._messages = [];\n  }\n  getState() {\n    return this._messages;\n  }\n  process(mutation, meta) {\n    this._messages.push(mutation);\n  }\n  snapshot() {\n    throw new Error(\"Method not implemented.\");\n  }\n  reset(snapshot) {\n    throw new Error(\"Method not implemented.\");\n  }\n};\nvar TestListModel = class extends Model {\n  get messages() {\n    return this._getState();\n  }\n  async sendMessage(data) {\n    const receipt = await this.write({\n      data\n    });\n    await receipt.waitToBeProcessed();\n  }\n};\nTestListModel.meta = {\n  type: \"dxos:model/test-list\",\n  stateMachine: () => new TestListModelStateMachine(),\n  mutationCodec: schema3.getCodecForType(\"example.testing.data.TestListMutation\")\n};\nexport {\n  Model,\n  ModelFactory,\n  StateManager,\n  TestBuilder,\n  TestListModel,\n  TestModel,\n  TestPeer,\n  createSetPropertyMutation,\n  validateModelClass\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467000,"end":1670465467000,"order":"pre"},{"name":"polyfill-node","result":"// packages/core/echo/model-factory/src/model.ts\nimport { Event } from \"@dxos/async\";\nvar Model = class {\n  constructor(_meta, _itemId, _getState, _mutationWriter) {\n    this._meta = _meta;\n    this._itemId = _itemId;\n    this._getState = _getState;\n    this._mutationWriter = _mutationWriter;\n    this.update = new Event();\n  }\n  toString() {\n    return `Model(${JSON.stringify(this.toJSON())})`;\n  }\n  toJSON() {\n    return {\n      id: this.itemId,\n      type: this._meta.type\n    };\n  }\n  get modelMeta() {\n    return this._meta;\n  }\n  get itemId() {\n    return this._itemId;\n  }\n  get readOnly() {\n    return this._mutationWriter === void 0;\n  }\n  subscribe(listener) {\n    return this.update.on(listener);\n  }\n  async write(mutation) {\n    if (!this._mutationWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    return this._mutationWriter(mutation);\n  }\n};\n\n// packages/core/echo/model-factory/src/model-factory.ts\nimport assert3 from \"@dxos/node-std/assert\";\nimport { Event as Event3, scheduleTask as scheduleTask2 } from \"@dxos/async\";\nimport { Context as Context2 } from \"@dxos/context\";\n\n// packages/core/echo/model-factory/src/state-manager.ts\nimport assert from \"@dxos/node-std/assert\";\nimport { Event as Event2, scheduleTask } from \"@dxos/async\";\nimport { Context } from \"@dxos/context\";\nimport { PublicKey as PublicKey2 } from \"@dxos/keys\";\nimport { log } from \"@dxos/log\";\n\n// packages/core/echo/model-factory/src/ordering.ts\nimport { PublicKey } from \"@dxos/keys\";\nimport { Timeframe } from \"@dxos/timeframe\";\nvar getInsertionIndex = (existing, newMutation) => {\n  let start = existing.length - 1;\n  for (const ourKey = PublicKey.from(newMutation.meta.feedKey); start >= 0; start--) {\n    if (ourKey.equals(existing[start].meta.feedKey)) {\n      break;\n    }\n  }\n  for (let i = start + 1; i < existing.length; i++) {\n    const existingTimeframe = Timeframe.merge(existing[i].meta.timeframe, new Timeframe([\n      [\n        PublicKey.from(existing[i].meta.feedKey),\n        existing[i].meta.seq - 1\n      ]\n    ]));\n    const deps = Timeframe.dependencies(newMutation.meta.timeframe, existingTimeframe);\n    if (deps.isEmpty()) {\n      if (PublicKey.from(newMutation.meta.feedKey).toHex() < PublicKey.from(existing[i].meta.feedKey).toHex()) {\n        return i;\n      }\n    }\n  }\n  return existing.length;\n};\n\n// packages/core/echo/model-factory/src/state-manager.ts\nvar StateManager = class {\n  constructor(_modelType, modelConstructor, _itemId, _initialState, _memberKey, _feedWriter) {\n    this._modelType = _modelType;\n    this._itemId = _itemId;\n    this._initialState = _initialState;\n    this._memberKey = _memberKey;\n    this._feedWriter = _feedWriter;\n    this._mutationProcessed = new Event2();\n    this._modelMeta = null;\n    this._stateMachine = null;\n    this._model = null;\n    this._mutations = [];\n    this._optimisticMutations = [];\n    if (modelConstructor) {\n      this.initialize(modelConstructor);\n    }\n  }\n  get initialized() {\n    return !!this._modelMeta;\n  }\n  get modelType() {\n    return this._modelType;\n  }\n  get modelMeta() {\n    assert(this._modelMeta, \"Model not initialized.\");\n    return this._modelMeta;\n  }\n  get model() {\n    assert(this._model, \"Model not initialized.\");\n    return this._model;\n  }\n  _emitModelUpdate() {\n    scheduleTask(new Context(), () => {\n      assert(this._model);\n      this._model.update.emit(this._model);\n    });\n  }\n  async _write(mutation) {\n    log(\"Write\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 120,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (!this._feedWriter) {\n      throw new Error(`Read-only model: ${this._itemId}`);\n    }\n    const mutationEncoded = this._modelMeta.mutationCodec.encode(mutation);\n    const optimisticMutation = {\n      mutation: mutationEncoded,\n      meta: {\n        author: this._memberKey\n      }\n    };\n    this._optimisticMutations.push(optimisticMutation);\n    if (this.initialized) {\n      log(\"Optimistic apply\", mutation, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n        line: 137,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      this._stateMachine.process(mutation, optimisticMutation.meta);\n      this._emitModelUpdate();\n    }\n    const receipt = await this._feedWriter.write(mutationEncoded);\n    log(\"Confirm\", mutation, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 146,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    optimisticMutation.receipt = receipt;\n    const processed = this._mutationProcessed.waitFor((meta) => receipt.feedKey.equals(meta.feedKey) && meta.seq === receipt.seq);\n    void processed.then(() => {\n      if (!optimisticMutation.receipt) {\n        log.error(\"Optimistic mutation was processed without being confirmed\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 157,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n      if (this._optimisticMutations.includes(optimisticMutation)) {\n        log.error(\"Optimistic mutation was processed without being removed from the optimistic queue\", {\n          itemId: this._itemId,\n          mutationType: mutation.type\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 163,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n      }\n    });\n    return {\n      ...receipt,\n      waitToBeProcessed: async () => {\n        await processed;\n      }\n    };\n  }\n  _resetStateMachine() {\n    var _a;\n    assert(this._modelMeta, \"Model not initialized.\");\n    log(\"Construct state machine\", {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 183,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    this._stateMachine = this._modelMeta.stateMachine();\n    if (this._initialState.snapshot) {\n      assert(this._modelMeta.snapshotCodec);\n      const decoded = this._modelMeta.snapshotCodec.decode(this._initialState.snapshot);\n      this._stateMachine.reset(decoded);\n    }\n    for (const mutation of (_a = this._initialState.mutations) != null ? _a : []) {\n      const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation.mutation);\n      this._stateMachine.process(mutationDecoded, {\n        author: PublicKey2.from(mutation.meta.memberKey)\n      });\n    }\n    for (const mutation1 of this._mutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation1.mutation), {\n        author: PublicKey2.from(mutation1.meta.memberKey)\n      });\n    }\n    for (const mutation2 of this._optimisticMutations) {\n      this._stateMachine.process(this._modelMeta.mutationCodec.decode(mutation2.mutation), mutation2.meta);\n    }\n  }\n  initialize(modelConstructor) {\n    assert(!this._modelMeta, \"Already iniitalized.\");\n    this._modelMeta = modelConstructor.meta;\n    this._resetStateMachine();\n    this._model = new modelConstructor(this._modelMeta, this._itemId, () => this._stateMachine.getState(), this._feedWriter ? (mutation) => this._write(mutation) : void 0);\n  }\n  processMessage(meta, mutation) {\n    const optimisticIndex = this._optimisticMutations.findIndex((message) => message.receipt && PublicKey2.equals(message.receipt.feedKey, meta.feedKey) && message.receipt.seq === meta.seq);\n    if (optimisticIndex !== -1) {\n      this._optimisticMutations.splice(optimisticIndex, 1);\n    }\n    const insertionIndex = getInsertionIndex(this._mutations, {\n      meta,\n      mutation\n    });\n    const lengthBefore = this._mutations.length;\n    this._mutations.splice(insertionIndex, 0, {\n      meta,\n      mutation\n    });\n    log(`Process ${PublicKey2.from(meta.feedKey)}/${meta.seq} insertionIndex=${insertionIndex} optimisticIndex=${optimisticIndex} queue length=${lengthBefore}`, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n      line: 256,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    if (this.initialized) {\n      if (insertionIndex !== lengthBefore || optimisticIndex > 0 || optimisticIndex === -1 && this._optimisticMutations.length > 0) {\n        log(\"Reset due to order change\", {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 271,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        this._resetStateMachine();\n      } else if (optimisticIndex === -1) {\n        log(`Apply ${JSON.stringify(meta)}`, {}, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/echo/model-factory/src/state-manager.ts\",\n          line: 274,\n          scope: this,\n          callSite: (f, a) => f(...a)\n        });\n        const mutationDecoded = this._modelMeta.mutationCodec.decode(mutation);\n        this._stateMachine.process(mutationDecoded, {\n          author: PublicKey2.from(meta.memberKey)\n        });\n        this._emitModelUpdate();\n      }\n    }\n    scheduleTask(new Context(), () => this._mutationProcessed.emit(meta));\n  }\n  createSnapshot() {\n    var _a;\n    if (this.initialized && this.modelMeta.snapshotCodec) {\n      return {\n        snapshot: this.modelMeta.snapshotCodec.encode(this._stateMachine.snapshot())\n      };\n    }\n    return {\n      snapshot: this._initialState.snapshot,\n      mutations: [\n        ...(_a = this._initialState.mutations) != null ? _a : [],\n        ...this._mutations\n      ]\n    };\n  }\n  resetToSnapshot(snapshot) {\n    this._initialState = snapshot;\n    this._mutations = [];\n    if (this.initialized) {\n      this._resetStateMachine();\n      this._emitModelUpdate();\n    }\n  }\n};\n\n// packages/core/echo/model-factory/src/types.ts\nimport assert2 from \"@dxos/node-std/assert\";\nfunction validateModelClass(model) {\n  assert2(typeof model === \"function\");\n  if (!model.meta) {\n    throw new TypeError(\"Invalid model: missing static `meta` field.\");\n  }\n  if (!model.meta.type) {\n    throw new TypeError(\"Invalid model: missing type URL.\");\n  }\n  if (!model.meta.mutationCodec) {\n    throw new TypeError(\"Invalid model: missing mutation codec.\");\n  }\n}\n\n// packages/core/echo/model-factory/src/model-factory.ts\nvar ModelFactory = class {\n  constructor() {\n    this.registered = new Event3();\n    this._models = /* @__PURE__ */ new Map();\n  }\n  hasModel(modelType) {\n    return this.getModel(modelType) !== void 0;\n  }\n  getModels() {\n    return Array.from(this._models.values());\n  }\n  getModel(modelType) {\n    assert3(modelType);\n    return this._models.get(modelType);\n  }\n  getModelMeta(modelType) {\n    if (!this._models.has(modelType)) {\n      throw new Error(`Invalid model type: ${modelType}`);\n    }\n    const { meta } = this._models.get(modelType);\n    return meta;\n  }\n  registerModel(constructor) {\n    validateModelClass(constructor);\n    const { meta } = constructor;\n    this._models.set(meta.type, {\n      meta,\n      constructor\n    });\n    scheduleTask2(new Context2(), () => {\n      this.registered.emit(constructor);\n    });\n    return this;\n  }\n  createModel(modelType, itemId, snapshot, memberKey, writeStream) {\n    var _a;\n    assert3(itemId);\n    const constructor = (_a = this._models.get(modelType)) == null ? void 0 : _a.constructor;\n    return new StateManager(modelType, constructor, itemId, snapshot, memberKey, writeStream != null ? writeStream : null);\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/messages.ts\nimport { schema } from \"@dxos/protocols\";\nimport { Timeframe as Timeframe2 } from \"@dxos/timeframe\";\nvar createSetPropertyMutation = (itemId, key, value, timeframe = new Timeframe2()) => ({\n  timeframe,\n  payload: {\n    \"@type\": \"dxos.echo.feed.EchoEnvelope\",\n    itemId,\n    mutation: schema.getCodecForType(\"example.testing.data.TestItemMutation\").encode({\n      key,\n      value\n    })\n  }\n});\n\n// packages/core/echo/model-factory/src/testing/test-builder.ts\nimport debug from \"debug\";\nimport { Trigger } from \"@dxos/async\";\nimport { createFeedWriter } from \"@dxos/feed-store\";\nimport { PublicKey as PublicKey3 } from \"@dxos/keys\";\nimport { Timeframe as Timeframe3 } from \"@dxos/timeframe\";\nimport { ComplexMap } from \"@dxos/util\";\nvar log2 = debug(\"dxos:echo:model-test-rig\");\nvar TestBuilder = class {\n  constructor(_modelFactory, _modelConstructor) {\n    this._modelFactory = _modelFactory;\n    this._modelConstructor = _modelConstructor;\n    this._peers = new ComplexMap(PublicKey3.hash);\n    this._replicationFinished = new Trigger();\n    this._replicating = true;\n    this._replicationFinished.wake();\n  }\n  createPeer() {\n    const key = PublicKey3.random();\n    const writer = createFeedWriter((data) => {\n      return Promise.resolve(this._writeMessage(key, data));\n    });\n    const id = PublicKey3.random().toHex();\n    const stateManager = this._modelFactory.createModel(this._modelConstructor.meta.type, id, {}, key, writer);\n    const peer = new TestPeer(stateManager, key);\n    this._peers.set(key, peer);\n    return peer;\n  }\n  configureReplication(value) {\n    this._replicating = value;\n    this._replicate();\n  }\n  async waitForReplication() {\n    log2(\"Waiting for replication...\");\n    await this._replicationFinished.wait();\n    log2(\"Replications started.\");\n  }\n  _writeMessage(peerKey, mutation) {\n    const peer = this._peers.get(peerKey);\n    const seq = peer.mutations.length;\n    const timeframe = peer.timeframe;\n    log2(`Write ${peerKey}:${seq}`);\n    const message = {\n      meta: {\n        feedKey: peerKey,\n        memberKey: peerKey,\n        seq,\n        timeframe\n      },\n      mutation\n    };\n    peer.mutations.push(message);\n    setTimeout(() => peer.processMutation(message));\n    if (this._replicating) {\n      setTimeout(() => this._replicate());\n    }\n    this._replicationFinished.reset();\n    log2(\"Reset replication lock.\");\n    return {\n      feedKey: peerKey,\n      seq\n    };\n  }\n  _replicate() {\n    for (const peer of this._peers.values()) {\n      for (const [feed, { mutations }] of this._peers) {\n        if (peer.key.equals(feed)) {\n          continue;\n        }\n        const timeframeSeq = peer.timeframe.get(feed);\n        const startingIndex = timeframeSeq === void 0 ? 0 : timeframeSeq + 1;\n        log2(`Replicating feed ${feed} -> ${peer.key} range [${startingIndex}; ${mutations.length})`);\n        for (let i = startingIndex; i < mutations.length; i++) {\n          log2(`Process ${feed}:${i} -> ${peer.key}`);\n          peer.processMutation(mutations[i]);\n        }\n      }\n    }\n    this._replicationFinished.wake();\n    log2(\"Wake replication lock.\");\n  }\n};\nvar TestPeer = class {\n  constructor(stateManager, key) {\n    this.stateManager = stateManager;\n    this.key = key;\n    this.timeframe = new Timeframe3();\n    this.mutations = [];\n  }\n  get model() {\n    return this.stateManager.model;\n  }\n  processMutation(message) {\n    this.stateManager.processMessage(message.meta, message.mutation);\n    this.timeframe = Timeframe3.merge(this.timeframe, new Timeframe3([\n      [\n        PublicKey3.from(message.meta.feedKey),\n        message.meta.seq\n      ]\n    ]));\n  }\n};\n\n// packages/core/echo/model-factory/src/testing/test-model.ts\nimport { checkType } from \"@dxos/debug\";\nimport { schema as schema2 } from \"@dxos/protocols\";\nvar TestModelStateMachine = class {\n  constructor() {\n    this._state = /* @__PURE__ */ new Map();\n  }\n  getState() {\n    return this._state;\n  }\n  process(mutation, meta) {\n    const { key, value } = mutation;\n    this._state.set(key, value);\n  }\n  snapshot() {\n    return {\n      keys: Array.from(this._state.entries()).map(([key, value]) => ({\n        key,\n        value\n      }))\n    };\n  }\n  reset(snapshot) {\n    var _a;\n    this._state.clear();\n    ((_a = snapshot.keys) != null ? _a : []).forEach(({ key, value }) => this._state.set(key, value));\n  }\n};\nvar TestModel = class extends Model {\n  get keys() {\n    return Array.from(this._getState().keys());\n  }\n  get properties() {\n    return Object.fromEntries(this._getState());\n  }\n  get(key) {\n    return this._getState().get(key);\n  }\n  async set(key, value) {\n    const receipt = await this.write(checkType({\n      key,\n      value\n    }));\n    await receipt.waitToBeProcessed();\n  }\n};\nTestModel.meta = {\n  type: \"dxos:model/test\",\n  stateMachine: () => new TestModelStateMachine(),\n  mutationCodec: schema2.getCodecForType(\"example.testing.data.TestItemMutation\"),\n  snapshotCodec: schema2.getCodecForType(\"example.testing.data.TestItemSnapshot\")\n};\n\n// packages/core/echo/model-factory/src/testing/test-list-model.ts\nimport { schema as schema3 } from \"@dxos/protocols\";\nvar TestListModelStateMachine = class {\n  constructor() {\n    this._messages = [];\n  }\n  getState() {\n    return this._messages;\n  }\n  process(mutation, meta) {\n    this._messages.push(mutation);\n  }\n  snapshot() {\n    throw new Error(\"Method not implemented.\");\n  }\n  reset(snapshot) {\n    throw new Error(\"Method not implemented.\");\n  }\n};\nvar TestListModel = class extends Model {\n  get messages() {\n    return this._getState();\n  }\n  async sendMessage(data) {\n    const receipt = await this.write({\n      data\n    });\n    await receipt.waitToBeProcessed();\n  }\n};\nTestListModel.meta = {\n  type: \"dxos:model/test-list\",\n  stateMachine: () => new TestListModelStateMachine(),\n  mutationCodec: schema3.getCodecForType(\"example.testing.data.TestListMutation\")\n};\nexport {\n  Model,\n  ModelFactory,\n  StateManager,\n  TestBuilder,\n  TestListModel,\n  TestModel,\n  TestPeer,\n  createSetPropertyMutation,\n  validateModelClass\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467000,"end":1670465467005,"order":"normal"}]}
