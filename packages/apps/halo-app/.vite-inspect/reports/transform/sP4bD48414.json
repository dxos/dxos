{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/@sentry+browser@7.20.0/node_modules/@sentry/browser/esm/integrations/globalhandlers.js","transforms":[{"name":"vite:load-fallback","result":"import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    const options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n    // eslint-disable-next-line guard-for-in\n    for (const key in options) {\n      const installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler(\n    'error',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      const event =\n        error === undefined && isString(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler(\n    'unhandledrejection',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      const event = isPrimitive(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  const ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  const groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  const e = (event.exception = event.exception || {});\n  // event.exception.values\n  const ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  const ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  const ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  const ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  const colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  const lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers };\n//# sourceMappingURL=globalhandlers.js.map\n","start":1670465466661,"end":1670465466942},{"name":"vite:react-babel","result":"import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    const options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n    // eslint-disable-next-line guard-for-in\n    for (const key in options) {\n      const installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler(\n    'error',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      const event =\n        error === undefined && isString(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler(\n    'unhandledrejection',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      const event = isPrimitive(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  const ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  const groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  const e = (event.exception = event.exception || {});\n  // event.exception.values\n  const ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  const ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  const ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  const ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  const colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  const lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers };\n//# sourceMappingURL=globalhandlers.js.map\n","start":1670465466942,"end":1670465466942,"order":"pre"},{"name":"polyfill-node","result":"import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    const options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n    // eslint-disable-next-line guard-for-in\n    for (const key in options) {\n      const installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler(\n    'error',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      const event =\n        error === undefined && isString(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler(\n    'unhandledrejection',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      const event = isPrimitive(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  const ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  const groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  const e = (event.exception = event.exception || {});\n  // event.exception.values\n  const ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  const ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  const ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  const ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  const colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  const lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers };\n//# sourceMappingURL=globalhandlers.js.map\n","start":1670465466944,"end":1670465466946,"order":"normal"}]}
