{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js","transforms":[{"name":"vite:load-fallback","result":"const sodium = require('sodium-universal')\nconst uint64be = require('uint64be')\n\n// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\nconst LEAF_TYPE = Buffer.from([0])\nconst PARENT_TYPE = Buffer.from([1])\nconst ROOT_TYPE = Buffer.from([2])\nconst CAP_TYPE = Buffer.from([3])\n\nconst HYPERCORE = Buffer.from('hypercore')\nconst HYPERCORE_CAP = Buffer.from('hypercore capability')\n\nexports.writerCapability = function (key, secretKey, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    CAP_TYPE,\n    HYPERCORE_CAP,\n    split.tx.slice(0, 32),\n    key\n  ], split.rx.slice(0, 32))\n\n  return exports.sign(out, secretKey)\n}\n\nexports.verifyRemoteWriterCapability = function (key, cap, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    CAP_TYPE,\n    HYPERCORE_CAP,\n    split.rx.slice(0, 32),\n    key\n  ], split.tx.slice(0, 32))\n\n  return exports.verify(out, cap, key)\n}\n\n// TODO: add in the CAP_TYPE in a future version\nexports.capability = function (key, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    HYPERCORE_CAP,\n    split.tx.slice(0, 32),\n    key\n  ], split.rx.slice(0, 32))\n\n  return out\n}\n\n// TODO: add in the CAP_TYPE in a future version\nexports.remoteCapability = function (key, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    HYPERCORE_CAP,\n    split.rx.slice(0, 32),\n    key\n  ], split.tx.slice(0, 32))\n\n  return out\n}\n\nexports.keyPair = function (seed) {\n  const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES)\n\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.validateKeyPair = function (keyPair) {\n  const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n  return pk.equals(keyPair.publicKey)\n}\n\nexports.sign = function (message, secretKey) {\n  const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, message, secretKey)\n  return signature\n}\n\nexports.verify = function (message, signature, publicKey) {\n  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n}\n\nexports.data = function (data) {\n  const out = Buffer.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    LEAF_TYPE,\n    encodeUInt64(data.length),\n    data\n  ])\n\n  return out\n}\n\nexports.leaf = function (leaf) {\n  return exports.data(leaf.data)\n}\n\nexports.parent = function (a, b) {\n  if (a.index > b.index) {\n    const tmp = a\n    a = b\n    b = tmp\n  }\n\n  const out = Buffer.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    PARENT_TYPE,\n    encodeUInt64(a.size + b.size),\n    a.hash,\n    b.hash\n  ])\n\n  return out\n}\n\nexports.tree = function (roots, out) {\n  const buffers = new Array(3 * roots.length + 1)\n  var j = 0\n\n  buffers[j++] = ROOT_TYPE\n\n  for (var i = 0; i < roots.length; i++) {\n    const r = roots[i]\n    buffers[j++] = r.hash\n    buffers[j++] = encodeUInt64(r.index)\n    buffers[j++] = encodeUInt64(r.size)\n  }\n\n  if (!out) out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, buffers)\n  return out\n}\n\nexports.signable = function (roots, length) {\n  const out = Buffer.allocUnsafe(40)\n\n  if (Buffer.isBuffer(roots)) roots.copy(out)\n  else exports.tree(roots, out.slice(0, 32))\n\n  uint64be.encode(length, out.slice(32))\n\n  return out\n}\n\nexports.randomBytes = function (n) {\n  const buf = Buffer.allocUnsafe(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nexports.discoveryKey = function (publicKey) {\n  const digest = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash(digest, HYPERCORE, publicKey)\n  return digest\n}\n\nif (sodium.sodium_free) {\n  exports.free = function (secureBuf) {\n    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n  }\n} else {\n  exports.free = function () {}\n}\n\nfunction encodeUInt64 (n) {\n  return uint64be.encode(n, Buffer.allocUnsafe(8))\n}\n","start":1670465468170,"end":1670465468231},{"name":"vite:react-babel","result":"const sodium = require('sodium-universal')\nconst uint64be = require('uint64be')\n\n// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\nconst LEAF_TYPE = Buffer.from([0])\nconst PARENT_TYPE = Buffer.from([1])\nconst ROOT_TYPE = Buffer.from([2])\nconst CAP_TYPE = Buffer.from([3])\n\nconst HYPERCORE = Buffer.from('hypercore')\nconst HYPERCORE_CAP = Buffer.from('hypercore capability')\n\nexports.writerCapability = function (key, secretKey, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    CAP_TYPE,\n    HYPERCORE_CAP,\n    split.tx.slice(0, 32),\n    key\n  ], split.rx.slice(0, 32))\n\n  return exports.sign(out, secretKey)\n}\n\nexports.verifyRemoteWriterCapability = function (key, cap, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    CAP_TYPE,\n    HYPERCORE_CAP,\n    split.rx.slice(0, 32),\n    key\n  ], split.tx.slice(0, 32))\n\n  return exports.verify(out, cap, key)\n}\n\n// TODO: add in the CAP_TYPE in a future version\nexports.capability = function (key, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    HYPERCORE_CAP,\n    split.tx.slice(0, 32),\n    key\n  ], split.rx.slice(0, 32))\n\n  return out\n}\n\n// TODO: add in the CAP_TYPE in a future version\nexports.remoteCapability = function (key, split) {\n  if (!split) return null\n\n  const out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, [\n    HYPERCORE_CAP,\n    split.rx.slice(0, 32),\n    key\n  ], split.tx.slice(0, 32))\n\n  return out\n}\n\nexports.keyPair = function (seed) {\n  const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES)\n\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.validateKeyPair = function (keyPair) {\n  const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n  return pk.equals(keyPair.publicKey)\n}\n\nexports.sign = function (message, secretKey) {\n  const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, message, secretKey)\n  return signature\n}\n\nexports.verify = function (message, signature, publicKey) {\n  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n}\n\nexports.data = function (data) {\n  const out = Buffer.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    LEAF_TYPE,\n    encodeUInt64(data.length),\n    data\n  ])\n\n  return out\n}\n\nexports.leaf = function (leaf) {\n  return exports.data(leaf.data)\n}\n\nexports.parent = function (a, b) {\n  if (a.index > b.index) {\n    const tmp = a\n    a = b\n    b = tmp\n  }\n\n  const out = Buffer.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    PARENT_TYPE,\n    encodeUInt64(a.size + b.size),\n    a.hash,\n    b.hash\n  ])\n\n  return out\n}\n\nexports.tree = function (roots, out) {\n  const buffers = new Array(3 * roots.length + 1)\n  var j = 0\n\n  buffers[j++] = ROOT_TYPE\n\n  for (var i = 0; i < roots.length; i++) {\n    const r = roots[i]\n    buffers[j++] = r.hash\n    buffers[j++] = encodeUInt64(r.index)\n    buffers[j++] = encodeUInt64(r.size)\n  }\n\n  if (!out) out = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, buffers)\n  return out\n}\n\nexports.signable = function (roots, length) {\n  const out = Buffer.allocUnsafe(40)\n\n  if (Buffer.isBuffer(roots)) roots.copy(out)\n  else exports.tree(roots, out.slice(0, 32))\n\n  uint64be.encode(length, out.slice(32))\n\n  return out\n}\n\nexports.randomBytes = function (n) {\n  const buf = Buffer.allocUnsafe(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nexports.discoveryKey = function (publicKey) {\n  const digest = Buffer.allocUnsafe(32)\n  sodium.crypto_generichash(digest, HYPERCORE, publicKey)\n  return digest\n}\n\nif (sodium.sodium_free) {\n  exports.free = function (secureBuf) {\n    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n  }\n} else {\n  exports.free = function () {}\n}\n\nfunction encodeUInt64 (n) {\n  return uint64be.encode(n, Buffer.allocUnsafe(8))\n}\n","start":1670465468231,"end":1670465468231,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as hypercoreCrypto } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js?commonjs-proxy\";\n\n(function (exports) {\n\tconst sodium = require$$0\n\tconst uint64be = require$$1\n\n\t// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\n\tconst LEAF_TYPE = Buffer.from([0])\n\tconst PARENT_TYPE = Buffer.from([1])\n\tconst ROOT_TYPE = Buffer.from([2])\n\tconst CAP_TYPE = Buffer.from([3])\n\n\tconst HYPERCORE = Buffer.from('hypercore')\n\tconst HYPERCORE_CAP = Buffer.from('hypercore capability')\n\n\texports.writerCapability = function (key, secretKey, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    CAP_TYPE,\n\t    HYPERCORE_CAP,\n\t    split.tx.slice(0, 32),\n\t    key\n\t  ], split.rx.slice(0, 32))\n\n\t  return exports.sign(out, secretKey)\n\t}\n\n\texports.verifyRemoteWriterCapability = function (key, cap, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    CAP_TYPE,\n\t    HYPERCORE_CAP,\n\t    split.rx.slice(0, 32),\n\t    key\n\t  ], split.tx.slice(0, 32))\n\n\t  return exports.verify(out, cap, key)\n\t}\n\n\t// TODO: add in the CAP_TYPE in a future version\n\texports.capability = function (key, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    HYPERCORE_CAP,\n\t    split.tx.slice(0, 32),\n\t    key\n\t  ], split.rx.slice(0, 32))\n\n\t  return out\n\t}\n\n\t// TODO: add in the CAP_TYPE in a future version\n\texports.remoteCapability = function (key, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    HYPERCORE_CAP,\n\t    split.rx.slice(0, 32),\n\t    key\n\t  ], split.tx.slice(0, 32))\n\n\t  return out\n\t}\n\n\texports.keyPair = function (seed) {\n\t  const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n\t  const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES)\n\n\t  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n\t  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n\t  return {\n\t    publicKey,\n\t    secretKey\n\t  }\n\t}\n\n\texports.validateKeyPair = function (keyPair) {\n\t  const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n\t  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n\t  return pk.equals(keyPair.publicKey)\n\t}\n\n\texports.sign = function (message, secretKey) {\n\t  const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES)\n\t  sodium.crypto_sign_detached(signature, message, secretKey)\n\t  return signature\n\t}\n\n\texports.verify = function (message, signature, publicKey) {\n\t  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n\t}\n\n\texports.data = function (data) {\n\t  const out = Buffer.allocUnsafe(32)\n\n\t  sodium.crypto_generichash_batch(out, [\n\t    LEAF_TYPE,\n\t    encodeUInt64(data.length),\n\t    data\n\t  ])\n\n\t  return out\n\t}\n\n\texports.leaf = function (leaf) {\n\t  return exports.data(leaf.data)\n\t}\n\n\texports.parent = function (a, b) {\n\t  if (a.index > b.index) {\n\t    const tmp = a\n\t    a = b\n\t    b = tmp\n\t  }\n\n\t  const out = Buffer.allocUnsafe(32)\n\n\t  sodium.crypto_generichash_batch(out, [\n\t    PARENT_TYPE,\n\t    encodeUInt64(a.size + b.size),\n\t    a.hash,\n\t    b.hash\n\t  ])\n\n\t  return out\n\t}\n\n\texports.tree = function (roots, out) {\n\t  const buffers = new Array(3 * roots.length + 1)\n\t  var j = 0\n\n\t  buffers[j++] = ROOT_TYPE\n\n\t  for (var i = 0; i < roots.length; i++) {\n\t    const r = roots[i]\n\t    buffers[j++] = r.hash\n\t    buffers[j++] = encodeUInt64(r.index)\n\t    buffers[j++] = encodeUInt64(r.size)\n\t  }\n\n\t  if (!out) out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, buffers)\n\t  return out\n\t}\n\n\texports.signable = function (roots, length) {\n\t  const out = Buffer.allocUnsafe(40)\n\n\t  if (Buffer.isBuffer(roots)) roots.copy(out)\n\t  else exports.tree(roots, out.slice(0, 32))\n\n\t  uint64be.encode(length, out.slice(32))\n\n\t  return out\n\t}\n\n\texports.randomBytes = function (n) {\n\t  const buf = Buffer.allocUnsafe(n)\n\t  sodium.randombytes_buf(buf)\n\t  return buf\n\t}\n\n\texports.discoveryKey = function (publicKey) {\n\t  const digest = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash(digest, HYPERCORE, publicKey)\n\t  return digest\n\t}\n\n\tif (sodium.sodium_free) {\n\t  exports.free = function (secureBuf) {\n\t    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n\t  }\n\t} else {\n\t  exports.free = function () {}\n\t}\n\n\tfunction encodeUInt64 (n) {\n\t  return uint64be.encode(n, Buffer.allocUnsafe(8))\n\t}\n} (hypercoreCrypto));\n\nexport default hypercoreCrypto;\nexport { hypercoreCrypto as __moduleExports };","start":1670465468231,"end":1670465471741,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as hypercoreCrypto } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/hypercore-crypto@2.3.2/node_modules/hypercore-crypto/index.js?commonjs-exports\"\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/sodium-universal@3.1.0/node_modules/sodium-universal/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/uint64be@3.0.0/node_modules/uint64be/index.js?commonjs-proxy\";\n\n(function (exports) {\n\tconst sodium = require$$0\n\tconst uint64be = require$$1\n\n\t// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\n\tconst LEAF_TYPE = Buffer.from([0])\n\tconst PARENT_TYPE = Buffer.from([1])\n\tconst ROOT_TYPE = Buffer.from([2])\n\tconst CAP_TYPE = Buffer.from([3])\n\n\tconst HYPERCORE = Buffer.from('hypercore')\n\tconst HYPERCORE_CAP = Buffer.from('hypercore capability')\n\n\texports.writerCapability = function (key, secretKey, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    CAP_TYPE,\n\t    HYPERCORE_CAP,\n\t    split.tx.slice(0, 32),\n\t    key\n\t  ], split.rx.slice(0, 32))\n\n\t  return exports.sign(out, secretKey)\n\t}\n\n\texports.verifyRemoteWriterCapability = function (key, cap, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    CAP_TYPE,\n\t    HYPERCORE_CAP,\n\t    split.rx.slice(0, 32),\n\t    key\n\t  ], split.tx.slice(0, 32))\n\n\t  return exports.verify(out, cap, key)\n\t}\n\n\t// TODO: add in the CAP_TYPE in a future version\n\texports.capability = function (key, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    HYPERCORE_CAP,\n\t    split.tx.slice(0, 32),\n\t    key\n\t  ], split.rx.slice(0, 32))\n\n\t  return out\n\t}\n\n\t// TODO: add in the CAP_TYPE in a future version\n\texports.remoteCapability = function (key, split) {\n\t  if (!split) return null\n\n\t  const out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, [\n\t    HYPERCORE_CAP,\n\t    split.rx.slice(0, 32),\n\t    key\n\t  ], split.tx.slice(0, 32))\n\n\t  return out\n\t}\n\n\texports.keyPair = function (seed) {\n\t  const publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n\t  const secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES)\n\n\t  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n\t  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n\t  return {\n\t    publicKey,\n\t    secretKey\n\t  }\n\t}\n\n\texports.validateKeyPair = function (keyPair) {\n\t  const pk = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n\t  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n\t  return pk.equals(keyPair.publicKey)\n\t}\n\n\texports.sign = function (message, secretKey) {\n\t  const signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES)\n\t  sodium.crypto_sign_detached(signature, message, secretKey)\n\t  return signature\n\t}\n\n\texports.verify = function (message, signature, publicKey) {\n\t  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n\t}\n\n\texports.data = function (data) {\n\t  const out = Buffer.allocUnsafe(32)\n\n\t  sodium.crypto_generichash_batch(out, [\n\t    LEAF_TYPE,\n\t    encodeUInt64(data.length),\n\t    data\n\t  ])\n\n\t  return out\n\t}\n\n\texports.leaf = function (leaf) {\n\t  return exports.data(leaf.data)\n\t}\n\n\texports.parent = function (a, b) {\n\t  if (a.index > b.index) {\n\t    const tmp = a\n\t    a = b\n\t    b = tmp\n\t  }\n\n\t  const out = Buffer.allocUnsafe(32)\n\n\t  sodium.crypto_generichash_batch(out, [\n\t    PARENT_TYPE,\n\t    encodeUInt64(a.size + b.size),\n\t    a.hash,\n\t    b.hash\n\t  ])\n\n\t  return out\n\t}\n\n\texports.tree = function (roots, out) {\n\t  const buffers = new Array(3 * roots.length + 1)\n\t  var j = 0\n\n\t  buffers[j++] = ROOT_TYPE\n\n\t  for (var i = 0; i < roots.length; i++) {\n\t    const r = roots[i]\n\t    buffers[j++] = r.hash\n\t    buffers[j++] = encodeUInt64(r.index)\n\t    buffers[j++] = encodeUInt64(r.size)\n\t  }\n\n\t  if (!out) out = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash_batch(out, buffers)\n\t  return out\n\t}\n\n\texports.signable = function (roots, length) {\n\t  const out = Buffer.allocUnsafe(40)\n\n\t  if (Buffer.isBuffer(roots)) roots.copy(out)\n\t  else exports.tree(roots, out.slice(0, 32))\n\n\t  uint64be.encode(length, out.slice(32))\n\n\t  return out\n\t}\n\n\texports.randomBytes = function (n) {\n\t  const buf = Buffer.allocUnsafe(n)\n\t  sodium.randombytes_buf(buf)\n\t  return buf\n\t}\n\n\texports.discoveryKey = function (publicKey) {\n\t  const digest = Buffer.allocUnsafe(32)\n\t  sodium.crypto_generichash(digest, HYPERCORE, publicKey)\n\t  return digest\n\t}\n\n\tif (sodium.sodium_free) {\n\t  exports.free = function (secureBuf) {\n\t    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n\t  }\n\t} else {\n\t  exports.free = function () {}\n\t}\n\n\tfunction encodeUInt64 (n) {\n\t  return uint64be.encode(n, Buffer.allocUnsafe(8))\n\t}\n} (hypercoreCrypto));\n\nexport default hypercoreCrypto;\nexport { hypercoreCrypto as __moduleExports };","start":1670465471741,"end":1670465471745,"order":"normal"}]}
