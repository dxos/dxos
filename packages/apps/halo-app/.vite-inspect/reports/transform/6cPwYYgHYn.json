{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/ltgt@2.2.1/node_modules/ltgt/index.js","transforms":[{"name":"vite:load-fallback","result":"\nexports.compare = function (a, b) {\n\n  if(Buffer.isBuffer(a)) {\n    var l = Math.min(a.length, b.length)\n    for(var i = 0; i < l; i++) {\n      var cmp = a[i] - b[i]\n      if(cmp) return cmp\n    }\n    return a.length - b.length\n  }\n\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\n// to be compatible with the current abstract-leveldown tests\n// nullish or empty strings.\n// I could use !!val but I want to permit numbers and booleans,\n// if possible.\n\nfunction isDef (val) {\n  return val !== undefined && val !== ''\n}\n\nfunction has (range, name) {\n  return Object.hasOwnProperty.call(range, name)\n}\n\nfunction hasKey(range, name) {\n  return Object.hasOwnProperty.call(range, name) && name\n}\n\nvar lowerBoundKey = exports.lowerBoundKey = function (range) {\n    return (\n       hasKey(range, 'gt')\n    || hasKey(range, 'gte')\n    || hasKey(range, 'min')\n    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))\n    || undefined\n    )\n}\n\nvar lowerBound = exports.lowerBound = function (range, def) {\n  var k = lowerBoundKey(range)\n  return k ? range[k] : def\n}\n\nvar lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {\n  return has(range, 'gt') ? false : true\n}\n\nvar upperBoundInclusive = exports.upperBoundInclusive =\n  function (range) {\n    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true\n  }\n\nvar lowerBoundExclusive = exports.lowerBoundExclusive =\n  function (range) {\n    return !lowerBoundInclusive(range)\n  }\n\nvar upperBoundExclusive = exports.upperBoundExclusive =\n  function (range) {\n    return !upperBoundInclusive(range)\n  }\n\nvar upperBoundKey = exports.upperBoundKey = function (range) {\n    return (\n       hasKey(range, 'lt')\n    || hasKey(range, 'lte')\n    || hasKey(range, 'max')\n    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))\n    || undefined\n    )\n}\n\nvar upperBound = exports.upperBound = function (range, def) {\n  var k = upperBoundKey(range)\n  return k ? range[k] : def\n}\n\nexports.start = function (range, def) {\n  return range.reverse ? upperBound(range, def) : lowerBound(range, def)\n}\nexports.end = function (range, def) {\n  return range.reverse ? lowerBound(range, def) : upperBound(range, def)\n}\nexports.startInclusive = function (range) {\n  return (\n    range.reverse\n  ? upperBoundInclusive(range)\n  : lowerBoundInclusive(range)\n  )\n}\nexports.endInclusive = function (range) {\n  return (\n    range.reverse\n  ? lowerBoundInclusive(range)\n  : upperBoundInclusive(range)\n  )\n}\n\nfunction id (e) { return e }\n\nexports.toLtgt = function (range, _range, map, lower, upper) {\n  _range = _range || {}\n  map = map || id\n  var defaults = arguments.length > 3\n  var lb = exports.lowerBoundKey(range)\n  var ub = exports.upperBoundKey(range)\n  if(lb) {\n    if(lb === 'gt') _range.gt = map(range.gt, false)\n    else            _range.gte = map(range[lb], false)\n  }\n  else if(defaults)\n    _range.gte = map(lower, false)\n\n  if(ub) {\n    if(ub === 'lt') _range.lt = map(range.lt, true)\n    else            _range.lte = map(range[ub], true)\n  }\n  else if(defaults)\n    _range.lte = map(upper, true)\n\n  if(range.reverse != null)\n    _range.reverse = !!range.reverse\n\n  //if range was used mutably\n  //(in level-sublevel it's part of an options object\n  //that has more properties on it.)\n  if(has(_range, 'max'))   delete _range.max\n  if(has(_range, 'min'))   delete _range.min\n  if(has(_range, 'start')) delete _range.start\n  if(has(_range, 'end'))   delete _range.end\n\n  return _range\n}\n\nexports.contains = function (range, key, compare) {\n  compare = compare || exports.compare\n\n  var lb = lowerBound(range)\n  if(isDef(lb)) {\n    var cmp = compare(key, lb)\n    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))\n      return false\n  }\n\n  var ub = upperBound(range)\n  if(isDef(ub)) {\n    var cmp = compare(key, ub)\n    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))\n      return false\n  }\n\n  return true\n}\n\nexports.filter = function (range, compare) {\n  return function (key) {\n    return exports.contains(range, key, compare)\n  }\n}\n\n\n","start":1670465468264,"end":1670465468311},{"name":"vite:react-babel","result":"\nexports.compare = function (a, b) {\n\n  if(Buffer.isBuffer(a)) {\n    var l = Math.min(a.length, b.length)\n    for(var i = 0; i < l; i++) {\n      var cmp = a[i] - b[i]\n      if(cmp) return cmp\n    }\n    return a.length - b.length\n  }\n\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\n// to be compatible with the current abstract-leveldown tests\n// nullish or empty strings.\n// I could use !!val but I want to permit numbers and booleans,\n// if possible.\n\nfunction isDef (val) {\n  return val !== undefined && val !== ''\n}\n\nfunction has (range, name) {\n  return Object.hasOwnProperty.call(range, name)\n}\n\nfunction hasKey(range, name) {\n  return Object.hasOwnProperty.call(range, name) && name\n}\n\nvar lowerBoundKey = exports.lowerBoundKey = function (range) {\n    return (\n       hasKey(range, 'gt')\n    || hasKey(range, 'gte')\n    || hasKey(range, 'min')\n    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))\n    || undefined\n    )\n}\n\nvar lowerBound = exports.lowerBound = function (range, def) {\n  var k = lowerBoundKey(range)\n  return k ? range[k] : def\n}\n\nvar lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {\n  return has(range, 'gt') ? false : true\n}\n\nvar upperBoundInclusive = exports.upperBoundInclusive =\n  function (range) {\n    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true\n  }\n\nvar lowerBoundExclusive = exports.lowerBoundExclusive =\n  function (range) {\n    return !lowerBoundInclusive(range)\n  }\n\nvar upperBoundExclusive = exports.upperBoundExclusive =\n  function (range) {\n    return !upperBoundInclusive(range)\n  }\n\nvar upperBoundKey = exports.upperBoundKey = function (range) {\n    return (\n       hasKey(range, 'lt')\n    || hasKey(range, 'lte')\n    || hasKey(range, 'max')\n    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))\n    || undefined\n    )\n}\n\nvar upperBound = exports.upperBound = function (range, def) {\n  var k = upperBoundKey(range)\n  return k ? range[k] : def\n}\n\nexports.start = function (range, def) {\n  return range.reverse ? upperBound(range, def) : lowerBound(range, def)\n}\nexports.end = function (range, def) {\n  return range.reverse ? lowerBound(range, def) : upperBound(range, def)\n}\nexports.startInclusive = function (range) {\n  return (\n    range.reverse\n  ? upperBoundInclusive(range)\n  : lowerBoundInclusive(range)\n  )\n}\nexports.endInclusive = function (range) {\n  return (\n    range.reverse\n  ? lowerBoundInclusive(range)\n  : upperBoundInclusive(range)\n  )\n}\n\nfunction id (e) { return e }\n\nexports.toLtgt = function (range, _range, map, lower, upper) {\n  _range = _range || {}\n  map = map || id\n  var defaults = arguments.length > 3\n  var lb = exports.lowerBoundKey(range)\n  var ub = exports.upperBoundKey(range)\n  if(lb) {\n    if(lb === 'gt') _range.gt = map(range.gt, false)\n    else            _range.gte = map(range[lb], false)\n  }\n  else if(defaults)\n    _range.gte = map(lower, false)\n\n  if(ub) {\n    if(ub === 'lt') _range.lt = map(range.lt, true)\n    else            _range.lte = map(range[ub], true)\n  }\n  else if(defaults)\n    _range.lte = map(upper, true)\n\n  if(range.reverse != null)\n    _range.reverse = !!range.reverse\n\n  //if range was used mutably\n  //(in level-sublevel it's part of an options object\n  //that has more properties on it.)\n  if(has(_range, 'max'))   delete _range.max\n  if(has(_range, 'min'))   delete _range.min\n  if(has(_range, 'start')) delete _range.start\n  if(has(_range, 'end'))   delete _range.end\n\n  return _range\n}\n\nexports.contains = function (range, key, compare) {\n  compare = compare || exports.compare\n\n  var lb = lowerBound(range)\n  if(isDef(lb)) {\n    var cmp = compare(key, lb)\n    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))\n      return false\n  }\n\n  var ub = upperBound(range)\n  if(isDef(ub)) {\n    var cmp = compare(key, ub)\n    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))\n      return false\n  }\n\n  return true\n}\n\nexports.filter = function (range, compare) {\n  return function (key) {\n    return exports.contains(range, key, compare)\n  }\n}\n\n\n","start":1670465468311,"end":1670465468311,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as ltgt } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/ltgt@2.2.1/node_modules/ltgt/index.js?commonjs-exports\"\n\n(function (exports) {\n\texports.compare = function (a, b) {\n\n\t  if(Buffer.isBuffer(a)) {\n\t    var l = Math.min(a.length, b.length)\n\t    for(var i = 0; i < l; i++) {\n\t      var cmp = a[i] - b[i]\n\t      if(cmp) return cmp\n\t    }\n\t    return a.length - b.length\n\t  }\n\n\t  return a < b ? -1 : a > b ? 1 : 0\n\t}\n\n\t// to be compatible with the current abstract-leveldown tests\n\t// nullish or empty strings.\n\t// I could use !!val but I want to permit numbers and booleans,\n\t// if possible.\n\n\tfunction isDef (val) {\n\t  return val !== undefined && val !== ''\n\t}\n\n\tfunction has (range, name) {\n\t  return Object.hasOwnProperty.call(range, name)\n\t}\n\n\tfunction hasKey(range, name) {\n\t  return Object.hasOwnProperty.call(range, name) && name\n\t}\n\n\tvar lowerBoundKey = exports.lowerBoundKey = function (range) {\n\t    return (\n\t       hasKey(range, 'gt')\n\t    || hasKey(range, 'gte')\n\t    || hasKey(range, 'min')\n\t    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))\n\t    || undefined\n\t    )\n\t}\n\n\tvar lowerBound = exports.lowerBound = function (range, def) {\n\t  var k = lowerBoundKey(range)\n\t  return k ? range[k] : def\n\t}\n\n\tvar lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {\n\t  return has(range, 'gt') ? false : true\n\t}\n\n\tvar upperBoundInclusive = exports.upperBoundInclusive =\n\t  function (range) {\n\t    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true\n\t  }\n\n\tvar lowerBoundExclusive = exports.lowerBoundExclusive =\n\t  function (range) {\n\t    return !lowerBoundInclusive(range)\n\t  }\n\n\tvar upperBoundExclusive = exports.upperBoundExclusive =\n\t  function (range) {\n\t    return !upperBoundInclusive(range)\n\t  }\n\n\tvar upperBoundKey = exports.upperBoundKey = function (range) {\n\t    return (\n\t       hasKey(range, 'lt')\n\t    || hasKey(range, 'lte')\n\t    || hasKey(range, 'max')\n\t    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))\n\t    || undefined\n\t    )\n\t}\n\n\tvar upperBound = exports.upperBound = function (range, def) {\n\t  var k = upperBoundKey(range)\n\t  return k ? range[k] : def\n\t}\n\n\texports.start = function (range, def) {\n\t  return range.reverse ? upperBound(range, def) : lowerBound(range, def)\n\t}\n\texports.end = function (range, def) {\n\t  return range.reverse ? lowerBound(range, def) : upperBound(range, def)\n\t}\n\texports.startInclusive = function (range) {\n\t  return (\n\t    range.reverse\n\t  ? upperBoundInclusive(range)\n\t  : lowerBoundInclusive(range)\n\t  )\n\t}\n\texports.endInclusive = function (range) {\n\t  return (\n\t    range.reverse\n\t  ? lowerBoundInclusive(range)\n\t  : upperBoundInclusive(range)\n\t  )\n\t}\n\n\tfunction id (e) { return e }\n\n\texports.toLtgt = function (range, _range, map, lower, upper) {\n\t  _range = _range || {}\n\t  map = map || id\n\t  var defaults = arguments.length > 3\n\t  var lb = exports.lowerBoundKey(range)\n\t  var ub = exports.upperBoundKey(range)\n\t  if(lb) {\n\t    if(lb === 'gt') _range.gt = map(range.gt, false)\n\t    else            _range.gte = map(range[lb], false)\n\t  }\n\t  else if(defaults)\n\t    _range.gte = map(lower, false)\n\n\t  if(ub) {\n\t    if(ub === 'lt') _range.lt = map(range.lt, true)\n\t    else            _range.lte = map(range[ub], true)\n\t  }\n\t  else if(defaults)\n\t    _range.lte = map(upper, true)\n\n\t  if(range.reverse != null)\n\t    _range.reverse = !!range.reverse\n\n\t  //if range was used mutably\n\t  //(in level-sublevel it's part of an options object\n\t  //that has more properties on it.)\n\t  if(has(_range, 'max'))   delete _range.max\n\t  if(has(_range, 'min'))   delete _range.min\n\t  if(has(_range, 'start')) delete _range.start\n\t  if(has(_range, 'end'))   delete _range.end\n\n\t  return _range\n\t}\n\n\texports.contains = function (range, key, compare) {\n\t  compare = compare || exports.compare\n\n\t  var lb = lowerBound(range)\n\t  if(isDef(lb)) {\n\t    var cmp = compare(key, lb)\n\t    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))\n\t      return false\n\t  }\n\n\t  var ub = upperBound(range)\n\t  if(isDef(ub)) {\n\t    var cmp = compare(key, ub)\n\t    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))\n\t      return false\n\t  }\n\n\t  return true\n\t}\n\n\texports.filter = function (range, compare) {\n\t  return function (key) {\n\t    return exports.contains(range, key, compare)\n\t  }\n\t}\n} (ltgt));\n\nexport default ltgt;\nexport { ltgt as __moduleExports };","start":1670465468311,"end":1670465468312,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as ltgt } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/ltgt@2.2.1/node_modules/ltgt/index.js?commonjs-exports\"\n\n(function (exports) {\n\texports.compare = function (a, b) {\n\n\t  if(Buffer.isBuffer(a)) {\n\t    var l = Math.min(a.length, b.length)\n\t    for(var i = 0; i < l; i++) {\n\t      var cmp = a[i] - b[i]\n\t      if(cmp) return cmp\n\t    }\n\t    return a.length - b.length\n\t  }\n\n\t  return a < b ? -1 : a > b ? 1 : 0\n\t}\n\n\t// to be compatible with the current abstract-leveldown tests\n\t// nullish or empty strings.\n\t// I could use !!val but I want to permit numbers and booleans,\n\t// if possible.\n\n\tfunction isDef (val) {\n\t  return val !== undefined && val !== ''\n\t}\n\n\tfunction has (range, name) {\n\t  return Object.hasOwnProperty.call(range, name)\n\t}\n\n\tfunction hasKey(range, name) {\n\t  return Object.hasOwnProperty.call(range, name) && name\n\t}\n\n\tvar lowerBoundKey = exports.lowerBoundKey = function (range) {\n\t    return (\n\t       hasKey(range, 'gt')\n\t    || hasKey(range, 'gte')\n\t    || hasKey(range, 'min')\n\t    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))\n\t    || undefined\n\t    )\n\t}\n\n\tvar lowerBound = exports.lowerBound = function (range, def) {\n\t  var k = lowerBoundKey(range)\n\t  return k ? range[k] : def\n\t}\n\n\tvar lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {\n\t  return has(range, 'gt') ? false : true\n\t}\n\n\tvar upperBoundInclusive = exports.upperBoundInclusive =\n\t  function (range) {\n\t    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true\n\t  }\n\n\tvar lowerBoundExclusive = exports.lowerBoundExclusive =\n\t  function (range) {\n\t    return !lowerBoundInclusive(range)\n\t  }\n\n\tvar upperBoundExclusive = exports.upperBoundExclusive =\n\t  function (range) {\n\t    return !upperBoundInclusive(range)\n\t  }\n\n\tvar upperBoundKey = exports.upperBoundKey = function (range) {\n\t    return (\n\t       hasKey(range, 'lt')\n\t    || hasKey(range, 'lte')\n\t    || hasKey(range, 'max')\n\t    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))\n\t    || undefined\n\t    )\n\t}\n\n\tvar upperBound = exports.upperBound = function (range, def) {\n\t  var k = upperBoundKey(range)\n\t  return k ? range[k] : def\n\t}\n\n\texports.start = function (range, def) {\n\t  return range.reverse ? upperBound(range, def) : lowerBound(range, def)\n\t}\n\texports.end = function (range, def) {\n\t  return range.reverse ? lowerBound(range, def) : upperBound(range, def)\n\t}\n\texports.startInclusive = function (range) {\n\t  return (\n\t    range.reverse\n\t  ? upperBoundInclusive(range)\n\t  : lowerBoundInclusive(range)\n\t  )\n\t}\n\texports.endInclusive = function (range) {\n\t  return (\n\t    range.reverse\n\t  ? lowerBoundInclusive(range)\n\t  : upperBoundInclusive(range)\n\t  )\n\t}\n\n\tfunction id (e) { return e }\n\n\texports.toLtgt = function (range, _range, map, lower, upper) {\n\t  _range = _range || {}\n\t  map = map || id\n\t  var defaults = arguments.length > 3\n\t  var lb = exports.lowerBoundKey(range)\n\t  var ub = exports.upperBoundKey(range)\n\t  if(lb) {\n\t    if(lb === 'gt') _range.gt = map(range.gt, false)\n\t    else            _range.gte = map(range[lb], false)\n\t  }\n\t  else if(defaults)\n\t    _range.gte = map(lower, false)\n\n\t  if(ub) {\n\t    if(ub === 'lt') _range.lt = map(range.lt, true)\n\t    else            _range.lte = map(range[ub], true)\n\t  }\n\t  else if(defaults)\n\t    _range.lte = map(upper, true)\n\n\t  if(range.reverse != null)\n\t    _range.reverse = !!range.reverse\n\n\t  //if range was used mutably\n\t  //(in level-sublevel it's part of an options object\n\t  //that has more properties on it.)\n\t  if(has(_range, 'max'))   delete _range.max\n\t  if(has(_range, 'min'))   delete _range.min\n\t  if(has(_range, 'start')) delete _range.start\n\t  if(has(_range, 'end'))   delete _range.end\n\n\t  return _range\n\t}\n\n\texports.contains = function (range, key, compare) {\n\t  compare = compare || exports.compare\n\n\t  var lb = lowerBound(range)\n\t  if(isDef(lb)) {\n\t    var cmp = compare(key, lb)\n\t    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))\n\t      return false\n\t  }\n\n\t  var ub = upperBound(range)\n\t  if(isDef(ub)) {\n\t    var cmp = compare(key, ub)\n\t    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))\n\t      return false\n\t  }\n\n\t  return true\n\t}\n\n\texports.filter = function (range, compare) {\n\t  return function (key) {\n\t    return exports.contains(range, key, compare)\n\t  }\n\t}\n} (ltgt));\n\nexport default ltgt;\nexport { ltgt as __moduleExports };","start":1670465468312,"end":1670465468314,"order":"normal"}]}
