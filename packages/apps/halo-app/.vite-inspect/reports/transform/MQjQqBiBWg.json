{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/debug/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/debug/src/assert.ts\nvar checkType = (value) => value;\n\n// packages/common/debug/src/error-handler.ts\nimport { EventEmitter } from \"@dxos/node-std/events\";\nvar ErrorHandler = class extends EventEmitter {\n  constructor() {\n    super();\n    this._listener = (event) => {\n      const cause = event.error || event.reason || event;\n      const message = cause.stack || cause.message || cause.toString();\n      this.emit(\"error\", message);\n    };\n    window.addEventListener(\"error\", this._listener);\n    window.addEventListener(\"unhandledrejection\", this._listener);\n  }\n  reset() {\n    window.removeEventListener(\"error\", this._listener);\n    window.removeEventListener(\"unhandledrejection\", this._listener);\n  }\n};\n\n// packages/common/debug/src/error-stream.ts\nvar ErrorStream = class {\n  constructor() {\n    this._unhandledErrors = 0;\n  }\n  assertNoUnhandledErrors() {\n    if (this._unhandledErrors > 0) {\n      throw new Error(`Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`);\n    }\n  }\n  raise(error) {\n    if (this._handler) {\n      this._handler(error);\n    } else {\n      this._unhandledError(error);\n    }\n  }\n  handle(handler) {\n    this._handler = handler;\n  }\n  pipeTo(receiver) {\n    this.handle((error) => receiver.raise(error));\n  }\n  _unhandledError(error) {\n    this._unhandledErrors++;\n    setTimeout(() => {\n      throw error;\n    });\n  }\n};\n\n// packages/common/debug/src/exceptions.ts\nvar throwUnhandledRejection = (error) => {\n  setTimeout(() => {\n    throw error;\n  });\n};\n\n// packages/common/debug/src/fail.ts\nvar failUndefined = () => {\n  throw new Error(\"Required value was null or undefined.\");\n};\n\n// packages/common/debug/src/inspect.ts\nimport { inspect } from \"@dxos/node-std/util\";\nvar inspectObject = (obj) => {\n  const name = Object.getPrototypeOf(obj).constructor.name;\n  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);\n};\n\n// packages/common/debug/src/log-method.ts\nfunction logMethod(target, propertyName, descriptor) {\n  const method = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);\n    try {\n      const result = method.apply(this, args);\n      if (typeof result.catch === \"function\") {\n        result.catch((err) => {\n          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);\n        });\n      }\n      return result;\n    } catch (err) {\n      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);\n      throw err;\n    }\n  };\n}\n\n// packages/common/debug/src/logging.ts\nimport debug from \"debug\";\ndebug.log = console.log.bind(console);\nvar log = (...args) => {\n  console.log(args.map((arg) => arg.toString()).join(\" \"));\n};\nvar logError = (str) => {\n  if (typeof str.message === \"string\") {\n    str = `Error: ${str.message.replace(\"\\n\", \"\")}`;\n  } else if (str instanceof Error) {\n    str = String(str);\n  } else if (typeof str === \"object\") {\n    str = JSON.stringify(str);\n  } else if (typeof str === \"string\") {\n    str = str.replace(\"\\n\", \"\");\n  }\n  console.error(`\n${str}`);\n};\nvar logs = (name) => {\n  const log2 = debug(name);\n  log2.log = console.log.bind(console);\n  const error = debug(`${name}:error`);\n  error.log = console.error.bind(console);\n  return {\n    log: log2,\n    error: (err, ...rest) => {\n      if (err instanceof Error) {\n        const { name: name2, message } = err;\n        error(`${name2}: ${message}`);\n        console.error(err);\n      } else {\n        error(err, ...rest);\n      }\n    }\n  };\n};\nvar enable = (namespaces) => {\n  debug.enable(namespaces);\n};\nvar disable = () => debug.disable();\n\n// packages/common/debug/src/raise.ts\nvar raise = (error) => {\n  throw error;\n};\n\n// packages/common/debug/src/snoop.ts\nvar SnoopLevel;\n(function(SnoopLevel2) {\n  SnoopLevel2[SnoopLevel2[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SnoopLevel2[SnoopLevel2[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  SnoopLevel2[SnoopLevel2[\"BOLD\"] = 2] = \"BOLD\";\n})(SnoopLevel || (SnoopLevel = {}));\nvar Snoop = class {\n  static stackFunction(err) {\n    const stack = err.stack.split(\"\\n\");\n    const match = stack[2].match(/.+\\((.+)\\).*/);\n    if (match) {\n      const [file, line] = match[1].split(\":\");\n      return `[${file.substring(file.lastIndexOf(\"/\") + 1)}:${line}]`;\n    }\n  }\n  constructor(_context) {\n    this._context = _context;\n  }\n  get verbose() {\n    return SnoopLevel.VERBOSE;\n  }\n  get bold() {\n    return SnoopLevel.BOLD;\n  }\n  format(prefix, name, args, level) {\n    const pre = prefix.repeat(level === SnoopLevel.BOLD ? 8 : 2);\n    const label = this._context ? `${this._context}.${name}` : name;\n    const line = `${pre} ${label}${args}`;\n    return level === SnoopLevel.BOLD ? [\n      pre,\n      line,\n      pre\n    ].join(\"\\n\") : line;\n  }\n  in(label, level, ...args) {\n    return this.format(\"<\", label, level === SnoopLevel.DEFAULT ? \"\" : `(${String(...args)})`, level);\n  }\n  out(label, level, result) {\n    return this.format(\">\", label, level === SnoopLevel.DEFAULT ? \"\" : ` = ${String(result)}`, level);\n  }\n  sync(f, label, level = SnoopLevel.VERBOSE) {\n    label = label != null ? label : Snoop.stackFunction(new Error());\n    return (...args) => {\n      console.log(this.in(label != null ? label : \"\", level, ...args));\n      const r = f(...args);\n      console.log(this.out(label != null ? label : \"\", level, r));\n      return r;\n    };\n  }\n  async(f, label, level = SnoopLevel.VERBOSE) {\n    label = label != null ? label : Snoop.stackFunction(new Error());\n    return async (...args) => {\n      console.log(this.in(label != null ? label : \"\", level, ...args));\n      const r = await f(...args);\n      console.log(this.out(label != null ? label : \"\", level, r));\n      return r;\n    };\n  }\n};\nvar snoop = new Snoop();\n\n// packages/common/debug/src/stack-trace.ts\nvar StackTrace = class {\n  constructor() {\n    this._stack = new Error();\n  }\n  getStack(skipFrames = 0) {\n    const stack = this._stack.stack.split(\"\\n\");\n    return stack.slice(skipFrames + 2).join(\"\\n\");\n  }\n};\n\n// packages/common/debug/src/strings.ts\nvar truncate = (str = \"\", length, pad = false) => {\n  if (str.length >= length - 1) {\n    return str.substring(0, length - 1) + \"\\u2026\";\n  } else {\n    return pad ? str.padEnd(length, typeof pad === \"boolean\" ? \" \" : pad[0]) : str;\n  }\n};\nvar truncateKey = (key, n = 4) => {\n  const str = String(key);\n  if (str.length < n * 2 + 2) {\n    return str;\n  }\n  return `${str.substring(0, n)}..${str.substring(str.length - n)}`;\n};\n\n// packages/common/debug/src/throw.ts\nvar expectToThrow = async (test, errType = Error) => {\n  let thrown;\n  try {\n    await test();\n  } catch (err) {\n    thrown = err;\n  }\n  if (thrown === void 0 || !(thrown instanceof errType)) {\n    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);\n  }\n};\n\n// packages/common/debug/src/timeout-warning.ts\nvar warnAfterTimeout = async (timeout, context, body) => {\n  const stack = new StackTrace();\n  const timeoutId = setTimeout(() => {\n    console.warn(`Action \\`${context}\\` is taking more then ${timeout} ms to complete. This might be a bug.\n${stack.getStack()}`);\n  }, timeout);\n  try {\n    return await body();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\nfunction timed(timeout) {\n  return (target, propertyName, descriptor) => {\n    const method = descriptor.value;\n    descriptor.value = function(...args) {\n      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));\n    };\n  };\n}\n\n// packages/common/debug/src/todo.ts\nvar todo = (message) => {\n  throw new Error(message != null ? message : \"Not implemented.\");\n};\nexport {\n  ErrorHandler,\n  ErrorStream,\n  Snoop,\n  SnoopLevel,\n  StackTrace,\n  checkType,\n  disable,\n  enable,\n  expectToThrow,\n  failUndefined,\n  inspectObject,\n  log,\n  logError,\n  logMethod,\n  logs,\n  raise,\n  snoop,\n  throwUnhandledRejection,\n  timed,\n  todo,\n  truncate,\n  truncateKey,\n  warnAfterTimeout\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465035,"end":1670465465322},{"name":"vite:react-babel","result":"// packages/common/debug/src/assert.ts\nvar checkType = (value) => value;\n\n// packages/common/debug/src/error-handler.ts\nimport { EventEmitter } from \"@dxos/node-std/events\";\nvar ErrorHandler = class extends EventEmitter {\n  constructor() {\n    super();\n    this._listener = (event) => {\n      const cause = event.error || event.reason || event;\n      const message = cause.stack || cause.message || cause.toString();\n      this.emit(\"error\", message);\n    };\n    window.addEventListener(\"error\", this._listener);\n    window.addEventListener(\"unhandledrejection\", this._listener);\n  }\n  reset() {\n    window.removeEventListener(\"error\", this._listener);\n    window.removeEventListener(\"unhandledrejection\", this._listener);\n  }\n};\n\n// packages/common/debug/src/error-stream.ts\nvar ErrorStream = class {\n  constructor() {\n    this._unhandledErrors = 0;\n  }\n  assertNoUnhandledErrors() {\n    if (this._unhandledErrors > 0) {\n      throw new Error(`Assertion failed: expected no unhandled errors to be thrown, but ${this._unhandledErrors} were thrown.`);\n    }\n  }\n  raise(error) {\n    if (this._handler) {\n      this._handler(error);\n    } else {\n      this._unhandledError(error);\n    }\n  }\n  handle(handler) {\n    this._handler = handler;\n  }\n  pipeTo(receiver) {\n    this.handle((error) => receiver.raise(error));\n  }\n  _unhandledError(error) {\n    this._unhandledErrors++;\n    setTimeout(() => {\n      throw error;\n    });\n  }\n};\n\n// packages/common/debug/src/exceptions.ts\nvar throwUnhandledRejection = (error) => {\n  setTimeout(() => {\n    throw error;\n  });\n};\n\n// packages/common/debug/src/fail.ts\nvar failUndefined = () => {\n  throw new Error(\"Required value was null or undefined.\");\n};\n\n// packages/common/debug/src/inspect.ts\nimport { inspect } from \"@dxos/node-std/util\";\nvar inspectObject = (obj) => {\n  const name = Object.getPrototypeOf(obj).constructor.name;\n  return obj.toJSON ? `${name}(${inspect(obj.toJSON())})` : String(obj);\n};\n\n// packages/common/debug/src/log-method.ts\nfunction logMethod(target, propertyName, descriptor) {\n  const method = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log(`Called ${target.constructor.name}.${propertyName} ${args}`);\n    try {\n      const result = method.apply(this, args);\n      if (typeof result.catch === \"function\") {\n        result.catch((err) => {\n          console.log(`Rejected ${target.constructor.name}.${propertyName}`, err);\n        });\n      }\n      return result;\n    } catch (err) {\n      console.log(`Thrown ${target.constructor.name}.${propertyName}`, err);\n      throw err;\n    }\n  };\n}\n\n// packages/common/debug/src/logging.ts\nimport debug from \"debug\";\ndebug.log = console.log.bind(console);\nvar log = (...args) => {\n  console.log(args.map((arg) => arg.toString()).join(\" \"));\n};\nvar logError = (str) => {\n  if (typeof str.message === \"string\") {\n    str = `Error: ${str.message.replace(\"\\n\", \"\")}`;\n  } else if (str instanceof Error) {\n    str = String(str);\n  } else if (typeof str === \"object\") {\n    str = JSON.stringify(str);\n  } else if (typeof str === \"string\") {\n    str = str.replace(\"\\n\", \"\");\n  }\n  console.error(`\n${str}`);\n};\nvar logs = (name) => {\n  const log2 = debug(name);\n  log2.log = console.log.bind(console);\n  const error = debug(`${name}:error`);\n  error.log = console.error.bind(console);\n  return {\n    log: log2,\n    error: (err, ...rest) => {\n      if (err instanceof Error) {\n        const { name: name2, message } = err;\n        error(`${name2}: ${message}`);\n        console.error(err);\n      } else {\n        error(err, ...rest);\n      }\n    }\n  };\n};\nvar enable = (namespaces) => {\n  debug.enable(namespaces);\n};\nvar disable = () => debug.disable();\n\n// packages/common/debug/src/raise.ts\nvar raise = (error) => {\n  throw error;\n};\n\n// packages/common/debug/src/snoop.ts\nvar SnoopLevel;\n(function(SnoopLevel2) {\n  SnoopLevel2[SnoopLevel2[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  SnoopLevel2[SnoopLevel2[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  SnoopLevel2[SnoopLevel2[\"BOLD\"] = 2] = \"BOLD\";\n})(SnoopLevel || (SnoopLevel = {}));\nvar Snoop = class {\n  static stackFunction(err) {\n    const stack = err.stack.split(\"\\n\");\n    const match = stack[2].match(/.+\\((.+)\\).*/);\n    if (match) {\n      const [file, line] = match[1].split(\":\");\n      return `[${file.substring(file.lastIndexOf(\"/\") + 1)}:${line}]`;\n    }\n  }\n  constructor(_context) {\n    this._context = _context;\n  }\n  get verbose() {\n    return SnoopLevel.VERBOSE;\n  }\n  get bold() {\n    return SnoopLevel.BOLD;\n  }\n  format(prefix, name, args, level) {\n    const pre = prefix.repeat(level === SnoopLevel.BOLD ? 8 : 2);\n    const label = this._context ? `${this._context}.${name}` : name;\n    const line = `${pre} ${label}${args}`;\n    return level === SnoopLevel.BOLD ? [\n      pre,\n      line,\n      pre\n    ].join(\"\\n\") : line;\n  }\n  in(label, level, ...args) {\n    return this.format(\"<\", label, level === SnoopLevel.DEFAULT ? \"\" : `(${String(...args)})`, level);\n  }\n  out(label, level, result) {\n    return this.format(\">\", label, level === SnoopLevel.DEFAULT ? \"\" : ` = ${String(result)}`, level);\n  }\n  sync(f, label, level = SnoopLevel.VERBOSE) {\n    label = label != null ? label : Snoop.stackFunction(new Error());\n    return (...args) => {\n      console.log(this.in(label != null ? label : \"\", level, ...args));\n      const r = f(...args);\n      console.log(this.out(label != null ? label : \"\", level, r));\n      return r;\n    };\n  }\n  async(f, label, level = SnoopLevel.VERBOSE) {\n    label = label != null ? label : Snoop.stackFunction(new Error());\n    return async (...args) => {\n      console.log(this.in(label != null ? label : \"\", level, ...args));\n      const r = await f(...args);\n      console.log(this.out(label != null ? label : \"\", level, r));\n      return r;\n    };\n  }\n};\nvar snoop = new Snoop();\n\n// packages/common/debug/src/stack-trace.ts\nvar StackTrace = class {\n  constructor() {\n    this._stack = new Error();\n  }\n  getStack(skipFrames = 0) {\n    const stack = this._stack.stack.split(\"\\n\");\n    return stack.slice(skipFrames + 2).join(\"\\n\");\n  }\n};\n\n// packages/common/debug/src/strings.ts\nvar truncate = (str = \"\", length, pad = false) => {\n  if (str.length >= length - 1) {\n    return str.substring(0, length - 1) + \"\\u2026\";\n  } else {\n    return pad ? str.padEnd(length, typeof pad === \"boolean\" ? \" \" : pad[0]) : str;\n  }\n};\nvar truncateKey = (key, n = 4) => {\n  const str = String(key);\n  if (str.length < n * 2 + 2) {\n    return str;\n  }\n  return `${str.substring(0, n)}..${str.substring(str.length - n)}`;\n};\n\n// packages/common/debug/src/throw.ts\nvar expectToThrow = async (test, errType = Error) => {\n  let thrown;\n  try {\n    await test();\n  } catch (err) {\n    thrown = err;\n  }\n  if (thrown === void 0 || !(thrown instanceof errType)) {\n    throw new Error(`Expected function to throw instance of ${errType.prototype.name}`);\n  }\n};\n\n// packages/common/debug/src/timeout-warning.ts\nvar warnAfterTimeout = async (timeout, context, body) => {\n  const stack = new StackTrace();\n  const timeoutId = setTimeout(() => {\n    console.warn(`Action \\`${context}\\` is taking more then ${timeout} ms to complete. This might be a bug.\n${stack.getStack()}`);\n  }, timeout);\n  try {\n    return await body();\n  } finally {\n    clearTimeout(timeoutId);\n  }\n};\nfunction timed(timeout) {\n  return (target, propertyName, descriptor) => {\n    const method = descriptor.value;\n    descriptor.value = function(...args) {\n      return warnAfterTimeout(timeout, `${target.constructor.name}.${propertyName}`, () => method.apply(this, args));\n    };\n  };\n}\n\n// packages/common/debug/src/todo.ts\nvar todo = (message) => {\n  throw new Error(message != null ? message : \"Not implemented.\");\n};\nexport {\n  ErrorHandler,\n  ErrorStream,\n  Snoop,\n  SnoopLevel,\n  StackTrace,\n  checkType,\n  disable,\n  enable,\n  expectToThrow,\n  failUndefined,\n  inspectObject,\n  log,\n  logError,\n  logMethod,\n  logs,\n  raise,\n  snoop,\n  throwUnhandledRejection,\n  timed,\n  todo,\n  truncate,\n  truncateKey,\n  warnAfterTimeout\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465322,"end":1670465465322,"order":"pre"}]}
