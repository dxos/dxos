{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/timeframe/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/timeframe/src/timeframe.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar Timeframe = class {\n  constructor(frames = []) {\n    this._frames = new ComplexMap(PublicKey.hash);\n    for (const [key, seq] of frames) {\n      this.set(key, seq);\n    }\n  }\n  toJSON() {\n    return this.frames().reduce((frames, [key, seq]) => {\n      frames[key.truncate()] = seq;\n      return frames;\n    }, {});\n  }\n  toString() {\n    return `([${this.frames().map(([key, seq]) => `${key.truncate()} => ${seq}`).join(\", \")}])`;\n  }\n  get(key) {\n    return this._frames.get(key);\n  }\n  set(key, value) {\n    this._frames.set(key, value);\n  }\n  frames() {\n    return Array.from(this._frames.entries()).filter((frame) => !!frame);\n  }\n  size() {\n    return this._frames.size;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  withoutKeys(keys) {\n    return new Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => Buffer.compare(key.asBuffer(), frameKey.asBuffer()) !== 0)));\n  }\n  totalMessages() {\n    return Array.from(this._frames.values()).reduce((result, seq) => result + seq + 1, 0);\n  }\n  [inspect.custom]() {\n    return `Timeframe${this.toString()}`;\n  }\n  static merge(...timeframes) {\n    const result = new Timeframe();\n    for (const timeframe of timeframes) {\n      for (const [key, seq] of timeframe.frames()) {\n        const current = result.get(key);\n        if (current === void 0 || seq > current) {\n          result.set(key, seq);\n        }\n      }\n    }\n    return result;\n  }\n  static dependencies(tf1, tf2) {\n    const result = new Timeframe();\n    for (const [key, seq] of tf1.frames()) {\n      const otherSeq = tf2.get(key);\n      if (otherSeq === void 0 || otherSeq < seq) {\n        result.set(key, seq);\n      }\n    }\n    return result;\n  }\n};\nexport {\n  Timeframe\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466968,"end":1670465467036},{"name":"vite:react-babel","result":"// packages/common/timeframe/src/timeframe.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar Timeframe = class {\n  constructor(frames = []) {\n    this._frames = new ComplexMap(PublicKey.hash);\n    for (const [key, seq] of frames) {\n      this.set(key, seq);\n    }\n  }\n  toJSON() {\n    return this.frames().reduce((frames, [key, seq]) => {\n      frames[key.truncate()] = seq;\n      return frames;\n    }, {});\n  }\n  toString() {\n    return `([${this.frames().map(([key, seq]) => `${key.truncate()} => ${seq}`).join(\", \")}])`;\n  }\n  get(key) {\n    return this._frames.get(key);\n  }\n  set(key, value) {\n    this._frames.set(key, value);\n  }\n  frames() {\n    return Array.from(this._frames.entries()).filter((frame) => !!frame);\n  }\n  size() {\n    return this._frames.size;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  withoutKeys(keys) {\n    return new Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => Buffer.compare(key.asBuffer(), frameKey.asBuffer()) !== 0)));\n  }\n  totalMessages() {\n    return Array.from(this._frames.values()).reduce((result, seq) => result + seq + 1, 0);\n  }\n  [inspect.custom]() {\n    return `Timeframe${this.toString()}`;\n  }\n  static merge(...timeframes) {\n    const result = new Timeframe();\n    for (const timeframe of timeframes) {\n      for (const [key, seq] of timeframe.frames()) {\n        const current = result.get(key);\n        if (current === void 0 || seq > current) {\n          result.set(key, seq);\n        }\n      }\n    }\n    return result;\n  }\n  static dependencies(tf1, tf2) {\n    const result = new Timeframe();\n    for (const [key, seq] of tf1.frames()) {\n      const otherSeq = tf2.get(key);\n      if (otherSeq === void 0 || otherSeq < seq) {\n        result.set(key, seq);\n      }\n    }\n    return result;\n  }\n};\nexport {\n  Timeframe\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467036,"end":1670465467036,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/timeframe/src/timeframe.ts\nimport { inspect } from \"@dxos/node-std/util\";\nimport { PublicKey } from \"@dxos/keys\";\nimport { ComplexMap } from \"@dxos/util\";\nvar Timeframe = class {\n  constructor(frames = []) {\n    this._frames = new ComplexMap(PublicKey.hash);\n    for (const [key, seq] of frames) {\n      this.set(key, seq);\n    }\n  }\n  toJSON() {\n    return this.frames().reduce((frames, [key, seq]) => {\n      frames[key.truncate()] = seq;\n      return frames;\n    }, {});\n  }\n  toString() {\n    return `([${this.frames().map(([key, seq]) => `${key.truncate()} => ${seq}`).join(\", \")}])`;\n  }\n  get(key) {\n    return this._frames.get(key);\n  }\n  set(key, value) {\n    this._frames.set(key, value);\n  }\n  frames() {\n    return Array.from(this._frames.entries()).filter((frame) => !!frame);\n  }\n  size() {\n    return this._frames.size;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  withoutKeys(keys) {\n    return new Timeframe(this.frames().filter(([frameKey]) => keys.every((key) => Buffer.compare(key.asBuffer(), frameKey.asBuffer()) !== 0)));\n  }\n  totalMessages() {\n    return Array.from(this._frames.values()).reduce((result, seq) => result + seq + 1, 0);\n  }\n  [inspect.custom]() {\n    return `Timeframe${this.toString()}`;\n  }\n  static merge(...timeframes) {\n    const result = new Timeframe();\n    for (const timeframe of timeframes) {\n      for (const [key, seq] of timeframe.frames()) {\n        const current = result.get(key);\n        if (current === void 0 || seq > current) {\n          result.set(key, seq);\n        }\n      }\n    }\n    return result;\n  }\n  static dependencies(tf1, tf2) {\n    const result = new Timeframe();\n    for (const [key, seq] of tf1.frames()) {\n      const otherSeq = tf2.get(key);\n      if (otherSeq === void 0 || otherSeq < seq) {\n        result.set(key, seq);\n      }\n    }\n    return result;\n  }\n};\nexport {\n  Timeframe\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467037,"end":1670465467038,"order":"normal"}]}
