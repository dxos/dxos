{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\nimport { log } from \"@dxos/log\";\nvar sendToIFrame = (iframe, origin, message) => {\n  if (!iframe.contentWindow) {\n    log(\"IFrame content window missing\", {\n      origin\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n      line: 12,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return;\n  }\n  iframe.contentWindow.postMessage(message, \"*\", [\n    message.payload\n  ]);\n};\nvar sendToParentWindow = (origin, message) => {\n  window.parent.postMessage(message, origin, [\n    message.payload\n  ]);\n};\nvar createIFramePort = ({ channel, iframe, origin, onOrigin }) => {\n  return {\n    send: async (data) => {\n      if (!origin) {\n        log.warn(\"no origin set\", {\n          channel\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n          line: 43,\n          scope: void 0,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"sending\", {\n        channel,\n        data: data.length\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n        line: 47,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n      const message = {\n        channel,\n        payload\n      };\n      if (iframe) {\n        sendToIFrame(iframe, origin, message);\n      } else {\n        sendToParentWindow(origin, message);\n      }\n    },\n    subscribe: (callback) => {\n      const handler = (event) => {\n        if (!iframe && event.source !== window.parent) {\n          return;\n        } else if (iframe && event.source !== iframe.contentWindow) {\n          return;\n        }\n        const isMessageData = event.data && typeof event.data === \"object\" && \"channel\" in event.data && \"payload\" in event.data;\n        const message = isMessageData ? event.data : void 0;\n        if ((message == null ? void 0 : message.channel) !== channel) {\n          return;\n        }\n        if (!origin) {\n          origin = event.origin;\n          onOrigin == null ? void 0 : onOrigin(origin);\n        }\n        log(\"received\", message, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n          line: 79,\n          scope: void 0,\n          callSite: (f, a) => f(...a)\n        });\n        callback(new Uint8Array(message.payload));\n      };\n      window.addEventListener(\"message\", handler);\n      return () => window.removeEventListener(\"message\", handler);\n    }\n  };\n};\nvar createIFrame = (source, id) => {\n  var _a;\n  const create = () => {\n    const iframe = document.createElement(\"iframe\");\n    iframe.id = id;\n    iframe.src = source;\n    iframe.setAttribute(\"style\", \"display: none;\");\n    document.body.appendChild(iframe);\n    return iframe;\n  };\n  {\n    const cssStyle = \"color:#C026D3;font-weight:bold\";\n    console.log(`%cDXOS Client is communicating with the shared worker on ${source}.\nInspect the worker using: chrome://inspect/#workers (URL must be copied manually).`, cssStyle);\n    console.log(`%cTo inspect this application, click here:\nhttps://devtools.dxos.org/?target=vault:${source}`, cssStyle);\n  }\n  return (_a = document.getElementById(id)) != null ? _a : create();\n};\n\n// packages/core/mesh/rpc-tunnel/src/ports/worker.ts\nimport { log as log2 } from \"@dxos/log\";\nvar createWorkerPort = ({ port, channel, subscribe }) => ({\n  send: async (message) => {\n    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);\n    port.postMessage({\n      channel,\n      payload\n    }, [\n      payload\n    ]);\n  },\n  subscribe: subscribe != null ? subscribe : (callback) => {\n    const handler = (event) => {\n      const message = event.data;\n      if (message.channel !== channel) {\n        return;\n      }\n      log2.debug(\"Recieved message\", message, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/worker.ts\",\n        line: 45,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      callback(new Uint8Array(message.payload));\n    };\n    port.onmessage = handler;\n    return () => {\n      port.onmessage = null;\n    };\n  }\n});\n\n// packages/core/mesh/rpc-tunnel/src/port-muxer.ts\nimport { log as log3 } from \"@dxos/log\";\nvar PortMuxer = class {\n  constructor(_messagePort) {\n    this._messagePort = _messagePort;\n    this._activeChannels = /* @__PURE__ */ new Map();\n    this._rpcPorts = /* @__PURE__ */ new Map();\n    if (this._messagePort) {\n      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);\n    }\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"message\", (event) => this.onWindowMessage(event));\n    }\n  }\n  createWorkerPort(options) {\n    if (!this._messagePort) {\n      throw new Error(\"Message port is required to create worker ports\");\n    }\n    const port = createWorkerPort({\n      ...options,\n      port: this._messagePort,\n      subscribe: (callback) => {\n        this._activeChannels.set(options.channel, callback);\n        return () => this._activeChannels.delete(options.channel);\n      }\n    });\n    this._rpcPorts.set(options.channel, port);\n    return port;\n  }\n  createIFramePort(options) {\n    const port = createIFramePort(options);\n    this._rpcPorts.set(options.channel, port);\n    return port;\n  }\n  onWorkerMessage(event) {\n    const message = event.data;\n    log3.debug(\"Recieved message from worker port\", {\n      channel: message.channel,\n      payload: message.payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts\",\n      line: 59,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const callback = this._activeChannels.get(message.channel);\n    callback == null ? void 0 : callback(new Uint8Array(message.payload));\n  }\n  onWindowMessage(event) {\n    const message = event.data;\n    log3.debug(\"Recieved message from window\", {\n      channel: message.channel,\n      payload: message.payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts\",\n      line: 70,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\nexport {\n  PortMuxer,\n  createIFrame,\n  createIFramePort,\n  createWorkerPort\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465465665,"end":1670465466246},{"name":"vite:react-babel","result":"// packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\nimport { log } from \"@dxos/log\";\nvar sendToIFrame = (iframe, origin, message) => {\n  if (!iframe.contentWindow) {\n    log(\"IFrame content window missing\", {\n      origin\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n      line: 12,\n      scope: void 0,\n      callSite: (f, a) => f(...a)\n    });\n    return;\n  }\n  iframe.contentWindow.postMessage(message, \"*\", [\n    message.payload\n  ]);\n};\nvar sendToParentWindow = (origin, message) => {\n  window.parent.postMessage(message, origin, [\n    message.payload\n  ]);\n};\nvar createIFramePort = ({ channel, iframe, origin, onOrigin }) => {\n  return {\n    send: async (data) => {\n      if (!origin) {\n        log.warn(\"no origin set\", {\n          channel\n        }, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n          line: 43,\n          scope: void 0,\n          callSite: (f, a) => f(...a)\n        });\n        return;\n      }\n      log(\"sending\", {\n        channel,\n        data: data.length\n      }, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n        line: 47,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      const payload = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n      const message = {\n        channel,\n        payload\n      };\n      if (iframe) {\n        sendToIFrame(iframe, origin, message);\n      } else {\n        sendToParentWindow(origin, message);\n      }\n    },\n    subscribe: (callback) => {\n      const handler = (event) => {\n        if (!iframe && event.source !== window.parent) {\n          return;\n        } else if (iframe && event.source !== iframe.contentWindow) {\n          return;\n        }\n        const isMessageData = event.data && typeof event.data === \"object\" && \"channel\" in event.data && \"payload\" in event.data;\n        const message = isMessageData ? event.data : void 0;\n        if ((message == null ? void 0 : message.channel) !== channel) {\n          return;\n        }\n        if (!origin) {\n          origin = event.origin;\n          onOrigin == null ? void 0 : onOrigin(origin);\n        }\n        log(\"received\", message, {\n          file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/iframe.ts\",\n          line: 79,\n          scope: void 0,\n          callSite: (f, a) => f(...a)\n        });\n        callback(new Uint8Array(message.payload));\n      };\n      window.addEventListener(\"message\", handler);\n      return () => window.removeEventListener(\"message\", handler);\n    }\n  };\n};\nvar createIFrame = (source, id) => {\n  var _a;\n  const create = () => {\n    const iframe = document.createElement(\"iframe\");\n    iframe.id = id;\n    iframe.src = source;\n    iframe.setAttribute(\"style\", \"display: none;\");\n    document.body.appendChild(iframe);\n    return iframe;\n  };\n  {\n    const cssStyle = \"color:#C026D3;font-weight:bold\";\n    console.log(`%cDXOS Client is communicating with the shared worker on ${source}.\nInspect the worker using: chrome://inspect/#workers (URL must be copied manually).`, cssStyle);\n    console.log(`%cTo inspect this application, click here:\nhttps://devtools.dxos.org/?target=vault:${source}`, cssStyle);\n  }\n  return (_a = document.getElementById(id)) != null ? _a : create();\n};\n\n// packages/core/mesh/rpc-tunnel/src/ports/worker.ts\nimport { log as log2 } from \"@dxos/log\";\nvar createWorkerPort = ({ port, channel, subscribe }) => ({\n  send: async (message) => {\n    const payload = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);\n    port.postMessage({\n      channel,\n      payload\n    }, [\n      payload\n    ]);\n  },\n  subscribe: subscribe != null ? subscribe : (callback) => {\n    const handler = (event) => {\n      const message = event.data;\n      if (message.channel !== channel) {\n        return;\n      }\n      log2.debug(\"Recieved message\", message, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/ports/worker.ts\",\n        line: 45,\n        scope: void 0,\n        callSite: (f, a) => f(...a)\n      });\n      callback(new Uint8Array(message.payload));\n    };\n    port.onmessage = handler;\n    return () => {\n      port.onmessage = null;\n    };\n  }\n});\n\n// packages/core/mesh/rpc-tunnel/src/port-muxer.ts\nimport { log as log3 } from \"@dxos/log\";\nvar PortMuxer = class {\n  constructor(_messagePort) {\n    this._messagePort = _messagePort;\n    this._activeChannels = /* @__PURE__ */ new Map();\n    this._rpcPorts = /* @__PURE__ */ new Map();\n    if (this._messagePort) {\n      this._messagePort.onmessage = (event) => this.onWorkerMessage(event);\n    }\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"message\", (event) => this.onWindowMessage(event));\n    }\n  }\n  createWorkerPort(options) {\n    if (!this._messagePort) {\n      throw new Error(\"Message port is required to create worker ports\");\n    }\n    const port = createWorkerPort({\n      ...options,\n      port: this._messagePort,\n      subscribe: (callback) => {\n        this._activeChannels.set(options.channel, callback);\n        return () => this._activeChannels.delete(options.channel);\n      }\n    });\n    this._rpcPorts.set(options.channel, port);\n    return port;\n  }\n  createIFramePort(options) {\n    const port = createIFramePort(options);\n    this._rpcPorts.set(options.channel, port);\n    return port;\n  }\n  onWorkerMessage(event) {\n    const message = event.data;\n    log3.debug(\"Recieved message from worker port\", {\n      channel: message.channel,\n      payload: message.payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts\",\n      line: 59,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n    const callback = this._activeChannels.get(message.channel);\n    callback == null ? void 0 : callback(new Uint8Array(message.payload));\n  }\n  onWindowMessage(event) {\n    const message = event.data;\n    log3.debug(\"Recieved message from window\", {\n      channel: message.channel,\n      payload: message.payload\n    }, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/core/mesh/rpc-tunnel/src/port-muxer.ts\",\n      line: 70,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    });\n  }\n};\nexport {\n  PortMuxer,\n  createIFrame,\n  createIFramePort,\n  createWorkerPort\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466246,"end":1670465466246,"order":"pre"}]}
