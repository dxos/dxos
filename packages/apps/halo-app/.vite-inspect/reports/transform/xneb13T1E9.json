{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/abstract-extension@3.1.1/node_modules/abstract-extension/index.js","transforms":[{"name":"vite:load-fallback","result":"const codecs = require('codecs')\n\nclass AbstractExtension {\n  constructor (local, name, handlers = {}) {\n    this.id = 0\n    this.name = name\n    this.encoding = codecs(handlers.encoding || 'binary')\n    this.handlers = handlers\n    this.local = local\n  }\n\n  encode (message) {\n    return this.encoding.encode(message)\n  }\n\n  remoteSupports () {\n    return !!(this.local && this.local.map && this.local.map[this.id] === this)\n  }\n\n  onmessage (buf, context) {\n    if (!this.handlers.onmessage) return\n\n    let message\n    try {\n      message = this.encoding.decode(buf)\n    } catch (err) {\n      if (this.handlers.onerror) this.handlers.onerror(err, context)\n      return\n    }\n\n    this.handlers.onmessage(message, context)\n  }\n\n  get destroyed () {\n    return this.local === null\n  }\n\n  destroy () {\n    if (this.local === null) return\n    this.local._remove(this)\n    this.local = null\n  }\n\n  static createLocal (handlers = null) {\n    return new Local(handlers, this)\n  }\n}\n\nclass Remote {\n  constructor (local) {\n    this.local = local\n    this.names = null\n    this.map = null\n    this.changes = 0\n  }\n\n  update (names) {\n    this.names = names\n    this.changes = 0\n  }\n\n  onmessage (id, message, context = null) {\n    if (this.changes !== this.local.changes) {\n      this.map = this.names ? match(this.local.messages, this.names) : null\n      this.changes = this.local.changes\n    }\n    const m = this.map && this.map[id]\n    if (m) m.onmessage(message, context)\n  }\n}\n\nclass Local {\n  constructor (handlers = null, M) {\n    this.messages = []\n    this.handlers = handlers\n    this.Extension = M\n    this.changes = 1\n    this.exclusive = true\n  }\n\n  get length () {\n    return this.messages.length\n  }\n\n  [Symbol.iterator] () {\n    return this.messages[Symbol.iterator]()\n  }\n\n  get (name) {\n    // technically we can bisect here, but yolo\n    for (const m of this.messages) {\n      if (m.name === name) return m\n    }\n    return null\n  }\n\n  add (name, handlers) {\n    let m\n\n    if (typeof handlers !== 'function') {\n      m = new this.Extension(this, name, handlers)\n    } else {\n      m = new this.Extension(this, name, {})\n      m.handlers = handlers(m) || {}\n      m.encoding = codecs(m.handlers.encoding || 'binary')\n    }\n\n    this.changes++\n    this.messages.push(m)\n    this.messages.sort(sortMessages)\n    for (let i = 0; i < this.messages.length; i++) {\n      this.messages[i].id = i\n    }\n\n    if (this.exclusive) {\n      if ((m.id > 0 && this.messages[m.id - 1].name === m.name) || (m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name)) {\n        this._remove(m)\n        throw new Error('Cannot add multiple messages with the same name')\n      }\n    }\n\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n\n    return m\n  }\n\n  remote () {\n    return new Remote(this)\n  }\n\n  _remove (m) {\n    this.changes++\n    this.messages.splice(m.id, 1)\n    m.id = -1\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n  }\n\n  names () {\n    const names = new Array(this.messages.length)\n    for (let i = 0; i < names.length; i++) {\n      names[i] = this.messages[i].name\n    }\n    return names\n  }\n}\n\nfunction sortMessages (a, b) {\n  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0\n}\n\nfunction match (local, remote) {\n  let i = 0\n  let j = 0\n\n  const map = new Array(remote.length)\n\n  while (i < local.length && j < remote.length) {\n    const l = local[i].name\n    const r = remote[j]\n\n    if (l < r) i++\n    else if (l > r) j++\n    else map[j++] = local[i]\n  }\n\n  return map\n}\n\nmodule.exports = AbstractExtension\n","start":1670465469223,"end":1670465469322},{"name":"vite:react-babel","result":"const codecs = require('codecs')\n\nclass AbstractExtension {\n  constructor (local, name, handlers = {}) {\n    this.id = 0\n    this.name = name\n    this.encoding = codecs(handlers.encoding || 'binary')\n    this.handlers = handlers\n    this.local = local\n  }\n\n  encode (message) {\n    return this.encoding.encode(message)\n  }\n\n  remoteSupports () {\n    return !!(this.local && this.local.map && this.local.map[this.id] === this)\n  }\n\n  onmessage (buf, context) {\n    if (!this.handlers.onmessage) return\n\n    let message\n    try {\n      message = this.encoding.decode(buf)\n    } catch (err) {\n      if (this.handlers.onerror) this.handlers.onerror(err, context)\n      return\n    }\n\n    this.handlers.onmessage(message, context)\n  }\n\n  get destroyed () {\n    return this.local === null\n  }\n\n  destroy () {\n    if (this.local === null) return\n    this.local._remove(this)\n    this.local = null\n  }\n\n  static createLocal (handlers = null) {\n    return new Local(handlers, this)\n  }\n}\n\nclass Remote {\n  constructor (local) {\n    this.local = local\n    this.names = null\n    this.map = null\n    this.changes = 0\n  }\n\n  update (names) {\n    this.names = names\n    this.changes = 0\n  }\n\n  onmessage (id, message, context = null) {\n    if (this.changes !== this.local.changes) {\n      this.map = this.names ? match(this.local.messages, this.names) : null\n      this.changes = this.local.changes\n    }\n    const m = this.map && this.map[id]\n    if (m) m.onmessage(message, context)\n  }\n}\n\nclass Local {\n  constructor (handlers = null, M) {\n    this.messages = []\n    this.handlers = handlers\n    this.Extension = M\n    this.changes = 1\n    this.exclusive = true\n  }\n\n  get length () {\n    return this.messages.length\n  }\n\n  [Symbol.iterator] () {\n    return this.messages[Symbol.iterator]()\n  }\n\n  get (name) {\n    // technically we can bisect here, but yolo\n    for (const m of this.messages) {\n      if (m.name === name) return m\n    }\n    return null\n  }\n\n  add (name, handlers) {\n    let m\n\n    if (typeof handlers !== 'function') {\n      m = new this.Extension(this, name, handlers)\n    } else {\n      m = new this.Extension(this, name, {})\n      m.handlers = handlers(m) || {}\n      m.encoding = codecs(m.handlers.encoding || 'binary')\n    }\n\n    this.changes++\n    this.messages.push(m)\n    this.messages.sort(sortMessages)\n    for (let i = 0; i < this.messages.length; i++) {\n      this.messages[i].id = i\n    }\n\n    if (this.exclusive) {\n      if ((m.id > 0 && this.messages[m.id - 1].name === m.name) || (m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name)) {\n        this._remove(m)\n        throw new Error('Cannot add multiple messages with the same name')\n      }\n    }\n\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n\n    return m\n  }\n\n  remote () {\n    return new Remote(this)\n  }\n\n  _remove (m) {\n    this.changes++\n    this.messages.splice(m.id, 1)\n    m.id = -1\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n  }\n\n  names () {\n    const names = new Array(this.messages.length)\n    for (let i = 0; i < names.length; i++) {\n      names[i] = this.messages[i].name\n    }\n    return names\n  }\n}\n\nfunction sortMessages (a, b) {\n  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0\n}\n\nfunction match (local, remote) {\n  let i = 0\n  let j = 0\n\n  const map = new Array(remote.length)\n\n  while (i < local.length && j < remote.length) {\n    const l = local[i].name\n    const r = remote[j]\n\n    if (l < r) i++\n    else if (l > r) j++\n    else map[j++] = local[i]\n  }\n\n  return map\n}\n\nmodule.exports = AbstractExtension\n","start":1670465469322,"end":1670465469322,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/codecs@2.2.0/node_modules/codecs/index.js?commonjs-proxy\";\n\nconst codecs = require$$0\n\nclass AbstractExtension {\n  constructor (local, name, handlers = {}) {\n    this.id = 0\n    this.name = name\n    this.encoding = codecs(handlers.encoding || 'binary')\n    this.handlers = handlers\n    this.local = local\n  }\n\n  encode (message) {\n    return this.encoding.encode(message)\n  }\n\n  remoteSupports () {\n    return !!(this.local && this.local.map && this.local.map[this.id] === this)\n  }\n\n  onmessage (buf, context) {\n    if (!this.handlers.onmessage) return\n\n    let message\n    try {\n      message = this.encoding.decode(buf)\n    } catch (err) {\n      if (this.handlers.onerror) this.handlers.onerror(err, context)\n      return\n    }\n\n    this.handlers.onmessage(message, context)\n  }\n\n  get destroyed () {\n    return this.local === null\n  }\n\n  destroy () {\n    if (this.local === null) return\n    this.local._remove(this)\n    this.local = null\n  }\n\n  static createLocal (handlers = null) {\n    return new Local(handlers, this)\n  }\n}\n\nclass Remote {\n  constructor (local) {\n    this.local = local\n    this.names = null\n    this.map = null\n    this.changes = 0\n  }\n\n  update (names) {\n    this.names = names\n    this.changes = 0\n  }\n\n  onmessage (id, message, context = null) {\n    if (this.changes !== this.local.changes) {\n      this.map = this.names ? match(this.local.messages, this.names) : null\n      this.changes = this.local.changes\n    }\n    const m = this.map && this.map[id]\n    if (m) m.onmessage(message, context)\n  }\n}\n\nclass Local {\n  constructor (handlers = null, M) {\n    this.messages = []\n    this.handlers = handlers\n    this.Extension = M\n    this.changes = 1\n    this.exclusive = true\n  }\n\n  get length () {\n    return this.messages.length\n  }\n\n  [Symbol.iterator] () {\n    return this.messages[Symbol.iterator]()\n  }\n\n  get (name) {\n    // technically we can bisect here, but yolo\n    for (const m of this.messages) {\n      if (m.name === name) return m\n    }\n    return null\n  }\n\n  add (name, handlers) {\n    let m\n\n    if (typeof handlers !== 'function') {\n      m = new this.Extension(this, name, handlers)\n    } else {\n      m = new this.Extension(this, name, {})\n      m.handlers = handlers(m) || {}\n      m.encoding = codecs(m.handlers.encoding || 'binary')\n    }\n\n    this.changes++\n    this.messages.push(m)\n    this.messages.sort(sortMessages)\n    for (let i = 0; i < this.messages.length; i++) {\n      this.messages[i].id = i\n    }\n\n    if (this.exclusive) {\n      if ((m.id > 0 && this.messages[m.id - 1].name === m.name) || (m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name)) {\n        this._remove(m)\n        throw new Error('Cannot add multiple messages with the same name')\n      }\n    }\n\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n\n    return m\n  }\n\n  remote () {\n    return new Remote(this)\n  }\n\n  _remove (m) {\n    this.changes++\n    this.messages.splice(m.id, 1)\n    m.id = -1\n    if (this.handlers && this.handlers.onextensionupdate) this.handlers.onextensionupdate()\n  }\n\n  names () {\n    const names = new Array(this.messages.length)\n    for (let i = 0; i < names.length; i++) {\n      names[i] = this.messages[i].name\n    }\n    return names\n  }\n}\n\nfunction sortMessages (a, b) {\n  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0\n}\n\nfunction match (local, remote) {\n  let i = 0\n  let j = 0\n\n  const map = new Array(remote.length)\n\n  while (i < local.length && j < remote.length) {\n    const l = local[i].name\n    const r = remote[j]\n\n    if (l < r) i++\n    else if (l > r) j++\n    else map[j++] = local[i]\n  }\n\n  return map\n}\n\nvar abstractExtension = AbstractExtension\n\nexport default abstractExtension;\nexport { abstractExtension as __moduleExports };","start":1670465469326,"end":1670465469349,"order":"normal"}]}
