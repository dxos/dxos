{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && process.env.NODE_ENV === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports.default = defaultContext.update;\n// @ts-ignore\nexports.default.default = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n","start":1670465465256,"end":1670465465977},{"name":"vite:react-babel","result":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && process.env.NODE_ENV === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports.default = defaultContext.update;\n// @ts-ignore\nexports.default.default = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n","start":1670465465977,"end":1670465465977,"order":"pre"},{"name":"vite:define","result":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && \"production\" === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports.default = defaultContext.update;\n// @ts-ignore\nexports.default.default = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n","start":1670465465977,"end":1670465465979,"order":"normal"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as immutabilityHelperModule, exports as immutabilityHelper } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js?commonjs-module\"\n\n(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tfunction stringifiable(obj) {\n\t    // Safely stringify Object.create(null)\n\t    /* istanbul ignore next */\n\t    return typeof obj === 'object' && !('toString' in obj) ?\n\t        Object.prototype.toString.call(obj).slice(8, -1) :\n\t        obj;\n\t}\n\tvar isProduction = typeof process === 'object' && \"production\" === 'production';\n\tfunction invariant(condition, message) {\n\t    if (!condition) {\n\t        /* istanbul ignore next */\n\t        if (isProduction) {\n\t            throw new Error('Invariant failed');\n\t        }\n\t        throw new Error(message());\n\t    }\n\t}\n\texports.invariant = invariant;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar splice = Array.prototype.splice;\n\tvar toString = Object.prototype.toString;\n\tfunction type(obj) {\n\t    return toString.call(obj).slice(8, -1);\n\t}\n\tvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n\t    getAllKeys(source).forEach(function (key) {\n\t        if (hasOwnProperty.call(source, key)) {\n\t            target[key] = source[key];\n\t        }\n\t    });\n\t    return target;\n\t});\n\tvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n\t    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n\t    /* istanbul ignore next */\n\t    : function (obj) { return Object.keys(obj); };\n\tfunction copy(object) {\n\t    return Array.isArray(object)\n\t        ? assign(object.constructor(object.length), object)\n\t        : (type(object) === 'Map')\n\t            ? new Map(object)\n\t            : (type(object) === 'Set')\n\t                ? new Set(object)\n\t                : (object && typeof object === 'object')\n\t                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n\t                    /* istanbul ignore next */\n\t                    : object;\n\t}\n\tvar Context = /** @class */ (function () {\n\t    function Context() {\n\t        this.commands = assign({}, defaultCommands);\n\t        this.update = this.update.bind(this);\n\t        // Deprecated: update.extend, update.isEquals and update.newContext\n\t        this.update.extend = this.extend = this.extend.bind(this);\n\t        this.update.isEquals = function (x, y) { return x === y; };\n\t        this.update.newContext = function () { return new Context().update; };\n\t    }\n\t    Object.defineProperty(Context.prototype, \"isEquals\", {\n\t        get: function () {\n\t            return this.update.isEquals;\n\t        },\n\t        set: function (value) {\n\t            this.update.isEquals = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Context.prototype.extend = function (directive, fn) {\n\t        this.commands[directive] = fn;\n\t    };\n\t    Context.prototype.update = function (object, $spec) {\n\t        var _this = this;\n\t        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n\t        if (!(Array.isArray(object) && Array.isArray(spec))) {\n\t            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n\t                \"not contain an array except as the value of $set, $push, $unshift, \" +\n\t                \"$splice or any custom command allowing an array value.\"; });\n\t        }\n\t        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n\t            \"every included key path must be plain objects containing one of the \" +\n\t            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n\t        var nextObject = object;\n\t        getAllKeys(spec).forEach(function (key) {\n\t            if (hasOwnProperty.call(_this.commands, key)) {\n\t                var objectWasNextObject = object === nextObject;\n\t                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n\t                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n\t                    nextObject = object;\n\t                }\n\t            }\n\t            else {\n\t                var nextValueForKey = type(object) === 'Map'\n\t                    ? _this.update(object.get(key), spec[key])\n\t                    : _this.update(object[key], spec[key]);\n\t                var nextObjectValue = type(nextObject) === 'Map'\n\t                    ? nextObject.get(key)\n\t                    : nextObject[key];\n\t                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n\t                    || typeof nextValueForKey === 'undefined'\n\t                        && !hasOwnProperty.call(object, key)) {\n\t                    if (nextObject === object) {\n\t                        nextObject = copy(object);\n\t                    }\n\t                    if (type(nextObject) === 'Map') {\n\t                        nextObject.set(key, nextValueForKey);\n\t                    }\n\t                    else {\n\t                        nextObject[key] = nextValueForKey;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        return nextObject;\n\t    };\n\t    return Context;\n\t}());\n\texports.Context = Context;\n\tvar defaultCommands = {\n\t    $push: function (value, nextObject, spec) {\n\t        invariantPushAndUnshift(nextObject, spec, '$push');\n\t        return value.length ? nextObject.concat(value) : nextObject;\n\t    },\n\t    $unshift: function (value, nextObject, spec) {\n\t        invariantPushAndUnshift(nextObject, spec, '$unshift');\n\t        return value.length ? value.concat(nextObject) : nextObject;\n\t    },\n\t    $splice: function (value, nextObject, spec, originalObject) {\n\t        invariantSplices(nextObject, spec);\n\t        value.forEach(function (args) {\n\t            invariantSplice(args);\n\t            if (nextObject === originalObject && args.length) {\n\t                nextObject = copy(originalObject);\n\t            }\n\t            splice.apply(nextObject, args);\n\t        });\n\t        return nextObject;\n\t    },\n\t    $set: function (value, _nextObject, spec) {\n\t        invariantSet(spec);\n\t        return value;\n\t    },\n\t    $toggle: function (targets, nextObject) {\n\t        invariantSpecArray(targets, '$toggle');\n\t        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n\t        targets.forEach(function (target) {\n\t            nextObjectCopy[target] = !nextObject[target];\n\t        });\n\t        return nextObjectCopy;\n\t    },\n\t    $unset: function (value, nextObject, _spec, originalObject) {\n\t        invariantSpecArray(value, '$unset');\n\t        value.forEach(function (key) {\n\t            if (Object.hasOwnProperty.call(nextObject, key)) {\n\t                if (nextObject === originalObject) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                delete nextObject[key];\n\t            }\n\t        });\n\t        return nextObject;\n\t    },\n\t    $add: function (values, nextObject, _spec, originalObject) {\n\t        invariantMapOrSet(nextObject, '$add');\n\t        invariantSpecArray(values, '$add');\n\t        if (type(nextObject) === 'Map') {\n\t            values.forEach(function (_a) {\n\t                var key = _a[0], value = _a[1];\n\t                if (nextObject === originalObject && nextObject.get(key) !== value) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject.set(key, value);\n\t            });\n\t        }\n\t        else {\n\t            values.forEach(function (value) {\n\t                if (nextObject === originalObject && !nextObject.has(value)) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject.add(value);\n\t            });\n\t        }\n\t        return nextObject;\n\t    },\n\t    $remove: function (value, nextObject, _spec, originalObject) {\n\t        invariantMapOrSet(nextObject, '$remove');\n\t        invariantSpecArray(value, '$remove');\n\t        value.forEach(function (key) {\n\t            if (nextObject === originalObject && nextObject.has(key)) {\n\t                nextObject = copy(originalObject);\n\t            }\n\t            nextObject.delete(key);\n\t        });\n\t        return nextObject;\n\t    },\n\t    $merge: function (value, nextObject, _spec, originalObject) {\n\t        invariantMerge(nextObject, value);\n\t        getAllKeys(value).forEach(function (key) {\n\t            if (value[key] !== nextObject[key]) {\n\t                if (nextObject === originalObject) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject[key] = value[key];\n\t            }\n\t        });\n\t        return nextObject;\n\t    },\n\t    $apply: function (value, original) {\n\t        invariantApply(value);\n\t        return value(original);\n\t    },\n\t};\n\tvar defaultContext = new Context();\n\texports.isEquals = defaultContext.update.isEquals;\n\texports.extend = defaultContext.extend;\n\texports.default = defaultContext.update;\n\t// @ts-ignore\n\texports.default.default = module.exports = assign(exports.default, exports);\n\t// invariants\n\tfunction invariantPushAndUnshift(value, spec, command) {\n\t    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n\t    invariantSpecArray(spec[command], command);\n\t}\n\tfunction invariantSpecArray(spec, command) {\n\t    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n\t        \"Did you forget to wrap your parameter in an array?\"; });\n\t}\n\tfunction invariantSplices(value, spec) {\n\t    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n\t    invariantSplice(spec.$splice);\n\t}\n\tfunction invariantSplice(value) {\n\t    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n\t        \"Did you forget to wrap your parameters in an array?\"; });\n\t}\n\tfunction invariantApply(fn) {\n\t    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n\t}\n\tfunction invariantSet(spec) {\n\t    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n\t}\n\tfunction invariantMerge(target, specValue) {\n\t    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n\t    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n\t}\n\tfunction invariantMapOrSet(target, command) {\n\t    var typeOfTarget = type(target);\n\t    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n\t}\n} (immutabilityHelperModule, immutabilityHelper));\n\nexport default /*@__PURE__*/commonjsHelpers.getDefaultExportFromCjs(immutabilityHelper);\nexport { immutabilityHelper as __moduleExports };","start":1670465465979,"end":1670465465982,"order":"normal"},{"name":"polyfill-node","result":"import { default as process } from '\u0000polyfill-node.process';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __module as immutabilityHelperModule, exports as immutabilityHelper } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/immutability-helper@3.1.1/node_modules/immutability-helper/index.js?commonjs-module\"\n\n(function (module, exports) {\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tfunction stringifiable(obj) {\n\t    // Safely stringify Object.create(null)\n\t    /* istanbul ignore next */\n\t    return typeof obj === 'object' && !('toString' in obj) ?\n\t        Object.prototype.toString.call(obj).slice(8, -1) :\n\t        obj;\n\t}\n\tvar isProduction = typeof process === 'object' && \"production\" === 'production';\n\tfunction invariant(condition, message) {\n\t    if (!condition) {\n\t        /* istanbul ignore next */\n\t        if (isProduction) {\n\t            throw new Error('Invariant failed');\n\t        }\n\t        throw new Error(message());\n\t    }\n\t}\n\texports.invariant = invariant;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar splice = Array.prototype.splice;\n\tvar toString = Object.prototype.toString;\n\tfunction type(obj) {\n\t    return toString.call(obj).slice(8, -1);\n\t}\n\tvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n\t    getAllKeys(source).forEach(function (key) {\n\t        if (hasOwnProperty.call(source, key)) {\n\t            target[key] = source[key];\n\t        }\n\t    });\n\t    return target;\n\t});\n\tvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n\t    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n\t    /* istanbul ignore next */\n\t    : function (obj) { return Object.keys(obj); };\n\tfunction copy(object) {\n\t    return Array.isArray(object)\n\t        ? assign(object.constructor(object.length), object)\n\t        : (type(object) === 'Map')\n\t            ? new Map(object)\n\t            : (type(object) === 'Set')\n\t                ? new Set(object)\n\t                : (object && typeof object === 'object')\n\t                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n\t                    /* istanbul ignore next */\n\t                    : object;\n\t}\n\tvar Context = /** @class */ (function () {\n\t    function Context() {\n\t        this.commands = assign({}, defaultCommands);\n\t        this.update = this.update.bind(this);\n\t        // Deprecated: update.extend, update.isEquals and update.newContext\n\t        this.update.extend = this.extend = this.extend.bind(this);\n\t        this.update.isEquals = function (x, y) { return x === y; };\n\t        this.update.newContext = function () { return new Context().update; };\n\t    }\n\t    Object.defineProperty(Context.prototype, \"isEquals\", {\n\t        get: function () {\n\t            return this.update.isEquals;\n\t        },\n\t        set: function (value) {\n\t            this.update.isEquals = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Context.prototype.extend = function (directive, fn) {\n\t        this.commands[directive] = fn;\n\t    };\n\t    Context.prototype.update = function (object, $spec) {\n\t        var _this = this;\n\t        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n\t        if (!(Array.isArray(object) && Array.isArray(spec))) {\n\t            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n\t                \"not contain an array except as the value of $set, $push, $unshift, \" +\n\t                \"$splice or any custom command allowing an array value.\"; });\n\t        }\n\t        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n\t            \"every included key path must be plain objects containing one of the \" +\n\t            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n\t        var nextObject = object;\n\t        getAllKeys(spec).forEach(function (key) {\n\t            if (hasOwnProperty.call(_this.commands, key)) {\n\t                var objectWasNextObject = object === nextObject;\n\t                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n\t                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n\t                    nextObject = object;\n\t                }\n\t            }\n\t            else {\n\t                var nextValueForKey = type(object) === 'Map'\n\t                    ? _this.update(object.get(key), spec[key])\n\t                    : _this.update(object[key], spec[key]);\n\t                var nextObjectValue = type(nextObject) === 'Map'\n\t                    ? nextObject.get(key)\n\t                    : nextObject[key];\n\t                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n\t                    || typeof nextValueForKey === 'undefined'\n\t                        && !hasOwnProperty.call(object, key)) {\n\t                    if (nextObject === object) {\n\t                        nextObject = copy(object);\n\t                    }\n\t                    if (type(nextObject) === 'Map') {\n\t                        nextObject.set(key, nextValueForKey);\n\t                    }\n\t                    else {\n\t                        nextObject[key] = nextValueForKey;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        return nextObject;\n\t    };\n\t    return Context;\n\t}());\n\texports.Context = Context;\n\tvar defaultCommands = {\n\t    $push: function (value, nextObject, spec) {\n\t        invariantPushAndUnshift(nextObject, spec, '$push');\n\t        return value.length ? nextObject.concat(value) : nextObject;\n\t    },\n\t    $unshift: function (value, nextObject, spec) {\n\t        invariantPushAndUnshift(nextObject, spec, '$unshift');\n\t        return value.length ? value.concat(nextObject) : nextObject;\n\t    },\n\t    $splice: function (value, nextObject, spec, originalObject) {\n\t        invariantSplices(nextObject, spec);\n\t        value.forEach(function (args) {\n\t            invariantSplice(args);\n\t            if (nextObject === originalObject && args.length) {\n\t                nextObject = copy(originalObject);\n\t            }\n\t            splice.apply(nextObject, args);\n\t        });\n\t        return nextObject;\n\t    },\n\t    $set: function (value, _nextObject, spec) {\n\t        invariantSet(spec);\n\t        return value;\n\t    },\n\t    $toggle: function (targets, nextObject) {\n\t        invariantSpecArray(targets, '$toggle');\n\t        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n\t        targets.forEach(function (target) {\n\t            nextObjectCopy[target] = !nextObject[target];\n\t        });\n\t        return nextObjectCopy;\n\t    },\n\t    $unset: function (value, nextObject, _spec, originalObject) {\n\t        invariantSpecArray(value, '$unset');\n\t        value.forEach(function (key) {\n\t            if (Object.hasOwnProperty.call(nextObject, key)) {\n\t                if (nextObject === originalObject) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                delete nextObject[key];\n\t            }\n\t        });\n\t        return nextObject;\n\t    },\n\t    $add: function (values, nextObject, _spec, originalObject) {\n\t        invariantMapOrSet(nextObject, '$add');\n\t        invariantSpecArray(values, '$add');\n\t        if (type(nextObject) === 'Map') {\n\t            values.forEach(function (_a) {\n\t                var key = _a[0], value = _a[1];\n\t                if (nextObject === originalObject && nextObject.get(key) !== value) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject.set(key, value);\n\t            });\n\t        }\n\t        else {\n\t            values.forEach(function (value) {\n\t                if (nextObject === originalObject && !nextObject.has(value)) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject.add(value);\n\t            });\n\t        }\n\t        return nextObject;\n\t    },\n\t    $remove: function (value, nextObject, _spec, originalObject) {\n\t        invariantMapOrSet(nextObject, '$remove');\n\t        invariantSpecArray(value, '$remove');\n\t        value.forEach(function (key) {\n\t            if (nextObject === originalObject && nextObject.has(key)) {\n\t                nextObject = copy(originalObject);\n\t            }\n\t            nextObject.delete(key);\n\t        });\n\t        return nextObject;\n\t    },\n\t    $merge: function (value, nextObject, _spec, originalObject) {\n\t        invariantMerge(nextObject, value);\n\t        getAllKeys(value).forEach(function (key) {\n\t            if (value[key] !== nextObject[key]) {\n\t                if (nextObject === originalObject) {\n\t                    nextObject = copy(originalObject);\n\t                }\n\t                nextObject[key] = value[key];\n\t            }\n\t        });\n\t        return nextObject;\n\t    },\n\t    $apply: function (value, original) {\n\t        invariantApply(value);\n\t        return value(original);\n\t    },\n\t};\n\tvar defaultContext = new Context();\n\texports.isEquals = defaultContext.update.isEquals;\n\texports.extend = defaultContext.extend;\n\texports.default = defaultContext.update;\n\t// @ts-ignore\n\texports.default.default = module.exports = assign(exports.default, exports);\n\t// invariants\n\tfunction invariantPushAndUnshift(value, spec, command) {\n\t    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n\t    invariantSpecArray(spec[command], command);\n\t}\n\tfunction invariantSpecArray(spec, command) {\n\t    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n\t        \"Did you forget to wrap your parameter in an array?\"; });\n\t}\n\tfunction invariantSplices(value, spec) {\n\t    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n\t    invariantSplice(spec.$splice);\n\t}\n\tfunction invariantSplice(value) {\n\t    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n\t        \"Did you forget to wrap your parameters in an array?\"; });\n\t}\n\tfunction invariantApply(fn) {\n\t    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n\t}\n\tfunction invariantSet(spec) {\n\t    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n\t}\n\tfunction invariantMerge(target, specValue) {\n\t    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n\t    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n\t}\n\tfunction invariantMapOrSet(target, command) {\n\t    var typeOfTarget = type(target);\n\t    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n\t}\n} (immutabilityHelperModule, immutabilityHelper));\n\nexport default /*@__PURE__*/commonjsHelpers.getDefaultExportFromCjs(immutabilityHelper);\nexport { immutabilityHelper as __moduleExports };","start":1670465465983,"end":1670465465990,"order":"normal"}]}
