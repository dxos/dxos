{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/namespace.js","transforms":[{"name":"vite:load-fallback","result":"\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(\"./field\"),\n    OneOf    = require(\"./oneof\"),\n    util     = require(\"./util\");\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","start":1670465470544,"end":1670465470640},{"name":"vite:react-babel","result":"\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(\"./field\"),\n    OneOf    = require(\"./oneof\"),\n    util     = require(\"./util\");\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","start":1670465470640,"end":1670465470640,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __require as require$$0 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/object.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/field.js?commonjs-wrapped\";\nimport { __require as require$$2 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/oneof.js?commonjs-wrapped\";\nimport { __require as require$$3 } from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/protobufjs@6.11.3/node_modules/protobufjs/src/util.js?commonjs-wrapped\";\n\nvar namespace;\nvar hasRequiredNamespace;\n\nfunction requireNamespace () {\n\tif (hasRequiredNamespace) return namespace;\n\thasRequiredNamespace = 1;\n\t\"use strict\";\n\tnamespace = Namespace;\n\n\t// extends ReflectionObject\n\tvar ReflectionObject = require$$0();\n\t((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\n\tvar Field    = require$$1(),\n\t    OneOf    = require$$2(),\n\t    util     = require$$3();\n\n\tvar Type,    // cyclic\n\t    Service,\n\t    Enum;\n\n\t/**\n\t * Constructs a new namespace instance.\n\t * @name Namespace\n\t * @classdesc Reflected namespace.\n\t * @extends NamespaceBase\n\t * @constructor\n\t * @param {string} name Namespace name\n\t * @param {Object.<string,*>} [options] Declared options\n\t */\n\n\t/**\n\t * Constructs a namespace from JSON.\n\t * @memberof Namespace\n\t * @function\n\t * @param {string} name Namespace name\n\t * @param {Object.<string,*>} json JSON object\n\t * @returns {Namespace} Created namespace\n\t * @throws {TypeError} If arguments are invalid\n\t */\n\tNamespace.fromJSON = function fromJSON(name, json) {\n\t    return new Namespace(name, json.options).addJSON(json.nested);\n\t};\n\n\t/**\n\t * Converts an array of reflection objects to JSON.\n\t * @memberof Namespace\n\t * @param {ReflectionObject[]} array Object array\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n\t */\n\tfunction arrayToJSON(array, toJSONOptions) {\n\t    if (!(array && array.length))\n\t        return undefined;\n\t    var obj = {};\n\t    for (var i = 0; i < array.length; ++i)\n\t        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n\t    return obj;\n\t}\n\n\tNamespace.arrayToJSON = arrayToJSON;\n\n\t/**\n\t * Tests if the specified id is reserved.\n\t * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n\t * @param {number} id Id to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tNamespace.isReservedId = function isReservedId(reserved, id) {\n\t    if (reserved)\n\t        for (var i = 0; i < reserved.length; ++i)\n\t            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n\t                return true;\n\t    return false;\n\t};\n\n\t/**\n\t * Tests if the specified name is reserved.\n\t * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n\t * @param {string} name Name to test\n\t * @returns {boolean} `true` if reserved, otherwise `false`\n\t */\n\tNamespace.isReservedName = function isReservedName(reserved, name) {\n\t    if (reserved)\n\t        for (var i = 0; i < reserved.length; ++i)\n\t            if (reserved[i] === name)\n\t                return true;\n\t    return false;\n\t};\n\n\t/**\n\t * Not an actual constructor. Use {@link Namespace} instead.\n\t * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n\t * @exports NamespaceBase\n\t * @extends ReflectionObject\n\t * @abstract\n\t * @constructor\n\t * @param {string} name Namespace name\n\t * @param {Object.<string,*>} [options] Declared options\n\t * @see {@link Namespace}\n\t */\n\tfunction Namespace(name, options) {\n\t    ReflectionObject.call(this, name, options);\n\n\t    /**\n\t     * Nested objects by name.\n\t     * @type {Object.<string,ReflectionObject>|undefined}\n\t     */\n\t    this.nested = undefined; // toJSON\n\n\t    /**\n\t     * Cached nested objects as an array.\n\t     * @type {ReflectionObject[]|null}\n\t     * @private\n\t     */\n\t    this._nestedArray = null;\n\t}\n\n\tfunction clearCache(namespace) {\n\t    namespace._nestedArray = null;\n\t    return namespace;\n\t}\n\n\t/**\n\t * Nested objects of this namespace as an array for iteration.\n\t * @name NamespaceBase#nestedArray\n\t * @type {ReflectionObject[]}\n\t * @readonly\n\t */\n\tObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n\t    get: function() {\n\t        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n\t    }\n\t});\n\n\t/**\n\t * Namespace descriptor.\n\t * @interface INamespace\n\t * @property {Object.<string,*>} [options] Namespace options\n\t * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n\t */\n\n\t/**\n\t * Any extension field descriptor.\n\t * @typedef AnyExtensionField\n\t * @type {IExtensionField|IExtensionMapField}\n\t */\n\n\t/**\n\t * Any nested object descriptor.\n\t * @typedef AnyNestedObject\n\t * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n\t */\n\t// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n\t/**\n\t * Converts this namespace to a namespace descriptor.\n\t * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n\t * @returns {INamespace} Namespace descriptor\n\t */\n\tNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n\t    return util.toObject([\n\t        \"options\" , this.options,\n\t        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n\t    ]);\n\t};\n\n\t/**\n\t * Adds nested objects to this namespace from nested object descriptors.\n\t * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n\t * @returns {Namespace} `this`\n\t */\n\tNamespace.prototype.addJSON = function addJSON(nestedJson) {\n\t    var ns = this;\n\t    /* istanbul ignore else */\n\t    if (nestedJson) {\n\t        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n\t            nested = nestedJson[names[i]];\n\t            ns.add( // most to least likely\n\t                ( nested.fields !== undefined\n\t                ? Type.fromJSON\n\t                : nested.values !== undefined\n\t                ? Enum.fromJSON\n\t                : nested.methods !== undefined\n\t                ? Service.fromJSON\n\t                : nested.id !== undefined\n\t                ? Field.fromJSON\n\t                : Namespace.fromJSON )(names[i], nested)\n\t            );\n\t        }\n\t    }\n\t    return this;\n\t};\n\n\t/**\n\t * Gets the nested object of the specified name.\n\t * @param {string} name Nested object name\n\t * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n\t */\n\tNamespace.prototype.get = function get(name) {\n\t    return this.nested && this.nested[name]\n\t        || null;\n\t};\n\n\t/**\n\t * Gets the values of the nested {@link Enum|enum} of the specified name.\n\t * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n\t * @param {string} name Nested enum name\n\t * @returns {Object.<string,number>} Enum values\n\t * @throws {Error} If there is no such enum\n\t */\n\tNamespace.prototype.getEnum = function getEnum(name) {\n\t    if (this.nested && this.nested[name] instanceof Enum)\n\t        return this.nested[name].values;\n\t    throw Error(\"no such enum: \" + name);\n\t};\n\n\t/**\n\t * Adds a nested object to this namespace.\n\t * @param {ReflectionObject} object Nested object to add\n\t * @returns {Namespace} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If there is already a nested object with this name\n\t */\n\tNamespace.prototype.add = function add(object) {\n\n\t    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))\n\t        throw TypeError(\"object must be a valid nested object\");\n\n\t    if (!this.nested)\n\t        this.nested = {};\n\t    else {\n\t        var prev = this.get(object.name);\n\t        if (prev) {\n\t            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n\t                // replace plain namespace but keep existing nested elements and options\n\t                var nested = prev.nestedArray;\n\t                for (var i = 0; i < nested.length; ++i)\n\t                    object.add(nested[i]);\n\t                this.remove(prev);\n\t                if (!this.nested)\n\t                    this.nested = {};\n\t                object.setOptions(prev.options, true);\n\n\t            } else\n\t                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\t        }\n\t    }\n\t    this.nested[object.name] = object;\n\t    object.onAdd(this);\n\t    return clearCache(this);\n\t};\n\n\t/**\n\t * Removes a nested object from this namespace.\n\t * @param {ReflectionObject} object Nested object to remove\n\t * @returns {Namespace} `this`\n\t * @throws {TypeError} If arguments are invalid\n\t * @throws {Error} If `object` is not a member of this namespace\n\t */\n\tNamespace.prototype.remove = function remove(object) {\n\n\t    if (!(object instanceof ReflectionObject))\n\t        throw TypeError(\"object must be a ReflectionObject\");\n\t    if (object.parent !== this)\n\t        throw Error(object + \" is not a member of \" + this);\n\n\t    delete this.nested[object.name];\n\t    if (!Object.keys(this.nested).length)\n\t        this.nested = undefined;\n\n\t    object.onRemove(this);\n\t    return clearCache(this);\n\t};\n\n\t/**\n\t * Defines additial namespaces within this one if not yet existing.\n\t * @param {string|string[]} path Path to create\n\t * @param {*} [json] Nested types to create from JSON\n\t * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n\t */\n\tNamespace.prototype.define = function define(path, json) {\n\n\t    if (util.isString(path))\n\t        path = path.split(\".\");\n\t    else if (!Array.isArray(path))\n\t        throw TypeError(\"illegal path\");\n\t    if (path && path.length && path[0] === \"\")\n\t        throw Error(\"path must be relative\");\n\n\t    var ptr = this;\n\t    while (path.length > 0) {\n\t        var part = path.shift();\n\t        if (ptr.nested && ptr.nested[part]) {\n\t            ptr = ptr.nested[part];\n\t            if (!(ptr instanceof Namespace))\n\t                throw Error(\"path conflicts with non-namespace objects\");\n\t        } else\n\t            ptr.add(ptr = new Namespace(part));\n\t    }\n\t    if (json)\n\t        ptr.addJSON(json);\n\t    return ptr;\n\t};\n\n\t/**\n\t * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n\t * @returns {Namespace} `this`\n\t */\n\tNamespace.prototype.resolveAll = function resolveAll() {\n\t    var nested = this.nestedArray, i = 0;\n\t    while (i < nested.length)\n\t        if (nested[i] instanceof Namespace)\n\t            nested[i++].resolveAll();\n\t        else\n\t            nested[i++].resolve();\n\t    return this.resolve();\n\t};\n\n\t/**\n\t * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n\t * @param {string|string[]} path Path to look up\n\t * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n\t * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n\t * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n\t */\n\tNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n\t    /* istanbul ignore next */\n\t    if (typeof filterTypes === \"boolean\") {\n\t        parentAlreadyChecked = filterTypes;\n\t        filterTypes = undefined;\n\t    } else if (filterTypes && !Array.isArray(filterTypes))\n\t        filterTypes = [ filterTypes ];\n\n\t    if (util.isString(path) && path.length) {\n\t        if (path === \".\")\n\t            return this.root;\n\t        path = path.split(\".\");\n\t    } else if (!path.length)\n\t        return this;\n\n\t    // Start at root if path is absolute\n\t    if (path[0] === \"\")\n\t        return this.root.lookup(path.slice(1), filterTypes);\n\n\t    // Test if the first part matches any nested object, and if so, traverse if path contains more\n\t    var found = this.get(path[0]);\n\t    if (found) {\n\t        if (path.length === 1) {\n\t            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n\t                return found;\n\t        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n\t            return found;\n\n\t    // Otherwise try each nested namespace\n\t    } else\n\t        for (var i = 0; i < this.nestedArray.length; ++i)\n\t            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n\t                return found;\n\n\t    // If there hasn't been a match, try again at the parent\n\t    if (this.parent === null || parentAlreadyChecked)\n\t        return null;\n\t    return this.parent.lookup(path, filterTypes);\n\t};\n\n\t/**\n\t * Looks up the reflection object at the specified path, relative to this namespace.\n\t * @name NamespaceBase#lookup\n\t * @function\n\t * @param {string|string[]} path Path to look up\n\t * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n\t * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n\t * @variation 2\n\t */\n\t// lookup(path: string, [parentAlreadyChecked: boolean])\n\n\t/**\n\t * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n\t * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n\t * @param {string|string[]} path Path to look up\n\t * @returns {Type} Looked up type\n\t * @throws {Error} If `path` does not point to a type\n\t */\n\tNamespace.prototype.lookupType = function lookupType(path) {\n\t    var found = this.lookup(path, [ Type ]);\n\t    if (!found)\n\t        throw Error(\"no such type: \" + path);\n\t    return found;\n\t};\n\n\t/**\n\t * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n\t * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n\t * @param {string|string[]} path Path to look up\n\t * @returns {Enum} Looked up enum\n\t * @throws {Error} If `path` does not point to an enum\n\t */\n\tNamespace.prototype.lookupEnum = function lookupEnum(path) {\n\t    var found = this.lookup(path, [ Enum ]);\n\t    if (!found)\n\t        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n\t    return found;\n\t};\n\n\t/**\n\t * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n\t * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n\t * @param {string|string[]} path Path to look up\n\t * @returns {Type} Looked up type or enum\n\t * @throws {Error} If `path` does not point to a type or enum\n\t */\n\tNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n\t    var found = this.lookup(path, [ Type, Enum ]);\n\t    if (!found)\n\t        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n\t    return found;\n\t};\n\n\t/**\n\t * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n\t * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n\t * @param {string|string[]} path Path to look up\n\t * @returns {Service} Looked up service\n\t * @throws {Error} If `path` does not point to a service\n\t */\n\tNamespace.prototype.lookupService = function lookupService(path) {\n\t    var found = this.lookup(path, [ Service ]);\n\t    if (!found)\n\t        throw Error(\"no such Service '\" + path + \"' in \" + this);\n\t    return found;\n\t};\n\n\t// Sets up cyclic dependencies (called in index-light)\n\tNamespace._configure = function(Type_, Service_, Enum_) {\n\t    Type    = Type_;\n\t    Service = Service_;\n\t    Enum    = Enum_;\n\t};\n\treturn namespace;\n}\n\nexport { requireNamespace as __require };","start":1670465470641,"end":1670465471393,"order":"normal"}]}
