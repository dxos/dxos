{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/common/random-access-storage/src/common/abstract-storage.ts\nimport { join as join2 } from \"@dxos/node-std/path\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\n\n// packages/common/random-access-storage/src/common/utils.ts\nimport { join } from \"@dxos/node-std/path\";\nvar stringDiff = (first, second) => first.split(second).join(\"\");\nvar getFullPath = (root, path) => join(root, stringDiff(path, root));\n\n// packages/common/random-access-storage/src/common/directory.ts\nvar Directory = class {\n  constructor(type, path, _getFiles, _getOrCreateFile, _delete) {\n    this.type = type;\n    this.path = path;\n    this._getFiles = _getFiles;\n    this._getOrCreateFile = _getOrCreateFile;\n    this._delete = _delete;\n  }\n  toString() {\n    return `Directory(${JSON.stringify({\n      type: this.type,\n      path: this.path\n    })})`;\n  }\n  createDirectory(path) {\n    return new Directory(this.type, getFullPath(this.path, path), this._getFiles, this._getOrCreateFile, this._delete);\n  }\n  getFiles() {\n    return this._getFiles();\n  }\n  getOrCreateFile(filename, opts) {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n  async delete() {\n    await this._delete();\n  }\n};\n\n// packages/common/random-access-storage/src/common/file.ts\nimport pify from \"pify\";\nvar pifyFields = (object, type, fields) => {\n  for (const field of fields) {\n    if (!object[field]) {\n    } else {\n      object[field] = pify(object[field].bind(object));\n    }\n  }\n  return object;\n};\nvar wrapFile = (native, type) => {\n  const file = pifyFields(native, type, [\n    \"write\",\n    \"read\",\n    \"del\",\n    \"stat\",\n    \"close\",\n    \"destroy\",\n    \"truncate\"\n  ]);\n  return Object.assign(file, {\n    type,\n    native\n  });\n};\n\n// packages/common/random-access-storage/src/common/abstract-storage.ts\nvar AbstractStorage = class {\n  constructor(path) {\n    this.path = path;\n    this._files = /* @__PURE__ */ new Map();\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      path: this.path\n    };\n  }\n  get size() {\n    return this._files.size;\n  }\n  createDirectory(sub = \"\") {\n    return new Directory(this.type, getFullPath(this.path, sub), () => this._getFiles(sub), (...args) => this.getOrCreateFile(...args), () => this._delete(sub));\n  }\n  async reset() {\n    try {\n      log.warn(\"Erasing all data...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 59,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._closeFilesInPath(\"\");\n      await this._delete(\"\");\n      await this._destroy();\n      log(\"Erased...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  getOrCreateFile(path, filename, opts) {\n    const fullPath = join2(path, filename);\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n      native = this._openFile(file.native);\n    }\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n  _destroy() {\n    return void 0;\n  }\n  _openFile(file) {\n    return void 0;\n  }\n  _getFileIfExists(filename) {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n  _getFiles(path) {\n    const fullPath = getFullPath(this.path, path);\n    return new Map([\n      ...this._files.entries()\n    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));\n  }\n  async _closeFilesInPath(path) {\n    await Promise.all(Array.from(this._getFiles(path).values()).map((file) => file.close().catch((err) => log.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n      line: 122,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async _delete(path) {\n    await Promise.all(Array.from(this._getFiles(path)).map(([path2, file]) => {\n      return file.destroy().then(() => this._files.delete(path2)).catch((err) => log.error(err.message, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 133,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }));\n  }\n};\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nimport ram from \"random-access-memory\";\n\n// packages/common/random-access-storage/src/common/storage.ts\nvar StorageType;\n(function(StorageType2) {\n  StorageType2[\"RAM\"] = \"ram\";\n  StorageType2[\"IDB\"] = \"idb\";\n  StorageType2[\"CHROME\"] = \"chrome\";\n  StorageType2[\"FIREFOX\"] = \"firefox\";\n  StorageType2[\"NODE\"] = \"node\";\n})(StorageType || (StorageType = {}));\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nvar MemoryStorage = class extends AbstractStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.RAM;\n  }\n  _createFile(path, filename) {\n    return this._patchFile(ram());\n  }\n  _openFile(file) {\n    const newFile = file.clone();\n    newFile.closed = false;\n    return this._patchFile(newFile);\n  }\n  _patchFile(file) {\n    const trueRead = file.read.bind(file);\n    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {\n      if (err) {\n        return cb(err);\n      } else {\n        return cb(err, Buffer.from(data));\n      }\n    });\n    return file;\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nimport raw from \"random-access-web/mutable-file-wrapper\";\n\n// packages/common/random-access-storage/src/browser/browser-storage.ts\nimport { join as join3 } from \"@dxos/node-std/path\";\nvar BrowserStorage = class extends AbstractStorage {\n  constructor(path) {\n    super(path);\n    this._fileStorage = this._createFileStorage(path);\n  }\n  _createFile(path, filename) {\n    const fullPath = join3(path, filename);\n    return this._fileStorage(fullPath);\n  }\n  async _destroy() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(this.path);\n      request.onsuccess = () => {\n        resolve();\n      };\n      request.onupgradeneeded = () => {\n        reject(new Error(\"Upgrade needed.\"));\n      };\n      request.onblocked = () => {\n        reject(new Error(\"Blocked.\"));\n      };\n      request.onerror = (err) => {\n        reject(err);\n      };\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nvar FirefoxStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.FIREFOX;\n  }\n  _createFileStorage(path) {\n    return raw({\n      name: path\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/idb-storage.ts\nimport idb from \"random-access-idb\";\nvar IDbStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.IDB;\n  }\n  _createFileStorage(path) {\n    return idb(path);\n  }\n};\n\n// packages/common/random-access-storage/src/browser/storage.ts\nvar createStorage = ({ type, root = \"\" } = {}) => {\n  if (type === void 0) {\n    return globalThis.IDBMutableFile ? new FirefoxStorage(root) : new IDbStorage(root);\n  }\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n    case StorageType.IDB:\n    case StorageType.CHROME: {\n      return new IDbStorage(root);\n    }\n    case StorageType.FIREFOX: {\n      return new FirefoxStorage(root);\n    }\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\nexport {\n  AbstractStorage,\n  Directory,\n  MemoryStorage,\n  StorageType,\n  createStorage,\n  getFullPath,\n  stringDiff,\n  wrapFile\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465466994,"end":1670465467184},{"name":"vite:react-babel","result":"// packages/common/random-access-storage/src/common/abstract-storage.ts\nimport { join as join2 } from \"@dxos/node-std/path\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\n\n// packages/common/random-access-storage/src/common/utils.ts\nimport { join } from \"@dxos/node-std/path\";\nvar stringDiff = (first, second) => first.split(second).join(\"\");\nvar getFullPath = (root, path) => join(root, stringDiff(path, root));\n\n// packages/common/random-access-storage/src/common/directory.ts\nvar Directory = class {\n  constructor(type, path, _getFiles, _getOrCreateFile, _delete) {\n    this.type = type;\n    this.path = path;\n    this._getFiles = _getFiles;\n    this._getOrCreateFile = _getOrCreateFile;\n    this._delete = _delete;\n  }\n  toString() {\n    return `Directory(${JSON.stringify({\n      type: this.type,\n      path: this.path\n    })})`;\n  }\n  createDirectory(path) {\n    return new Directory(this.type, getFullPath(this.path, path), this._getFiles, this._getOrCreateFile, this._delete);\n  }\n  getFiles() {\n    return this._getFiles();\n  }\n  getOrCreateFile(filename, opts) {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n  async delete() {\n    await this._delete();\n  }\n};\n\n// packages/common/random-access-storage/src/common/file.ts\nimport pify from \"pify\";\nvar pifyFields = (object, type, fields) => {\n  for (const field of fields) {\n    if (!object[field]) {\n    } else {\n      object[field] = pify(object[field].bind(object));\n    }\n  }\n  return object;\n};\nvar wrapFile = (native, type) => {\n  const file = pifyFields(native, type, [\n    \"write\",\n    \"read\",\n    \"del\",\n    \"stat\",\n    \"close\",\n    \"destroy\",\n    \"truncate\"\n  ]);\n  return Object.assign(file, {\n    type,\n    native\n  });\n};\n\n// packages/common/random-access-storage/src/common/abstract-storage.ts\nvar AbstractStorage = class {\n  constructor(path) {\n    this.path = path;\n    this._files = /* @__PURE__ */ new Map();\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      path: this.path\n    };\n  }\n  get size() {\n    return this._files.size;\n  }\n  createDirectory(sub = \"\") {\n    return new Directory(this.type, getFullPath(this.path, sub), () => this._getFiles(sub), (...args) => this.getOrCreateFile(...args), () => this._delete(sub));\n  }\n  async reset() {\n    try {\n      log.warn(\"Erasing all data...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 59,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._closeFilesInPath(\"\");\n      await this._delete(\"\");\n      await this._destroy();\n      log(\"Erased...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  getOrCreateFile(path, filename, opts) {\n    const fullPath = join2(path, filename);\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n      native = this._openFile(file.native);\n    }\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n  _destroy() {\n    return void 0;\n  }\n  _openFile(file) {\n    return void 0;\n  }\n  _getFileIfExists(filename) {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n  _getFiles(path) {\n    const fullPath = getFullPath(this.path, path);\n    return new Map([\n      ...this._files.entries()\n    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));\n  }\n  async _closeFilesInPath(path) {\n    await Promise.all(Array.from(this._getFiles(path).values()).map((file) => file.close().catch((err) => log.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n      line: 122,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async _delete(path) {\n    await Promise.all(Array.from(this._getFiles(path)).map(([path2, file]) => {\n      return file.destroy().then(() => this._files.delete(path2)).catch((err) => log.error(err.message, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 133,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }));\n  }\n};\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nimport ram from \"random-access-memory\";\n\n// packages/common/random-access-storage/src/common/storage.ts\nvar StorageType;\n(function(StorageType2) {\n  StorageType2[\"RAM\"] = \"ram\";\n  StorageType2[\"IDB\"] = \"idb\";\n  StorageType2[\"CHROME\"] = \"chrome\";\n  StorageType2[\"FIREFOX\"] = \"firefox\";\n  StorageType2[\"NODE\"] = \"node\";\n})(StorageType || (StorageType = {}));\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nvar MemoryStorage = class extends AbstractStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.RAM;\n  }\n  _createFile(path, filename) {\n    return this._patchFile(ram());\n  }\n  _openFile(file) {\n    const newFile = file.clone();\n    newFile.closed = false;\n    return this._patchFile(newFile);\n  }\n  _patchFile(file) {\n    const trueRead = file.read.bind(file);\n    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {\n      if (err) {\n        return cb(err);\n      } else {\n        return cb(err, Buffer.from(data));\n      }\n    });\n    return file;\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nimport raw from \"random-access-web/mutable-file-wrapper\";\n\n// packages/common/random-access-storage/src/browser/browser-storage.ts\nimport { join as join3 } from \"@dxos/node-std/path\";\nvar BrowserStorage = class extends AbstractStorage {\n  constructor(path) {\n    super(path);\n    this._fileStorage = this._createFileStorage(path);\n  }\n  _createFile(path, filename) {\n    const fullPath = join3(path, filename);\n    return this._fileStorage(fullPath);\n  }\n  async _destroy() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(this.path);\n      request.onsuccess = () => {\n        resolve();\n      };\n      request.onupgradeneeded = () => {\n        reject(new Error(\"Upgrade needed.\"));\n      };\n      request.onblocked = () => {\n        reject(new Error(\"Blocked.\"));\n      };\n      request.onerror = (err) => {\n        reject(err);\n      };\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nvar FirefoxStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.FIREFOX;\n  }\n  _createFileStorage(path) {\n    return raw({\n      name: path\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/idb-storage.ts\nimport idb from \"random-access-idb\";\nvar IDbStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.IDB;\n  }\n  _createFileStorage(path) {\n    return idb(path);\n  }\n};\n\n// packages/common/random-access-storage/src/browser/storage.ts\nvar createStorage = ({ type, root = \"\" } = {}) => {\n  if (type === void 0) {\n    return globalThis.IDBMutableFile ? new FirefoxStorage(root) : new IDbStorage(root);\n  }\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n    case StorageType.IDB:\n    case StorageType.CHROME: {\n      return new IDbStorage(root);\n    }\n    case StorageType.FIREFOX: {\n      return new FirefoxStorage(root);\n    }\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\nexport {\n  AbstractStorage,\n  Directory,\n  MemoryStorage,\n  StorageType,\n  createStorage,\n  getFullPath,\n  stringDiff,\n  wrapFile\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467184,"end":1670465467185,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/common/random-access-storage/src/common/abstract-storage.ts\nimport { join as join2 } from \"@dxos/node-std/path\";\nimport { inspect } from \"@dxos/node-std/util\";\nimport { inspectObject } from \"@dxos/debug\";\nimport { log } from \"@dxos/log\";\n\n// packages/common/random-access-storage/src/common/utils.ts\nimport { join } from \"@dxos/node-std/path\";\nvar stringDiff = (first, second) => first.split(second).join(\"\");\nvar getFullPath = (root, path) => join(root, stringDiff(path, root));\n\n// packages/common/random-access-storage/src/common/directory.ts\nvar Directory = class {\n  constructor(type, path, _getFiles, _getOrCreateFile, _delete) {\n    this.type = type;\n    this.path = path;\n    this._getFiles = _getFiles;\n    this._getOrCreateFile = _getOrCreateFile;\n    this._delete = _delete;\n  }\n  toString() {\n    return `Directory(${JSON.stringify({\n      type: this.type,\n      path: this.path\n    })})`;\n  }\n  createDirectory(path) {\n    return new Directory(this.type, getFullPath(this.path, path), this._getFiles, this._getOrCreateFile, this._delete);\n  }\n  getFiles() {\n    return this._getFiles();\n  }\n  getOrCreateFile(filename, opts) {\n    return this._getOrCreateFile(this.path, filename, opts);\n  }\n  async delete() {\n    await this._delete();\n  }\n};\n\n// packages/common/random-access-storage/src/common/file.ts\nimport pify from \"pify\";\nvar pifyFields = (object, type, fields) => {\n  for (const field of fields) {\n    if (!object[field]) {\n    } else {\n      object[field] = pify(object[field].bind(object));\n    }\n  }\n  return object;\n};\nvar wrapFile = (native, type) => {\n  const file = pifyFields(native, type, [\n    \"write\",\n    \"read\",\n    \"del\",\n    \"stat\",\n    \"close\",\n    \"destroy\",\n    \"truncate\"\n  ]);\n  return Object.assign(file, {\n    type,\n    native\n  });\n};\n\n// packages/common/random-access-storage/src/common/abstract-storage.ts\nvar AbstractStorage = class {\n  constructor(path) {\n    this.path = path;\n    this._files = /* @__PURE__ */ new Map();\n  }\n  [inspect.custom]() {\n    return inspectObject(this);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      path: this.path\n    };\n  }\n  get size() {\n    return this._files.size;\n  }\n  createDirectory(sub = \"\") {\n    return new Directory(this.type, getFullPath(this.path, sub), () => this._getFiles(sub), (...args) => this.getOrCreateFile(...args), () => this._delete(sub));\n  }\n  async reset() {\n    try {\n      log.warn(\"Erasing all data...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 59,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n      await this._closeFilesInPath(\"\");\n      await this._delete(\"\");\n      await this._destroy();\n      log(\"Erased...\", {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 63,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    } catch (err) {\n      log.catch(err, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 65,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      });\n    }\n  }\n  getOrCreateFile(path, filename, opts) {\n    const fullPath = join2(path, filename);\n    let native;\n    let file = this._getFileIfExists(fullPath);\n    if (file) {\n      if (!file.closed) {\n        return file;\n      }\n      native = this._openFile(file.native);\n    }\n    if (!native) {\n      native = this._createFile(path, filename, opts);\n    }\n    file = wrapFile(native, this.type);\n    this._files.set(fullPath, file);\n    return file;\n  }\n  _destroy() {\n    return void 0;\n  }\n  _openFile(file) {\n    return void 0;\n  }\n  _getFileIfExists(filename) {\n    if (this._files.has(filename)) {\n      const file = this._files.get(filename);\n      if (file && !file.destroyed) {\n        return file;\n      }\n    }\n  }\n  _getFiles(path) {\n    const fullPath = getFullPath(this.path, path);\n    return new Map([\n      ...this._files.entries()\n    ].filter(([path2, file]) => path2.includes(fullPath) && file.destroyed !== true));\n  }\n  async _closeFilesInPath(path) {\n    await Promise.all(Array.from(this._getFiles(path).values()).map((file) => file.close().catch((err) => log.catch(err, {}, {\n      file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n      line: 122,\n      scope: this,\n      callSite: (f, a) => f(...a)\n    }))));\n  }\n  async _delete(path) {\n    await Promise.all(Array.from(this._getFiles(path)).map(([path2, file]) => {\n      return file.destroy().then(() => this._files.delete(path2)).catch((err) => log.error(err.message, {}, {\n        file: \"/home/jdw/Code/dxos/dxos/packages/common/random-access-storage/src/common/abstract-storage.ts\",\n        line: 133,\n        scope: this,\n        callSite: (f, a) => f(...a)\n      }));\n    }));\n  }\n};\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nimport ram from \"random-access-memory\";\n\n// packages/common/random-access-storage/src/common/storage.ts\nvar StorageType;\n(function(StorageType2) {\n  StorageType2[\"RAM\"] = \"ram\";\n  StorageType2[\"IDB\"] = \"idb\";\n  StorageType2[\"CHROME\"] = \"chrome\";\n  StorageType2[\"FIREFOX\"] = \"firefox\";\n  StorageType2[\"NODE\"] = \"node\";\n})(StorageType || (StorageType = {}));\n\n// packages/common/random-access-storage/src/common/memory-storage.ts\nvar MemoryStorage = class extends AbstractStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.RAM;\n  }\n  _createFile(path, filename) {\n    return this._patchFile(ram());\n  }\n  _openFile(file) {\n    const newFile = file.clone();\n    newFile.closed = false;\n    return this._patchFile(newFile);\n  }\n  _patchFile(file) {\n    const trueRead = file.read.bind(file);\n    file.read = (offset, size, cb) => trueRead(offset, size, (err, data) => {\n      if (err) {\n        return cb(err);\n      } else {\n        return cb(err, Buffer.from(data));\n      }\n    });\n    return file;\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nimport raw from \"random-access-web/mutable-file-wrapper\";\n\n// packages/common/random-access-storage/src/browser/browser-storage.ts\nimport { join as join3 } from \"@dxos/node-std/path\";\nvar BrowserStorage = class extends AbstractStorage {\n  constructor(path) {\n    super(path);\n    this._fileStorage = this._createFileStorage(path);\n  }\n  _createFile(path, filename) {\n    const fullPath = join3(path, filename);\n    return this._fileStorage(fullPath);\n  }\n  async _destroy() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(this.path);\n      request.onsuccess = () => {\n        resolve();\n      };\n      request.onupgradeneeded = () => {\n        reject(new Error(\"Upgrade needed.\"));\n      };\n      request.onblocked = () => {\n        reject(new Error(\"Blocked.\"));\n      };\n      request.onerror = (err) => {\n        reject(err);\n      };\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/firefox-storage.ts\nvar FirefoxStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.FIREFOX;\n  }\n  _createFileStorage(path) {\n    return raw({\n      name: path\n    });\n  }\n};\n\n// packages/common/random-access-storage/src/browser/idb-storage.ts\nimport idb from \"random-access-idb\";\nvar IDbStorage = class extends BrowserStorage {\n  constructor() {\n    super(...arguments);\n    this.type = StorageType.IDB;\n  }\n  _createFileStorage(path) {\n    return idb(path);\n  }\n};\n\n// packages/common/random-access-storage/src/browser/storage.ts\nvar createStorage = ({ type, root = \"\" } = {}) => {\n  if (type === void 0) {\n    return globalThis.IDBMutableFile ? new FirefoxStorage(root) : new IDbStorage(root);\n  }\n  switch (type) {\n    case StorageType.RAM: {\n      return new MemoryStorage(root);\n    }\n    case StorageType.IDB:\n    case StorageType.CHROME: {\n      return new IDbStorage(root);\n    }\n    case StorageType.FIREFOX: {\n      return new FirefoxStorage(root);\n    }\n    default: {\n      throw new Error(`Invalid type: ${type}`);\n    }\n  }\n};\nexport {\n  AbstractStorage,\n  Directory,\n  MemoryStorage,\n  StorageType,\n  createStorage,\n  getFullPath,\n  stringDiff,\n  wrapFile\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465467185,"end":1670465467194,"order":"normal"}]}
