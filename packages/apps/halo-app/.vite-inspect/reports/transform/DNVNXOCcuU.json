{"resolvedId":"/home/jdw/Code/dxos/dxos/packages/core/mesh/broadcast/dist/lib/browser/index.mjs","transforms":[{"name":"vite:load-fallback","result":"// packages/core/mesh/broadcast/src/broadcast.ts\nimport debug from \"debug\";\nimport assert from \"@dxos/node-std/assert\";\nimport LRU from \"tiny-lru\";\nimport { Event } from \"@dxos/async\";\nimport { randomBytes } from \"@dxos/crypto\";\nimport { schema } from \"@dxos/protocols\";\ndebug.formatters.h = (v) => v.toString(\"hex\").slice(0, 6);\nvar log = debug(\"broadcast\");\nvar Broadcast = class {\n  constructor(middleware, options = {}) {\n    this._codec = schema.getCodecForType(\"dxos.mesh.broadcast.Packet\");\n    this._isOpen = false;\n    this._peers = [];\n    this.send = new Event();\n    this.sendError = new Event();\n    this.packet = new Event();\n    this.subscribeError = new Event();\n    assert(middleware);\n    assert(middleware.send);\n    assert(middleware.subscribe);\n    const { id = randomBytes(32), maxAge = 10 * 1e3, maxSize = 1e3 } = options;\n    this._id = id;\n    this._send = middleware.send;\n    this._subscribe = middleware.subscribe;\n    this._seenSeqs = LRU(maxSize, maxAge);\n    if (middleware.lookup) {\n      this._lookup = () => middleware.lookup();\n    }\n  }\n  async publish(data, options = {}) {\n    const { seq = randomBytes(32) } = options;\n    assert(Buffer.isBuffer(data));\n    assert(Buffer.isBuffer(seq));\n    return this._publish({\n      seq,\n      origin: this._id,\n      data\n    });\n  }\n  updatePeers(peers) {\n    assert(peers.every((peer) => Buffer.isBuffer(peer.id)), \"Peer ID is expected to be a buffer.\");\n    this._peers = peers;\n  }\n  updateCache(opts = {}) {\n    if (opts.maxAge) {\n      this._seenSeqs.ttl = opts.maxAge;\n    }\n    if (opts.maxSize) {\n      this._seenSeqs.max = opts.maxSize;\n    }\n  }\n  pruneCache() {\n    const time = Date.now();\n    for (const item of Object.values(this._seenSeqs.items)) {\n      if (this._seenSeqs.ttl > 0 && item.expiry <= time) {\n        this._seenSeqs.delete(item.key);\n      }\n    }\n  }\n  open() {\n    if (this._isOpen) {\n      return;\n    }\n    this._isOpen = true;\n    this._unsubscribe = this._subscribe(this._onPacket.bind(this), this.updatePeers.bind(this)) || (() => {\n    });\n    log(\"running %h\", this._id);\n  }\n  close() {\n    var _a;\n    if (!this._isOpen) {\n      return;\n    }\n    this._isOpen = false;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    this._seenSeqs.clear();\n    log(\"stop %h\", this._id);\n  }\n  async _publish(packet, options = {}) {\n    this._lookup && this.updatePeers(await this._lookup());\n    const peers = this._peers.filter((peer) => !Buffer.from(packet.origin).equals(peer.id) && (!packet.from || !Buffer.from(packet.from).equals(peer.id)));\n    if (peers.length === 0) {\n      return;\n    }\n    packet = Object.assign({}, packet, {\n      from: this._id\n    });\n    const packetEncoded = this._codec.encode(packet);\n    await Promise.all(peers.map((peer) => {\n      log(\"publish %h -> %h\", this._id, peer.id, packet);\n      return this._send(packetEncoded, peer, options).then(() => {\n        this.send.emit([\n          packetEncoded,\n          peer\n        ]);\n      }).catch((err) => {\n        this.sendError.emit(err);\n      });\n    }));\n    return packet;\n  }\n  _onPacket(packetEncoded) {\n    if (!this._isOpen) {\n      return;\n    }\n    try {\n      const packet = this._codec.decode(packetEncoded);\n      if (!packet || !packet.seq || !packet.origin || !packet.from) {\n        return;\n      }\n      if (Buffer.from(packet.origin).equals(this._id)) {\n        return;\n      }\n      const packetId = Buffer.from(packet.origin).toString(\"hex\") + \":\" + Buffer.from(packet.seq).toString(\"hex\");\n      if (this._seenSeqs.get(packetId)) {\n        return;\n      }\n      this._seenSeqs.set(packetId, 1);\n      log(\"received %h -> %h\", this._id, packet.from, packet);\n      this._publish(packet).catch(() => {\n      });\n      this.packet.emit(packet);\n      return packet;\n    } catch (err) {\n      this.subscribeError.emit(err);\n    }\n  }\n};\nexport {\n  Broadcast\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465468224,"end":1670465468292},{"name":"vite:react-babel","result":"// packages/core/mesh/broadcast/src/broadcast.ts\nimport debug from \"debug\";\nimport assert from \"@dxos/node-std/assert\";\nimport LRU from \"tiny-lru\";\nimport { Event } from \"@dxos/async\";\nimport { randomBytes } from \"@dxos/crypto\";\nimport { schema } from \"@dxos/protocols\";\ndebug.formatters.h = (v) => v.toString(\"hex\").slice(0, 6);\nvar log = debug(\"broadcast\");\nvar Broadcast = class {\n  constructor(middleware, options = {}) {\n    this._codec = schema.getCodecForType(\"dxos.mesh.broadcast.Packet\");\n    this._isOpen = false;\n    this._peers = [];\n    this.send = new Event();\n    this.sendError = new Event();\n    this.packet = new Event();\n    this.subscribeError = new Event();\n    assert(middleware);\n    assert(middleware.send);\n    assert(middleware.subscribe);\n    const { id = randomBytes(32), maxAge = 10 * 1e3, maxSize = 1e3 } = options;\n    this._id = id;\n    this._send = middleware.send;\n    this._subscribe = middleware.subscribe;\n    this._seenSeqs = LRU(maxSize, maxAge);\n    if (middleware.lookup) {\n      this._lookup = () => middleware.lookup();\n    }\n  }\n  async publish(data, options = {}) {\n    const { seq = randomBytes(32) } = options;\n    assert(Buffer.isBuffer(data));\n    assert(Buffer.isBuffer(seq));\n    return this._publish({\n      seq,\n      origin: this._id,\n      data\n    });\n  }\n  updatePeers(peers) {\n    assert(peers.every((peer) => Buffer.isBuffer(peer.id)), \"Peer ID is expected to be a buffer.\");\n    this._peers = peers;\n  }\n  updateCache(opts = {}) {\n    if (opts.maxAge) {\n      this._seenSeqs.ttl = opts.maxAge;\n    }\n    if (opts.maxSize) {\n      this._seenSeqs.max = opts.maxSize;\n    }\n  }\n  pruneCache() {\n    const time = Date.now();\n    for (const item of Object.values(this._seenSeqs.items)) {\n      if (this._seenSeqs.ttl > 0 && item.expiry <= time) {\n        this._seenSeqs.delete(item.key);\n      }\n    }\n  }\n  open() {\n    if (this._isOpen) {\n      return;\n    }\n    this._isOpen = true;\n    this._unsubscribe = this._subscribe(this._onPacket.bind(this), this.updatePeers.bind(this)) || (() => {\n    });\n    log(\"running %h\", this._id);\n  }\n  close() {\n    var _a;\n    if (!this._isOpen) {\n      return;\n    }\n    this._isOpen = false;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    this._seenSeqs.clear();\n    log(\"stop %h\", this._id);\n  }\n  async _publish(packet, options = {}) {\n    this._lookup && this.updatePeers(await this._lookup());\n    const peers = this._peers.filter((peer) => !Buffer.from(packet.origin).equals(peer.id) && (!packet.from || !Buffer.from(packet.from).equals(peer.id)));\n    if (peers.length === 0) {\n      return;\n    }\n    packet = Object.assign({}, packet, {\n      from: this._id\n    });\n    const packetEncoded = this._codec.encode(packet);\n    await Promise.all(peers.map((peer) => {\n      log(\"publish %h -> %h\", this._id, peer.id, packet);\n      return this._send(packetEncoded, peer, options).then(() => {\n        this.send.emit([\n          packetEncoded,\n          peer\n        ]);\n      }).catch((err) => {\n        this.sendError.emit(err);\n      });\n    }));\n    return packet;\n  }\n  _onPacket(packetEncoded) {\n    if (!this._isOpen) {\n      return;\n    }\n    try {\n      const packet = this._codec.decode(packetEncoded);\n      if (!packet || !packet.seq || !packet.origin || !packet.from) {\n        return;\n      }\n      if (Buffer.from(packet.origin).equals(this._id)) {\n        return;\n      }\n      const packetId = Buffer.from(packet.origin).toString(\"hex\") + \":\" + Buffer.from(packet.seq).toString(\"hex\");\n      if (this._seenSeqs.get(packetId)) {\n        return;\n      }\n      this._seenSeqs.set(packetId, 1);\n      log(\"received %h -> %h\", this._id, packet.from, packet);\n      this._publish(packet).catch(() => {\n      });\n      this.packet.emit(packet);\n      return packet;\n    } catch (err) {\n      this.subscribeError.emit(err);\n    }\n  }\n};\nexport {\n  Broadcast\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465468292,"end":1670465468292,"order":"pre"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\n// packages/core/mesh/broadcast/src/broadcast.ts\nimport debug from \"debug\";\nimport assert from \"@dxos/node-std/assert\";\nimport LRU from \"tiny-lru\";\nimport { Event } from \"@dxos/async\";\nimport { randomBytes } from \"@dxos/crypto\";\nimport { schema } from \"@dxos/protocols\";\ndebug.formatters.h = (v) => v.toString(\"hex\").slice(0, 6);\nvar log = debug(\"broadcast\");\nvar Broadcast = class {\n  constructor(middleware, options = {}) {\n    this._codec = schema.getCodecForType(\"dxos.mesh.broadcast.Packet\");\n    this._isOpen = false;\n    this._peers = [];\n    this.send = new Event();\n    this.sendError = new Event();\n    this.packet = new Event();\n    this.subscribeError = new Event();\n    assert(middleware);\n    assert(middleware.send);\n    assert(middleware.subscribe);\n    const { id = randomBytes(32), maxAge = 10 * 1e3, maxSize = 1e3 } = options;\n    this._id = id;\n    this._send = middleware.send;\n    this._subscribe = middleware.subscribe;\n    this._seenSeqs = LRU(maxSize, maxAge);\n    if (middleware.lookup) {\n      this._lookup = () => middleware.lookup();\n    }\n  }\n  async publish(data, options = {}) {\n    const { seq = randomBytes(32) } = options;\n    assert(Buffer.isBuffer(data));\n    assert(Buffer.isBuffer(seq));\n    return this._publish({\n      seq,\n      origin: this._id,\n      data\n    });\n  }\n  updatePeers(peers) {\n    assert(peers.every((peer) => Buffer.isBuffer(peer.id)), \"Peer ID is expected to be a buffer.\");\n    this._peers = peers;\n  }\n  updateCache(opts = {}) {\n    if (opts.maxAge) {\n      this._seenSeqs.ttl = opts.maxAge;\n    }\n    if (opts.maxSize) {\n      this._seenSeqs.max = opts.maxSize;\n    }\n  }\n  pruneCache() {\n    const time = Date.now();\n    for (const item of Object.values(this._seenSeqs.items)) {\n      if (this._seenSeqs.ttl > 0 && item.expiry <= time) {\n        this._seenSeqs.delete(item.key);\n      }\n    }\n  }\n  open() {\n    if (this._isOpen) {\n      return;\n    }\n    this._isOpen = true;\n    this._unsubscribe = this._subscribe(this._onPacket.bind(this), this.updatePeers.bind(this)) || (() => {\n    });\n    log(\"running %h\", this._id);\n  }\n  close() {\n    var _a;\n    if (!this._isOpen) {\n      return;\n    }\n    this._isOpen = false;\n    (_a = this._unsubscribe) == null ? void 0 : _a.call(this);\n    this._seenSeqs.clear();\n    log(\"stop %h\", this._id);\n  }\n  async _publish(packet, options = {}) {\n    this._lookup && this.updatePeers(await this._lookup());\n    const peers = this._peers.filter((peer) => !Buffer.from(packet.origin).equals(peer.id) && (!packet.from || !Buffer.from(packet.from).equals(peer.id)));\n    if (peers.length === 0) {\n      return;\n    }\n    packet = Object.assign({}, packet, {\n      from: this._id\n    });\n    const packetEncoded = this._codec.encode(packet);\n    await Promise.all(peers.map((peer) => {\n      log(\"publish %h -> %h\", this._id, peer.id, packet);\n      return this._send(packetEncoded, peer, options).then(() => {\n        this.send.emit([\n          packetEncoded,\n          peer\n        ]);\n      }).catch((err) => {\n        this.sendError.emit(err);\n      });\n    }));\n    return packet;\n  }\n  _onPacket(packetEncoded) {\n    if (!this._isOpen) {\n      return;\n    }\n    try {\n      const packet = this._codec.decode(packetEncoded);\n      if (!packet || !packet.seq || !packet.origin || !packet.from) {\n        return;\n      }\n      if (Buffer.from(packet.origin).equals(this._id)) {\n        return;\n      }\n      const packetId = Buffer.from(packet.origin).toString(\"hex\") + \":\" + Buffer.from(packet.seq).toString(\"hex\");\n      if (this._seenSeqs.get(packetId)) {\n        return;\n      }\n      this._seenSeqs.set(packetId, 1);\n      log(\"received %h -> %h\", this._id, packet.from, packet);\n      this._publish(packet).catch(() => {\n      });\n      this.packet.emit(packet);\n      return packet;\n    } catch (err) {\n      this.subscribeError.emit(err);\n    }\n  }\n};\nexport {\n  Broadcast\n};\n//# sourceMappingURL=index.mjs.map\n","start":1670465468293,"end":1670465468294,"order":"normal"}]}
