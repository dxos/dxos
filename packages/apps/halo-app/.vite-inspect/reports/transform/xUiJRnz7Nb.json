{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/readable-stream@3.6.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js","transforms":[{"name":"vite:load-fallback","result":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","start":1670465470085,"end":1670465470143},{"name":"vite:react-babel","result":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","start":1670465470143,"end":1670465470143,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\n\nvar buffer_list;\nvar hasRequiredBuffer_list;\n\nfunction requireBuffer_list () {\n\tif (hasRequiredBuffer_list) return buffer_list;\n\thasRequiredBuffer_list = 1;\n\t'use strict';\n\n\tfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n\tfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tvar _require = require$$0,\n\t    Buffer = _require.Buffer;\n\n\tvar _require2 = require$$1,\n\t    inspect = _require2.inspect;\n\n\tvar custom = inspect && inspect.custom || 'inspect';\n\n\tfunction copyBuffer(src, target, offset) {\n\t  Buffer.prototype.copy.call(src, target, offset);\n\t}\n\n\tbuffer_list =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function BufferList() {\n\t    _classCallCheck(this, BufferList);\n\n\t    this.head = null;\n\t    this.tail = null;\n\t    this.length = 0;\n\t  }\n\n\t  _createClass(BufferList, [{\n\t    key: \"push\",\n\t    value: function push(v) {\n\t      var entry = {\n\t        data: v,\n\t        next: null\n\t      };\n\t      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n\t      this.tail = entry;\n\t      ++this.length;\n\t    }\n\t  }, {\n\t    key: \"unshift\",\n\t    value: function unshift(v) {\n\t      var entry = {\n\t        data: v,\n\t        next: this.head\n\t      };\n\t      if (this.length === 0) this.tail = entry;\n\t      this.head = entry;\n\t      ++this.length;\n\t    }\n\t  }, {\n\t    key: \"shift\",\n\t    value: function shift() {\n\t      if (this.length === 0) return;\n\t      var ret = this.head.data;\n\t      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n\t      --this.length;\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      this.head = this.tail = null;\n\t      this.length = 0;\n\t    }\n\t  }, {\n\t    key: \"join\",\n\t    value: function join(s) {\n\t      if (this.length === 0) return '';\n\t      var p = this.head;\n\t      var ret = '' + p.data;\n\n\t      while (p = p.next) {\n\t        ret += s + p.data;\n\t      }\n\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"concat\",\n\t    value: function concat(n) {\n\t      if (this.length === 0) return Buffer.alloc(0);\n\t      var ret = Buffer.allocUnsafe(n >>> 0);\n\t      var p = this.head;\n\t      var i = 0;\n\n\t      while (p) {\n\t        copyBuffer(p.data, ret, i);\n\t        i += p.data.length;\n\t        p = p.next;\n\t      }\n\n\t      return ret;\n\t    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n\t  }, {\n\t    key: \"consume\",\n\t    value: function consume(n, hasStrings) {\n\t      var ret;\n\n\t      if (n < this.head.data.length) {\n\t        // `slice` is the same for buffers and strings.\n\t        ret = this.head.data.slice(0, n);\n\t        this.head.data = this.head.data.slice(n);\n\t      } else if (n === this.head.data.length) {\n\t        // First chunk is a perfect match.\n\t        ret = this.shift();\n\t      } else {\n\t        // Result spans more than one buffer.\n\t        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n\t      }\n\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this.head.data;\n\t    } // Consumes a specified amount of characters from the buffered data.\n\n\t  }, {\n\t    key: \"_getString\",\n\t    value: function _getString(n) {\n\t      var p = this.head;\n\t      var c = 1;\n\t      var ret = p.data;\n\t      n -= ret.length;\n\n\t      while (p = p.next) {\n\t        var str = p.data;\n\t        var nb = n > str.length ? str.length : n;\n\t        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n\t        n -= nb;\n\n\t        if (n === 0) {\n\t          if (nb === str.length) {\n\t            ++c;\n\t            if (p.next) this.head = p.next;else this.head = this.tail = null;\n\t          } else {\n\t            this.head = p;\n\t            p.data = str.slice(nb);\n\t          }\n\n\t          break;\n\t        }\n\n\t        ++c;\n\t      }\n\n\t      this.length -= c;\n\t      return ret;\n\t    } // Consumes a specified amount of bytes from the buffered data.\n\n\t  }, {\n\t    key: \"_getBuffer\",\n\t    value: function _getBuffer(n) {\n\t      var ret = Buffer.allocUnsafe(n);\n\t      var p = this.head;\n\t      var c = 1;\n\t      p.data.copy(ret);\n\t      n -= p.data.length;\n\n\t      while (p = p.next) {\n\t        var buf = p.data;\n\t        var nb = n > buf.length ? buf.length : n;\n\t        buf.copy(ret, ret.length - n, 0, nb);\n\t        n -= nb;\n\n\t        if (n === 0) {\n\t          if (nb === buf.length) {\n\t            ++c;\n\t            if (p.next) this.head = p.next;else this.head = this.tail = null;\n\t          } else {\n\t            this.head = p;\n\t            p.data = buf.slice(nb);\n\t          }\n\n\t          break;\n\t        }\n\n\t        ++c;\n\t      }\n\n\t      this.length -= c;\n\t      return ret;\n\t    } // Make sure the linked list only shows the minimal necessary information.\n\n\t  }, {\n\t    key: custom,\n\t    value: function value(_, options) {\n\t      return inspect(this, _objectSpread({}, options, {\n\t        // Only inspect one level.\n\t        depth: 0,\n\t        // It should not recurse.\n\t        customInspect: false\n\t      }));\n\t    }\n\t  }]);\n\n\t  return BufferList;\n\t}();\n\treturn buffer_list;\n}\n\nexport { requireBuffer_list as __require };","start":1670465470143,"end":1670465470146,"order":"normal"},{"name":"polyfill-node","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000__vite-browser-external?commonjs-proxy\";\n\nvar buffer_list;\nvar hasRequiredBuffer_list;\n\nfunction requireBuffer_list () {\n\tif (hasRequiredBuffer_list) return buffer_list;\n\thasRequiredBuffer_list = 1;\n\t'use strict';\n\n\tfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n\tfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\tvar _require = require$$0,\n\t    Buffer = _require.Buffer;\n\n\tvar _require2 = require$$1,\n\t    inspect = _require2.inspect;\n\n\tvar custom = inspect && inspect.custom || 'inspect';\n\n\tfunction copyBuffer(src, target, offset) {\n\t  Buffer.prototype.copy.call(src, target, offset);\n\t}\n\n\tbuffer_list =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function BufferList() {\n\t    _classCallCheck(this, BufferList);\n\n\t    this.head = null;\n\t    this.tail = null;\n\t    this.length = 0;\n\t  }\n\n\t  _createClass(BufferList, [{\n\t    key: \"push\",\n\t    value: function push(v) {\n\t      var entry = {\n\t        data: v,\n\t        next: null\n\t      };\n\t      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n\t      this.tail = entry;\n\t      ++this.length;\n\t    }\n\t  }, {\n\t    key: \"unshift\",\n\t    value: function unshift(v) {\n\t      var entry = {\n\t        data: v,\n\t        next: this.head\n\t      };\n\t      if (this.length === 0) this.tail = entry;\n\t      this.head = entry;\n\t      ++this.length;\n\t    }\n\t  }, {\n\t    key: \"shift\",\n\t    value: function shift() {\n\t      if (this.length === 0) return;\n\t      var ret = this.head.data;\n\t      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n\t      --this.length;\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      this.head = this.tail = null;\n\t      this.length = 0;\n\t    }\n\t  }, {\n\t    key: \"join\",\n\t    value: function join(s) {\n\t      if (this.length === 0) return '';\n\t      var p = this.head;\n\t      var ret = '' + p.data;\n\n\t      while (p = p.next) {\n\t        ret += s + p.data;\n\t      }\n\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"concat\",\n\t    value: function concat(n) {\n\t      if (this.length === 0) return Buffer.alloc(0);\n\t      var ret = Buffer.allocUnsafe(n >>> 0);\n\t      var p = this.head;\n\t      var i = 0;\n\n\t      while (p) {\n\t        copyBuffer(p.data, ret, i);\n\t        i += p.data.length;\n\t        p = p.next;\n\t      }\n\n\t      return ret;\n\t    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n\t  }, {\n\t    key: \"consume\",\n\t    value: function consume(n, hasStrings) {\n\t      var ret;\n\n\t      if (n < this.head.data.length) {\n\t        // `slice` is the same for buffers and strings.\n\t        ret = this.head.data.slice(0, n);\n\t        this.head.data = this.head.data.slice(n);\n\t      } else if (n === this.head.data.length) {\n\t        // First chunk is a perfect match.\n\t        ret = this.shift();\n\t      } else {\n\t        // Result spans more than one buffer.\n\t        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n\t      }\n\n\t      return ret;\n\t    }\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this.head.data;\n\t    } // Consumes a specified amount of characters from the buffered data.\n\n\t  }, {\n\t    key: \"_getString\",\n\t    value: function _getString(n) {\n\t      var p = this.head;\n\t      var c = 1;\n\t      var ret = p.data;\n\t      n -= ret.length;\n\n\t      while (p = p.next) {\n\t        var str = p.data;\n\t        var nb = n > str.length ? str.length : n;\n\t        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n\t        n -= nb;\n\n\t        if (n === 0) {\n\t          if (nb === str.length) {\n\t            ++c;\n\t            if (p.next) this.head = p.next;else this.head = this.tail = null;\n\t          } else {\n\t            this.head = p;\n\t            p.data = str.slice(nb);\n\t          }\n\n\t          break;\n\t        }\n\n\t        ++c;\n\t      }\n\n\t      this.length -= c;\n\t      return ret;\n\t    } // Consumes a specified amount of bytes from the buffered data.\n\n\t  }, {\n\t    key: \"_getBuffer\",\n\t    value: function _getBuffer(n) {\n\t      var ret = Buffer.allocUnsafe(n);\n\t      var p = this.head;\n\t      var c = 1;\n\t      p.data.copy(ret);\n\t      n -= p.data.length;\n\n\t      while (p = p.next) {\n\t        var buf = p.data;\n\t        var nb = n > buf.length ? buf.length : n;\n\t        buf.copy(ret, ret.length - n, 0, nb);\n\t        n -= nb;\n\n\t        if (n === 0) {\n\t          if (nb === buf.length) {\n\t            ++c;\n\t            if (p.next) this.head = p.next;else this.head = this.tail = null;\n\t          } else {\n\t            this.head = p;\n\t            p.data = buf.slice(nb);\n\t          }\n\n\t          break;\n\t        }\n\n\t        ++c;\n\t      }\n\n\t      this.length -= c;\n\t      return ret;\n\t    } // Make sure the linked list only shows the minimal necessary information.\n\n\t  }, {\n\t    key: custom,\n\t    value: function value(_, options) {\n\t      return inspect(this, _objectSpread({}, options, {\n\t        // Only inspect one level.\n\t        depth: 0,\n\t        // It should not recurse.\n\t        customInspect: false\n\t      }));\n\t    }\n\t  }]);\n\n\t  return BufferList;\n\t}();\n\treturn buffer_list;\n}\n\nexport { requireBuffer_list as __require };","start":1670465470146,"end":1670465470154,"order":"normal"}]}
