{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/random-access-idb@1.2.2/node_modules/random-access-idb/index.js","transforms":[{"name":"vite:load-fallback","result":"var RandomAccess = require('random-access-storage')\nvar inherits = require('inherits')\nvar nextTick = require('next-tick')\nvar once = require('once')\nvar blocks = require('./lib/blocks.js')\nvar bufferFrom = require('buffer-from')\nvar bufferAlloc = require('buffer-alloc')\n\nvar DELIM = '\\0'\nvar win = typeof window !== 'undefined' ? window\n  : (typeof self !== 'undefined' ? self : {})\n\nmodule.exports = function (dbname, xopts) {\n  if (!xopts) xopts = {}\n  var idb = xopts.idb || (typeof win !== 'undefined'\n    ? win.indexedDB || win.mozIndexedDB\n      || win.webkitIndexedDB || win.msIndexedDB\n    : null)\n  if (!idb) throw new Error('indexedDB not present and not given')\n  var db = null, dbqueue = []\n  if (typeof idb.open === 'function') {\n    var req = idb.open(dbname)\n    req.addEventListener('upgradeneeded', function () {\n      db = req.result\n      db.createObjectStore('data')\n    })\n    req.addEventListener('success', function () {\n      db = req.result\n      dbqueue.forEach(function (cb) { cb(db) })\n      dbqueue = null\n    })\n  } else {\n    db = idb\n  }\n  return function (name, opts) {\n    if (typeof name === 'object') {\n      opts = name\n      name = opts.name\n    }\n\n    if (!opts) opts = {}\n    opts.name = name\n\n    return new Store(Object.assign({ db: getdb }, xopts, opts))\n  }\n  function getdb (cb) {\n    if (db) nextTick(function () { cb(db) })\n    else dbqueue.push(cb)\n  }\n}\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  RandomAccess.call(this)\n  if (!opts) opts = {}\n  if (typeof opts === 'string') opts = { name: opts }\n  this.size = opts.size || 4096\n  this.name = opts.name\n  this.length = opts.length || 0\n  this._getdb = opts.db\n}\ninherits(Store, RandomAccess)\n\nStore.prototype._blocks = function (i, j) {\n  return blocks(this.size, i, j)\n}\n\nStore.prototype._read = function (req) {\n  var self = this\n  var buffers = []\n  self._store('readonly', function (err, store) {\n    if ((self.length || 0) < req.offset+req.size) {\n      return req.callback(new Error('Could not satisfy length'))\n    }\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset+req.size)\n    var pending = offsets.length + 1\n    var firstBlock = offsets.length > 0 ? offsets[0].block : 0\n    var j = 0\n    for (var i = 0; i < offsets.length; i++) (function (o) {\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[o.block-firstBlock] = ev.target.result\n          ? bufferFrom(ev.target.result.subarray(o.start,o.end))\n          : bufferAlloc(o.end-o.start)\n        if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n      })\n    })(offsets[i])\n    if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n  })\n}\n\nStore.prototype._write = function (req) {\n  var self = this\n  self._store('readwrite', function (err, store) {\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset + req.data.length)\n    var pending = 1\n    var buffers = {}\n    for (var i = 0; i < offsets.length; i++) (function (o,i) {\n      if (o.end-o.start === self.size) return\n      pending++\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size))\n        if (--pending === 0) write(store, offsets, buffers)\n      })\n    })(offsets[i],i)\n    if (--pending === 0) write(store, offsets, buffers)\n  })\n  function write (store, offsets, buffers) {\n    var block\n    for (var i = 0, j = 0; i < offsets.length; i++) {\n      var o = offsets[i]\n      var len = o.end - o.start\n      if (len === self.size) {\n        block = bufferFrom(req.data.slice(j, j+len))\n      } else {\n        block = buffers[i]\n        req.data.copy(block, o.start, j, j+len)\n      }\n      store.put(block,self.name + DELIM + o.block)\n      j += len\n    }\n    var length = Math.max(self.length || 0, req.offset + req.data.length)\n    store.put(length, self.name + DELIM + 'length')\n    store.transaction.addEventListener('complete', function () {\n      self.length = length\n      req.callback(null)\n    })\n    store.transaction.addEventListener('error', function (err) {\n      req.callback(err)\n    })\n  }\n}\n\nStore.prototype._store = function (mode, cb) {\n  cb = once(cb)\n  var self = this\n  self._getdb(function (db) {\n    var tx = db.transaction(['data'], mode)\n    var store = tx.objectStore('data')\n    tx.addEventListener('error', cb)\n    cb(null, store)\n  })\n}\n\nStore.prototype._open = function (req) {\n  var self = this\n  this._getdb(function(db) {\n    self._store('readonly', function (err, store) {\n      backify(store.get(self.name + DELIM + \"length\"), function(err, ev) {\n        self.length = ev.target.result || 0\n        req.callback(null)\n      })\n    })\n  })\n}\n\nStore.prototype._close = function (req) {\n  this._getdb(function (db) {\n    // db.close() // TODO: reopen gracefully. Close breaks with corestore, as innercorestore closes the db\n    req.callback()\n  })\n}\n\nStore.prototype._stat = function (req) {\n  var self = this\n  nextTick(function () {\n    req.callback(null, { size: self.length })\n  })\n}\n\nfunction backify (r, cb) {\n  r.addEventListener('success', function (ev) { cb(null, ev) })\n  r.addEventListener('error', cb)\n}\n","start":1670465468295,"end":1670465468554},{"name":"vite:react-babel","result":"var RandomAccess = require('random-access-storage')\nvar inherits = require('inherits')\nvar nextTick = require('next-tick')\nvar once = require('once')\nvar blocks = require('./lib/blocks.js')\nvar bufferFrom = require('buffer-from')\nvar bufferAlloc = require('buffer-alloc')\n\nvar DELIM = '\\0'\nvar win = typeof window !== 'undefined' ? window\n  : (typeof self !== 'undefined' ? self : {})\n\nmodule.exports = function (dbname, xopts) {\n  if (!xopts) xopts = {}\n  var idb = xopts.idb || (typeof win !== 'undefined'\n    ? win.indexedDB || win.mozIndexedDB\n      || win.webkitIndexedDB || win.msIndexedDB\n    : null)\n  if (!idb) throw new Error('indexedDB not present and not given')\n  var db = null, dbqueue = []\n  if (typeof idb.open === 'function') {\n    var req = idb.open(dbname)\n    req.addEventListener('upgradeneeded', function () {\n      db = req.result\n      db.createObjectStore('data')\n    })\n    req.addEventListener('success', function () {\n      db = req.result\n      dbqueue.forEach(function (cb) { cb(db) })\n      dbqueue = null\n    })\n  } else {\n    db = idb\n  }\n  return function (name, opts) {\n    if (typeof name === 'object') {\n      opts = name\n      name = opts.name\n    }\n\n    if (!opts) opts = {}\n    opts.name = name\n\n    return new Store(Object.assign({ db: getdb }, xopts, opts))\n  }\n  function getdb (cb) {\n    if (db) nextTick(function () { cb(db) })\n    else dbqueue.push(cb)\n  }\n}\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  RandomAccess.call(this)\n  if (!opts) opts = {}\n  if (typeof opts === 'string') opts = { name: opts }\n  this.size = opts.size || 4096\n  this.name = opts.name\n  this.length = opts.length || 0\n  this._getdb = opts.db\n}\ninherits(Store, RandomAccess)\n\nStore.prototype._blocks = function (i, j) {\n  return blocks(this.size, i, j)\n}\n\nStore.prototype._read = function (req) {\n  var self = this\n  var buffers = []\n  self._store('readonly', function (err, store) {\n    if ((self.length || 0) < req.offset+req.size) {\n      return req.callback(new Error('Could not satisfy length'))\n    }\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset+req.size)\n    var pending = offsets.length + 1\n    var firstBlock = offsets.length > 0 ? offsets[0].block : 0\n    var j = 0\n    for (var i = 0; i < offsets.length; i++) (function (o) {\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[o.block-firstBlock] = ev.target.result\n          ? bufferFrom(ev.target.result.subarray(o.start,o.end))\n          : bufferAlloc(o.end-o.start)\n        if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n      })\n    })(offsets[i])\n    if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n  })\n}\n\nStore.prototype._write = function (req) {\n  var self = this\n  self._store('readwrite', function (err, store) {\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset + req.data.length)\n    var pending = 1\n    var buffers = {}\n    for (var i = 0; i < offsets.length; i++) (function (o,i) {\n      if (o.end-o.start === self.size) return\n      pending++\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size))\n        if (--pending === 0) write(store, offsets, buffers)\n      })\n    })(offsets[i],i)\n    if (--pending === 0) write(store, offsets, buffers)\n  })\n  function write (store, offsets, buffers) {\n    var block\n    for (var i = 0, j = 0; i < offsets.length; i++) {\n      var o = offsets[i]\n      var len = o.end - o.start\n      if (len === self.size) {\n        block = bufferFrom(req.data.slice(j, j+len))\n      } else {\n        block = buffers[i]\n        req.data.copy(block, o.start, j, j+len)\n      }\n      store.put(block,self.name + DELIM + o.block)\n      j += len\n    }\n    var length = Math.max(self.length || 0, req.offset + req.data.length)\n    store.put(length, self.name + DELIM + 'length')\n    store.transaction.addEventListener('complete', function () {\n      self.length = length\n      req.callback(null)\n    })\n    store.transaction.addEventListener('error', function (err) {\n      req.callback(err)\n    })\n  }\n}\n\nStore.prototype._store = function (mode, cb) {\n  cb = once(cb)\n  var self = this\n  self._getdb(function (db) {\n    var tx = db.transaction(['data'], mode)\n    var store = tx.objectStore('data')\n    tx.addEventListener('error', cb)\n    cb(null, store)\n  })\n}\n\nStore.prototype._open = function (req) {\n  var self = this\n  this._getdb(function(db) {\n    self._store('readonly', function (err, store) {\n      backify(store.get(self.name + DELIM + \"length\"), function(err, ev) {\n        self.length = ev.target.result || 0\n        req.callback(null)\n      })\n    })\n  })\n}\n\nStore.prototype._close = function (req) {\n  this._getdb(function (db) {\n    // db.close() // TODO: reopen gracefully. Close breaks with corestore, as innercorestore closes the db\n    req.callback()\n  })\n}\n\nStore.prototype._stat = function (req) {\n  var self = this\n  nextTick(function () {\n    req.callback(null, { size: self.length })\n  })\n}\n\nfunction backify (r, cb) {\n  r.addEventListener('success', function (ev) { cb(null, ev) })\n  r.addEventListener('error', cb)\n}\n","start":1670465468554,"end":1670465468554,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/random-access-storage@1.4.3/node_modules/random-access-storage/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/next-tick@1.1.0/node_modules/next-tick/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/once@1.4.0/node_modules/once/once.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/random-access-idb@1.2.2/node_modules/random-access-idb/lib/blocks.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer-from@0.1.2/node_modules/buffer-from/index.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js?commonjs-proxy\";\n\nvar RandomAccess = require$$0\nvar inherits = require$$1\nvar nextTick = require$$2\nvar once = require$$3\nvar blocks = require$$4\nvar bufferFrom = require$$5\nvar bufferAlloc = require$$6\n\nvar DELIM = '\\0'\nvar win = typeof window !== 'undefined' ? window\n  : (typeof self !== 'undefined' ? self : {})\n\nvar randomAccessIdb = function (dbname, xopts) {\n  if (!xopts) xopts = {}\n  var idb = xopts.idb || (typeof win !== 'undefined'\n    ? win.indexedDB || win.mozIndexedDB\n      || win.webkitIndexedDB || win.msIndexedDB\n    : null)\n  if (!idb) throw new Error('indexedDB not present and not given')\n  var db = null, dbqueue = []\n  if (typeof idb.open === 'function') {\n    var req = idb.open(dbname)\n    req.addEventListener('upgradeneeded', function () {\n      db = req.result\n      db.createObjectStore('data')\n    })\n    req.addEventListener('success', function () {\n      db = req.result\n      dbqueue.forEach(function (cb) { cb(db) })\n      dbqueue = null\n    })\n  } else {\n    db = idb\n  }\n  return function (name, opts) {\n    if (typeof name === 'object') {\n      opts = name\n      name = opts.name\n    }\n\n    if (!opts) opts = {}\n    opts.name = name\n\n    return new Store(Object.assign({ db: getdb }, xopts, opts))\n  }\n  function getdb (cb) {\n    if (db) nextTick(function () { cb(db) })\n    else dbqueue.push(cb)\n  }\n}\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  RandomAccess.call(this)\n  if (!opts) opts = {}\n  if (typeof opts === 'string') opts = { name: opts }\n  this.size = opts.size || 4096\n  this.name = opts.name\n  this.length = opts.length || 0\n  this._getdb = opts.db\n}\ninherits(Store, RandomAccess)\n\nStore.prototype._blocks = function (i, j) {\n  return blocks(this.size, i, j)\n}\n\nStore.prototype._read = function (req) {\n  var self = this\n  var buffers = []\n  self._store('readonly', function (err, store) {\n    if ((self.length || 0) < req.offset+req.size) {\n      return req.callback(new Error('Could not satisfy length'))\n    }\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset+req.size)\n    var pending = offsets.length + 1\n    var firstBlock = offsets.length > 0 ? offsets[0].block : 0\n    var j = 0\n    for (var i = 0; i < offsets.length; i++) (function (o) {\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[o.block-firstBlock] = ev.target.result\n          ? bufferFrom(ev.target.result.subarray(o.start,o.end))\n          : bufferAlloc(o.end-o.start)\n        if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n      })\n    })(offsets[i])\n    if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n  })\n}\n\nStore.prototype._write = function (req) {\n  var self = this\n  self._store('readwrite', function (err, store) {\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset + req.data.length)\n    var pending = 1\n    var buffers = {}\n    for (var i = 0; i < offsets.length; i++) (function (o,i) {\n      if (o.end-o.start === self.size) return\n      pending++\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size))\n        if (--pending === 0) write(store, offsets, buffers)\n      })\n    })(offsets[i],i)\n    if (--pending === 0) write(store, offsets, buffers)\n  })\n  function write (store, offsets, buffers) {\n    var block\n    for (var i = 0, j = 0; i < offsets.length; i++) {\n      var o = offsets[i]\n      var len = o.end - o.start\n      if (len === self.size) {\n        block = bufferFrom(req.data.slice(j, j+len))\n      } else {\n        block = buffers[i]\n        req.data.copy(block, o.start, j, j+len)\n      }\n      store.put(block,self.name + DELIM + o.block)\n      j += len\n    }\n    var length = Math.max(self.length || 0, req.offset + req.data.length)\n    store.put(length, self.name + DELIM + 'length')\n    store.transaction.addEventListener('complete', function () {\n      self.length = length\n      req.callback(null)\n    })\n    store.transaction.addEventListener('error', function (err) {\n      req.callback(err)\n    })\n  }\n}\n\nStore.prototype._store = function (mode, cb) {\n  cb = once(cb)\n  var self = this\n  self._getdb(function (db) {\n    var tx = db.transaction(['data'], mode)\n    var store = tx.objectStore('data')\n    tx.addEventListener('error', cb)\n    cb(null, store)\n  })\n}\n\nStore.prototype._open = function (req) {\n  var self = this\n  this._getdb(function(db) {\n    self._store('readonly', function (err, store) {\n      backify(store.get(self.name + DELIM + \"length\"), function(err, ev) {\n        self.length = ev.target.result || 0\n        req.callback(null)\n      })\n    })\n  })\n}\n\nStore.prototype._close = function (req) {\n  this._getdb(function (db) {\n    // db.close() // TODO: reopen gracefully. Close breaks with corestore, as innercorestore closes the db\n    req.callback()\n  })\n}\n\nStore.prototype._stat = function (req) {\n  var self = this\n  nextTick(function () {\n    req.callback(null, { size: self.length })\n  })\n}\n\nfunction backify (r, cb) {\n  r.addEventListener('success', function (ev) { cb(null, ev) })\n  r.addEventListener('error', cb)\n}\n\nexport default randomAccessIdb;\nexport { randomAccessIdb as __moduleExports };","start":1670465468554,"end":1670465470548,"order":"normal"},{"name":"polyfill-node","result":"import { Buffer as Buffer } from '\u0000polyfill-node.buffer';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport require$$0 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/random-access-storage@1.4.3/node_modules/random-access-storage/index.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/next-tick@1.1.0/node_modules/next-tick/index.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/once@1.4.0/node_modules/once/once.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/random-access-idb@1.2.2/node_modules/random-access-idb/lib/blocks.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer-from@0.1.2/node_modules/buffer-from/index.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/home/jdw/Code/dxos/dxos/node_modules/.pnpm/buffer-alloc@1.2.0/node_modules/buffer-alloc/index.js?commonjs-proxy\";\n\nvar RandomAccess = require$$0\nvar inherits = require$$1\nvar nextTick = require$$2\nvar once = require$$3\nvar blocks = require$$4\nvar bufferFrom = require$$5\nvar bufferAlloc = require$$6\n\nvar DELIM = '\\0'\nvar win = typeof window !== 'undefined' ? window\n  : (typeof self !== 'undefined' ? self : {})\n\nvar randomAccessIdb = function (dbname, xopts) {\n  if (!xopts) xopts = {}\n  var idb = xopts.idb || (typeof win !== 'undefined'\n    ? win.indexedDB || win.mozIndexedDB\n      || win.webkitIndexedDB || win.msIndexedDB\n    : null)\n  if (!idb) throw new Error('indexedDB not present and not given')\n  var db = null, dbqueue = []\n  if (typeof idb.open === 'function') {\n    var req = idb.open(dbname)\n    req.addEventListener('upgradeneeded', function () {\n      db = req.result\n      db.createObjectStore('data')\n    })\n    req.addEventListener('success', function () {\n      db = req.result\n      dbqueue.forEach(function (cb) { cb(db) })\n      dbqueue = null\n    })\n  } else {\n    db = idb\n  }\n  return function (name, opts) {\n    if (typeof name === 'object') {\n      opts = name\n      name = opts.name\n    }\n\n    if (!opts) opts = {}\n    opts.name = name\n\n    return new Store(Object.assign({ db: getdb }, xopts, opts))\n  }\n  function getdb (cb) {\n    if (db) nextTick(function () { cb(db) })\n    else dbqueue.push(cb)\n  }\n}\n\nfunction Store (opts) {\n  if (!(this instanceof Store)) return new Store(opts)\n  RandomAccess.call(this)\n  if (!opts) opts = {}\n  if (typeof opts === 'string') opts = { name: opts }\n  this.size = opts.size || 4096\n  this.name = opts.name\n  this.length = opts.length || 0\n  this._getdb = opts.db\n}\ninherits(Store, RandomAccess)\n\nStore.prototype._blocks = function (i, j) {\n  return blocks(this.size, i, j)\n}\n\nStore.prototype._read = function (req) {\n  var self = this\n  var buffers = []\n  self._store('readonly', function (err, store) {\n    if ((self.length || 0) < req.offset+req.size) {\n      return req.callback(new Error('Could not satisfy length'))\n    }\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset+req.size)\n    var pending = offsets.length + 1\n    var firstBlock = offsets.length > 0 ? offsets[0].block : 0\n    var j = 0\n    for (var i = 0; i < offsets.length; i++) (function (o) {\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[o.block-firstBlock] = ev.target.result\n          ? bufferFrom(ev.target.result.subarray(o.start,o.end))\n          : bufferAlloc(o.end-o.start)\n        if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n      })\n    })(offsets[i])\n    if (--pending === 0) req.callback(null, Buffer.concat(buffers))\n  })\n}\n\nStore.prototype._write = function (req) {\n  var self = this\n  self._store('readwrite', function (err, store) {\n    if (err) return req.callback(err)\n    var offsets = self._blocks(req.offset, req.offset + req.data.length)\n    var pending = 1\n    var buffers = {}\n    for (var i = 0; i < offsets.length; i++) (function (o,i) {\n      if (o.end-o.start === self.size) return\n      pending++\n      var key = self.name + DELIM + o.block\n      backify(store.get(key), function (err, ev) {\n        if (err) return req.callback(err)\n        buffers[i] = bufferFrom(ev.target.result || bufferAlloc(self.size))\n        if (--pending === 0) write(store, offsets, buffers)\n      })\n    })(offsets[i],i)\n    if (--pending === 0) write(store, offsets, buffers)\n  })\n  function write (store, offsets, buffers) {\n    var block\n    for (var i = 0, j = 0; i < offsets.length; i++) {\n      var o = offsets[i]\n      var len = o.end - o.start\n      if (len === self.size) {\n        block = bufferFrom(req.data.slice(j, j+len))\n      } else {\n        block = buffers[i]\n        req.data.copy(block, o.start, j, j+len)\n      }\n      store.put(block,self.name + DELIM + o.block)\n      j += len\n    }\n    var length = Math.max(self.length || 0, req.offset + req.data.length)\n    store.put(length, self.name + DELIM + 'length')\n    store.transaction.addEventListener('complete', function () {\n      self.length = length\n      req.callback(null)\n    })\n    store.transaction.addEventListener('error', function (err) {\n      req.callback(err)\n    })\n  }\n}\n\nStore.prototype._store = function (mode, cb) {\n  cb = once(cb)\n  var self = this\n  self._getdb(function (db) {\n    var tx = db.transaction(['data'], mode)\n    var store = tx.objectStore('data')\n    tx.addEventListener('error', cb)\n    cb(null, store)\n  })\n}\n\nStore.prototype._open = function (req) {\n  var self = this\n  this._getdb(function(db) {\n    self._store('readonly', function (err, store) {\n      backify(store.get(self.name + DELIM + \"length\"), function(err, ev) {\n        self.length = ev.target.result || 0\n        req.callback(null)\n      })\n    })\n  })\n}\n\nStore.prototype._close = function (req) {\n  this._getdb(function (db) {\n    // db.close() // TODO: reopen gracefully. Close breaks with corestore, as innercorestore closes the db\n    req.callback()\n  })\n}\n\nStore.prototype._stat = function (req) {\n  var self = this\n  nextTick(function () {\n    req.callback(null, { size: self.length })\n  })\n}\n\nfunction backify (r, cb) {\n  r.addEventListener('success', function (ev) { cb(null, ev) })\n  r.addEventListener('error', cb)\n}\n\nexport default randomAccessIdb;\nexport { randomAccessIdb as __moduleExports };","start":1670465470555,"end":1670465470569,"order":"normal"}]}
