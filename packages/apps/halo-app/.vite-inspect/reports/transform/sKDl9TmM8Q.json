{"resolvedId":"/home/jdw/Code/dxos/dxos/node_modules/.pnpm/nanoguard@1.3.0/node_modules/nanoguard/index.js","transforms":[{"name":"vite:load-fallback","result":"module.exports = class Nanoguard {\n  constructor () {\n    this._tick = 0\n    this._fns = []\n    this._dep = null\n  }\n\n  get waiting () {\n    return this._tick > 0\n  }\n\n  depend (dep) {\n    if (this._dep !== null) throw new Error('Can only depend on one other guard currently')\n    this._dep = dep\n  }\n\n  wait () {\n    this._tick++\n  }\n\n  continue (cb, err, val) {\n    if (this._tick === 1) process.nextTick(continueNT, this)\n    else this._tick--\n    if (cb) cb(err, val)\n  }\n\n  waitAndContinue () {\n    let once = false\n    this.wait()\n    return () => {\n      if (once) return false\n      once = true\n      this.continue()\n      return true\n    }\n  }\n\n  continueSync (cb, err, val) {\n    if (--this._tick) return\n    while (this._fns !== null && this._fns.length) this._ready(this._fns.pop())\n    if (cb) cb(err, val)\n  }\n\n  destroy () {\n    const fns = this._fns\n    if (fns) return\n    this._fns = null\n    while (fns.length) fns.pop()()\n  }\n\n  ready (fn) {\n    if (this._fns === null || this._tick === 0) this._ready(fn)\n    else this._fns.push(fn)\n  }\n\n  _ready (fn) {\n    if (this._dep === null) fn()\n    else this._dep.ready(fn)\n  }\n}\n\nfunction continueNT (guard) {\n  guard.continueSync()\n}\n","start":1670465469218,"end":1670465469297},{"name":"vite:react-babel","result":"module.exports = class Nanoguard {\n  constructor () {\n    this._tick = 0\n    this._fns = []\n    this._dep = null\n  }\n\n  get waiting () {\n    return this._tick > 0\n  }\n\n  depend (dep) {\n    if (this._dep !== null) throw new Error('Can only depend on one other guard currently')\n    this._dep = dep\n  }\n\n  wait () {\n    this._tick++\n  }\n\n  continue (cb, err, val) {\n    if (this._tick === 1) process.nextTick(continueNT, this)\n    else this._tick--\n    if (cb) cb(err, val)\n  }\n\n  waitAndContinue () {\n    let once = false\n    this.wait()\n    return () => {\n      if (once) return false\n      once = true\n      this.continue()\n      return true\n    }\n  }\n\n  continueSync (cb, err, val) {\n    if (--this._tick) return\n    while (this._fns !== null && this._fns.length) this._ready(this._fns.pop())\n    if (cb) cb(err, val)\n  }\n\n  destroy () {\n    const fns = this._fns\n    if (fns) return\n    this._fns = null\n    while (fns.length) fns.pop()()\n  }\n\n  ready (fn) {\n    if (this._fns === null || this._tick === 0) this._ready(fn)\n    else this._fns.push(fn)\n  }\n\n  _ready (fn) {\n    if (this._dep === null) fn()\n    else this._dep.ready(fn)\n  }\n}\n\nfunction continueNT (guard) {\n  guard.continueSync()\n}\n","start":1670465469297,"end":1670465469297,"order":"pre"},{"name":"commonjs","result":"import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nvar nanoguard = class Nanoguard {\n  constructor () {\n    this._tick = 0\n    this._fns = []\n    this._dep = null\n  }\n\n  get waiting () {\n    return this._tick > 0\n  }\n\n  depend (dep) {\n    if (this._dep !== null) throw new Error('Can only depend on one other guard currently')\n    this._dep = dep\n  }\n\n  wait () {\n    this._tick++\n  }\n\n  continue (cb, err, val) {\n    if (this._tick === 1) process.nextTick(continueNT, this)\n    else this._tick--\n    if (cb) cb(err, val)\n  }\n\n  waitAndContinue () {\n    let once = false\n    this.wait()\n    return () => {\n      if (once) return false\n      once = true\n      this.continue()\n      return true\n    }\n  }\n\n  continueSync (cb, err, val) {\n    if (--this._tick) return\n    while (this._fns !== null && this._fns.length) this._ready(this._fns.pop())\n    if (cb) cb(err, val)\n  }\n\n  destroy () {\n    const fns = this._fns\n    if (fns) return\n    this._fns = null\n    while (fns.length) fns.pop()()\n  }\n\n  ready (fn) {\n    if (this._fns === null || this._tick === 0) this._ready(fn)\n    else this._fns.push(fn)\n  }\n\n  _ready (fn) {\n    if (this._dep === null) fn()\n    else this._dep.ready(fn)\n  }\n}\n\nfunction continueNT (guard) {\n  guard.continueSync()\n}\n\nexport default nanoguard;\nexport { nanoguard as __moduleExports };","start":1670465469297,"end":1670465469298,"order":"normal"},{"name":"polyfill-node","result":"import { default as process } from '\u0000polyfill-node.process';\n\nimport * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\n\nvar nanoguard = class Nanoguard {\n  constructor () {\n    this._tick = 0\n    this._fns = []\n    this._dep = null\n  }\n\n  get waiting () {\n    return this._tick > 0\n  }\n\n  depend (dep) {\n    if (this._dep !== null) throw new Error('Can only depend on one other guard currently')\n    this._dep = dep\n  }\n\n  wait () {\n    this._tick++\n  }\n\n  continue (cb, err, val) {\n    if (this._tick === 1) process.nextTick(continueNT, this)\n    else this._tick--\n    if (cb) cb(err, val)\n  }\n\n  waitAndContinue () {\n    let once = false\n    this.wait()\n    return () => {\n      if (once) return false\n      once = true\n      this.continue()\n      return true\n    }\n  }\n\n  continueSync (cb, err, val) {\n    if (--this._tick) return\n    while (this._fns !== null && this._fns.length) this._ready(this._fns.pop())\n    if (cb) cb(err, val)\n  }\n\n  destroy () {\n    const fns = this._fns\n    if (fns) return\n    this._fns = null\n    while (fns.length) fns.pop()()\n  }\n\n  ready (fn) {\n    if (this._fns === null || this._tick === 0) this._ready(fn)\n    else this._fns.push(fn)\n  }\n\n  _ready (fn) {\n    if (this._dep === null) fn()\n    else this._dep.ready(fn)\n  }\n}\n\nfunction continueNT (guard) {\n  guard.continueSync()\n}\n\nexport default nanoguard;\nexport { nanoguard as __moduleExports };","start":1670465469298,"end":1670465469300,"order":"normal"}]}
