//
// Copyright 2022 DXOS.org
//
import { existsSync, statSync } from 'node:fs';
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';

import yaml from 'js-yaml';
import { v4 as uuid, validate as validateUuid } from 'uuid';

/**
 * Print observability banner once per installation.
 */
export const showObservabilityBanner = async (configDir: string, bannercb: (input: string) => void) => {
  const path = join(configDir, '.observability-banner-printed');
  if (existsSync(path)) {
    return;
  }
  bannercb(
    'Basic observability data will be sent to the DXOS team in order to improve the product. This includes \
    performance metrics, error logs, and usage data. No personally identifiable information, other than your \
    public key, is included with this data and no private data ever leaves your devices. To disable sending \
    observability data, set the environment variable DX_DISABLE_OBSERVABILITY=true.',
  );

  await writeFile(path, '', 'utf-8');
};

export const isObservabilityDisabled = async (configDir: string): Promise<boolean> => {
  const observabilityState = await getObservabilityState(configDir);
  return observabilityState.disabled;
};

export const storeObservabilityDisabled = async (configDir: string, value: boolean) => {
  const observabilityState = await getObservabilityState(configDir);
  observabilityState.disabled = value;
  await writeFile(join(configDir, 'observability.yml'), yaml.dump(observabilityState), 'utf-8');
};

export const getObservabilityGroup = async (configDir: string): Promise<string | undefined> => {
  const observabilityState = await getObservabilityState(configDir);
  return observabilityState.group;
};

export const storeObservabilityGroup = async (configDir: string, value: string) => {
  const observabilityState = await getObservabilityState(configDir);
  observabilityState.group = value;
  await writeFile(join(configDir, 'observability.yml'), yaml.dump(observabilityState), 'utf-8');
};

const getObservabilityState = async (configDir: string): Promise<PersistentObservabilityState> => {
  // check whether configDir exists and if it's a directory

  if (existsSync(configDir)) {
    if (!statSync(configDir).isDirectory()) {
      throw new Error(`Config directory ${configDir} exists but is not a directory`);
    }
  } else {
    await mkdir(configDir, { recursive: true });
  }

  const idPath = join(configDir, 'observability.yml');
  if (existsSync(idPath)) {
    const context = await readFile(idPath, 'utf-8');
    return validate(context) ?? initializeState(idPath);
  }

  return initializeState(idPath);
};

export type PersistentObservabilityState = {
  installationId: string;
  disabled: boolean;
  group?: string;
};

// create initial state and write to file, using environment variables to override defaults.
const initializeState = async (idPath: string): Promise<PersistentObservabilityState> => {
  // TODO(nf): read initial values from config or seed file
  const observabilityState = {
    installationId: uuid(),
    disabled: process.env.DX_DISABLE_OBSERVABILITY ? true : false,
    group: process.env.DX_OBSERVABILITY_GROUP ?? undefined,
  };

  await writeFile(
    idPath,
    '# This file is automatically generated by the @dxos/cli.\n' + yaml.dump(observabilityState),
    'utf-8',
  );

  return observabilityState;
};

const validate = (contextString: string) => {
  const context = yaml.load(contextString) as PersistentObservabilityState;
  if (Boolean(context.installationId) && validateUuid(context.installationId!)) {
    return {
      ...context,
      disabled: process.env.DX_DISABLE_OBSERVABILITY ? true : (context.disabled ?? false),
    };
  }
};
