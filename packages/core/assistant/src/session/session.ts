//
// Copyright 2025 DXOS.org
//

import { Chunk, Context, Effect, Option, Schema, Stream } from 'effect';

import {
  createTool,
  getToolCalls,
  structuredOutputParser,
  ToolResult,
  type AgentStatus,
  type AiInputPreprocessingError,
  type ExecutableTool,
  type GenerateRequest,
  type GenerationStream,
  type ToolId,
  type ToolResolver,
} from '@dxos/ai';
import { type ArtifactDefinition } from '@dxos/artifact';
import { Event } from '@dxos/async';
import { Obj } from '@dxos/echo';
import { ObjectVersion } from '@dxos/echo-db';
import { type ObjectId } from '@dxos/echo-schema';
import { log } from '@dxos/log';

import { AiParser, AiPreprocessor } from '@dxos/ai';
import { todo } from '@dxos/debug';
import { DataType, type ContentBlock } from '@dxos/schema';
import { AiLanguageModel, type AiError, type AiResponse } from '@effect/ai';
import { AiAssistantError } from '../errors';

/**
 * Contains message history, tools, current context.
 * Current context means the state of the app, time of day, and other contextual information.
 * It makes requests to the model, its a state machine.
 * It keeps track of the current goal.
 * It manages the context window.
 * Tracks the success criteria of reaching the goal, exposing metrics (stretch)
 * Could be run locally in the app or remotely.
 * Could be personal or shared.
 */

/**
 * Resolves artifact ids to their versions.
 * Used to give the model a sense of the changes to the artifacts made by users during the conversation.
 * The artifacts versions are pinned in the history, and whenever the artifact changes in-between assistant's steps,
 * a diff is inserted into the conversation.
 *
 * Can be optionally provided to the session run call.
 */
export class ArtifactDiffResolver extends Context.Tag('ArtifactDiffResolver')<
  ArtifactDiffResolver,
  ArtifactDiffResolver.Service
>() {}

export namespace ArtifactDiffResolver {
  export type Service = {
    resolve: (artifacts: { id: ObjectId; lastVersion: ObjectVersion }[]) => Promise<
      Map<
        ObjectId,
        {
          version: ObjectVersion;
          diff?: string;
        }
      >
    >;
  };
}

export type SessionRunOptions = {
  artifacts: ArtifactDefinition[];

  /**
   * Non-artifact specific tools.
   */
  tools: ToolId[];

  history: DataType.Message[];

  prompt: string;

  generationOptions?: Pick<GenerateRequest, 'model'>;

  extensions?: ToolContextExtensions;

  systemPrompt?: string;

  /**
   * Pre-require artifacts.
   */
  requiredArtifactIds?: string[];

  toolResolver: ToolResolver;

  /**
   * Executable tools that do not go through the tool resolver.
   */
  executableTools?: ExecutableTool[];
};

type OperationModel = 'planning' | 'importing' | 'configured';

export type AiSessionOptions = {
  /**
   * Determines the agent's handling of the artifacts definitions:
   *
   * - `planning`: The model will create a plan with required artifacts for each step.
   * - `importing`: The model can query registry and only pull in the artifacts that are required to complete the task.
   * - `configured`: The available artifacts are pre-selected and the model cannot select additional artifacts.
   */
  operationModel: OperationModel;
};

export class AISession {
  /** Pending messages (incl. the current user request). */
  private _pending: DataType.Message[] = [];

  /** Current streaming response. */
  private _stream: GenerationStream | undefined;

  /** Prior history from queue. */
  private _history: DataType.Message[] = [];

  /**
   * New message.
   */
  public readonly message = new Event<DataType.Message>();

  /**
   * Complete block added to Message.
   */
  public readonly block = new Event<ContentBlock.Any>();

  /**
   * Update partial block (while streaming).
   */
  public readonly update = new Event<ContentBlock.Any>();

  /**
   * Unparsed events from the underlying generation stream.
   */
  public readonly streamEvent = new Event<AiResponse.Part>();

  /**
   * User prompt or tool result.
   */
  public readonly userMessage = new Event<DataType.Message>();

  /**
   * Agent self-reporting its status.
   * Triggered by the model.
   */
  public readonly statusReport = new Event<AgentStatus>();

  /**
   * Emits when the session is done.
   */
  public readonly done = new Event<void>();

  private readonly _semaphore = Effect.runSync(Effect.makeSemaphore(1));

  constructor(private readonly _options: AiSessionOptions) {}

  /**
   * Runs the AI model loop interacting with tools and artifacts.
   * @param options - The session options.
   * @returns The messages generated by the session, including the user's prompt.
   */
  // @synchronized
  run = (
    options: SessionRunOptions,
  ): Effect.Effect<
    DataType.Message[],
    AiAssistantError | AiInputPreprocessingError | AiError.AiError,
    AiLanguageModel.AiLanguageModel
  > =>
    Effect.gen(this, function* () {
      // const systemTools: ExecutableTool[] = [];
      // switch (this._options.operationModel) {
      //   case 'planning':
      //     systemTools.push(this._createQueryArtifactsTool(options.artifacts), this._createPlanningTool(options));
      //     break;
      //   case 'importing':
      //     systemTools.push(
      //       this._createQueryArtifactsTool(options.artifacts),
      //       this._createRequireTool(options.artifacts, (artifactDefinitionIds) => {
      //         for (const artifactDefinitionId of artifactDefinitionIds) {
      //           requiredArtifactIds.add(artifactDefinitionId);
      //         }
      //       }),
      //     );
      //     break;
      //   case 'configured':
      //     // no system tools
      //     break;
      //   default:
      //     throw new TypeError(`Invalid operation model: ${this._options.operationModel}`);
      // // }

      this._history = [...options.history];

      const promptMessages = yield* this._formatUserPrompt(options.prompt, options.history);
      this._pending = [promptMessages];
      this.userMessage.emit(promptMessages);

      // const requiredArtifactIds = new Set<string>(options.requiredArtifactIds ?? []);
      do {
        // const tools: ExecutableTool[] = pipe(
        //   [
        //     ...systemTools,
        //     ...(await Promise.all(options.tools.map((toolId) => options.toolResolver.resolve(toolId)))),
        //     ...(options.executableTools ?? []),
        //     ...options.artifacts
        //       .filter((artifact) => requiredArtifactIds.has(artifact.id))
        //       .flatMap((artifact) => artifact.tools),
        //   ],
        //   Array.dedupeWith((a, b) => a.id === b.id),
        // );

        log('request', {
          pending: this._pending.length,
          history: this._history.length,
          // tools: tools.map((tool) => tool.name),
        });

        const prompt = yield* AiPreprocessor.preprocessAiInput([...this._history, ...this._pending]);

        // Open request stream.
        // this._stream = await options.client.execStream({
        //   ...(options.generationOptions ?? {}),
        //   // TODO(burdon): Rename messages or separate history/message.
        //   history: [...this._history, ...this._pending],
        //   tools,
        //   systemPrompt:
        //     options.systemPrompt ??
        //     createBaseInstructions({
        //       availableArtifacts: [...requiredArtifactIds],
        //       operationModel: this._options.operationModel,
        //     }),
        // });
        const blocks = yield* AiLanguageModel.streamText({
          prompt,
          // toolkit,
          system: 'You are a helpful assistant.',
          disableToolCallResolution: true,
        }).pipe(AiParser.parseGptStream(), Stream.runCollect, Effect.map(Chunk.toArray));
        const response = Obj.make(DataType.Message, {
          sender: {
            role: 'assistant',
          },
          blocks,
          created: new Date().toISOString(),
        });
        this._pending.push(response);

        const toolCalls = getToolCalls(response);
        if (toolCalls.length === 0) {
          break;
        }

        todo('Implement tool execution');

        //     // const actualToolkit = Effect.isEffect(toolkit)
        //     //   ? yield* toolkit as unknown as Effect.Effect<AiToolkit.ToHandler<any>>
        //     //   : (toolkit as unknown as AiToolkit.ToHandler<any>);
        //     // const toolCalls = getToolCalls(message);
        //     // if (toolCalls.length === 0) {
        //     //   break;
        //     // }

        //     // const toolResults: ContentBlock.ToolResult[] = yield* Effect.forEach(toolCalls, (toolCall) =>
        //     //   runTool(actualToolkit, toolCall),
        //     // );
        //     history.push(
        //       Obj.make(DataType.Message, {
        //         sender: {
        //           role: 'user',
        //         },
        //         blocks: toolResults,
        //         created: new Date().toISOString(),
        //       }),
        //     );
      } while (true);

      return this._pending;
    }).pipe(this._semaphore.withPermits(1), Effect.withSpan('AISession.run'));

  async runStructured<S extends Schema.Schema.AnyNoContext>(
    schema: S,
    options: SessionRunOptions,
  ): Promise<Schema.Schema.Type<S>> {
    return todo();
    // const parser = structuredOutputParser(schema);
    // const result = await this.run({
    //   ...options,
    //   executableTools: [...(options.executableTools ?? []), parser.tool],
    // });
    // return parser.getResult(result);
  }

  private _formatUserPrompt = (prompt: string, history: DataType.Message[]) =>
    Effect.gen(function* () {
      const prelude: ContentBlock.Any[] = [];

      // TODO(dmaretskyi): Evaluate other approaches as `serviceOption` isn't represented in the type system.
      const artifactDiffResolver = yield* Effect.serviceOption(ArtifactDiffResolver);
      if (Option.isSome(artifactDiffResolver)) {
        const versions = gatherObjectVersions(history);

        const artifactDiff = yield* Effect.tryPromise({
          try: () =>
            artifactDiffResolver.value.resolve(
              [...versions.entries()].map(([id, version]) => ({ id, lastVersion: version })),
            ),
          catch: AiAssistantError.wrap('Artifact diff resolution error'),
        });

        log.info('vision', {
          artifactDiff,
          versions,
        });

        for (const [id, { version }] of [...artifactDiff.entries()]) {
          if (ObjectVersion.equals(version, versions.get(id)!)) {
            artifactDiff.delete(id);
            continue;
          }

          prelude.push({ _tag: 'artifactPin', objectId: id, version });
        }
        if (artifactDiff.size > 0) {
          prelude.push(createArtifactUpdateBlock(artifactDiff));
        }
      }

      return Obj.make(DataType.Message, {
        sender: { role: 'user' },
        blocks: [...prelude, { _tag: 'text', text: prompt }],
        created: new Date().toUTCString(),
      });
    });

  private _createQueryArtifactsTool(artifacts: ArtifactDefinition[]): ExecutableTool {
    return createTool('system', {
      name: 'query_artifact_definitions',
      description: 'Query the available artifact definitions',
      schema: Schema.Struct({}),
      execute: async () => {
        return ToolResult.Success({
          artifactDefinitions: artifacts.map((artifact) => ({
            id: artifact.id,
            name: artifact.name,
            description: artifact.description,
          })),
        });
      },
    });
  }

  private _createRequireTool(
    artifacts: ArtifactDefinition[],
    onRequire: (artifactDefinitionIds: readonly string[]) => void,
  ): ExecutableTool {
    return createTool('system', {
      name: 'require_artifact_definitions',
      description:
        'Require the use of specific artifact definitions. This will allow the model to interact with artifact definitions and use their tools.',
      schema: Schema.Struct({
        artifactDefinitionIds: Schema.Array(Schema.String).annotations({
          description: 'The ids of the artifact definitions to require',
          examples: [['artifact:dxos.org/example/Test']],
        }),
      }),
      execute: async ({ artifactDefinitionIds }) => {
        const missingArtifactDefinitionIds = artifactDefinitionIds.filter(
          (artifactId) => !artifacts.some((artifact) => artifact.id === artifactId),
        );
        if (missingArtifactDefinitionIds.length > 0) {
          return ToolResult.Error(
            `One or more artifact definition ids are invalid: ${missingArtifactDefinitionIds.join(', ')}`,
          );
        }

        onRequire(artifactDefinitionIds);

        return ToolResult.Success({});
      },
    });
  }

  abort(): void {
    this._stream?.abort();
  }
}

// TODO(burdon): Use handlebars template with effect-schema input.
const createBaseInstructions = ({
  availableArtifacts,
  operationModel,
}: {
  availableArtifacts: string[];
  operationModel: OperationModel;
}) => `
  You are a friendly, advanced AI assistant capable of creating and managing artifacts from available data and tools. 
  Your task is to process user commands and questions and decide how best to respond.
  In some cases, you will need to create or reference data objects called artifacts.

  Follow these guidelines carefully:

  Decision-making:

  - Analyze the structure and type of the content in the user's message.
  
  
  ${
    operationModel === 'planning'
      ? `
      - Can you complete the task using the available artifacts?
      - If you can't complete the task using the available artifacts, query the list of available artifacts using the appropriate tool.
      - Identify which artifacts are relevant to the user's request.
        - Break down the user's request into a step-by-step plan that you will use to execute the user's request, the plan items should include artifacts which will be used to perform the actions.
      `
      : ''
  }
  ${
    operationModel === 'importing'
      ? `
      - Can you complete the task using the available artifacts?
      - If you can't complete the task using the available artifacts, query the list of available artifacts using the appropriate tool.
      - Identify which artifacts are relevant to the user's request.
    - Are the required artifacts already available?
    - If not, select which artifact(s) will be the most relevant and require them using the require_artifacts tool.
    - The require'd artifact tools will be available for use after require.
  `
      : ''
  }
  ${
    operationModel === 'configured'
      ? `
    - Select the most relevant artifact(s) to complete the task.
    - Call the appropriate tool to use the artifact(s).
  `
      : ''
  }

  ${availableArtifacts.length > 0 ? `Artifacts already in context: ${availableArtifacts.join('\n')}` : ''}
`;

const gatherObjectVersions = (messages: DataType.Message[]): Map<ObjectId, ObjectVersion> => {
  const artifactIds = new Map<ObjectId, ObjectVersion>();
  for (const message of messages) {
    for (const block of message.blocks) {
      if (block._tag === 'artifactPin') {
        artifactIds.set(block.objectId, block.version as ObjectVersion);
      }
    }
  }

  return artifactIds;
};

const createArtifactUpdateBlock = (
  artifactDiff: Map<ObjectId, { version: ObjectVersion; diff?: string }>,
): ContentBlock.Any => {
  return {
    _tag: 'text',
    // TODO(dmaretskyi): Does this need to be a special content-block?
    disposition: 'artifact-update',
    text: `
      The following artifacts have been updated since the last message:
      ${[...artifactDiff.entries()]
        .map(([id, { diff }]) => `<changed-artifact id="${id}">${diff ? `\n${diff}` : ''}</changed-artifact>`)
        .join('\n')}
    `,
  };
};
