// Code generated by protoc-gen-go-dxrpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-dxrpc v0.0.1
// - protoc              v3.20.3
// source: dxos/mesh/signal.proto

package signal

import (
	context "context"
	errors "errors"
	dxrpc "github.com/dxos/dxos/dxrpc"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the dxrpc package it is being compiled against.
const _ = dxrpc.SupportPackageIsVersion1

// SignalClient is the client API for Signal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SignalClient interface {
	Join(ctx context.Context, in *JoinRequest, opts ...dxrpc.CallOption) (Signal_JoinClient, error)
	ReceiveMessages(ctx context.Context, in *ReceptionRequest, opts ...dxrpc.CallOption) (Signal_ReceiveMessagesClient, error)
	SendMessage(ctx context.Context, in *Message, opts ...dxrpc.CallOption) (*emptypb.Empty, error)
}

type signalClient struct {
	cc dxrpc.ClientConnInterface
}

func NewSignalClient(cc dxrpc.ClientConnInterface) SignalClient {
	return &signalClient{cc}
}

func (c *signalClient) Join(ctx context.Context, in *JoinRequest, opts ...dxrpc.CallOption) (Signal_JoinClient, error) {
	stream, err := c.cc.NewStream(ctx, &Signal_ServiceDesc.Streams[0], "dxos.mesh.signal.Signal.Join", opts...)
	if err != nil {
		return nil, err
	}
	x := &signalJoinClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	return x, nil
}

type Signal_JoinClient interface {
	Recv() (*SwarmEvent, error)
	dxrpc.ClientStream
}

type signalJoinClient struct {
	dxrpc.ClientStream
}

func (x *signalJoinClient) Recv() (*SwarmEvent, error) {
	m := new(SwarmEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *signalClient) ReceiveMessages(ctx context.Context, in *ReceptionRequest, opts ...dxrpc.CallOption) (Signal_ReceiveMessagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Signal_ServiceDesc.Streams[1], "dxos.mesh.signal.Signal.ReceiveMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &signalReceiveMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	return x, nil
}

type Signal_ReceiveMessagesClient interface {
	Recv() (*Message, error)
	dxrpc.ClientStream
}

type signalReceiveMessagesClient struct {
	dxrpc.ClientStream
}

func (x *signalReceiveMessagesClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *signalClient) SendMessage(ctx context.Context, in *Message, opts ...dxrpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "dxos.mesh.signal.Signal.SendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignalServer is the server API for Signal service.
// All implementations must embed UnimplementedSignalServer
// for forward compatibility
type SignalServer interface {
	Join(*JoinRequest, Signal_JoinServer) error
	ReceiveMessages(*ReceptionRequest, Signal_ReceiveMessagesServer) error
	SendMessage(context.Context, *Message) (*emptypb.Empty, error)
	mustEmbedUnimplementedSignalServer()
}

// UnimplementedSignalServer must be embedded to have forward compatible implementations.
type UnimplementedSignalServer struct {
}

func (UnimplementedSignalServer) Join(*JoinRequest, Signal_JoinServer) error {
	return errors.New("method Join not implemented")
}
func (UnimplementedSignalServer) ReceiveMessages(*ReceptionRequest, Signal_ReceiveMessagesServer) error {
	return errors.New("method ReceiveMessages not implemented")
}
func (UnimplementedSignalServer) SendMessage(context.Context, *Message) (*emptypb.Empty, error) {
	return nil, errors.New("method SendMessage not implemented")
}
func (UnimplementedSignalServer) mustEmbedUnimplementedSignalServer() {}

// UnsafeSignalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignalServer will
// result in compilation errors.
type UnsafeSignalServer interface {
	mustEmbedUnimplementedSignalServer()
}

func RegisterSignalServer(s dxrpc.ServiceRegistrar, srv SignalServer) {
	s.RegisterService(&Signal_ServiceDesc, srv)
}

func _Signal_Join_Handler(srv interface{}, stream dxrpc.ServerStream) error {
	m := new(JoinRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SignalServer).Join(m, &signalJoinServer{stream})
}

type Signal_JoinServer interface {
	Send(*SwarmEvent) error
	dxrpc.ServerStream
}

type signalJoinServer struct {
	dxrpc.ServerStream
}

func (x *signalJoinServer) Send(m *SwarmEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Signal_ReceiveMessages_Handler(srv interface{}, stream dxrpc.ServerStream) error {
	m := new(ReceptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SignalServer).ReceiveMessages(m, &signalReceiveMessagesServer{stream})
}

type Signal_ReceiveMessagesServer interface {
	Send(*Message) error
	dxrpc.ServerStream
}

type signalReceiveMessagesServer struct {
	dxrpc.ServerStream
}

func (x *signalReceiveMessagesServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Signal_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(proto.Message) error) (proto.Message, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	return srv.(SignalServer).SendMessage(ctx, in)
}

// Signal_ServiceDesc is the dxrpc.ServiceDesc for Signal service.
// It's only intended for direct use with dxrpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Signal_ServiceDesc = dxrpc.ServiceDesc{
	ServiceName: "dxos.mesh.signal.Signal",
	HandlerType: (*SignalServer)(nil),
	Methods: []dxrpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _Signal_SendMessage_Handler,
		},
	},
	Streams: []dxrpc.StreamDesc{
		{
			StreamName:    "Join",
			Handler:       _Signal_Join_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReceiveMessages",
			Handler:       _Signal_ReceiveMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dxos/mesh/signal.proto",
}
