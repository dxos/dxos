//
// Copyright 2021 DXOS.org
//

syntax = "proto3";

import "google/protobuf/empty.proto";

import "dxos/config.proto";
import "dxos/halo/credentials.proto";
import "dxos/mesh/teleport/gossip.proto";
import "dxos/keys.proto";

// TODO(burdon): Reorganize packages (e.g., client.services, echo.database).

package dxos.client.services;

//
// Design notes:
// - Basic CRUD methods for records (streaming queries).
// - Custom Request/Response objects for complex operations; otherwise generic structs for simplicity.
// - Normalize records for performance (e.g., Space members separate from Space metadata).
//

enum SystemStatus {
  ACTIVE = 0;
  INACTIVE = 1;
}

message UpdateSystemStatusRequest {
  SystemStatus status = 1;
}

message SystemStatusResponse {
  SystemStatus status = 1;
}

//
// System
//

service SystemService {
  /// Get the static config of the client.
  rpc GetConfig(google.protobuf.Empty) returns (dxos.config.Config);

  /// Update the status of the client. Used to re-activate an inactive client.
  rpc UpdateStatus(UpdateSystemStatusRequest) returns (google.protobuf.Empty);

  /// Stream the status of the client.
  rpc QueryStatus(google.protobuf.Empty) returns (stream SystemStatusResponse);

  /// Reset the client.
  rpc Reset(google.protobuf.Empty) returns (google.protobuf.Empty);
}

//
// Halo
//

message Identity {
  dxos.keys.PublicKey identity_key = 1;
  optional dxos.keys.PublicKey space_key = 2;
  optional halo.credentials.ProfileDocument profile = 3;
}

message RecoverIdentityRequest {
  bytes recovery_key = 1;
}

message QueryIdentityResponse {
  optional Identity identity = 1;
}

message SignPresentationRequest {
  dxos.halo.credentials.Presentation presentation = 1;
  optional bytes nonce = 2;
}

// TODO(wittjosiah): Align pluralization with other services.
service IdentityService {
  rpc CreateIdentity(halo.credentials.ProfileDocument) returns (Identity);
  rpc RecoverIdentity(RecoverIdentityRequest) returns (Identity);
  rpc QueryIdentity(google.protobuf.Empty) returns (stream QueryIdentityResponse);

  rpc SignPresentation(SignPresentationRequest) returns (dxos.halo.credentials.Presentation);
}

//
// Devices
//

enum DeviceKind {
  CURRENT = 0;
  TRUSTED = 1;
}

// TODO(burdon): Preferences (in database).
message Device {
  dxos.keys.PublicKey device_key = 1;
  DeviceKind kind = 2;
  optional halo.credentials.ProfileDocument profile = 3;
}

message QueryDevicesResponse {
  repeated Device devices = 1;
}

service DevicesService {
  rpc UpdateDevice(halo.credentials.ProfileDocument) returns (Device);
  rpc QueryDevices(google.protobuf.Empty) returns (stream QueryDevicesResponse);
}

//
// Contacts
//

message Contact {
  halo.credentials.ProfileDocument profile = 1;
}

service ContactsService {
  rpc UpdateContact(google.protobuf.Empty) returns (Contact);
  rpc QueryContacts(google.protobuf.Empty) returns (stream Contact);
}

//
// Data Spaces
// TODO(burdon): Move to dxos.echo? Or rename dxos.echo => dxos.database?
//

message SpaceMember {
  enum PresenceState {
    OFFLINE = 0;
    ONLINE = 1;
  }

  Identity identity = 1;
  PresenceState presence = 2;
}

/// Runtime state of the space object.
enum SpaceState {
  /// Space is closed.
  CLOSED = 1;

  /// Space is inactive. Database is not available.
  INACTIVE = 2;

  /// Data pipeline is initializing.
  INITIALIZING = 4;

  /// Data pipeline is ready.
  READY = 3;
}

message Space {
  // TODO(dmaretskyi): Consider merging with space metadata records.
  // TODO(dmaretskyi): ...or split into two separate pipeline messages.
  message PipelineState {
    optional dxos.keys.PublicKey control_feed_key = 1;
    optional dxos.keys.PublicKey data_feed_key = 2;

    optional timeframe.TimeframeVector current_control_timeframe = 10;
    optional timeframe.TimeframeVector target_control_timeframe = 11;
    optional timeframe.TimeframeVector current_data_timeframe = 12;
    optional timeframe.TimeframeVector target_data_timeframe = 13;

    // TODO(dmaretskyi): Snapshot & epoch info.
  }

  dxos.keys.PublicKey space_key = 1;
  SpaceState state = 2;
  optional PipelineState pipeline = 3;

  repeated SpaceMember members = 10;

  // TODO(dmaretskyi): Inline a snapshot of space.properties here so that inactive spaces still display their title.
}

message UpdateSpaceRequest {
  optional Status status = 1;
}

message QuerySpacesResponse {
  repeated Space spaces = 1;
}

message PostMessageRequest {
  dxos.keys.PublicKey space_key = 1;
  string channel = 2;
  google.protobuf.Any message = 3;
}

message SubscribeMessagesRequest {
  dxos.keys.PublicKey space_key = 1;
  string channel = 2;
}

message WriteCredentialsRequest {
  dxos.keys.PublicKey space_key = 1;
  repeated dxos.halo.credentials.Credential credentials = 2;
}

message QueryCredentialsRequest {
  dxos.keys.PublicKey space_key = 1;
}

service SpacesService {
  rpc CreateSpace(google.protobuf.Empty) returns (Space);
  rpc UpdateSpace(UpdateSpaceRequest) returns (google.protobuf.Empty);
  rpc QuerySpaces(google.protobuf.Empty) returns (stream QuerySpacesResponse);

  rpc PostMessage(PostMessageRequest) returns (google.protobuf.Empty);
  rpc SubscribeMessages(SubscribeMessagesRequest) returns (stream dxos.mesh.teleport.gossip.GossipMessage);

  /// Write credentials to the space control feed.
  rpc WriteCredentials(WriteCredentialsRequest) returns (google.protobuf.Empty);
  /// Query credentials from the space control feed.
  rpc QueryCredentials(QueryCredentialsRequest) returns (stream dxos.halo.credentials.Credential);
}

//
// Invitations (Halo and Data Spaces).
//

/**
 * Represents the invitation state passed between client and service.
 */
message Invitation {
  enum Type {
    /// Requires both to be online to complete key exchange.
    INTERACTIVE = 0;
    /// Guest's identity key is known; invitation can be accepted by any valid peer.
    OFFLINE = 1;
    /// Multiple-use interactive invitation.
    MULTIUSE = 2;
  }

  enum Kind {
    DEVICE = 0;
    SPACE = 1;
  }

  enum AuthMethod {
    /// No authnetication is required. Guest should not call `Authenticate`.
    NONE = 0;

    /// Guest should call `Authenticate` with the shared secret.
    SHARED_SECRET = 1;
  }

  enum State {
    INIT = 0;
    CONNECTING = 1;
    CONNECTED = 2;
    AUTHENTICATING = 3;
    SUCCESS = 4;
    CANCELLED = 5;
    TIMEOUT = 6;
    ERROR = 7;
  }

  /// Local identifier (random).
  string invitation_id = 1;

  /// Determines the behavior of the invitation.
  Type type = 2;

  /// Kind of access the invitation will grant.
  Kind kind = 3;

  /// How the invitation is authenticated.
  AuthMethod auth_method = 4;

  /// Swarm rendezvous (random).
  dxos.keys.PublicKey swarm_key = 5;

  /// Local state.
  State state = 6;

  /// Timeout (ms).
  optional int32 timeout = 7;

  /// Guest's identity.
  optional dxos.keys.PublicKey identity_key = 8;

  /// Space to join (only present if kind is SPACE).
  optional dxos.keys.PublicKey space_key = 9;

  /// Authentication code created by host (only present if auth_method is SHARED_SECRET).
  optional string authentication_code = 10;
}

message AuthenticationRequest {
  string invitation_id = 1;
  string authentication_code = 2;
}

message CancelInvitationRequest {
  string invitation_id = 1;
}

service InvitationsService {
  rpc CreateInvitation(Invitation) returns (stream Invitation);
  rpc Authenticate(AuthenticationRequest) returns (google.protobuf.Empty);
  rpc AcceptInvitation(Invitation) returns (stream Invitation);
  rpc CancelInvitation(CancelInvitationRequest) returns (google.protobuf.Empty);
}

//
// MESH
//

enum ConnectionState {
  OFFLINE = 0;
  ONLINE = 1;
}

// TODO(mykola): Broden API.
message NetworkStatus {
  ConnectionState state = 1;
}

message SetNetworkOptionsRequest {
  ConnectionState state = 1;
}

// TODO(burdon): Widen API (too heavy for single feature: e.g., status).
service NetworkService {
  // TODO(wittjosiah): Align verbs with other services.
  rpc SubscribeToNetworkStatus(google.protobuf.Empty) returns (stream NetworkStatus);
  rpc SetNetworkOptions(SetNetworkOptionsRequest) returns (google.protobuf.Empty);
}
