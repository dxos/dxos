//
// Copyright 2022 DXOS.org
//

syntax = "proto3";

package dxos.halo.credentials;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

import "dxos/keys.proto";

//
// TODO(burdon): Reference/extract these notes to the design doc commentary.
// Peers maintain Feeds that are admitted to HALO and ECHO Spaces.
// Peers act as Verifiers for Credentials that may be Presented from other Peers.
// Since Feeds implement a signed hash-linked data structure, they constitute a chain-of-authority for chained Credentials.
// Credentials written to HALO Feeds may be Presented to Peers Verifying ECHO Spaces.
//

//
// **SpaceGenesis** -
// First message written to initial Feed in a new Space.
//

// [ASSERTION]
message SpaceGenesis {
  dxos.keys.PublicKey space_key = 1; // Feeds belong to Spaces.
}

//
// **Claim** -
// Statement about a subject.
// Claims can be written directly to a feed or used within Credentials.
//

// TODO(burdon): Reconcile with dxos.client.SpaceMember.
// [ASSERTION]:  Agent is authorized to access Space.
message SpaceMember {
  // TODO(burdon): Consider permissions (e.g., for Bots).
  enum Role {
    INVALID = 0;
    /// Manage members.
    ADMIN = 1;
    /// Read and write.
    MEMBER = 2;
    /// Read-only.
    READER = 3;
  }

  dxos.keys.PublicKey space_key = 1;
  Role role = 2;

  // TODO: Move elsewhere.
  optional ProfileDocument profile = 3;
}

// [ASSERTION]: Device is authorized to sign messages for a given Agent (Identity).
// NOTE: Devices are Admitted to Identities.
message AuthorizedDevice {
  dxos.keys.PublicKey identity_key = 1;
  dxos.keys.PublicKey device_key = 2; // Existing authorized device.
}

// [ASSERTION]: Feed is admitted to the Space for replication.
// NOTE: Feeds are Admitted to Spaces.
message AdmittedFeed {
  enum Designation {
    /// Classic general purpose feeds for both HALO and ECHO messages together. To be deprecated.
    GENERAL = 0;
    /// Contain system-level messages messages, such as credentials and epochs.
    CONTROL = 1;
    /// Database mutations.
    DATA = 2;
  }

  dxos.keys.PublicKey space_key = 1;

  /// Owning identity.
  dxos.keys.PublicKey identity_key = 2; // Could be derived.
  /// Owning device.
  dxos.keys.PublicKey device_key = 3;

  /// Controls sets the feed designation.
  /// Feeds with different designations are consumed by separate pipelines.
  Designation designation = 4;
}

/// [ASSERTION]: Associtaes a space that will implement Agent's HALO with an Identity.
message HaloSpace {
  dxos.keys.PublicKey identity_key = 1;
  /// Space key.
  dxos.keys.PublicKey halo_key = 2;
}

/// [ASSERTION]: Grants recovery permissions to a recovery key.
message IdentityRecovery {
  dxos.keys.PublicKey identity_key = 1;
  /// Public key derrived from the recovery seedphrase.
  dxos.keys.PublicKey recovery_key = 2;
}

message ProfileDocument {
  optional string display_name = 1;
  optional string avatar_cid = 2;
}

/// [ASSERTION]: Sets profile information.
message IdentityProfile {

  // TODO(dmaretskyi): This could also be a DXNS link or stored in user's public HALO (we could also index the public HALO in the DMG).
  ProfileDocument profile = 1;
}

/// Metadata associated with a key.
/// Subject must be a key being referenced.
message KeyInfo {
  optional string name = 1;
}

/// Assertion for agents authenticating in the space swarm.
message Auth {
}

//
// **Claim** -
// Statement about a subject.
// Claims can be written directly to a feed or used within Credentials.
//

message Claim {
  dxos.keys.PublicKey id = 1;                     // Subject of claim (e.g., Agent, Device, Feed).
  google.protobuf.Any assertion = 2;
}

//
// **Proof** -
// Signature that makes Credential tamper-evident.
// The proof is signed by the issuer of the Credential.
// Ref: https://www.w3.org/TR/vc-data-model/#proofs-signatures
//

message Proof {
  string type = 1;                                // Type of proof (e.g., "Ed25519Signature2020").
  google.protobuf.Timestamp creation_date = 2;
  dxos.keys.PublicKey signer = 3;                 // Entity that created the proof (e.g., Agent, Device, Space).
  optional bytes nonce = 4;                       // Used in Presentations to protect against replay attacks.

  /// Signature (excluded from signed data).
  bytes value = 5;

  /**
   * Must be present if signer is not credential issuer.
   * Establishes the authority of the signer. Proves that the signer can issue such credentials.
   * Excluded from signed data.
   */
  optional Chain chain = 6;
}

/**
 * A chain of credentials that establishes the delegated authority to issue new credentials.
 * Each key in the chain has an assotiated credential that establishes the authrity of that specific key.
 *
 * Example:
 *   Alice/Device-2 => Alice/Device-1 => Alice
 *
 * This chain would include 2 credentials:
 *   1. Giving Alice/Device-2 the authority to issue credentials on behalf of Alice, signed by Alice/Device-1.
 *   2. Giving Alice/Device-1 the authority to issue credentials on behalf of Alice, signed by Alice.
 */
message Chain {
  /// Credential that authorizes the subject to issue new credentials (can be recursive).
  Credential credential = 1;
}

//
// **Credential** -
// Set of claims containing a proof signed by the issuer.
// Credentials may be stored in a Credential Repository (e.g., digital wallet.)
// Credentials may also be store within feeds (e.g., an agent's HALO).
//

message Credential {
  optional dxos.keys.PublicKey id = 1;                      // Credential identifier (e.g., for storage indexing).
  dxos.keys.PublicKey issuer = 2;                           // key = { Space (genesis) | Identity (genesis) | (authorized) Device }
  google.protobuf.Timestamp issuance_date = 3;
  optional google.protobuf.Timestamp expiration_date = 4;
  optional bytes expiration_ref = 5;                        // Could reference blockchain or epoch number.
  Claim subject = 10;
  Proof proof = 11;
}

//
// **Presentation** -
// Signed Credential(s) sent to a Verifier.
// Presentations are typically NOT stored any may include a challenge (e.g., nonce).
// Presentations may contain multiple Credentials (and require multiple proofs).
//

message Presentation {
  repeated Credential credentials = 1;
  repeated Proof proofs = 2;
}

//
// **Metadata** -
// Persistent metadata stored outside of used to bootsrapt the stack.
//

/// Information needed to bootstrap a Space.
message SpaceRecord {
  dxos.keys.PublicKey space_key = 1;

  /// All feeds in the space must form a DAG (or a tree?)
  ///   This is the root feed of that structure.
  dxos.keys.PublicKey genesis_feed_key = 2;

  /// Key of the writable feed for control messages.
  ///   Keyring must have the associated private key.
  dxos.keys.PublicKey write_control_feed_key = 3;

  /// Key of the writable feed for data messages.
  ///   Keyring must have the associated private key.
  dxos.keys.PublicKey write_data_feed_key = 4;
}

/// Information needed to bootstrap an Identity.
message IdentityRecord {
  dxos.keys.PublicKey identity_key = 1;
  dxos.keys.PublicKey device_key = 2;

  SpaceRecord halo_space = 3;

  /// Public profile information.
  /// TODO(burdon): Not yet implemented. Must be null.
  optional SpaceRecord profile_space = 4;

  /// Cached profile.
  optional ProfileDocument profile = 5;
}
