// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file proto/messenger.proto (package dxos.mesh.messenger, syntax proto2)
/* eslint-disable */
// @ts-nocheck

//
// The messenger protocol supports routing messages between peers.
//

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message as Message$1, proto2 } from "@bufbuild/protobuf";

/**
 *
 * Network peer.
 *
 * TODO(burdon): Distinguish between point-to-point and broadcast messaging.
 * TODO(burdon): Rename PeerInfo?
 *
 * @generated from message dxos.mesh.messenger.Peer
 */
export class Peer extends Message$1<Peer> {
  /**
   * TODO(burdon): Rename topic?
   *
   * @generated from field: optional string swarmKey = 1;
   */
  swarmKey?: string;

  /**
   * @generated from field: optional string identityKey = 2;
   */
  identityKey?: string;

  /**
   * @generated from field: required string peerKey = 3;
   */
  peerKey?: string;

  constructor(data?: PartialMessage<Peer>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "dxos.mesh.messenger.Peer";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "swarmKey", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "identityKey", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "peerKey", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Peer {
    return new Peer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Peer {
    return new Peer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Peer {
    return new Peer().fromJsonString(jsonString, options);
  }

  static equals(a: Peer | PlainMessage<Peer> | undefined, b: Peer | PlainMessage<Peer> | undefined): boolean {
    return proto2.util.equals(Peer, a, b);
  }
}

/**
 *
 * Message envelope.
 *
 *
 * @generated from message dxos.mesh.messenger.Message
 */
export class Message extends Message$1<Message> {
  /**
   * @generated from field: optional string timestamp = 1;
   */
  timestamp?: string;

  /**
   * Routing.
   *
   * @generated from field: optional dxos.mesh.messenger.Peer source = 10;
   */
  source?: Peer;

  /**
   * @generated from field: repeated dxos.mesh.messenger.Peer target = 11;
   */
  target: Peer[] = [];

  /**
   * TODO(burdon): Routing info.
   *
   * @generated from field: optional string service_id = 20;
   */
  serviceId?: string;

  /**
   * @generated from field: optional google.protobuf.Any payload = 100;
   */
  payload?: Any;

  constructor(data?: PartialMessage<Message>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "dxos.mesh.messenger.Message";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "source", kind: "message", T: Peer, opt: true },
    { no: 11, name: "target", kind: "message", T: Peer, repeated: true },
    { no: 20, name: "service_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 100, name: "payload", kind: "message", T: Any, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message {
    return new Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJsonString(jsonString, options);
  }

  static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean {
    return proto2.util.equals(Message, a, b);
  }
}

/**
 *
 * Swarms are used to publish and subscribe to messages based on a topic.
 *
 *
 * @generated from message dxos.mesh.messenger.SwarmRequest
 */
export class SwarmRequest extends Message$1<SwarmRequest> {
  /**
   * @generated from field: optional dxos.mesh.messenger.SwarmRequest.Action action = 1;
   */
  action?: SwarmRequest_Action;

  /**
   * TODO(burdon): Rename topic?
   *
   * @generated from field: repeated string swarmKeys = 2;
   */
  swarmKeys: string[] = [];

  constructor(data?: PartialMessage<SwarmRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "dxos.mesh.messenger.SwarmRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "action", kind: "enum", T: proto2.getEnumType(SwarmRequest_Action), opt: true },
    { no: 2, name: "swarmKeys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwarmRequest {
    return new SwarmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwarmRequest {
    return new SwarmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwarmRequest {
    return new SwarmRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SwarmRequest | PlainMessage<SwarmRequest> | undefined, b: SwarmRequest | PlainMessage<SwarmRequest> | undefined): boolean {
    return proto2.util.equals(SwarmRequest, a, b);
  }
}

/**
 * @generated from enum dxos.mesh.messenger.SwarmRequest.Action
 */
export enum SwarmRequest_Action {
  /**
   * @generated from enum value: INFO = 0;
   */
  INFO = 0,

  /**
   * @generated from enum value: JOIN = 1;
   */
  JOIN = 1,

  /**
   * @generated from enum value: LEAVE = 2;
   */
  LEAVE = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(SwarmRequest_Action)
proto2.util.setEnumType(SwarmRequest_Action, "dxos.mesh.messenger.SwarmRequest.Action", [
  { no: 0, name: "INFO" },
  { no: 1, name: "JOIN" },
  { no: 2, name: "LEAVE" },
]);

/**
 * @generated from message dxos.mesh.messenger.SwarmResponse
 */
export class SwarmResponse extends Message$1<SwarmResponse> {
  /**
   * @generated from field: required string swarmKey = 1;
   */
  swarmKey?: string;

  /**
   * @generated from field: repeated dxos.mesh.messenger.Peer peers = 2;
   */
  peers: Peer[] = [];

  constructor(data?: PartialMessage<SwarmResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "dxos.mesh.messenger.SwarmResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "swarmKey", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 2, name: "peers", kind: "message", T: Peer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwarmResponse {
    return new SwarmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwarmResponse {
    return new SwarmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwarmResponse {
    return new SwarmResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SwarmResponse | PlainMessage<SwarmResponse> | undefined, b: SwarmResponse | PlainMessage<SwarmResponse> | undefined): boolean {
    return proto2.util.equals(SwarmResponse, a, b);
  }
}

/**
 *
 * Text message.
 *
 *
 * @generated from message dxos.mesh.messenger.TextMessage
 */
export class TextMessage extends Message$1<TextMessage> {
  /**
   * @generated from field: optional string message = 1;
   */
  message?: string;

  constructor(data?: PartialMessage<TextMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "dxos.mesh.messenger.TextMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextMessage {
    return new TextMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextMessage {
    return new TextMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextMessage {
    return new TextMessage().fromJsonString(jsonString, options);
  }

  static equals(a: TextMessage | PlainMessage<TextMessage> | undefined, b: TextMessage | PlainMessage<TextMessage> | undefined): boolean {
    return proto2.util.equals(TextMessage, a, b);
  }
}

