//
// Copyright 2025 DXOS.org
//

import { afterEach, beforeEach, describe, expect, test } from 'vitest';

import { Filter, Query, Relation } from '@dxos/echo';
import { Obj } from '@dxos/echo';
import { TestSchema } from '@dxos/echo/testing';

import { type Hypergraph } from '../hypergraph';
import { EchoTestBuilder } from '../testing';

import { type EchoDatabase } from './database';

describe('Relations', () => {
  let testBuilder: EchoTestBuilder;
  let db: EchoDatabase;
  let graph: Hypergraph;

  beforeEach(async () => {
    testBuilder = await new EchoTestBuilder().open();
    ({ db, graph } = await testBuilder.createDatabase());
    graph.schemaRegistry.addSchema([TestSchema.Person, TestSchema.HasManager]);
  });

  afterEach(async () => {
    await testBuilder.close();
  });

  test('create relation between two objects', async () => {
    const user1 = db.add(Obj.make(TestSchema.Person, { name: 'Alice' }));
    const user2 = db.add(Obj.make(TestSchema.Person, { name: 'Bob' }));

    const manager = db.add(
      Relation.make(TestSchema.HasManager, {
        [Relation.Source]: user1,
        [Relation.Target]: user2,
        // since: '2022',
      }),
    );

    expect(Relation.isRelation(manager)).to.be.true;
    expect(Relation.getSource(manager) === user1).to.be.true;
    expect(Relation.getTarget(manager) === user2).to.be.true;
    expect(manager.since).to.equal('2022');

    await db.flush({ indexes: true });
    await testBuilder.lastPeer!.reload();
    {
      const db = await testBuilder.lastPeer!.openLastDatabase();
      const { objects } = await db.query(Query.select(Filter.everything())).run();

      const manager = objects.find((obj) => Relation.isRelation(obj));
      expect(manager).toBeDefined();

      expect(Relation.isRelation(manager)).to.be.true;
      expect(Relation.getSource(manager).name).toEqual('Alice');
      expect(Relation.getTarget(manager).name).toEqual('Bob');
      expect(manager.since).to.equal('2022');
    }
  });
});
