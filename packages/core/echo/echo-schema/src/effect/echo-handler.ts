//
// Copyright 2024 DXOS.org
//

import * as S from '@effect/schema/Schema';
import { type Brand } from 'effect';
import { inspect, type InspectOptionsStylized } from 'node:util';

import { Reference } from '@dxos/echo-db';
import { compositeRuntime } from '@dxos/echo-signals/runtime';
import { invariant } from '@dxos/invariant';
import { assignDeep, ComplexMap, defaultMap, getDeep } from '@dxos/util';

import { DynamicEchoSchema } from './dynamic/dynamic-schema';
import { StoredEchoSchema } from './dynamic/stored-schema';
import {
  createReactiveProxy,
  getProxyHandlerSlot,
  isReactiveProxy,
  symbolIsProxy,
  type ReactiveHandler,
} from './proxy';
import { getSchema, getTypeReference, type EchoReactiveObject, EchoReactiveHandler } from './reactive';
import { getTargetMeta } from './reactive-meta-handler';
import { SchemaValidator } from './schema-validator';
import { AutomergeObjectCore, META_NAMESPACE } from '../automerge/automerge-object-core';
import { type KeyPath } from '../automerge/key-path';
import { encodeReference } from '../automerge/types';
import { data, type ObjectMeta } from '../object';
import { defineHiddenProperty } from '../util/property';

const symbolPath = Symbol('path');
const symbolNamespace = Symbol('namespace');
const symbolHandler = Symbol('handler');
const symbolInternals = Symbol('internals');

/**
 * Generic proxy target type for ECHO handler.
 * Targets can either be objects or arrays (instances of `EchoArrayTwoPointO`).
 * Every targets holds a set of hidden properties on symbols.
 */
type ProxyTarget = {
  [symbolInternals]: ObjectInternals;
  /**
   * `data` or `meta` namespace.
   */
  [symbolNamespace]: string;

  /**
   * Path within the namespace.
   *
   * Root objects have an empty path: `[]`.
   */
  [symbolPath]: KeyPath;

  /**
   * Reference to the handler.
   */
  // TODO(dmaretskyi): Can be removed.
  [symbolHandler]?: EchoReactiveHandler;
} & ({ [key: keyof any]: any } | EchoArrayTwoPointO<any>);

/**
 * Extends the native array with methods overrides for automerge.
 */
// TODO(dmaretskyi): Rename once the original AutomergeArray gets deleted.
class EchoArrayTwoPointO<T> extends Array<T> {
  static get [Symbol.species]() {
    return Array;
  }

  // Will be initialize when the proxy is created.
  [symbolInternals]: ObjectInternals = null as any;
  [symbolPath]: KeyPath = null as any;
  [symbolNamespace]: string = null as any;
  [symbolHandler]: EchoReactiveHandler = null as any;

  static {
    /**
     * These methods will trigger proxy traps like `set` and `defineProperty` and emit signal notifications.
     * We wrap them in a batch to avoid unnecessary signal notifications.
     */
    const BATCHED_METHODS = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] as const;

    for (const method of BATCHED_METHODS) {
      const handlerMethodName = `array${method.slice(0, 1).toUpperCase()}${method.slice(1)}`;

      Object.defineProperty(this.prototype, method, {
        enumerable: false,
        value: function (this: EchoArrayTwoPointO<any>, ...args: any[]) {
          let result!: any;
          compositeRuntime.batch(() => {
            const handler = this[symbolHandler] as any;
            result = (handler[handlerMethodName] as any).apply(handler, [this, this[symbolPath], ...args]);
          });
          return result;
        },
      });
    }
  }
}

/**
 * For tracking proxy targets in the `targetsMap`.
 */
type TargetKey = {
  path: KeyPath;
  namespace: string;
  type: 'record' | 'array';
} & Brand.Brand<'TargetKey'>;

const TargetKey = {
  /**
   * Constructor function forces the order of the fields.
   */
  new: (path: KeyPath, namespace: string, type: 'record' | 'array'): TargetKey =>
    ({
      path,
      namespace,
      type,
    }) as TargetKey,
  hash: (key: TargetKey): string => JSON.stringify(key),
};

type ObjectInternals = {
  core: AutomergeObjectCore;

  /**
   * Caching targets based on key path.
   * Only used for records and arrays.
   */
  // TODO(dmaretskyi): We need to include data type in the map key. it's safe for typed objects since fields cannot change from record to array and vice versa, but its gonna be a bug for untyped objects.
  targetsMap: ComplexMap<KeyPath, ProxyTarget>;
};

const PROPERTY_ID = 'id';

const DATA_NAMESPACE = 'data';

/**
 * Shared for all targets within one ECHO object.
 */
export class EchoReactiveHandlerImpl extends EchoReactiveHandler implements ReactiveHandler<ProxyTarget> {
  public static instance = new EchoReactiveHandlerImpl();

  private constructor() {
    super();
  }

  _proxyMap = new WeakMap<object, any>();

  _init(target: ProxyTarget): void {
    invariant(target[symbolInternals]);
    invariant(!(target as any)[symbolIsProxy]);
    invariant(Array.isArray(target[symbolPath]));

    // Handle ID pre-generated by `E.object`.
    if (PROPERTY_ID in target) {
      target[symbolInternals].core.id = target[PROPERTY_ID];
      delete target[PROPERTY_ID];
    }

    if (target[symbolPath].length === 0) {
      this.validateInitialProps(target);
      if (target[symbolInternals].core.database == null) {
        target[symbolInternals].core.initNewObject(target);
      }
    }

    // Clear extra keys from objects
    if (!Array.isArray(target)) {
      for (const key in target) {
        if (typeof key !== 'symbol') {
          delete (target as any)[key];
        }
      }
    }

    defineHiddenProperty(target, symbolHandler, this);
    if (inspect.custom) {
      defineHiddenProperty(target, inspect.custom, this._inspect.bind(target));
    }
  }

  private validateInitialProps(target: ProxyTarget) {
    for (const key in target) {
      const value = target[key];
      if (value === undefined) {
        delete target[key];
      } else if (typeof value === 'object') {
        if (value instanceof DynamicEchoSchema) {
          target[key] = value.serializedSchema;
        } else {
          throwIfCustomClass(key, value);
        }
        this.validateInitialProps(target[key]);
      }
    }
  }

  ownKeys(target: ProxyTarget): ArrayLike<string | symbol> {
    const { value } = this.getDecodedValueAtPath(target);
    const keys = typeof value === 'object' ? Reflect.ownKeys(value) : [];
    if (isRootDataObject(target)) {
      keys.push(PROPERTY_ID);
    }
    return keys;
  }

  getOwnPropertyDescriptor(target: ProxyTarget, p: string | symbol): PropertyDescriptor | undefined {
    const { value } = this.getDecodedValueAtPath(target);
    if (isRootDataObject(target) && p === PROPERTY_ID) {
      return { enumerable: true, configurable: true, writable: false };
    }
    return typeof value === 'object' ? Reflect.getOwnPropertyDescriptor(value, p) : undefined;
  }

  get(target: ProxyTarget, prop: string | symbol, receiver: any): any {
    invariant(Array.isArray(target[symbolPath]));

    target[symbolInternals].core.signal.notifyRead();

    if (isRootDataObject(target)) {
      const handled = this._handleRootObjectProperty(target, prop);
      if (handled != null) {
        return handled;
      }
    }

    if (typeof prop === 'symbol') {
      return Reflect.get(target, prop);
    }

    if (target instanceof EchoArrayTwoPointO) {
      return this._arrayGet(target, prop);
    }

    const decodedValueAtPath = this.getDecodedValueAtPath(target, prop);
    return this._wrapInProxyIfRequired(target, decodedValueAtPath);
  }

  private _handleRootObjectProperty(target: ProxyTarget, prop: string | symbol) {
    if (prop === data) {
      return this._toJSON(target);
    }
    if (prop === 'toJSON') {
      return () => this._toJSON(target);
    }
    if (prop === PROPERTY_ID) {
      return target[symbolInternals].core.id;
    }
    return null;
  }

  /**
   * Takes a decoded value from the document, and wraps it in a proxy if required.
   * We use it to wrap records and arrays to provide deep mutability.
   * Wrapped targets are cached in the `targetsMap` to ensure that the same proxy is returned for the same path.
   */
  private _wrapInProxyIfRequired(target: ProxyTarget, decodedValueAtPath: DecodedValueAtPath) {
    const { value: decoded, dataPath, namespace } = decodedValueAtPath;
    if (decoded == null) {
      return decoded;
    }
    if (decoded[symbolIsProxy]) {
      return this._handleStoredSchema(target, decoded);
    }
    if (decoded instanceof Reference) {
      return this._handleStoredSchema(target, target[symbolInternals].core.lookupLink(decoded));
    }
    if (Array.isArray(decoded)) {
      const newTarget = defaultMap(target[symbolInternals].targetsMap, dataPath, (): ProxyTarget => {
        const array = new EchoArrayTwoPointO();
        array[symbolInternals] = target[symbolInternals];
        array[symbolPath] = dataPath;
        array[symbolNamespace] = namespace;
        array[symbolHandler] = this;
        return array;
      });
      return createReactiveProxy(newTarget, this);
    }
    if (typeof decoded === 'object') {
      // TODO(dmaretskyi): Materialize properties for easier debugging.
      const newTarget = defaultMap(
        target[symbolInternals].targetsMap,
        dataPath,
        (): ProxyTarget => ({
          [symbolInternals]: target[symbolInternals],
          [symbolPath]: dataPath,
          [symbolNamespace]: namespace,
        }),
      );
      return createReactiveProxy(newTarget, this);
    }
    return decoded;
  }

  private _handleStoredSchema(target: ProxyTarget, object: any): any {
    if (object != null && object instanceof StoredEchoSchema) {
      return target[symbolInternals].core.database?._dbApi.schemaRegistry.register(object);
    }
    return object;
  }

  has(target: ProxyTarget, p: string | symbol): boolean {
    if (target instanceof EchoArrayTwoPointO) {
      return this._arrayHas(target, p);
    }
    const { value } = this.getDecodedValueAtPath(target);
    return typeof value === 'object' ? Reflect.has(value, p) : false;
  }

  defineProperty(target: ProxyTarget, property: string | symbol, attributes: PropertyDescriptor): boolean {
    return this.set(target, property, attributes.value, target);
  }

  private getDecodedValueAtPath(target: ProxyTarget, prop?: string): DecodedValueAtPath {
    const dataPath = [...target[symbolPath]];
    if (prop != null) {
      dataPath.push(prop);
    }
    const fullPath = [getNamespace(target), ...dataPath];
    const value = target[symbolInternals].core.get(fullPath);
    return { namespace: getNamespace(target), value: target[symbolInternals].core.decode(value), dataPath };
  }

  private _arrayGet(target: ProxyTarget, prop: string) {
    invariant(target instanceof EchoArrayTwoPointO);
    if (prop === 'constructor') {
      return Array.prototype.constructor;
    }
    if (prop !== 'length' && isNaN(parseInt(prop))) {
      return Reflect.get(target, prop);
    }
    const decodedValueAtPath = this.getDecodedValueAtPath(target, prop);
    return this._wrapInProxyIfRequired(target, decodedValueAtPath);
  }

  private _arrayHas(target: ProxyTarget, prop: string | symbol) {
    invariant(target instanceof EchoArrayTwoPointO);
    if (typeof prop === 'string') {
      const parsedIndex = parseInt(prop);
      const { value: length } = this.getDecodedValueAtPath(target, 'length');
      invariant(typeof length === 'number');
      if (!isNaN(parsedIndex)) {
        return parsedIndex < length;
      }
    }
    return Reflect.has(target, prop);
  }

  set(target: ProxyTarget, prop: string | symbol, value: any, receiver: any): boolean {
    invariant(Array.isArray(target[symbolPath]));
    invariant(typeof prop === 'string');

    if (target instanceof EchoArrayTwoPointO && prop === 'length') {
      this._arraySetLength(target, target[symbolPath], value);
      return true;
    }

    const validatedValue = this.validateValue(target, [...target[symbolPath], prop], value);
    const fullPath = [getNamespace(target), ...target[symbolPath], prop];

    if (validatedValue === undefined) {
      target[symbolInternals].core.delete(fullPath);
    } else if (validatedValue !== null && validatedValue[symbolHandler] instanceof EchoReactiveHandlerImpl) {
      const link = this._linkReactiveHandler(target, validatedValue, validatedValue[symbolInternals]);
      target[symbolInternals].core.set(fullPath, encodeReference(link));
    } else {
      const encoded = target[symbolInternals].core.encode(validatedValue, { removeUndefined: true });
      target[symbolInternals].core.set(fullPath, encoded);
    }

    return true;
  }

  /**
   * Used when `set` and other mutating methods are called with a proxy.
   * @param target - self
   * @param proxy - the proxy that was passed to the method
   * @param internals - internals of the proxy
   */
  private _linkReactiveHandler(target: ProxyTarget, proxy: any, internals: ObjectInternals): Reference {
    const itemId = internals.core.id;
    if (target[symbolInternals].core.database) {
      const anotherDb = internals.core.database;
      if (!anotherDb) {
        target[symbolInternals].core.database.add(proxy);
        return new Reference(itemId);
      } else {
        if (anotherDb !== target[symbolInternals].core.database) {
          return new Reference(itemId, undefined, anotherDb.spaceKey.toHex());
        } else {
          return new Reference(itemId);
        }
      }
    } else {
      invariant(target[symbolInternals].core.linkCache);
      target[symbolInternals].core.linkCache.set(itemId, proxy);
      return new Reference(itemId);
    }
  }

  private validateValue(target: ProxyTarget, path: KeyPath, value: any): any {
    invariant(path.length > 0);
    throwIfCustomClass(path[path.length - 1], value);
    const rootObjectSchema = this.getSchema(target);
    if (rootObjectSchema == null) {
      const typeReference = target[symbolInternals].core.getType();
      if (typeReference) {
        throw new Error(`Schema not found in schema registry: ${typeReference.itemId}`);
      }
      return value;
    }
    // DynamicEchoSchema is a utility-wrapper around the object we actually store in automerge, unwrap it
    const unwrappedValue = value instanceof DynamicEchoSchema ? value.serializedSchema : value;
    const propertySchema = SchemaValidator.getPropertySchema(rootObjectSchema, path, (path) =>
      target[symbolInternals].core.getDecoded([getNamespace(target), ...path]),
    );
    if (propertySchema == null) {
      return unwrappedValue;
    }
    const _ = S.asserts(propertySchema)(unwrappedValue);
    return unwrappedValue;
  }

  getSchema(target: ProxyTarget): S.Schema<any> | undefined {
    // TODO: make reactive
    invariant(target[symbolInternals].core.database, 'EchoHandler used without database');
    const typeReference = target[symbolInternals].core.getType();
    if (typeReference == null) {
      return undefined;
    }
    const staticSchema = target[symbolInternals].core.database.graph.types.getEffectSchema(typeReference.itemId);
    if (staticSchema != null) {
      return staticSchema;
    }
    return target[symbolInternals].core.database._dbApi.schemaRegistry.getById(typeReference.itemId);
  }

  arrayPush(target: ProxyTarget, path: KeyPath, ...items: any[]): number {
    this._validateForArray(target, path, items, target.length);

    const fullPath = this._getPropertyMountPath(target, path);

    const encodedItems = this._encodeForArray(target, items);

    let newLength: number = -1;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      newLength = array.push(...encodedItems);
    });
    invariant(newLength !== -1);

    return newLength;
  }

  arrayPop(target: ProxyTarget, path: KeyPath): any {
    const fullPath = this._getPropertyMountPath(target, path);

    let returnValue: any | undefined;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      returnValue = array.pop();
    });

    return returnValue;
  }

  arrayShift(target: ProxyTarget, path: KeyPath): any {
    const fullPath = this._getPropertyMountPath(target, path);

    let returnValue: any | undefined;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      returnValue = array.shift();
    });

    return returnValue;
  }

  arrayUnshift(target: ProxyTarget, path: KeyPath, ...items: any[]): number {
    this._validateForArray(target, path, items, 0);

    const fullPath = this._getPropertyMountPath(target, path);

    const encodedItems = this._encodeForArray(target, items);

    let newLength: number = -1;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      newLength = array.unshift(...encodedItems);
    });
    invariant(newLength !== -1);

    return newLength;
  }

  arraySplice(target: ProxyTarget, path: KeyPath, start: number, deleteCount?: number, ...items: any[]): any[] {
    this._validateForArray(target, path, items, start);

    const fullPath = this._getPropertyMountPath(target, path);

    const encodedItems = this._encodeForArray(target, items);

    let deletedElements: any[] | undefined;
    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      if (deleteCount != null) {
        deletedElements = array.splice(start, deleteCount, ...encodedItems);
      } else {
        deletedElements = array.splice(start);
      }
    });
    invariant(deletedElements);

    return deletedElements;
  }

  arraySort(target: ProxyTarget, path: KeyPath, compareFn?: (v1: any, v2: any) => number): any[] {
    const fullPath = this._getPropertyMountPath(target, path);

    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      const sortedArray = [...array].sort(compareFn);
      assignDeep(doc, fullPath, sortedArray);
    });

    return target as EchoArrayTwoPointO<any>;
  }

  arrayReverse(target: ProxyTarget, path: KeyPath): any[] {
    const fullPath = this._getPropertyMountPath(target, path);

    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      const reversedArray = [...array].reverse();
      assignDeep(doc, fullPath, reversedArray);
    });

    return target as EchoArrayTwoPointO<any>;
  }

  getMeta(target: ProxyTarget): ObjectMeta {
    const metaTarget: ProxyTarget = {
      [symbolInternals]: target[symbolInternals],
      [symbolPath]: [],
      [symbolNamespace]: META_NAMESPACE,
    };
    return createReactiveProxy(metaTarget, this) as any;
  }

  private _arraySetLength(target: ProxyTarget, path: KeyPath, newLength: number) {
    if (newLength < 0) {
      throw new RangeError('Invalid array length');
    }
    const fullPath = this._getPropertyMountPath(target, path);

    target[symbolInternals].core.change((doc) => {
      const array = getDeep(doc, fullPath);
      invariant(Array.isArray(array));
      const trimmedArray = [...array];
      trimmedArray.length = newLength;
      assignDeep(doc, fullPath, trimmedArray);
    });
  }

  private _validateForArray(target: ProxyTarget, path: KeyPath, items: any[], start: number) {
    let index = start;
    for (const item of items) {
      this.validateValue(target, [...path, String(index++)], item);
    }
  }

  // TODO(dmaretskyi): Change to not rely on object-core doing linking.
  private _encodeForArray(target: ProxyTarget, items: any[] | undefined): any[] {
    return items?.map((value) => target[symbolInternals].core.encode(value, { removeUndefined: true })) ?? [];
  }

  private _getPropertyMountPath(target: ProxyTarget, path: KeyPath): KeyPath {
    return [...target[symbolInternals].core.mountPath, getNamespace(target), ...path];
  }

  // Will be bound to the proxy target.
  _inspect = function (
    this: ProxyTarget,
    _: number,
    options: InspectOptionsStylized,
    inspectFn: (value: any, options?: InspectOptionsStylized) => string,
  ) {
    const handler = this[symbolHandler] as EchoReactiveHandlerImpl;
    const isTyped = !!this[symbolInternals].core.getType();
    const proxy = handler.getReified(this);
    invariant(proxy, '_proxyMap corrupted');
    const reified = { ...proxy }; // Will call proxy methods and construct a plain JS object.
    return `${isTyped ? 'Typed' : ''}EchoObject ${inspectFn(reified, {
      ...options,
      compact: true,
      showHidden: false,
      customInspect: false,
    })}`;
  };

  private _toJSON(target: ProxyTarget): any {
    const typeRef = target[symbolInternals].core.getType();
    const reified = this.getReified(target);
    delete reified.id;
    return {
      '@type': typeRef ? encodeReference(typeRef) : undefined,
      ...(target[symbolInternals].core.isDeleted() ? { '@deleted': true } : {}),
      '@meta': { ...this.getMeta(target) },
      '@id': target[symbolInternals].core.id,
      ...reified,
    };
  }

  private getReified(target: ProxyTarget) {
    const proxy = this._proxyMap.get(target);
    invariant(proxy, '_proxyMap corrupted');
    // Will call proxy methods and construct a plain JS object.
    return { ...proxy };
  }
}

const throwIfCustomClass = (prop: KeyPath[number], value: any) => {
  if (value == null || Array.isArray(value)) {
    return;
  }
  if (value instanceof DynamicEchoSchema) {
    return;
  }
  const proto = Object.getPrototypeOf(value);
  if (typeof value === 'object' && proto !== Object.prototype) {
    throw new Error(`class instances are not supported: setting ${proto} on ${String(prop)}`);
  }
};

// TODO(dmaretskyi): Read schema from typed in-memory objects.
export const createEchoReactiveObject = <T extends {}>(init: T): EchoReactiveObject<T> => {
  const schema = getSchema(init);
  if (schema != null) {
    validateSchema(schema);
  }

  if (isReactiveProxy(init)) {
    const proxy = init as any;

    const slot = getProxyHandlerSlot(proxy);
    const meta = getProxyHandlerSlot<ObjectMeta>(getTargetMeta(slot.target)).target!;

    const core = new AutomergeObjectCore();
    core.rootProxy = proxy;

    slot.handler = EchoReactiveHandlerImpl.instance;
    const target = slot.target as ProxyTarget;

    target[symbolInternals] = {
      core,
      targetsMap: new ComplexMap((key) => JSON.stringify(key)),
    };
    target[symbolPath] = [];
    target[symbolNamespace] = DATA_NAMESPACE;
    slot.handler._proxyMap.set(target, proxy);
    slot.handler._init(target);
    saveTypeInAutomerge(target[symbolInternals], schema);
    if (meta.keys.length > 0) {
      target[symbolInternals].core.setMeta(meta);
    }
    return proxy;
  } else {
    const core = new AutomergeObjectCore();
    const target: ProxyTarget = {
      [symbolInternals]: {
        core,
        targetsMap: new ComplexMap((key) => JSON.stringify(key)),
      },
      [symbolPath]: [],
      [symbolNamespace]: DATA_NAMESPACE,
      ...(init as any),
    };
    const proxy = createReactiveProxy<ProxyTarget>(target, EchoReactiveHandlerImpl.instance) as any;
    core.rootProxy = proxy;
    saveTypeInAutomerge(target[symbolInternals], schema);
    return proxy;
  }
};

export const initEchoReactiveObjectRootProxy = (core: AutomergeObjectCore) => {
  const target: ProxyTarget = {
    [symbolInternals]: {
      core,
      targetsMap: new ComplexMap((key) => JSON.stringify(key)),
    },
    [symbolPath]: [],
    [symbolNamespace]: DATA_NAMESPACE,
  };
  core.rootProxy = createReactiveProxy<ProxyTarget>(target, EchoReactiveHandlerImpl.instance) as any;
};

const validateSchema = (schema: S.Schema<any>) => {
  getSchemaTypeRefOrThrow(schema);
  SchemaValidator.validateSchema(schema);
};

const saveTypeInAutomerge = (internals: ObjectInternals, schema: S.Schema<any> | undefined) => {
  if (schema != null) {
    internals.core.setType(getSchemaTypeRefOrThrow(schema));
  }
};

export const getSchemaTypeRefOrThrow = (schema: S.Schema<any>): Reference => {
  const typeReference = getTypeReference(schema);
  if (typeReference == null) {
    throw new Error(
      'EchoObject schema must have a valid annotation: MyTypeSchema.pipe(R.echoObject("MyType", "1.0.0"))',
    );
  }
  return typeReference;
};

export const getObjectCoreFromEchoTarget = (target: ProxyTarget): AutomergeObjectCore => target[symbolInternals].core;

const getNamespace = (target: ProxyTarget): string => target[symbolNamespace];

const isRootDataObject = (target: ProxyTarget) => {
  const path = target[symbolPath];
  if (!Array.isArray(path) || path.length > 0) {
    return false;
  }
  return getNamespace(target) === DATA_NAMESPACE;
};

interface DecodedValueAtPath {
  value: any;
  namespace: string;
  dataPath: KeyPath;
}
