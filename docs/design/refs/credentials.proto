//
// Copyright 2022 DXOS.org
//

syntax = "proto3";

package dxos.halo.credentials;

import "google/protobuf/timestamp.proto";
import "@dxos/protocols/src/proto/dxos/halo/keys.proto";

//
// TODO(burdon): Move these notes to the design doc commentary.
// Peers maintain Feeds that are admitted to HALO and ECHO Parties.
// Peers act as Verifiers for Credentials that may be Presented from other Peers.
// Since Feeds implement a signed hash-linked data structure, they constitute a chain-of-authority for chained Credentials.
// Credentials written to HALO Feeds may be Presented to Peers Verifying ECHO Parties.
//

//
// **PartyGenesis** -
//  First message written to initial Feed in a new Party.
//

message PartyGenesis {
  PubKey partyKey = 1; // Feeds belong to Parties.
  PubKey identityKey = 2; // Devices belong to Identities.
}

//
// **Claim** - 
//  Statement about a subject.
//  Claims can be written directly to a feed or used within Credentials.
//

// Agent is authorized to access Party.
message PartyMember {
  enum Role {
    MEMBER = 0;
    WRITER = 1;
    ADMIN = 2;
  }

  PubKey partyKey = 1;
  repeated Role roles = 2;
}

// Device is authorized to sign messages for a given Agent (Identity).
// NOTE: Devices are Admitted to Identities.
message AuthorizedDevice {
  PubKey identityKey = 1;
  PubKey deviceKey = 2; // Existing authorized device.
}

// Feed is admitted to the Party for replication.
// NOTE: Feeds are Admitted to Parties.
message AdmittedFeed {
  PubKey identityKey = 1; // Could be derived.
  PubKey partyKey = 2;
  PubKey deviceKey = 3;
}

//
// **Claim** - 
//  Statement about a subject.
//  Claims can be written directly to a feed or used within Credentials.
//

message Claim {
  PubKey id = 1; // Subject of claim (e.g., Agent, Device, Feed).
  google.protobuf.Any assertion = 2;
}

//
// **Proof** -
//  Signature that makes Credential tamper-evident.
//  The proof is signed by the issuer of the Credential.
//  Ref: https://www.w3.org/TR/vc-data-model/#proofs-signatures
//

message Proof {
  string type = 1; // Type of proof (e.g., "Ed25519Signature2020").
  Timestamp creationDate = 2;
  PubKey signer = 3;        // Entity that created the proof (e.g., Agent, Device, Party).
  optional bytes nonce = 4; // Used in Presentations to protect against replay attacks.
  bytes value = 5; // Signature.
  /// Must be present if signer is not credential issuer. Establishes the authority of the signer. Proves that the signer can issue such credentials.
  optional Chain chain = 6;
}

/**
 * A chain of credentials that establishes the delegated authority to issue new credentials.
 * Each key in the chain has an assotiated credential that establishes the authrity of that specific key.
 *
 * For example: 
 *    Alice/Device-2 => Alice/Device-1 => Alice
 *
 * This chain would include 2 credentials:
 *   1. Giving Alice/Device-2 the authority to issue credentials on behalf of Alice, signed by Alice/Device-1.
 *   2. Giving Alice/Device-1 the authority to issue credentials on behalf of Alice, signed by Alice.
 */
message Chain {
  /// A mapping from the key to the credential that establishes it's authority. Keys must be encoded to string in lowercase hex with leading '0x'.
  map<string, Credential> keys = 1;
}

//
// **Credential** -
//  Set of claims containing a proof signed by the issuer.
//  Credentials may be stored in a Credential Repository (e.g., digital wallet.)
//  Credentials may also be store within feeds (e.g., an agent's HALO).
//

message Credential {
  PubKey id = 1; // Credential identifier (e.g., for storage indexing).
  PubKey issuer = 2; // key = { Party (genesis) | Identity (genesis) | (authorized) Device }
  Timestamp issuanceDate = 3;
  Timestamp expirationDate = 4;
  bytes expirationRef = 5; // Could reference blockchain or epoch number.
  Claim subject = 10;
  Proof proof = 11;
}

//
// **Presentation** -
//  Signed Credential(s) sent to a Verifier.
//  Presentations are typically NOT stored any may include a challenge (e.g., nonce).
//  Presentations may contain multiple Credentials (and require multiple proofs).
//

message Presentation {
  repeated Credential credentials = 1;
  repeated Proof proofs = 2;
}
